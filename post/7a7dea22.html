<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>软考中级 | Liooser's Blog</title><meta name="author" content="Liooser"><meta name="copyright" content="Liooser"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="第1章：计算机组成原理与体系结构基础知识1.数据的表示1.1进制转换任意进制–&gt;十进制   二进制&lt;–&gt;八、十六进制   十进制–&gt;任意进制 十进制转R进制使用短除法。 1.2真值与机器数真值：符合人剋习惯的数字。 机器数：数字实际存到机器里的形式，正负号需要被“数字化“ 定点数 vs 浮点数 定点数:小数点的位置固定          Eg: 996.007-常规计数 浮">
<meta property="og:type" content="article">
<meta property="og:title" content="软考中级">
<meta property="og:url" content="https://liooser.github.io/post/7a7dea22.html">
<meta property="og:site_name" content="Liooser&#39;s Blog">
<meta property="og:description" content="第1章：计算机组成原理与体系结构基础知识1.数据的表示1.1进制转换任意进制–&gt;十进制   二进制&lt;–&gt;八、十六进制   十进制–&gt;任意进制 十进制转R进制使用短除法。 1.2真值与机器数真值：符合人剋习惯的数字。 机器数：数字实际存到机器里的形式，正负号需要被“数字化“ 定点数 vs 浮点数 定点数:小数点的位置固定          Eg: 996.007-常规计数 浮">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/Liooser/Liooser.github.io/main/images/index/ruankaozhongji.png">
<meta property="article:published_time" content="2024-03-08T16:00:00.000Z">
<meta property="article:modified_time" content="2024-03-13T14:29:33.487Z">
<meta property="article:author" content="Liooser">
<meta property="article:tag" content="软考">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/Liooser/Liooser.github.io/main/images/index/ruankaozhongji.png"><link rel="shortcut icon" href="https://raw.githubusercontent.com/Liooser/Liooser.github.io/main/images/index/a2.png"><link rel="canonical"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"top-right"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '软考中级',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-03-13 22:29:33'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css" /><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://raw.githubusercontent.com/Liooser/Liooser.github.io/main/images/index/5.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">43</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">35</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/timeline/"><i class="fa-fw fa fa-bell"></i><span> 日志</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 菜单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about"><i class="fa-fw /about/"></i><span> 0</span></a></li><li><a class="site-page child" href="/myself"><i class="fa-fw /myself/"></i><span> 1</span></a></li><li><a class="site-page child" href="/butterfly"><i class="fa-fw https://github.com/jerryc127/hexo-theme-butterfly/"></i><span> 2</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://raw.githubusercontent.com/Liooser/Liooser.github.io/main/images/index/ruankaozhongji.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Liooser's Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/timeline/"><i class="fa-fw fa fa-bell"></i><span> 日志</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 菜单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about"><i class="fa-fw /about/"></i><span> 0</span></a></li><li><a class="site-page child" href="/myself"><i class="fa-fw /myself/"></i><span> 1</span></a></li><li><a class="site-page child" href="/butterfly"><i class="fa-fw https://github.com/jerryc127/hexo-theme-butterfly/"></i><span> 2</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">软考中级</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-03-08T16:00:00.000Z" title="发表于 2024-03-09 00:00:00">2024-03-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-03-13T14:29:33.487Z" title="更新于 2024-03-13 22:29:33">2024-03-13</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">13.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>43分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="软考中级"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="第1章：计算机组成原理与体系结构基础知识"><a href="#第1章：计算机组成原理与体系结构基础知识" class="headerlink" title="第1章：计算机组成原理与体系结构基础知识"></a>第1章：计算机组成原理与体系结构基础知识</h3><h4 id="1-数据的表示"><a href="#1-数据的表示" class="headerlink" title="1.数据的表示"></a>1.数据的表示</h4><h5 id="1-1进制转换"><a href="#1-1进制转换" class="headerlink" title="1.1进制转换"></a>1.1进制转换</h5><p>任意进制–&gt;十进制</p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240304195622340.png" alt="image-20240304195622340" style="zoom: 67%;" />

<p>二进制&lt;–&gt;八、十六进制</p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240304200015583.png" alt="image-20240304200015583" style="zoom: 50%;" />

<p>十进制–&gt;任意进制</p>
<p>十进制转R进制使用短除法。</p>
<h5 id="1-2真值与机器数"><a href="#1-2真值与机器数" class="headerlink" title="1.2真值与机器数"></a>1.2真值与机器数</h5><p>真值：符合人剋习惯的数字。</p>
<p><strong>机器数：数字实际存到机器里的形式，正负号需要被“数字化“</strong></p>
<p>定点数 vs 浮点数</p>
<p>定点数:小数点的位置固定          Eg: 996.007-常规计数</p>
<p>浮点数:小数点的位置不固定      Eg:9.96007<em>10</em>10-科学计数法</p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240304202011683.png" alt="image-20240304202011683" style="zoom: 50%;" />

<p>无符号数:整个机器字长的全部二进制位均为数值位没有符号位相当于数的绝对值。通常只有无符号整数，而没有无符号小数。</p>
<p>二进制（B）、八进制（O）、十进制（D）、十六进制（H）</p>
<p><mark><strong>原码:用数值部分表示真值的绝对值，符号位“0&#x2F;1”对应“正&#x2F;负。</strong></mark></p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240304202403019.png" alt="image-20240304202403019" style="zoom:50%;" />

<p><mark><strong>反码: 若符号位为0，则反码与原码相同。若符号位为1，则数值位全部取反。</strong></mark></p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240304202519132.png" alt="image-20240304202519132" style="zoom:50%;" />

<p><mark><strong>补码:正数的补码 &#x3D; 原码，负数的补码 &#x3D; 反码末位+1 (要考虑进位）</strong></mark></p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240304202832355.png" alt="image-20240304202832355" style="zoom:50%;" />

<p><mark><strong>移码:补码的基础上将符号位取反。注意: 移码只能用于表示整数</strong></mark></p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240304202937781.png" alt="image-20240304202937781" style="zoom:50%;" />

<p><strong>真值0有+0和-0两种</strong></p>
<p>[+0]原&#x3D; 00000000</p>
<p>[+0]反&#x3D; 00000000</p>
<p>[-0]原&#x3D; 10000000</p>
<p>[-0]反 &#x3D; 11111111</p>
<p>[+0]补 &#x3D; [-0]补 &#x3D; 00000000</p>
<p>[+0]移 &#x3D; [-0]移 &#x3D; 10000000</p>
<p><strong>浮点数</strong></p>
<p>浮点数是小数点位置不固定的数，它能表示更大范围的数。浮点数的表示格式如图</p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240304203139763.png" alt="image-20240304203139763" style="zoom:50%;" />

<p>N&#x3D;M*R^E</p>
<p>其中，M称为尾数，R称为基数，E称为阶码</p>
<p>阶码，决定浮点数所能表示的数值范围</p>
<p>尾数，决定浮点数所能表示的数值精度</p>
<h4 id="2-校验码"><a href="#2-校验码" class="headerlink" title="2.校验码"></a>2.校验码</h4><p>奇偶校验和循环几余校验码(了解)</p>
<p>奇偶校验是一种简单有效的校验方法。其基本思想是: 通过在编码中增加一位校验位来使编码中 1 的个数为奇数(奇校验)或者为偶数(偶校验)，从而使码距变为 2。对于奇校验,它可以检测代码中奇数位出错的编码，但不能发现偶数位出错的情况，即当合法编码中奇数位发生了错误，也就是编码中的 1 变成0或0 变成1，则该编码中1的个数的奇偶性就发生了变化，从而可以发现错误。</p>
<p>常用的奇偶校验码有 3 种:水平奇偶校验码、垂直奇偶校验码和水平垂直奇偶校验码。</p>
<p><strong>海明码</strong><br>海明码的构成方法是: 在数据为之间插入 k 个校验码，通过扩大码距来实现讲错和纠错。</p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240304203538348.png" alt="image-20240304203538348" style="zoom:50%;" />

<p>选C</p>
<h4 id="3-计算机体系结构"><a href="#3-计算机体系结构" class="headerlink" title="3.计算机体系结构"></a>3.计算机体系结构</h4><h5 id="3-1五大部件"><a href="#3-1五大部件" class="headerlink" title="3.1五大部件"></a>3.1五大部件</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240304204222011.png" alt="image-20240304204222011" style="zoom: 25%;" />

<h5 id="3-2主存储器"><a href="#3-2主存储器" class="headerlink" title="3.2主存储器"></a>3.2主存储器</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240304204708090.png" alt="image-20240304204708090" style="zoom: 50%;" />

<p>存储单元:每个存储单元存放一串二进制代码</p>
<p>存储字(word): 存储单元中二进制代码的组合</p>
<p>存储字长:存储单元中二进制代码的位数</p>
<p>存储元:即存储二进制的电子元件，每个存储元可存 1bit</p>
<p>MAR:地址寄存器</p>
<p>MDR:数据寄存器</p>
<h5 id="3-3CPU"><a href="#3-3CPU" class="headerlink" title="3.3CPU"></a>3.3CPU</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240304204728203.png" alt="image-20240304204728203" style="zoom: 67%;" />

<p>ACC:累加器，用于存放操作数，或运算结果</p>
<p>MQ:乘商寄存器，在乘、除运算时，用于存放操作数或运算结果</p>
<p>X:通用的操作数寄存器，用于存放操作数</p>
<p>ALU:算术逻辑单元，通过内部复杂的电路实现算数运算、逻辑运算</p>
<p>DR:数据缓存寄存器</p>
<p>PSW: 状态条件寄存器，用来保存指令运行标志</p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240304204841944.png" alt="image-20240304204841944" style="zoom:50%;" />

<p>CU:控制单元，分析指令，给出控制信号</p>
<p>R:指令寄存器，存放当前执行的指令</p>
<p>PC:程序计数器，存放下一条指令地址，有自动加1功能</p>
<p>AR:地址寄存器，保存当前CPU所访问的内存单元地址</p>
<p>ID:指令译码器，对操作码进行分析</p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240304205028912.png" alt="image-20240304205028912" style="zoom:50%;" />

<h5 id="3-4Flynn分类法"><a href="#3-4Flynn分类法" class="headerlink" title="3.4Flynn分类法"></a>3.4Flynn分类法</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240304205237326.png" alt="image-20240304205237326" style="zoom: 33%;" />

<p>Single单一的</p>
<p>Multiple倍数，多样的</p>
<h4 id="4-指令系统"><a href="#4-指令系统" class="headerlink" title="4.指令系统"></a>4.指令系统</h4><h5 id="4-1指令格式"><a href="#4-1指令格式" class="headerlink" title="4.1指令格式"></a>4.1指令格式</h5><p>一条指令就是机器语言的一个语句，它是一组有意义的二进制代码</p>
<p>一条指令通常要包括操作码字段和地址码字段两部分</p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240304205533590.png" alt="image-20240304205533590" style="zoom: 67%;" />

<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240304205446506.png" alt="image-20240304205446506" style="zoom: 67%;" />

<h5 id="4-2寻址方式"><a href="#4-2寻址方式" class="headerlink" title="4.2寻址方式"></a>4.2寻址方式</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240304205555125.png" alt="image-20240304205555125" style="zoom: 50%;" />

<p><strong>寻址方式（数据寻址）</strong></p>
<ul>
<li><p>立即寻址：操作数作为指令的一部分直接写在指令中，这种操作数称为立即数。</p>
</li>
<li><p>寄存器寻址： 指令所要的操作数已存储在某寄存器中，或把目标操作数存入寄存器。</p>
</li>
<li><p>直接寻址：指令所要的操作数存放在内存中，在指令中直接给出该操作数的有效地址。</p>
</li>
<li><p>寄存器间接寻址：操作数在存储器中，操作数的有效地址用SI、DI、BX和BP四个寄存器之一来指定。</p>
</li>
<li><p>寄存器相对寻址：操作数在存储器中，其有效地址是一个基址寄存器(BX、BP)或变址寄0存器(SIDI)的内容和指令中的8位&#x2F;16位偏移量之和。</p>
</li>
<li><p>基址加变址寻址方式：操作数在存储器中，其有效地址是-一个基址寄存器(BX.BP)和一个变址寄存器(SI、DI)的 内容之和。</p>
</li>
<li><p>相对基址加变址寻址;操作数在存储器中,其有效地址是一个基址寄存器(BX.BP)的值、一个变址寄存器(SI、DI)的值和指令中的8位&#x2F;16位偏移量之和。</p>
</li>
</ul>
<h5 id="4-3CISC和RISC"><a href="#4-3CISC和RISC" class="headerlink" title="4.3CISC和RISC"></a>4.3CISC和RISC</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240304205805214.png" alt="image-20240304205805214" style="zoom:50%;" />

<h5 id="4-4指令的流水方式"><a href="#4-4指令的流水方式" class="headerlink" title="4.4指令的流水方式"></a>4.4指令的流水方式</h5><p>指令控制方式有顺序方式、重叠方式和流水方式三种</p>
<p>流水方式:是指并行性或并发性嵌入计算机系统里的一种形式，它把重复的顺序处理过程分解为若千子过程，每个子过程能在专用的独立模块上有效地并发工作。</p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240304205907482.png" alt="image-20240304205907482" style="zoom: 67%;" />

<p>在概念上“流水”可以看成是“重叠”的延伸。差别仅在于“一次重叠”只是把一条指令解释分解为两个子过程，而“流水”则是分解为更多的子过程。</p>
<h5 id="4-5流水线计算"><a href="#4-5流水线计算" class="headerlink" title="4.5流水线计算"></a>4.5流水线计算</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240304210021669.png" alt="image-20240304210021669" style="zoom:50%;" />

<p>答：周期2ns,全部时间2+2+1+(100-1)*2&#x3D;203s</p>
<p>流水线的吞吐率(Though Put rate,TP):是指在单位时间内流水线所完成的任务数量或输出的结果数量。</p>
<p><mark><strong>计算流水线吞吐率的最基本的公式如下:</strong></mark></p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240304210303420.png" alt="image-20240304210303420" style="zoom:50%;" />

<p>流水线开始工作后，须经过一定时间才能达到最大吞吐率，这就是建立时间若m个子过程所用时间一样，均为t，则建立时间T&#x3D;m*t.</p>
<p>完成同样一批任务，不使用流水线所用的时间与使用流水线所用的时间之比称为流水线的加速比。</p>
<p>计算流水线加速比的基本公式如下:</p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240304210507760.png" alt="image-20240304210507760" style="zoom: 67%;" />

<h4 id="5-存储系统"><a href="#5-存储系统" class="headerlink" title="5.存储系统"></a>5.存储系统</h4><h5 id="5-1层次结构"><a href="#5-1层次结构" class="headerlink" title="5.1层次结构"></a>5.1层次结构</h5><p>把U盘、光盘等称为“外存”有的教材把安装在电脑内部的磁盘称为“辅存”也有的教材把磁盘、U盘、光盘等统称为“辅存”或“外存</p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240305133940347.png" alt="image-20240305133940347" style="zoom:50%;" />

<p>1.<strong>寄存器是中央处理器内的组成部份。</strong>寄存器Q 是有限存贮容量的高速存贮部件，它们可用来暂存指令、数据和位址。在中央处理器的控制部件中，包含的寄存器有指令寄存器(IR)和程序计数器(PC)。在中央处理器的算术及逻辑部件中，包含的寄存器有累加器(ACC)。<strong>寄存器拥有非常高的读写速度，所以在寄存器之间的数据传送非常快。</strong></p>
<p>2.Cache: <strong>即高速缓冲存储器，是位于CPU与主内存间的一种容量较小但速度很高的存储器。</strong>由于CPU的速度远高于主内存，CPU直接从内存中存取数据要等待一定时间周期，Cache中保存着CPU刚用过或循环使用的一部分数据，当CPU再次使用该部分数据时可从Cache中直接调用,这样就减少了CPU的等待时间,提高了系统的效率。Cache又分为一级Cache(L1 Cache)和二级Cache(L2Cache)，L1 Cache集成在CPU内部，L2 Cache早期一般是焊在主板上,现在也都集成在CPU内部常见的容量有256KB或512KB L2 Cache。</p>
<p>3.内存包含的范围非常广，一般分为只读存储器 (ROM) 、随机存储器 (RAM)和高速缓存存储器(cache) 。</p>
<p>主存一辅存:实现虚拟存储系统，解决了主存容量不够的问题.</p>
<p>cpu—Cache—主存:解决了主存与CPU速度不匹配的问题。</p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240305134111329.png" alt="image-20240305134111329" style="zoom:50%;" />

<h5 id="5-2存储器的分类"><a href="#5-2存储器的分类" class="headerlink" title="5.2存储器的分类"></a>5.2存储器的分类</h5><p>1、按位置分类，可分为内存和外存</p>
<ul>
<li><p>内存(主存): 用来存储当前运行所需要的程序和数据，速度快，容量小。</p>
</li>
<li><p>外存(辅存)::用来存储当前不参与运行的数据，容量大但速度慢。</p>
</li>
</ul>
<p>2.按材料分类，可分为磁存储器、半导体存储器和光存储器磁存储器</p>
<ul>
<li><p>磁存储器：用磁性介质做成，如磁芯、磁泡、磁盘、磁带等</p>
</li>
<li><p>半导体存储器: 根据所用元件又可分为双极型和MOS型两类；根据是否需要刷新又可分为静态和动态两类。</p>
</li>
<li><p>光存储器:由光学、电学和机械部件等组成，如光盘存储器。</p>
</li>
</ul>
<p>3.按工作方式，可分为读&#x2F;写存储器和只读存储器</p>
<ul>
<li><p>读&#x2F;写存储器(RAM)：它指既能读取数据也能存入数据的存储器</p>
</li>
<li><p>只读存储器(ROM)：工作过程中仅能读取的存储器。</p>
</li>
</ul>
<p>根据数据的写入方式，又可细分为ROM、PROM、EPROM和EEPROM等类型。</p>
<ul>
<li><p>固定只读存储器(ROM)。这种存储器是在厂家生产时就写好数据的，其内容只能读出，不能改变。一般用于存放系统程序BIOS和用于微程序控制。</p>
</li>
<li><p>可编程的只读存储器(PROM)。其中的内容可以由用户一次性地写入，写入后不能再修改。</p>
</li>
<li><p>可擦除可编程的只读存储器(EPROM)。其中的内容既可以读出，也可以由用户写入，写入后还可以修改，紫外线照射擦除信息。</p>
</li>
<li><p>电擦除可编程的只读存储器(EEPROM)。与EPROM相似，EEPROM 中的内容既可以读出，也可以进行改写，电擦除的方法进行数据的改写。</p>
</li>
<li><p>闪速存储器(Flash Memory)。简称闪存闪存的特性于EPROM和EEPROM之类似于EEPROM,也可使用电信号进行信息的擦除操作。整块闪存可以在数秒内删除，速度远快于EPROM。</p>
</li>
</ul>
<h5 id="5-3高速缓存Cache"><a href="#5-3高速缓存Cache" class="headerlink" title="5.3高速缓存Cache"></a>5.3高速缓存Cache</h5><p><strong>程序访问的局部性原理</strong></p>
<ul>
<li><p>空间局部性：在最近的未来要用到的信息（指令和数据），很可能与现在正在使用的信息在存储空间上是邻近的.</p>
<p>eg：数据元组、顺序执行的指令代码。</p>
</li>
<li><p>时间局部性：在最近的未来要用到的信息，很可能是现在正在使用的信息.</p>
<p>eg：循环结构里的指令代码。</p>
<p>高速缓冲技术是利用程序访问的局部性原理，把程序中正在使用的部分存放在一个高速的、容量较小的Cache中，使CPU的访存操作大多数针对Cache进行，从而大大提高程序的执行速度。</p>
</li>
</ul>
<p>要把主存种的地址映射为Cache存储器里面的地址，地址映像方法有三</p>
<ul>
<li>直接映像:就是主存的块与Cache中块的对应关系是固定的。这种方式的优点是<strong>地址变换很简单</strong>，缺点是<strong>灵活性差</strong>。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240305152001220.png" alt="image-20240305152001220" style="zoom: 67%;" />

<ul>
<li>全相联映像:<strong>允许主存的任一块可以调入Cache的任一块的空间</strong>。这种方式的优点是主存的块调入Cache的<strong>位置不受限制，十分灵活</strong>。其缺点是<strong>无法从主存块号中直接获得Cache的块号，变换比较复杂，速度比较慢。</strong></li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240305152147304.png" alt="image-20240305152147304" style="zoom:67%;" />

<ul>
<li>组相联映像:这种方式是前面两种方式的折中。具体方法是将Cache先分成组再分块组相联映像就是<strong>组间采用直接映像方式</strong>，而<strong>组内的块采用全相联映像方式。</strong></li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240305152252334.png" alt="image-20240305152252334" style="zoom:67%;" />

<p><strong>选择替换算法的目标是使Cache获得最高的命中率。常用的替换算法有以下几种：</strong></p>
<ul>
<li>1、随机替换(RAND)算法: 用随机数发生器产生一个要替换的块号，将该块替换出去</li>
<li>2、先进先出(FIFO)算法: 将最先进入的Cache信息块替换出去。</li>
<li>3、近期最少使用(LRU)算法: 将近期最少使用的Cache中的信息块替换出去。这种算法较先进先出算法要好些，但此法也不能保证过去不常用的将来也不常用。</li>
<li>4、优化替换OPT)算法: 先执行一次程序，统计Cache的替换情况。有了这样的先验信息，在第二次执行该程序时便可以用最有效的方式来替换，达到最优目的。</li>
</ul>
<p><strong>Cache的性能分析：</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240305152538828.png" alt="image-20240305152538828" style="zoom:67%;" />

<p><strong>例题：</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240305152625647.png" alt="image-20240305152625647" style="zoom:67%;" />

<p>选A、D</p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240305152842388.png" alt="image-20240305152842388" style="zoom:67%;" />

<p>选A</p>
<h5 id="5-4主存的编址"><a href="#5-4主存的编址" class="headerlink" title="5.4主存的编址"></a>5.4主存的编址</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240305153428082.png" alt="image-20240305153428082" style="zoom: 50%;" />

<p>例题：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240305153744081.png" alt="image-20240305153744081"></p>
<p>（C7FFFH+1）- AC000H &#x3D; 1C000 H</p>
<p>1C000H &#x3D; 114688D</p>
<p>114688&#x2F;2^10&#x3D;112</p>
<p>(112k * 16b)&#x2F;28 * 16k &#x3D; 4b</p>
<h5 id="5-6硬盘"><a href="#5-6硬盘" class="headerlink" title="5.6硬盘"></a>5.6硬盘</h5><p>存取时间&#x3D;寻道时间+等待时间(平均定位时间+转动延迟</p>
<p>注意:寻道时间是指磁头移动到磁道所需的时间；</p>
<p>等待时间为等待读写的扇区转到磁头下方所用的时间。</p>
<h4 id="6-总线系统"><a href="#6-总线系统" class="headerlink" title="6.总线系统"></a>6.总线系统</h4><p><strong>总线分类</strong></p>
<p>1、片内总线</p>
<p>片内总线是芯片内部的总线。 它是CPU芯片内部寄存器与寄存器之间、寄存器与ALU之间的公共连接线。</p>
<p>2、系统总线<br>系统总线是计算机系统内各功能部件(CPU、主存、I&#x2F;0接口)之间相互连接的总线。按系统总线传输信息内容的不同，又可分为3类: 数据总线、地址总线和控制总线。</p>
<p>3、通信总线</p>
<h4 id="7-输入输出技术"><a href="#7-输入输出技术" class="headerlink" title="7.输入输出技术"></a>7.输入输出技术</h4><p><strong>CPU与外设之间的数据传送方式</strong></p>
<p><strong>1、直接程序控制方式</strong></p>
<p>直接程序控制方式是指在完成数据的输入&#x2F;输出中，整个输入&#x2F;输出过程是在CPU执行程序的控制下完成的。</p>
<p>这种方式还可以分为以下两种:</p>
<p>(1)无条件传送方式:无条件地与CPU交换数据。</p>
<p>(2)程序查询方式:先通过CPU查询外设状态，准备好之后再与CPU交换数据。</p>
<p><strong>2、中断方式</strong></p>
<p><strong>3、直接存储器存取方式</strong></p>
<p>直接存储器存取(Direct Memory Access， DMA)方式是在存储器与&#x2F;0设备间直接传送数据，即在内存与I&#x2F;0设备之间传送一个数据块的过程中，<strong>不需要CPU的任何干涉，是一种完全由DMA硬件完成I&#x2F;O操作的方式。</strong></p>
<p>例题：</p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240305155813487.png" alt="image-20240305155813487" style="zoom:50%;" />

<p>选D</p>
<h4 id="8-可靠性"><a href="#8-可靠性" class="headerlink" title="8.可靠性"></a>8.可靠性</h4><p><strong>计算机系统的可靠性是指从它开始运行(t&#x3D;)到某个时刻t这段时间内能正常运行的概率，用R(t)表示。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240305160046422.png" alt="image-20240305160046422"></p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240305160122410.png" alt="image-20240305160122410" style="zoom:50%;" />

<p>失效率 &#x3D; 1 - 可靠的</p>
<p>选B</p>
<h3 id="第2章：数据结构与算法基础"><a href="#第2章：数据结构与算法基础" class="headerlink" title="第2章：数据结构与算法基础"></a>第2章：数据结构与算法基础</h3><h4 id="1-基本概念与三要素"><a href="#1-基本概念与三要素" class="headerlink" title="1.基本概念与三要素"></a>1.基本概念与三要素</h4><h5 id="1-1数据的基本概念"><a href="#1-1数据的基本概念" class="headerlink" title="1.1数据的基本概念"></a>1.1数据的基本概念</h5><p>数据是信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号的集合。数据是计算机程序加工的原料。</p>
<p><strong>数据元素、数据项</strong>: <mark><strong>数据元素是数据的基本单位</strong></mark>，通常作为一个整体进行考虑和处理。 <mark>一个数据元素可由若干数据项组成，数据项是构成数据元素的不可分割的最小单位。</mark></p>
<p><strong>数据结构是相互之间存在一种或多种特定关系的数据元素的集合。</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240305181703309.png" alt="image-20240305181703309" style="zoom:50%;" />

<h5 id="1-2数据结构三要素"><a href="#1-2数据结构三要素" class="headerlink" title="1.2数据结构三要素"></a>1.2数据结构三要素</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240305181835399.png" alt="image-20240305181835399" style="zoom: 67%;" />

<p><strong>逻辑结构的四种表示方式</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240305181852844.png" alt="image-20240305181852844" style="zoom: 80%;" />

<ul>
<li><p>集合:各个元素同属一个集合，别无其他关系</p>
</li>
<li><p>线性结构:数据元素之间是一对一的关系。除了第一个元素，所有元素</p>
</li>
<li><p>有唯前驱;除了最后一个元素，所有元素都有唯一后继</p>
</li>
<li><p>树形结构:数据元素之间是一对多的关系</p>
</li>
<li><p>图结构:数据元素之间是多对多的关系</p>
</li>
</ul>
<p><strong>物理结构</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240305182500727.png" alt="image-20240305182500727" style="zoom:67%;" />

<h4 id="2-算法"><a href="#2-算法" class="headerlink" title="2.算法"></a>2.算法</h4><h5 id="2-1什么是算法"><a href="#2-1什么是算法" class="headerlink" title="2.1什么是算法"></a>2.1什么是算法</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240305182543990.png" alt="image-20240305182543990" style="zoom:67%;" />

<p>五个特性</p>
<ul>
<li><p>有穷性:一个算法必须总在执行有穷步之后结束，且每一步都可在有穷时间内完成。</p>
</li>
<li><p>确定性:算法中每条指令必须有确切的含义，对于<strong>相同的输入只能得出相同的输出。</strong></p>
</li>
<li><p>可行性:算法中描述的操作都可以通过已经实现的<strong>基本运算执行有限次来实现。</strong></p>
</li>
<li><p>输入:<strong>一个算法有零个或多个输入</strong>，这些输入取自于某个特定的对象的集合</p>
</li>
<li><p>输出:<strong>一个算法有一个或多个输出</strong>，这些输出是与输入有着某种特定关系的量。</p>
</li>
</ul>
<h5 id="2-2算法效率的度量"><a href="#2-2算法效率的度量" class="headerlink" title="2.2算法效率的度量"></a>2.2算法效率的度量</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240305183124686.png" alt="image-20240305183124686" style="zoom:67%;" />

<p><strong>时间复杂度</strong></p>
<p>只在乎n的最高次数（算法循环次数）</p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240305183809014.png" alt="image-20240305183809014" style="zoom: 33%;" />

<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240305183824953.png" alt="image-20240305183824953" style="zoom: 67%;" />

<p><strong>空间复杂度</strong></p>
<p>只在乎储存空间大小（算法所储存变量个数）</p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240305184800349.png" alt="image-20240305184800349" style="zoom: 50%;" />

<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240305184827267.png" alt="image-20240305184827267" style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240305184526616.png" alt="image-20240305184526616" style="zoom:67%;" />

<h4 id="3-线性表"><a href="#3-线性表" class="headerlink" title="3.线性表"></a>3.线性表</h4><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240305193451605.png" alt="image-20240305193451605" style="zoom: 67%;" />



<h5 id="3-1定义"><a href="#3-1定义" class="headerlink" title="3.1定义"></a>3.1定义</h5><p>线性表是具有相同数据类型的n(n&gt;&#x3D;0)个数据元素的有限序列，其n为表长，当n&#x3D;0时，线性表是一个空表。</p>
<p>若用L命名线性表，则其一般表为:	L&#x3D;(a1, a2,…,ai,ai+1,..an)</p>
<p><strong>几个概念：</strong></p>
<ul>
<li><p><strong>ai是线性表中的“第i个”元素线性表中的位序。</strong></p>
</li>
<li><p><strong>a1是表头元素；an是表尾元素。</strong></p>
</li>
<li><p><strong>除第一个元素外，每个元素有且仅有一个直接前驱；除最后一个元素外每个元素有且仅有一个直接后继。</strong></p>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240306180042672.png" alt="image-20240306180042672" style="zoom: 67%;" />

<h5 id="3-2存储结构"><a href="#3-2存储结构" class="headerlink" title="3.2存储结构"></a>3.2存储结构</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240306180150852.png" alt="image-20240306180150852" style="zoom:67%;" />

<p><strong>顺序存储与链式存储比较</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240306180244036.png" alt="image-20240306180244036" style="zoom:67%;" />

<p><strong>顺序存储与链式存储的基本操作</strong></p>
<p>顺序存储</p>
<ul>
<li><p>插入元素前要移动元素以挪出空的存储单元，然后再插入元素</p>
</li>
<li><p>删除元素时同样需要移动元素，以填充被删除元素的存储单元。</p>
</li>
</ul>
<p>链式存储</p>
<p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240306180414983.png" alt="image-20240306180414983"></p>
<h4 id="4-栈和队列"><a href="#4-栈和队列" class="headerlink" title="4.栈和队列"></a>4.栈和队列</h4><h5 id="4-1栈定义"><a href="#4-1栈定义" class="headerlink" title="4.1栈定义"></a>4.1栈定义</h5><p>线性表是具有相同数据类型的n(nz0)个数据元素的有限序列，其中n为表长，当n&#x3D;0时线 性表是一个空表。若用L命名线性表，则其一般表示为:</p>
<p>L&#x3D;(a1, a2,…, ai, ai+1,.,an)</p>
<p><mark><strong>栈(Stack)是只允许在一端进行插入或删除操作的线性表。</strong></mark></p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240306181028017.png" alt="image-20240306181028017" style="zoom: 80%;" />

<h5 id="4-2队列定义"><a href="#4-2队列定义" class="headerlink" title="4.2队列定义"></a>4.2队列定义</h5><p><mark><strong>队列是一种先进先出(FIFO)的线性表，它只允许在表的一端插入元素，而在表的另一端删除元素。</strong></mark>在队列中，允许插入元素的一端称为队尾(Rear)，允许删除元素的一端称为队头(Front)。</p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240306181202107.png" alt="image-20240306181202107" style="zoom:67%;" />

<p><strong>循环队列</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240306181259016.png" alt="image-20240306181259016" style="zoom:80%;" />

<p><strong>例题</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240306181313852.png" alt="image-20240306181313852" style="zoom: 67%;" />

<p>选D</p>
<h4 id="5-串、数组、矩阵和广义表"><a href="#5-串、数组、矩阵和广义表" class="headerlink" title="5.串、数组、矩阵和广义表"></a>5.串、数组、矩阵和广义表</h4><h5 id="5-1串"><a href="#5-1串" class="headerlink" title="5.1串"></a>5.1串</h5><p>串是仅由字符构成的有限序列，是取值范围受限的线性表。般记为S&#x3D; ‘a1 a2…an’，其中S是串名，a1a2…an是串值。</p>
<p><strong>五种串的定义：</strong></p>
<ul>
<li><p>(1)空串：长度为零的串，空串不包合任何字符。</p>
</li>
<li><p>(2)空格串：由一个或多个空格组成的串。含有子串的串</p>
</li>
<li><p>(3)子串：由串中任意长度的连续字符构成的序列。称为主串。子串在主串中的位置指子串首次出现时，该子串的第一个字符在主串中的位置。<mark><strong>空串是任意串的子串</strong>。</mark></p>
</li>
<li><p>(4)<mark><strong>串相等：指两个串长度相等且对应位置上的字符也相同。</strong></mark></p>
</li>
<li><p>(5)<mark><strong>串比较：两个串比较大小时以字符的ASCII码值作为依据。</strong></mark>比较操作从两个串的第一个字符开始进行，字符的ASCI码值大者所在–个串先结束，则以串长较大者为大。</p>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240306181819681.png" alt="image-20240306181819681" style="zoom: 50%;" />

<p><strong>对串进行的基本操作</strong></p>
<ul>
<li><p>赋值操作StrAssign(s,)：将串t的值赋给串s</p>
</li>
<li><p>连接操作Concat(s,t)：将串t接续在串s的尾部，形成一个新串。</p>
</li>
<li><p>求串长StrLength(s)：返回串s的长度。</p>
</li>
<li><p>串比较StrCompare(s.t)：比较两个串的大小。</p>
</li>
<li><p>求子串SubString(,tart,len)：返回串s中从start开始的、长度为len的字符序列。</p>
</li>
</ul>
<p><strong>串的存储结构</strong></p>
<ul>
<li><p>串的顺序存储：定长存储结构</p>
</li>
<li><p>串的链式存储：块链</p>
</li>
</ul>
<p>  <strong>子串的定位操作通常称为串的模式匹配</strong>，它是各种串处理系统中最重要的运算之一。子串也称为模式串。</p>
<h5 id="5-2数组"><a href="#5-2数组" class="headerlink" title="5.2数组"></a>5.2数组</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240306182429126.png" alt="image-20240306182429126" style="zoom: 67%;" />

<p><strong>例题：</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240306182442694.png" alt="image-20240306182442694" style="zoom:67%;" />

<p>答：26</p>
<p><strong>二维数组计算</strong>（没有原理，只有技巧）</p>
<ul>
<li><p><mark>按行优先，首地址+副对角线相乘再相加</mark></p>
</li>
<li><p><mark>按列优先，首地址+主对角线相乘再相加</mark></p>
</li>
</ul>
<p><strong>注意：</strong></p>
<p><mark>首地址从0开始A[0,0]</mark></p>
<ul>
<li><mark><strong>元素数字不变</strong></mark></li>
</ul>
<p><mark>首地址从1开始A[1,1]</mark></p>
<ul>
<li><mark><strong>元素</strong>A需行减-1，列-1</mark></li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240305203308565.png" alt="image-20240305203308565" style="zoom: 33%;" />

<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240305203511539.png" alt="image-20240305203511539" style="zoom:33%;" />

<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240305203657165.png" alt="image-20240305203657165" style="zoom:33%;" />

<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/Snipaste_2024-03-05_20-41-44.png" alt="Snipaste_2024-03-05_20-41-44" style="zoom:33%;" />

<h5 id="5-3矩阵"><a href="#5-3矩阵" class="headerlink" title="5.3矩阵"></a>5.3矩阵</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240306182842250.png" alt="image-20240306182842250" style="zoom: 67%;" />

<p><strong>例题：</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240306182906824.png" alt="image-20240306182906824" style="zoom:67%;" />

<p>答：使用代入法，由于三角矩阵首地址A[0,0]，压缩在数组首地址M[1]中，可得出A[0,0]&#x3D;M[1]，既i&#x3D;0,j&#x3D;0，A和D选项满足条件，又由于三角矩阵第二行首地址为A[1,0]，压缩在数组第二个地址M[2]中，既i&#x3D;1,j&#x3D;0，A满足条件。</p>
<h5 id="5-3广义表"><a href="#5-3广义表" class="headerlink" title="5.3广义表"></a>5.3广义表</h5><p>广义表是n个表元素组成的有限序列，是线性表的推广。通常用递归的形式进行定义，记做:LS&#x3D;(ao,a1…，an)。</p>
<p><strong>定义：</strong></p>
<ul>
<li><p>其中LS是表名，a：是表元素，它可以是表(称做子表)，也可以是数据元素(称为原子)。</p>
</li>
<li><p>其中n是广义表的长度(也就是最外层包含的元素个数)，n&#x3D;0的广义表为空表。</p>
</li>
<li><p>而递归定义的重数就是广义表的深度，直观地说，就是定义中所含括号的重数(原子的深度为0，空表的深度为1)。</p>
</li>
</ul>
<p><strong>基本运算</strong></p>
<ul>
<li><p>取表头head(Ls)和取表尾tail(Ls)。</p>
</li>
<li><p>若有:LS1 &#x3D; (a，(b，c)，(d，e))</p>
<p>head(Ls1) &#x3D; a</p>
<p>tail(Ls1) &#x3D; ((b，c)，(d，e))</p>
</li>
</ul>
<p><strong>重点：</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240308183743533.png" alt="image-20240308183743533" style="zoom: 50%;" />

<p><strong>例题：</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240308183832607.png" alt="image-20240308183832607" style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240308183933222.png" alt="image-20240308183933222" style="zoom:50%;" />



<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240306184236384.png" alt="image-20240306184236384" style="zoom:67%;" />

<p>答：1.长度5，深度2</p>
<ol start="2">
<li>先取表尾tail(LS1)，再执行取表头head(tail(LS1))，再取表头head(head(tail(Ls1)))</li>
</ol>
<h4 id="6-树和二叉树"><a href="#6-树和二叉树" class="headerlink" title="6.树和二叉树"></a>6.树和二叉树</h4><h5 id="6-1树的基本概念："><a href="#6-1树的基本概念：" class="headerlink" title="6.1树的基本概念："></a>6.1<strong>树的基本概念：</strong></h5><p>1.结点的度</p>
<p>2.树的度</p>
<p>3.叶子结点</p>
<p>4.分支结点</p>
<p>5.内部结点</p>
<p>6.父结点</p>
<p>7.子结点</p>
<p>8.兄弟结点</p>
<p>9.层次</p>
<p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240308193922788.png" alt="image-20240308193922788"></p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240308193951620.png" alt="image-20240308193951620"  />

<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240308194007549.png" alt="image-20240308194007549" style="zoom: 67%;" />

<h5 id="6-2二叉树的遍历："><a href="#6-2二叉树的遍历：" class="headerlink" title="6.2二叉树的遍历："></a>6.2二叉树的遍历：</h5><ul>
<li><p>前序遍历:根左右</p>
</li>
<li><p>中序遍历:左根右</p>
</li>
<li><p>后序遍历:左右根</p>
</li>
<li><p>层次遍历：按层遍历</p>
</li>
</ul>
<p><strong>反向构造二叉树</strong></p>
<p><strong>例题：</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240308194654024.png" alt="image-20240308194654024" style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240308194733081.png" alt="image-20240308194733081" style="zoom:50%;" />



<h5 id="6-3树、二叉树、森林的转换"><a href="#6-3树、二叉树、森林的转换" class="headerlink" title="6.3树、二叉树、森林的转换"></a>6.3树、二叉树、森林的转换</h5><p><strong>树—&gt;二叉树</strong></p>
<p>兄弟相连留长子，兄弟变为右孩子。</p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240308175839513.png" alt="image-20240308175839513" style="zoom:50%;" />

<p><strong>二叉树—&gt;树</strong></p>
<p>右孩子变兄弟，兄弟不连留长子。</p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240308180135071.png" alt="image-20240308180135071" style="zoom:50%;" />

<p><strong>森林—&gt;二叉树</strong></p>
<p>兄弟相连留长子，兄弟变为右孩子，连接所有根节点。（树变二叉根相连）</p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240308180826070.png" alt="image-20240308180826070" style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240308180903594.png" alt="image-20240308180903594" style="zoom: 25%;" />

<p><strong>二叉树—&gt;森林</strong></p>
<p>右孩子变兄弟，兄弟不连留长子，根不连。</p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240308181253836.png" alt="image-20240308181253836" style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240308181831273.png" alt="image-20240308181831273" style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240307210816-17098170018274.jpg" alt="微信图片_20240307210816" style="zoom:25%;" />

<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240307210624-17098171043856.jpg" alt="微信图片_20240307210624" style="zoom:25%;" />



<h5 id="6-4查找二叉树-二叉排序树"><a href="#6-4查找二叉树-二叉排序树" class="headerlink" title="6.4查找二叉树(二叉排序树)"></a>6.4查找二叉树(二叉排序树)</h5><p><strong>特点：左孩子小于根，右孩子大于根。</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240308195126757.png" alt="image-20240308195126757" style="zoom: 67%;" />

<p>插入结点：</p>
<p>①若该键值结点已存在,则不再插入，如: 48.</p>
<p>②)若查找二叉树为空树,则以新结点为查找二叉树。</p>
<p>③将要插入结点键值与插入后父结点键值比较，就能确定新结点是父结点的左子结点,还是右子结点。</p>
<p>删除结点：</p>
<p>①若待删除结点是叶子结点,则直接删除。</p>
<p>②若待删除结点只有一个子结点,则将这个子结点与待删除结点的父结点直接连接，如:56。</p>
<p>③若待删除的结点p有两个子结点，则在其左子树上，用中序遍历寻找关键值最大的结点s,用结点s的值代替结点p的值，然后删除节点s，节点s必属于上述①，②情况之一，如89。</p>
<h5 id="6-5构造Huffman树-带权路径长度最小"><a href="#6-5构造Huffman树-带权路径长度最小" class="headerlink" title="6.5构造Huffman树(带权路径长度最小)"></a>6.5构造Huffman树(带权路径长度最小)</h5><p><mark>Huffman树构造不唯一，因此编码也不唯一，但是带权路径长度（WLP）唯一。</mark></p>
<p><strong>构造方法：</strong></p>
<p>选取数组中权值最小的两个数构成叶子节点，将相加和再次放入数组中，从下到上依次重复执行。</p>
<p><strong>例题1：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240308195725295.png" alt="image-20240308195725295"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240308195740361.png" alt="image-20240308195740361"></p>
<p><strong>例题2：</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240307210149.jpg" alt="微信图片_20240307210149" style="zoom:25%;" />

<h5 id="6-6线索二叉树"><a href="#6-6线索二叉树" class="headerlink" title="6.6线索二叉树"></a>6.6线索二叉树</h5><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240308200313628.png" alt="image-20240308200313628"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240308200323522.png" alt="image-20240308200323522"></p>
<p><strong>画线索技巧：</strong></p>
<p><mark><strong>某节点若没有左孩子，则线索指向它的前驱；</strong></mark></p>
<p><mark><strong>某节点若没有右孩子，则线索指向它的后继。</strong></mark></p>
<p><strong>例题：</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240308172852440.png" alt="image-20240308172852440" style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240308172954917.png" alt="image-20240308172954917" style="zoom:50%;" />



<h5 id="6-7平衡二叉树"><a href="#6-7平衡二叉树" class="headerlink" title="6.7平衡二叉树"></a>6.7平衡二叉树</h5><p><strong>定义：任意结点的左右子树深度相差不超过1，每结点的平衡度只能为-1、0或1。</strong></p>
<p>提出的原因：</p>
<p>例:对数列{1,5,7,9,8,39,73,88}构造排序二叉树，可以构造出多棵形式不同的排序二叉树。</p>
<p>不平衡：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240308201352076.png" alt="image-20240308201352076"></p>
<p>平衡：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240308201502167.png" alt="image-20240308201502167"></p>
<h4 id="7-图"><a href="#7-图" class="headerlink" title="7.图"></a>7.图</h4><h5 id="7-1基本概念"><a href="#7-1基本概念" class="headerlink" title="7.1基本概念"></a>7.1基本概念</h5><p>1、有向图</p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240308202126615.png" alt="image-20240308202126615" style="zoom: 50%;" />

<p>2、无向图</p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240308202137900.png" alt="image-20240308202137900" style="zoom:50%;" />

<p>3、完全图</p>
<ul>
<li>在无向图中，若每对顶点之间都有一条边相连，则称该图为完全图。</li>
<li>在有向图中,若每对顶点之间都有二条有向边相互连接,则称该图为完全图。</li>
</ul>
<p>4、度，入度与出度</p>
<h5 id="7-2储存结构"><a href="#7-2储存结构" class="headerlink" title="7.2储存结构"></a>7.2储存结构</h5><p><strong>邻接矩阵</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240308202236491.png" alt="image-20240308202236491" style="zoom: 50%;" />

<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240308202244742.png" alt="image-20240308202244742" style="zoom:50%;" />

<h5 id="7-3图的遍历"><a href="#7-3图的遍历" class="headerlink" title="7.3图的遍历"></a>7.3图的遍历</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240308202354444.png" alt="image-20240308202354444" style="zoom:50%;" />

<h5 id="7-4拓扑排序"><a href="#7-4拓扑排序" class="headerlink" title="7.4拓扑排序"></a>7.4拓扑排序</h5><p><strong>拓扑排序概念：</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240308190153589.png" alt="image-20240308190153589" style="zoom: 50%;" />

<p><strong>拓扑序列不唯一。</strong></p>
<p><strong>拓扑排序过程：</strong></p>
<ul>
<li><mark>在有向图中选一个无前驱的顶点且输出它。</mark></li>
<li><mark>从图中删除该顶点和所有以它为尾的张。</mark></li>
<li><mark>重复(1)和(2)，直至不存在无前驱的顶点。</mark></li>
<li><mark>若此时输出的顶点数小于有向图中的顶点数，则说明有向图中存在环。否则输出的顶点序列即为一个拓扑序列。</mark></li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240308202516122.png" alt="image-20240308202516122" style="zoom:50%;" />

<p><strong>例题：</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240308190625058.png" alt="image-20240308190625058" style="zoom: 50%;" />

<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240308190722695.png" alt="image-20240308190722695" style="zoom: 67%;" />



<h5 id="7-5最小生成树"><a href="#7-5最小生成树" class="headerlink" title="7.5最小生成树"></a>7.5最小生成树</h5><p><strong>概念：</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240308202937992.png" alt="image-20240308202937992" style="zoom:50%;" />

<p><strong>prim算法（加点法）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240308203209735.png" alt="image-20240308203209735"></p>
<p><strong>kruakal算法（加边法）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240308203256316.png" alt="image-20240308203256316"></p>
<p>当存在权值相等的边时，最小生成树可能不唯一。</p>
<p><strong>例题1：</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240308203824319.png" alt="image-20240308203824319" style="zoom:50%;" />

<p><strong>例题2：</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240308204259371.png" alt="image-20240308204259371" style="zoom:50%;" />

<h4 id="8-查找"><a href="#8-查找" class="headerlink" title="8.查找"></a>8.查找</h4><p>在数据集合中寻找满足某种条件的数据元素的过程称为查找。</p>
<p>查找表(查找结构)–用于查找的数据集合称为查找表，它由同一类型的类据元素(或记录)组成。</p>
<p>数据元素中唯一标识该元素的某个数据项的值，使用基于关键字关键字–查找，查找结果应该是唯一的。</p>
<p>查找长度–在查找运算中，需要对比关键字的次数称为查找长度。</p>
<p>平均查找长度(ASL，Average Search Length)– 所有查找过程中进行关键字的比较次数的平均值。</p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240309213542009.png" alt="image-20240309213542009" style="zoom:50%;" />

<h5 id="8-1顺序查找"><a href="#8-1顺序查找" class="headerlink" title="8.1顺序查找"></a>8.1顺序查找</h5><p>顺序查找，又叫“线性查找”，通常用于线性表。算法思想:从头到脚挨个找(或者反过来也OK)</p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240309213604222.png" alt="image-20240309213604222" style="zoom:50%;" />



<h5 id="8-2折半查找"><a href="#8-2折半查找" class="headerlink" title="8.2折半查找"></a>8.2折半查找</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240309213719521.png" alt="image-20240309213719521" style="zoom: 50%;" />

<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240309213816391.png" alt="image-20240309213816391" style="zoom: 50%;" />



<h5 id="8-3分块查找"><a href="#8-3分块查找" class="headerlink" title="8.3分块查找"></a>8.3分块查找</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240309213900092.png" alt="image-20240309213900092" style="zoom:50%;" />

<p><strong>特点：块内无序、块间有序</strong></p>
<p>第一步在索引表中确定待查记录所在的块，第二步在块内顺序查找。</p>
<h5 id="8-4哈希表"><a href="#8-4哈希表" class="headerlink" title="8.4哈希表"></a>8.4哈希表</h5><p>散列表(Hash Table)又称哈希表。是一种数据结构，特点是:数据元素的关键字与其存储地址直接相关。</p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240309214157554.png" alt="image-20240309214157554" style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240309214206896.png" alt="image-20240309214206896" style="zoom:50%;" />

<p><strong>冲突：若不同的关键字通过散列函数映射到同一个值，则称它们为“同义词通过散列函数确定的位置已经存放了其他元素，则称这种情况为“冲突”。</strong></p>
<p>解决冲突方法：开放地址法、链地址法、再哈希法、建立一个公共溢出区。</p>
<h4 id="9-排序"><a href="#9-排序" class="headerlink" title="9.排序"></a>9.排序</h4><h5 id="9-1冒泡排序"><a href="#9-1冒泡排序" class="headerlink" title="9.1冒泡排序"></a>9.1冒泡排序</h5><p> 冒泡排序(Bubble Sort)，又被称为气泡排序或泡沫排序。<strong>它会遍历若干次需要排序的数列，每次遍历时，它都会从前往后依次的<mark>比较相邻两个数的大小</mark>；如果<mark>前者比后者大，则交换它们的位置</mark>。这样，一次遍历之后，最大的元素就在数列的末尾！ 采用相同的方法再次遍历时，第二大的元素就被排列在最大元素之前。</strong>重复此操作，直到整个数列都有序为止。</p>
<p>冒泡排序升序：元素两两比较，小的在前，大的在后，交换位置，依次重复，最终从末端向左依次逐渐。</p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/v2-33a947c71ad62b254cab62e5364d2813_b.gif" alt="v2-33a947c71ad62b254cab62e5364d2813_b" style="zoom: 67%;" />

<p>假设待排序序列为 (5,1,4,2,8)，如果采用冒泡排序对其进行升序（由小到大）排序，则整个排序过程如下所示：</p>
<ol>
<li>第一轮排序，此时整个序列中的元素都位于待排序序列，依次扫描每对相邻的元素，并对顺序不正确的元素对交换位置，整个过程如图 1 所示。</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240309210537956.png" alt="image-20240309210537956" style="zoom:50%;" />

<p>从图 1 可以看到，经过第一轮冒泡排序，从待排序序列中找出了最大数 8，并将其放到了待排序序列的尾部，并入已排序序列中。</p>
<ol start="2">
<li>第二轮排序，此时待排序序列只包含前 4 个元素，依次扫描每对相邻元素，对顺序不正确的元素对交换位置，整个过程如图 2 所示。</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240309210630962.png" alt="image-20240309210630962" style="zoom:50%;" />

<p>可以看到，经过第二轮冒泡排序，从待排序序列中找出了最大数 5，并将其放到了待排序序列的尾部，并入已排序序列中。</p>
<ol start="3">
<li>第三轮排序，此时待排序序列包含前 3 个元素，依次扫描每对相邻元素，对顺序不正确的元素对交换位置，整个过程如图 3 所示。</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240309210640333.png" alt="image-20240309210640333" style="zoom:50%;" />

<p>经过本轮冒泡排序，从待排序序列中找出了最大数 4，并将其放到了待排序序列的尾部，并入已排序序列中。</p>
<ol start="4">
<li>第四轮排序，此时待排序序列包含前 2 个元素，对其进行冒泡排序的整个过程如图 4 所示。</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240309210701680.png" alt="image-20240309210701680" style="zoom:50%;" />

<p>经过本轮冒泡排序，从待排序序列中找出了最大数 2，并将其放到了待排序序列的尾部，并入已排序序列中。</p>
<ol start="5">
<li>当进行第五轮冒泡排序时，由于待排序序列中仅剩 1 个元素，无论再进行相邻元素的比较，因此直接将其并入已排序序列中，此时的序列就认定为已排序好的序列（如图 5 所示）。</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240309210750236.png" alt="image-20240309210750236" style="zoom:50%;" />



<h5 id="9-2选择排序"><a href="#9-2选择排序" class="headerlink" title="9.2选择排序"></a>9.2选择排序</h5><p>从头至尾扫描序列，找出最小的一个元素，和第一个元素交换，接着从剩下的元素中继续这种选择和交换方式，最终得到一个有序序列。</p>
<p>动图：<a target="_blank" rel="noopener" href="https://pic1.zhimg.com/v2-1c7e20f306ddc02eb4e3a50fa7817ff4_b.webp">https://pic1.zhimg.com/v2-1c7e20f306ddc02eb4e3a50fa7817ff4_b.webp</a></p>
<p><strong>算法优化</strong></p>
<p>选择排序一趟只选取最小值，优化的办法就是<strong>一趟把最小值和最大值都选出来</strong>，<strong>最小的放在左边，最大的放在右边优化后的方法循环趟数将减半</strong>。</p>
<h5 id="9-3插入排序"><a href="#9-3插入排序" class="headerlink" title="9.3插入排序"></a>9.3插入排序</h5><p>插入排序算法常常被比作打牌：<mark>我们从第二个元素开始，此后的每个元素就像新拿到的一张牌，我们要做的事就是将这张牌与之前的所有手牌进行比较，把这张牌插到适合他的位置。</mark>这样，我们看过所有牌之后，他们的顺序自然就是从小到大或从大到小了~</p>
<p>从前往后，每次拿出一个元素，从后向前扫描，比较大小，找到相应位置并插入。</p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/v2-91b76e8e4dab9b0cad9a017d7dd431e2_b.gif" alt="v2-91b76e8e4dab9b0cad9a017d7dd431e2_b" style="zoom: 67%;" />



<h5 id="9-4希尔排序"><a href="#9-4希尔排序" class="headerlink" title="9.4希尔排序"></a>9.4希尔排序</h5><p>希尔排序就是升级版的插入排序，由D.L.Shell于1959年提出而得名希尔排序。<mark>它会从大到小，通过设置不同的间隔，优先对“子数列”进行插入排序，最后实现对整体进行排序。</mark>它对于计算机而言会更加“经济”，但是对于人来说，这未免更难以理解，毕竟我们都不是这么打牌的。</p>
<p><strong>基本思想：</strong></p>
<ul>
<li><p>将待排序数组按照一定的间隔分为多个子数组，每组分别进行插入排序。这里按照间隔分组指的不是取连续的一段数组，而是每跳跃一定间隔取一个值组成一组。</p>
</li>
<li><p>逐渐缩小间隔进行下一轮排序。</p>
</li>
<li><p>最后一轮时，取间隔为 1，也就相当于直接使用插入排序。但这时经过前面的「宏观调控」，数组已经基本有序了，所以此时的插入排序只需进行少量交换便可完成。</p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/6f304b5936f54b1fa34372de002b6e39.png" alt="6f304b5936f54b1fa34372de002b6e39" style="zoom: 80%;" />

<p>动图：<a target="_blank" rel="noopener" href="https://vdn6.vzuu.com/SD/6613c382-2362-11eb-a750-d6c52a23d5aa.mp4?pkey=AAWC8g1iqWHaXJ0HthWhutvZ9HpwSst14r_5NQsgwOZSZKu3Az-7QrokptSq4Kyy85l6fUpNVfdqme1KJNLEWnEg&c=avc.0.0&f=mp4&pu=078babd7&bu=078babd7&expiration=1709998038&v=ks6">https://vdn6.vzuu.com/SD/6613c382-2362-11eb-a750-d6c52a23d5aa.mp4?pkey=AAWC8g1iqWHaXJ0HthWhutvZ9HpwSst14r_5NQsgwOZSZKu3Az-7QrokptSq4Kyy85l6fUpNVfdqme1KJNLEWnEg&amp;c=avc.0.0&amp;f=mp4&amp;pu=078babd7&amp;bu=078babd7&amp;expiration=1709998038&amp;v=ks6</a></p>
</li>
</ul>
<h5 id="9-5快速排序"><a href="#9-5快速排序" class="headerlink" title="9.5快速排序"></a>9.5快速排序</h5><p>快速排序是C.R.A.Hoare于1962年提出的。</p>
<p><strong>基本思想：</strong></p>
<ul>
<li>先从数列中取出一个元素作为基准数。</li>
<li>扫描数列，将比基准数小的元素全部放到它的左边，大于或等于基准数的元素全部放到它的右边，得到左右两个区间。</li>
<li>再对左右区间重复第二步，直到各区间少于两个元素。</li>
</ul>
<p>动图：<a target="_blank" rel="noopener" href="https://pic1.zhimg.com/v2-c411339b79f92499dcb7b5f304c826f4_b.webp">https://pic1.zhimg.com/v2-c411339b79f92499dcb7b5f304c826f4_b.webp</a></p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240309200940816.png" alt="image-20240309200940816" style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240309201004494.png" alt="image-20240309201004494" style="zoom: 67%;" />



<h5 id="9-6归并排序"><a href="#9-6归并排序" class="headerlink" title="9.6归并排序"></a>9.6归并排序</h5><p>归并排序，是创建在归并操作上的一种有效的排序算法。算法是<strong>采用分治法</strong>（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。归并排序思路简单，速度仅次于快速排序，为稳定排序算法。</p>
<p><strong>基本思想</strong>：</p>
<ol>
<li><strong>将序列中待排序数字分为若干组，最终每个数字分为一组。（默认长度为1的序列是有序的）</strong></li>
<li><strong>将若干个组两两合并，保证合并后的组是有序的。（俩个子序列头部进行比较大小）</strong></li>
<li><strong>重复第二步操作直到只剩下一组，排序完成。</strong></li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240309192849272.png" alt="image-20240309192849272" style="zoom:50%;" />



<h5 id="9-7堆排序"><a href="#9-7堆排序" class="headerlink" title="9.7堆排序"></a>9.7堆排序</h5><p><strong>基本思想：</strong></p>
<ul>
<li><p>首先，把要排序的数组变成一个大顶堆，这样最大的数就在堆的顶部。</p>
</li>
<li><p>接着，把堆顶的数和数组的最后一个数交换。现在，最大的数已经在数组的末尾，剩下的数组元素个数变为 n-1。</p>
</li>
<li><p>对剩下的 n-1 个数再次构建大顶堆，然后把新堆顶的数和 n-1 位置的数交换。不断重复这个过程，直到得到一个升序排列的数组。</p>
</li>
</ul>
<p><strong>注意</strong>：要得到升序排列的数组，用大顶堆；要得到降序排列的数组，用小顶堆（默认情况下，我们使用升序排序）。</p>
<p>动图：<a target="_blank" rel="noopener" href="https://vdn6.vzuu.com/SD/3bb38dfe-236a-11eb-8039-a6caf32b14c9.mp4?pkey=AAXegJegAOYaIZJ2lt_NrJ_tqfqL-0qseqCFmvbqfa7oYnW6KHwSMV8afFgYY_l4WBsUMjCJ0JRqpYNjHX66q0ms&c=avc.0.0&f=mp4&pu=078babd7&bu=078babd7&expiration=1709998241&v=ks6">https://vdn6.vzuu.com/SD/3bb38dfe-236a-11eb-8039-a6caf32b14c9.mp4?pkey=AAXegJegAOYaIZJ2lt_NrJ_tqfqL-0qseqCFmvbqfa7oYnW6KHwSMV8afFgYY_l4WBsUMjCJ0JRqpYNjHX66q0ms&amp;c=avc.0.0&amp;f=mp4&amp;pu=078babd7&amp;bu=078babd7&amp;expiration=1709998241&amp;v=ks6</a></p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240309194855331.png" alt="image-20240309194855331" style="zoom: 67%;" />

<p><strong>现在我们已经构建了一个大顶堆，接下来进行排序。</strong></p>
<p><strong>首先，将堆顶元素（假设为9）与数组末尾元素（假设为4）交换位置</strong>。此时，数组末尾的数字是最大值。<strong>排除已经确定的最大元素，将剩下的元素重新构建成一个大顶堆。</strong></p>
<p><strong>以下是第一次交换的示意图：</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240309195009037.png" alt="image-20240309195009037" style="zoom: 67%;" />



<h5 id="9-8基数排序（桶排序）"><a href="#9-8基数排序（桶排序）" class="headerlink" title="9.8基数排序（桶排序）"></a>9.8基数排序（桶排序）</h5><p><strong>基本思想：</strong></p>
<p>将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。</p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240309200014247.png" alt="image-20240309200014247" style="zoom: 67%;" />

<p>动图：<a target="_blank" rel="noopener" href="https://upload-images.jianshu.io/upload_images/13587608-450e0c1edb8c7137.gif">https://upload-images.jianshu.io/upload_images/13587608-450e0c1edb8c7137.gif</a></p>
<h5 id="9-9计数排序（Counting-Sort）"><a href="#9-9计数排序（Counting-Sort）" class="headerlink" title="9.9计数排序（Counting Sort）"></a>9.9计数排序（Counting Sort）</h5><blockquote>
<p>计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>
</blockquote>
<p><strong>算法描述</strong> - 找出待排序的数组中最大和最小的元素； - 统计数组中每个值为i的元素出现的次数，存入数组C的第i项； - 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）； - 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</p>
<p>动图：<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/v2-3c7ddb59df2d21b287e42a7b908409cb_b.gif" alt="v2-3c7ddb59df2d21b287e42a7b908409cb_b" style="zoom:67%;" /></p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240309195416586.png" alt="image-20240309195416586" style="zoom: 67%;" />

<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240310152916106.png" alt="image-20240310152916106" style="zoom: 33%;" />

<h3 id="第3章：算法分析与设计"><a href="#第3章：算法分析与设计" class="headerlink" title="第3章：算法分析与设计"></a>第3章：算法分析与设计</h3><h4 id="3-1分治法"><a href="#3-1分治法" class="headerlink" title="3.1分治法"></a>3.1分治法</h4><p>对于一个规模为n的问题,若该问题可以容易地解决(比如说规模n较小则直接解决，否则将其分解为k个规模较小的子问题，这些<mark>子问题互相独立且与原问题形式相同</mark>，递归地解这些子问题,然后将各子问题的解合并得到原问题的解。</p>
<p><strong>要求:</strong></p>
<ul>
<li>该问题的规模缩小到一定的程度就可以容易地解决</li>
<li>该问题可以分解为若干个规模较小的相同问题</li>
<li>利用该问题分解出的子问题的解可以合并为该问题的解</li>
<li><strong>该问题所分解出的各个子问题是相互独立的。</strong></li>
</ul>
<p><strong>递归算法：</strong></p>
<p>程序执行过程中自己调用自己。</p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240310151450204.png" alt="image-20240310151450204" style="zoom: 50%;" />

<p><strong>快速排序</strong></p>
<h4 id="3-2动态规划"><a href="#3-2动态规划" class="headerlink" title="3.2动态规划"></a>3.2动态规划</h4><h5 id="3-2-1动态规划算法"><a href="#3-2-1动态规划算法" class="headerlink" title="3.2.1动态规划算法"></a>3.2.1动态规划算法</h5><p><strong>基本思想</strong></p>
<p>将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。<mark>与分治法不同的是，适合于用动态规划法求解的问题，经分解得到的子问题往往不是独立的。</mark><mark>与贪心算法不同的是，找到的解是整体最优的解。</mark></p>
<p><strong>动态规划算法重要性质：</strong></p>
<p><strong>1. 最优子结构</strong></p>
<p>设计动态规划算法的第一步通常是要刻画最优解的结构。当问题的最优解包含了其子问题的最优解时，称该问题具有最优子结构性质。问题的最优子结构性质提供了该问题可用动态规划算法求解的重要线索。利用问题的最优子结构性质，以自底向上的方式递归地从子问题的最优解逐步构造出整个问题的最优解。</p>
<p><strong>2. 重叠子问题</strong></p>
<p>可用动态规划算法求解的问题应具备的另一基本要素是子问题的重叠性质。在用递归算法自顶向下解此问题时，每次产生的子问题并不总是新问题，有些子问题被反复计算多次。动态规划算法正是利用了这种子问题的重叠性质，<strong>对每一个子问题只解一次，而后将其解保存在一个表格中，当再次需要解此子问题时，只是简单地用常数时间查看一下结果</strong>。通常，不同的子问题个数随问题的大小呈多项式增长。因此，用动态规划算法通常只需要多项式时间，从而获得较高的解题效率。</p>
<p>动态规划算法通常用于求解具有某种最优性质的问题在这类问题中，可能会有许多可行解，每个解都对应于一个值，我们希望找到具有最优值的那个解。当然，最优解可能会有多个，动态规划算法能找出其中的一个最优解。</p>
<p><strong>0-1背包问题</strong></p>
<p> 假设我们有n件物品，分别编号为1, 2…n。其中编号为i的物品价值为vi，它的重量为wi。为了简化问题，假定价值和重量都是整数值。现在，假设我们有一个背包，它能够承载的重量是W。现在，我们希望往包里装这些物品，使得包里装的物品价值最大化。</p>
<p>这个问题其实根据不同的情况可以归结为不同的解决方法。假定我们这里<strong>选取的物品每个都是独立的，不能选取部分</strong>。也就是说我们要么选取某个物品，要么不能选取，不能只选取一个物品的一部分。这种情况，我们称之为0-1背包问题。</p>
<p>举例说明：</p>
<p>设背包容量为5，有五个物品：</p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240310150356549.png" alt="image-20240310150356549" style="zoom: 33%;" />

<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240310150525093.png" alt="image-20240310150525093" style="zoom:33%;" />

<p><mark>动态规划本质：就是填表</mark>，一旦找出动态转移方程，就可以用方程把整个表都填满了。</p>
<p>这里我们先将空表画出来，<strong>i表示物品，j表示背包容量。</strong></p>
<p>容易看出，当J&#x3D;0(背包容量为0)时，背包价值永远为0，故第一列全为0；当i&#x3D;0(没有物品)时，背包价值永远为0，故第一行全为0。</p>
<p><mark>0-1背包问题：时间复杂度：O(nW)  （n：物品数量，W：最大装包容量）</mark></p>
<h5 id="3-2-2贪心算法"><a href="#3-2-2贪心算法" class="headerlink" title="3.2.2贪心算法"></a>3.2.2贪心算法</h5><p>总是做出在当前来说是最好的选择，而并不从整体上加以考虑,它所做的每步选择只是当前步骤的局部最优选择，但从整体来说不一定是最优的选择。由于它不必为了寻找最优解而穷尽所有可能解，因此其耗费时间少，一般可以快速得到满意的解，但得不到最优解。也常用于解决最优化的问题。</p>
<p><strong>贪心算法重要性质：</strong></p>
<p><strong>1. 最优子结构</strong></p>
<p>当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构。问题的最优子结构是该问题可以采用动态规划法或者贪心法求解的关键性质。</p>
<p><strong>2. 贪心选择性质</strong></p>
<p>指问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来得到。这是贪心法和动态规划法的主要区别。</p>
<p><strong>部分背包问题</strong></p>
<p>部分背包问题。有n个物体，第i个物体的重量为wi，价值为vi。在总重量不超过C的情况下让总价值尽量高。<strong>每一个物体都可以只取走一部分，价值和重量按比例计算</strong>。</p>
<p><mark>贪心策略本质：优先拿性价比高的，也就是vi &#x2F; wi大的，直到重量恰好为C。</mark></p>
<p>由于可以拿部分，因此一定能保证重量恰好为C(除非n个物体总重量不足C)，并且除了拿的最后一个物体可能是拿部分以外，其他拿的都是拿整个。</p>
<p><mark>部分背包问题：时间复杂度：O(nlogn)</mark></p>
<h4 id="3-3回溯法"><a href="#3-3回溯法" class="headerlink" title="3.3回溯法"></a>3.3回溯法</h4><p>回溯法是种选优搜索法,按选优条件向前搜索,以达到目标。但当搜索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择。这种走不通就退回再走的技术就是回溯法。</p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240310152737384.png" alt="image-20240310152737384" style="zoom:50%;" />





<h3 id="第4章：操作系统基本原理"><a href="#第4章：操作系统基本原理" class="headerlink" title="第4章：操作系统基本原理"></a>第4章：操作系统基本原理</h3><h4 id="4-1基本概念"><a href="#4-1基本概念" class="headerlink" title="4.1基本概念"></a>4.1基本概念</h4><p><strong>特征：</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240310155920376.png" alt="image-20240310155920376" style="zoom: 33%;" />

<p><strong>发展与分类：</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240310160006326.png" alt="image-20240310160006326" style="zoom: 33%;" />

<h4 id="4-2进程管理"><a href="#4-2进程管理" class="headerlink" title="4.2进程管理"></a>4.2进程管理</h4><h5 id="4-2-1进程概念"><a href="#4-2-1进程概念" class="headerlink" title="4.2.1进程概念"></a>4.2.1进程概念</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240310175533814.png" alt="image-20240310175533814" style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240310175609911.png" alt="image-20240310175609911" style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240310175635999.png" alt="image-20240310175635999" style="zoom:50%;" />

<h5 id="4-2-2进程执行流程"><a href="#4-2-2进程执行流程" class="headerlink" title="4.2.2进程执行流程"></a>4.2.2进程执行流程</h5><p>三状态图：</p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240310175457737.png" alt="image-20240310175457737" style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240310175709484.png" alt="image-20240310175709484" style="zoom:50%;" />

<p>选C</p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240310180425283.png" alt="image-20240310180425283" style="zoom:50%;" />

<p>选C</p>
<p>五状态图：</p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240310180120927.png" alt="image-20240310180120927" style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240310160127593.png" alt="image-20240310160127593" style="zoom:33%;" />

<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240310155655980.png" alt="image-20240310155655980" style="zoom: 33%;" />



<p><strong>进程同步机制:</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240310160505935.png" alt="image-20240310160505935" style="zoom:33%;" />

<p>读进程和写进程并发地运行，由于并发必然导致异步性，因此“写数读”和“读数据”两个操作执行的先后顺序是不确定的。而实际应用中又必须按照“写数据一读数据”的顺序来执行的。进程同步机制”所讨论的内容。就是如何解决这种异步问题。</p>
<p>同步：亦称直接制约关系，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。</p>
<h5 id="4-2-3信号量与PV操作"><a href="#4-2-3信号量与PV操作" class="headerlink" title="4.2.3信号量与PV操作"></a>4.2.3信号量与PV操作</h5><p><mark>临界资源就是互斥资源。</mark></p>
<p><strong>进程互斥机制：</strong></p>
<p>进程的“并发”需要“共享”的支持。各个并发执行的进程不可避免的需要共享一些系统资源(比如内存，又比如汀印机、摄像头这样的I&#x2F;0设备。</p>
<p><mark>我们把一个时间段内只允许一个进程使用的资源称为临界资源（互斥资源）。</mark>此外还有许多变量、数据、内存缓冲区等都属都属于临界资源。物理设备(比如摄像头、打印机)都属都属于临界资源。</p>
<p><mark>对临界资源访问，必须互斥的进行。</mark>互斥，亦称间接制约关系。进程必互斥指当一个进程访问某临界资源，另一个想要访问该临界资源的明须等待。当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源。</p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240310181234260.png" alt="image-20240310181234260" style="zoom: 50%;" />



<h6 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h6><p>信号量是一种特殊的变量。</p>
<ul>
<li><p>信号量为正数表示资源数量;</p>
</li>
<li><p>信号量为负数时，绝对值表示排队进程数（阻塞队列数量）。</p>
<p>P是荷兰语Passeren,V是荷兰语Verhoog.</p>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240310182534445.png" alt="image-20240310182534445" style="zoom:50%;" />

<p><mark>P：要资源；V：释放资源<mark></p>
<p>例题：</p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240310182838144.png" alt="image-20240310182838144" style="zoom:50%;" />

<p>初值2；范围[-1,2]</p>
<h6 id="互斥模型"><a href="#互斥模型" class="headerlink" title="互斥模型"></a>互斥模型</h6><p><strong>多个进程共享（互斥）一台打印机问题</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240310183305425.png" alt="image-20240310183305425" style="zoom:50%;" />

<p>注:</p>
<ul>
<li><p><mark>互斥信号量S（资源数量）一般初值为1。</mark></p>
</li>
<li><p><mark>互斥信号量S的初值一般为非0。</mark></p>
</li>
<li><p><mark>访问权是一类特殊的互斥资源，同一时刻仅允许1个人用，则信号量初值为1。</mark></p>
</li>
<li><p><strong>先P后V</strong></p>
</li>
</ul>
<h6 id="同步模型"><a href="#同步模型" class="headerlink" title="同步模型"></a>同步模型</h6><p><strong>单缓冲区生产者、消费者问题</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240311172833295.png" alt="image-20240311172833295" style="zoom: 50%;" />

<p>S1：市场个数，初值为1；S2：产品数量，初值为0；</p>
<p>注：</p>
<ul>
<li><strong>同步信号量S的初值一般为0。</strong></li>
<li><strong>先V后P</strong></li>
</ul>
<p><strong>互斥模型和同步模型对比：</strong></p>
<p><mark>互斥模型先P后V，信号量初值S≠0；</mark></p>
<p><mark>同步模型先V后P，信号量初值S&#x3D;0。</mark></p>
<p>例题：</p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240311173858556.png" alt="image-20240311173858556" style="zoom:50%;" />

<p>选B</p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240311174044423.png" alt="image-20240311174044423" style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240311174212942.png" alt="image-20240311174212942" style="zoom:50%;" />

<p>选C、D</p>
<h5 id="4-2-4前驱图与PV操作"><a href="#4-2-4前驱图与PV操作" class="headerlink" title="4.2.4前驱图与PV操作"></a>4.2.4前驱图与PV操作</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240311174343812.png" alt="image-20240311174343812" style="zoom:50%;" />

<p>技巧:</p>
<p>并发图中某活动<mark>有后继就有v操作释放资源</mark>，<mark>有前驱就有p操作消耗资源</mark>。</p>
<p><mark>实现并发的信号量初值一般为0。有几个箭头就有几个信号量。</mark></p>
<p>例题;</p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240311174707693.png" alt="image-20240311174707693" style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240311174748231.png" alt="image-20240311174748231" style="zoom:50%;" />

<p>选C 、A</p>
<h5 id="4-2-5死锁问题"><a href="#4-2-5死锁问题" class="headerlink" title="4.2.5死锁问题"></a>4.2.5死锁问题</h5><p>了解概念</p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240311174858820.png" alt="image-20240311174858820" style="zoom:50%;" />

<p><strong>考点：</strong></p>
<p>进程管理是操作系统的核心，但如果设计不当，就会出现死锁的问题。如果进程在等待一件不可能发生的事，则进程就死锁了。而如果多个进程产生死锁，就会造成系统死锁。</p>
<p><mark>系统可能发生死锁的最大资源数        (w-1)*m &lt;&#x3D;n</mark></p>
<p><mark>系统不可能发生死锁的最小资源数    (w-1)*m+1&lt;&#x3D;n</mark></p>
<p><strong>w：单个进程所需系统资源数；m：系统进程数</strong></p>
<p>例题：</p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240311175641436.png" alt="image-20240311175641436" style="zoom:50%;" />

<p>答：求不可能发生死锁的最小资源数为16</p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240311175859350.png" alt="image-20240311175859350" style="zoom:50%;" />

<p>选D，（4-1）*3 &#x3D; 9 &gt; 8</p>
<h5 id="4-2-6进程资源图"><a href="#4-2-6进程资源图" class="headerlink" title="4.2.6进程资源图"></a>4.2.6进程资源图</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240311180608902.png" alt="image-20240311180608902" style="zoom:50%;" />

<p><strong>考点：</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240311180808593.png" alt="image-20240311180808593" style="zoom: 50%;" />

<ul>
<li><p><strong>先分析资源分配情况，列出剩余可用资源：此时已分配1个R1给进程P，剩余1个R1可用。</strong></p>
</li>
<li><p><strong>再判断申请后进程是否能够执行：P进程申请1个R1，系统有1个R1可用，P进程可成功执行，执行后释放占用的2个R1。</strong></p>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240311180844569.png" alt="image-20240311180844569" style="zoom:50%;" />

<p><strong>解题思路：</strong></p>
<ul>
<li><p><mark>先确定定下的，即资源主动分派给进程的(R–&gt;P)，再确定进程被动向进程要的(P–&gt;R)。</mark></p>
</li>
<li><p><mark>进程被动向进程要资源，如果资源有剩余，进程就能要到，该进程就为非阻塞，反之为阻塞。</mark></p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240311183319553.png" alt="image-20240311183319553" style="zoom:50%;" />

<p>如题所示，资源先分配进程，之后P1内R2要资源，R2中剩余一个资源，即P1不阻塞，P2向R1要资源，R1没有剩余资源，即P2阻塞，R3不阻塞。选D</p>
</li>
</ul>
<h4 id="4-3存储管理"><a href="#4-3存储管理" class="headerlink" title="4.3存储管理"></a>4.3存储管理</h4><h5 id="4-3-1段页式存储"><a href="#4-3-1段页式存储" class="headerlink" title="4.3.1段页式存储"></a>4.3.1段页式存储</h5><h6 id="页式存储"><a href="#页式存储" class="headerlink" title="页式存储"></a>页式存储</h6><p><strong>将程序与内存均划分为同样大小的块，以页为单位将程序调入内存。</strong></p>
<p><strong>对于用户程序称为页，对于内存称为块。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240312174627061.png" alt="image-20240312174627061"></p>
<ul>
<li><p><strong>优点：利用率高，碎片小，分配及管理简单</strong></p>
</li>
<li><p><strong>缺点：增加了系统开销，可能产生抖动现象</strong></p>
</li>
</ul>
<p>高级程序语言使用逻辑地址；运行状态，内存中使用物理地址。</p>
<p><strong>逻辑地址&#x3D;页号+页内地址</strong></p>
<p><strong>物理地址&#x3D;页号+页内地址</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240312174943787.png" alt="image-20240312174943787" style="zoom: 67%;" />

<p>分析：每个页有2^12个 Byte，相当于2^12个地址，10为页号，110011011110为页内偏移量，页号(10)B&#x3D;2对应的页号为6&#x3D;(110)B</p>
<p><strong>注意：</strong></p>
<p><mark>对于段页式存储而言，逻辑地–&gt;物理地址，只改变页号为页帧号，页内偏移量不变。</mark></p>
<p>文件替换规律：</p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240312180418244.png" alt="image-20240312180418244" style="zoom:67%;" />



<h6 id="段式存储"><a href="#段式存储" class="headerlink" title="段式存储"></a>段式存储</h6><p><strong>按用户作业中的自然段来划分逻辑空间，然后调入内存，段的长度可以不一样。</strong></p>
<p><mark>段式存储映射该段在内存中的起始位置（基址）。</mark></p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240312181112318.png" alt="image-20240312181112318" style="zoom:67%;" />

<ul>
<li><p><strong>优点：多道程序共享内存，各段程序修改互不影响</strong></p>
</li>
<li><p><strong>缺点：内存利用率低，内存碎片浪费大</strong></p>
</li>
</ul>
<h6 id="段页式存储"><a href="#段页式存储" class="headerlink" title="段页式存储"></a>段页式存储</h6><p><strong>段式与页式的综合体。先分段，再分页。</strong>1个程序有若干个段，每个段中可以有若干页，每个页的大小相同，但每个段的大小不同。</p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240312181226761.png" alt="image-20240312181226761" style="zoom:67%;" />

<ul>
<li><strong>优点：空间浪费小、存储共享容易、存储保护容易、能动态连接</strong></li>
<li><strong>缺点：由于管理软件的增加，复杂性和开销也随之增加，需要的硬件以及占用的内容也有所增加，使得执行速度大大下降</strong></li>
</ul>
<p>例题：</p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240312181538482.png" alt="image-20240312181538482" style="zoom:67%;" />

<p>分析：逻辑地址2对应物理块4，页内偏移量不变，H为16进制。选C</p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240312182133499.png" alt="image-20240312182133499" style="zoom:67%;" />

<p>选A</p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240312182455902.png" alt="image-20240312182455902" style="zoom:67%;" />

<p>分析，看段号和段长，选B</p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240312183317120.png" alt="image-20240312183317120" style="zoom:67%;" />

<p>选B</p>
<h4 id="4-4磁盘管理"><a href="#4-4磁盘管理" class="headerlink" title="4.4磁盘管理"></a>4.4磁盘管理</h4><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240312183449242.png" alt="image-20240312183449242" style="zoom:67%;" />

<p>多个磁片的同一个磁道形成一个柱面，所以磁道有时也叫做柱面。</p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240313201447574.png" alt="image-20240313201447574" style="zoom:67%;" />

<p><strong>读取磁盘数据的时间应包括以下三个部分：</strong></p>
<ul>
<li><mark>(1)找磁道的时间。</mark></li>
<li><mark>(2)找块(扇区)的时间，即旋转延迟时间。</mark></li>
<li><mark>(3)传输时间。</mark></li>
</ul>
<p>例题：</p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240313201924108.png" alt="image-20240313201924108" style="zoom:67%;" />



<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240313202055233.png" alt="image-20240313202055233" style="zoom:67%;" />

<h5 id="4-4-1先来先服务"><a href="#4-4-1先来先服务" class="headerlink" title="4.4.1先来先服务"></a>4.4.1先来先服务</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240313202306797.png" alt="image-20240313202306797" style="zoom: 67%;" />

<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240313202333375.png" alt="image-20240313202333375" style="zoom: 67%;" />



<h5 id="4-4-2最短寻道时间优先"><a href="#4-4-2最短寻道时间优先" class="headerlink" title="4.4.2最短寻道时间优先"></a>4.4.2最短寻道时间优先</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240313202716975.png" alt="image-20240313202716975" style="zoom:67%;" />

<p>例题：</p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240313202739489.png" alt="image-20240313202739489" style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240313203014539.png" alt="image-20240313203014539" style="zoom:67%;" />

<p>分析：磁盘旋转周期33ms对应11扇区，每块3ms，经过3ms读完R0，经过3ms处理缓冲区，3ms*10扇区+3ms+3ms+处理R0的6ms&#x3D;366ms；优化11 * (3+3)&#x3D;66ms</p>
<p>选B、B</p>
<h4 id="4-5文件管理"><a href="#4-5文件管理" class="headerlink" title="4.5文件管理"></a>4.5文件管理</h4><h5 id="4-5-1基本概念"><a href="#4-5-1基本概念" class="headerlink" title="4.5.1基本概念"></a>4.5.1基本概念</h5><p>了解即可</p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240313211017768.png" alt="image-20240313211017768" style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240313211115552.png" alt="image-20240313211115552" style="zoom:67%;" />

<p><strong>考点：</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240313211245366.png" alt="image-20240313211245366" style="zoom:67%;" />

<p>例题：</p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240313211309262.png" alt="image-20240313211309262" style="zoom:67%;" />

<p>选A，BCD 为具体文件</p>
<h5 id="4-5-2树形目录结构"><a href="#4-5-2树形目录结构" class="headerlink" title="4.5.2树形目录结构"></a>4.5.2树形目录结构</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240313211537662.png" alt="image-20240313211537662" style="zoom:67%;" />

<p>例题：</p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240313211601341.png" alt="image-20240313211601341" style="zoom:67%;" />

<p>选C、B</p>
<h5 id="4-5-3索引文件结构"><a href="#4-5-3索引文件结构" class="headerlink" title="4.5.3索引文件结构"></a>4.5.3索引文件结构</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240313211655682.png" alt="image-20240313211655682" style="zoom:67%;" />

<p>例题：</p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240313211954129.png" alt="image-20240313211954129" style="zoom:67%;" />

<p>分析：假设从0开始，逻辑块4采用直接地址索引，5采用一级简介地址索引，7采用二级简介地址索引，选B；</p>
<p>计算：1KB &#x2F; 4 &#x3D; 256KB，既256个地址，</p>
<p>一级5个 + 二级256*2 + 三级256^2 &#x3D; 66053，选D </p>
<h5 id="4-5-4位视图"><a href="#4-5-4位视图" class="headerlink" title="4.5.4位视图"></a>4.5.4位视图</h5><p>作用：标识物理块是否可用。</p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240313212845963.png" alt="image-20240313212845963" style="zoom:67%;" />

<p><strong>重点：1行为1个字</strong></p>
<p><strong>做题技巧：物理块(当前格子编号) &#x2F; 字长</strong>    注意：字号，字长都从0开始</p>
<p>例题：</p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240313213629412.png" style="zoom:67%;" />

<p>分析：(300 * 1024MB) &#x2F; 32，选D</p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240313213657603.png" alt="image-20240313213657603" style="zoom:67%;" />

<p>分析：2053 &#x2F; 32 ，选C</p>
<h4 id="4-6设备管理"><a href="#4-6设备管理" class="headerlink" title="4.6设备管理"></a>4.6设备管理</h4><h5 id="4-6-1-IO的设备管理"><a href="#4-6-1-IO的设备管理" class="headerlink" title="4.6.1 IO的设备管理"></a>4.6.1 IO的设备管理</h5><p><strong>考点：流程图（背）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240313204937941.png" alt="image-20240313204937941" style="zoom:67%;" />

<p>例题：</p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240313205143177.png" alt="image-20240313205143177" style="zoom:67%;" />

<p>选D</p>
<h5 id="4-6-2单缓冲器计算问题"><a href="#4-6-2单缓冲器计算问题" class="headerlink" title="4.6.2单缓冲器计算问题"></a>4.6.2单缓冲器计算问题</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240313205718485.png" alt="image-20240313205718485" style="zoom:67%;" />

<p>例题：</p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240313205423717.png" alt="image-20240313205423717" style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240313210930424.png" alt="image-20240313210930424" style="zoom: 50%;" />

<p>分析：当缓冲区处理完数据，第二个文件就可以继续输入了，当处理最后一个数据时，还需要在工作区处理2μs，总计（10+6）+2μs。</p>
<h4 id="4-7微内核操作系统"><a href="#4-7微内核操作系统" class="headerlink" title="4.7微内核操作系统"></a>4.7微内核操作系统</h4><h5 id="4-7-1概念"><a href="#4-7-1概念" class="headerlink" title="4.7.1概念"></a>4.7.1概念</h5><p><strong>微内核操作系统是一种以微内核为核心的操作系统范式</strong>，与传统内核操作系统不同的是，<strong>它将操作系统的核心部分精简到最小，只包含了最基本和最核心的操作系统服务</strong>。这些服务采用了更为安全、可靠的方式，运行在系统的用户空间中，避免了传统操作系统中内核部分的单点故障风险。</p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240313215257854.png" alt="image-20240313215257854" style="zoom: 50%;" />

<h4 id="4-8总结"><a href="#4-8总结" class="headerlink" title="4.8总结"></a>4.8总结</h4><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240313214022640.png" alt="image-20240313214022640" style="zoom: 67%;" />



<h3 id="第5章：计算机网络基础"><a href="#第5章：计算机网络基础" class="headerlink" title="第5章：计算机网络基础"></a>第5章：计算机网络基础</h3><p>题型少，设计不广</p>
<h4 id="5-1计算机网络的分类"><a href="#5-1计算机网络的分类" class="headerlink" title="5.1计算机网络的分类"></a>5.1计算机网络的分类</h4><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240313215800889.png" alt="image-20240313215800889" style="zoom:67%;" />

<h4 id="5-2七层网络体系结构"><a href="#5-2七层网络体系结构" class="headerlink" title="5.2七层网络体系结构"></a>5.2七层网络体系结构</h4><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240313220334228.png" alt="image-20240313220334228" style="zoom:67%;" />

<p>标准</p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240313220421685.png" alt="image-20240313220421685" style="zoom: 33%;" />

<h4 id="5-3网络的设备"><a href="#5-3网络的设备" class="headerlink" title="5.3网络的设备"></a>5.3网络的设备</h4><h4 id="5-4TCP-IP协议族"><a href="#5-4TCP-IP协议族" class="headerlink" title="5.4TCP&#x2F;IP协议族"></a>5.4TCP&#x2F;IP协议族</h4><p>TCP&#x2F;IP作为Internet的核心协议，被广泛应用于局域网和广域网中，目前已成为事实上的国际标准。</p>
<p>1、TCP&#x2F;IP分层模型TCP&#x2F;IP协议是Internet的基础和核心，和OSI参考模型一样，也是采用层次体系结构，从上而下分为应用层、传输层、网际层和网络接口层。</p>
<p>2、网络接口层协议</p>
<p>3、网际层协议一IP</p>
<p>ARP和RARP地址解析协议(Address Resolution Protocol, ARP)及反地址解析协议(RARP)。</p>
<p>ARP的作用是将IP地址转换为物理地址，RARP的作用是将物理地址转换为IP地址。</p>
<p>5、网际层协议一ICMP</p>
<p><strong>6、传输层协议一TCP</strong></p>
<p><mark>TCP(Transmission Control Protocol,传输控制协议)为应用程序提供了一个可靠的、面向连接的数据传输服务。</mark></p>
<p><strong>7.传输层协议一UDP</strong></p>
<p><mark>用户数据报协议(User Dataqram Protocol, UDP)是 一种不可靠的、无连接的协议可以保证应用程序进程间的通信。</mark></p>
<p><strong>TCP和UDP区别：</strong></p>
<ul>
<li><p>①<strong>TCP面向连接；UDP是无连接的。</strong></p>
</li>
<li><p>②TCP 提供可靠的服务，通过TCP连接传送的数据，无差错、不丢失、不重复，且按序到达;UDP尽最大努力交付，不保证可靠交付。</p>
</li>
<li><p>③TCP面向字节流；UDP是面向报文的，没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低。</p>
</li>
<li><p>④每一条TCP连接只能是点到点的；UDP支持一对一、一对多、多对一和多对多的交互通信。</p>
</li>
<li><p>⑤TCP首部开销20字节；UDP的首部开销小，只有8个字节。</p>
</li>
<li><p>⑥TCP的逻辑通信信道是全双工的可靠信道0；UDP则是不可靠信道，整体来看UDP开销较小。</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240313221009168.png" alt="image-20240313221009168"></p>
<p>选B</p>
<h4 id="5-5IP地址和IPv6简介"><a href="#5-5IP地址和IPv6简介" class="headerlink" title="5.5IP地址和IPv6简介"></a>5.5IP地址和IPv6简介</h4><p>IP地址的长度为32位，分为4段，每段8位，可以用十进制数和二进制数表示。每段数字范围为0~255，段与段之间用句点隔开。<strong>IP 地址由两部分组成，一部分为网络地址，另一部分为主机地址。</strong></p>
<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240313221225107.png" alt="image-20240313221225107" style="zoom:67%;" />

<p>IPV6简介</p>
<p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240313221506911.png" alt="image-20240313221506911"></p>
<h4 id="5-6Internet服务"><a href="#5-6Internet服务" class="headerlink" title="5.6Internet服务"></a>5.6Internet服务</h4><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240313221630445.png" alt="image-20240313221630445"></p>
<p>例题：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240313221919525.png" alt="image-20240313221919525"></p>
<p>选A</p>
<h3 id="第6章：数据库系统基础知识"><a href="#第6章：数据库系统基础知识" class="headerlink" title="第6章：数据库系统基础知识"></a>第6章：数据库系统基础知识</h3><h3 id="第7章：程序设计语言基础知识"><a href="#第7章：程序设计语言基础知识" class="headerlink" title="第7章：程序设计语言基础知识"></a>第7章：程序设计语言基础知识</h3><p>项目管理基础</p>
<p>结构化开发</p>
<p>UML建模</p>
<p>面向对象基础</p>
<p>信息安全</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://Liooser.github.io">Liooser</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://liooser.github.io/post/7a7dea22.html">https://liooser.github.io/post/7a7dea22.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://Liooser.github.io" target="_blank">Liooser's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BD%AF%E8%80%83/">软考</a></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/Liooser/Liooser.github.io/main/images/index/ruankaozhongji.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/a7101757.html"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240317231657176.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">网络技术三级</div></div></a></div><div class="next-post pull-right"><a href="/post/ee7dbeea.html"><img class="next-cover" src="https://raw.githubusercontent.com/Liooser/Liooser.github.io/main/images/index/Database_level_3.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">数据库三级【故障管理、备份与恢复】</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://raw.githubusercontent.com/Liooser/Liooser.github.io/main/images/index/5.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Liooser</div><div class="author-info__description">潮落之后是潮起</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">43</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">35</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://haiyong.site/moyu/"><i class="iconfont icon-youxishoubing"></i><span>摸鱼</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://Liooser.github.io" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content"><b><font color="#e66b6d">双</font> <font color="#e66d98">手</font> <font color="#e66cc6">合</font> <font color="#cc6de6">十</font> <font color="#9770e6">成</font> <font color="#6d93e6">为</font> <font color="#6fcde6">自</font> <font color="#72e6b6">己</font> <font color="#72e689">的</font> <font color="#99e670">神</font>, <font color="#cde670">自</font> <font color="#e6df72">己</font> <font color="#e6c073">所</font> <font color="#e6a271">信</font> <font color="#e6796f">念</font> <font color="#e65454">的</font> <font color="#e63333">即</font> <font color="#e62c2c">是</font> <font color="#e60101">信</font> <font color="#e60101">仰</font></b> <p align="center"><img src="https://haiyong.site/img/img-blog.csdnimg.cn/f7384c88956d4378b72e47548e19c9f8.gif" width="50" alt="mao"></p></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">1.</span> <span class="toc-text">第1章：计算机组成原理与体系结构基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="toc-number">1.1.</span> <span class="toc-text">1.数据的表示</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1进制转换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2%E7%9C%9F%E5%80%BC%E4%B8%8E%E6%9C%BA%E5%99%A8%E6%95%B0"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2真值与机器数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%A0%A1%E9%AA%8C%E7%A0%81"><span class="toc-number">1.2.</span> <span class="toc-text">2.校验码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.</span> <span class="toc-text">3.计算机体系结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1%E4%BA%94%E5%A4%A7%E9%83%A8%E4%BB%B6"><span class="toc-number">1.3.1.</span> <span class="toc-text">3.1五大部件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">1.3.2.</span> <span class="toc-text">3.2主存储器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3CPU"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.3CPU</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4Flynn%E5%88%86%E7%B1%BB%E6%B3%95"><span class="toc-number">1.3.4.</span> <span class="toc-text">3.4Flynn分类法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.4.</span> <span class="toc-text">4.指令系统</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.4.1.</span> <span class="toc-text">4.1指令格式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="toc-number">1.4.2.</span> <span class="toc-text">4.2寻址方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3CISC%E5%92%8CRISC"><span class="toc-number">1.4.3.</span> <span class="toc-text">4.3CISC和RISC</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-4%E6%8C%87%E4%BB%A4%E7%9A%84%E6%B5%81%E6%B0%B4%E6%96%B9%E5%BC%8F"><span class="toc-number">1.4.4.</span> <span class="toc-text">4.4指令的流水方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-5%E6%B5%81%E6%B0%B4%E7%BA%BF%E8%AE%A1%E7%AE%97"><span class="toc-number">1.4.5.</span> <span class="toc-text">4.5流水线计算</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.5.</span> <span class="toc-text">5.存储系统</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-number">1.5.1.</span> <span class="toc-text">5.1层次结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-2%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.5.2.</span> <span class="toc-text">5.2存储器的分类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-3%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98Cache"><span class="toc-number">1.5.3.</span> <span class="toc-text">5.3高速缓存Cache</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-4%E4%B8%BB%E5%AD%98%E7%9A%84%E7%BC%96%E5%9D%80"><span class="toc-number">1.5.4.</span> <span class="toc-text">5.4主存的编址</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-6%E7%A1%AC%E7%9B%98"><span class="toc-number">1.5.5.</span> <span class="toc-text">5.6硬盘</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E6%80%BB%E7%BA%BF%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.6.</span> <span class="toc-text">6.总线系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%8A%80%E6%9C%AF"><span class="toc-number">1.7.</span> <span class="toc-text">7.输入输出技术</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="toc-number">1.8.</span> <span class="toc-text">8.可靠性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80"><span class="toc-number">2.</span> <span class="toc-text">第2章：数据结构与算法基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E4%B8%89%E8%A6%81%E7%B4%A0"><span class="toc-number">2.1.</span> <span class="toc-text">1.基本概念与三要素</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1%E6%95%B0%E6%8D%AE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.1.1.</span> <span class="toc-text">1.1数据的基本概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89%E8%A6%81%E7%B4%A0"><span class="toc-number">2.1.2.</span> <span class="toc-text">1.2数据结构三要素</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%AE%97%E6%B3%95"><span class="toc-number">2.2.</span> <span class="toc-text">2.算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1%E4%BB%80%E4%B9%88%E6%98%AF%E7%AE%97%E6%B3%95"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.1什么是算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87%E7%9A%84%E5%BA%A6%E9%87%8F"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2算法效率的度量</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="toc-number">2.3.</span> <span class="toc-text">3.线性表</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1%E5%AE%9A%E4%B9%89"><span class="toc-number">2.3.1.</span> <span class="toc-text">3.1定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">2.3.2.</span> <span class="toc-text">3.2存储结构</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="toc-number">2.4.</span> <span class="toc-text">4.栈和队列</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1%E6%A0%88%E5%AE%9A%E4%B9%89"><span class="toc-number">2.4.1.</span> <span class="toc-text">4.1栈定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2%E9%98%9F%E5%88%97%E5%AE%9A%E4%B9%89"><span class="toc-number">2.4.2.</span> <span class="toc-text">4.2队列定义</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E4%B8%B2%E3%80%81%E6%95%B0%E7%BB%84%E3%80%81%E7%9F%A9%E9%98%B5%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8"><span class="toc-number">2.5.</span> <span class="toc-text">5.串、数组、矩阵和广义表</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1%E4%B8%B2"><span class="toc-number">2.5.1.</span> <span class="toc-text">5.1串</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-2%E6%95%B0%E7%BB%84"><span class="toc-number">2.5.2.</span> <span class="toc-text">5.2数组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-3%E7%9F%A9%E9%98%B5"><span class="toc-number">2.5.3.</span> <span class="toc-text">5.3矩阵</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-3%E5%B9%BF%E4%B9%89%E8%A1%A8"><span class="toc-number">2.5.4.</span> <span class="toc-text">5.3广义表</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.6.</span> <span class="toc-text">6.树和二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6-1%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%9A"><span class="toc-number">2.6.1.</span> <span class="toc-text">6.1树的基本概念：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%EF%BC%9A"><span class="toc-number">2.6.2.</span> <span class="toc-text">6.2二叉树的遍历：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-3%E6%A0%91%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%81%E6%A3%AE%E6%9E%97%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.6.3.</span> <span class="toc-text">6.3树、二叉树、森林的转换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-4%E6%9F%A5%E6%89%BE%E4%BA%8C%E5%8F%89%E6%A0%91-%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91"><span class="toc-number">2.6.4.</span> <span class="toc-text">6.4查找二叉树(二叉排序树)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-5%E6%9E%84%E9%80%A0Huffman%E6%A0%91-%E5%B8%A6%E6%9D%83%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F"><span class="toc-number">2.6.5.</span> <span class="toc-text">6.5构造Huffman树(带权路径长度最小)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-6%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.6.6.</span> <span class="toc-text">6.6线索二叉树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-7%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.6.7.</span> <span class="toc-text">6.7平衡二叉树</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E5%9B%BE"><span class="toc-number">2.7.</span> <span class="toc-text">7.图</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#7-1%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.7.1.</span> <span class="toc-text">7.1基本概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-2%E5%82%A8%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-number">2.7.2.</span> <span class="toc-text">7.2储存结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-3%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">2.7.3.</span> <span class="toc-text">7.3图的遍历</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-4%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-number">2.7.4.</span> <span class="toc-text">7.4拓扑排序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-5%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">2.7.5.</span> <span class="toc-text">7.5最小生成树</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E6%9F%A5%E6%89%BE"><span class="toc-number">2.8.</span> <span class="toc-text">8.查找</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#8-1%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE"><span class="toc-number">2.8.1.</span> <span class="toc-text">8.1顺序查找</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-2%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE"><span class="toc-number">2.8.2.</span> <span class="toc-text">8.2折半查找</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-3%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE"><span class="toc-number">2.8.3.</span> <span class="toc-text">8.3分块查找</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-4%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">2.8.4.</span> <span class="toc-text">8.4哈希表</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-%E6%8E%92%E5%BA%8F"><span class="toc-number">2.9.</span> <span class="toc-text">9.排序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#9-1%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">2.9.1.</span> <span class="toc-text">9.1冒泡排序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-2%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">2.9.2.</span> <span class="toc-text">9.2选择排序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-3%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">2.9.3.</span> <span class="toc-text">9.3插入排序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-4%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="toc-number">2.9.4.</span> <span class="toc-text">9.4希尔排序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-5%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">2.9.5.</span> <span class="toc-text">9.5快速排序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-6%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">2.9.6.</span> <span class="toc-text">9.6归并排序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-7%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-number">2.9.7.</span> <span class="toc-text">9.7堆排序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-8%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%EF%BC%88%E6%A1%B6%E6%8E%92%E5%BA%8F%EF%BC%89"><span class="toc-number">2.9.8.</span> <span class="toc-text">9.8基数排序（桶排序）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-9%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%EF%BC%88Counting-Sort%EF%BC%89"><span class="toc-number">2.9.9.</span> <span class="toc-text">9.9计数排序（Counting Sort）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0%EF%BC%9A%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1"><span class="toc-number">3.</span> <span class="toc-text">第3章：算法分析与设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1%E5%88%86%E6%B2%BB%E6%B3%95"><span class="toc-number">3.1.</span> <span class="toc-text">3.1分治法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">3.2.</span> <span class="toc-text">3.2动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-1%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95"><span class="toc-number">3.2.1.</span> <span class="toc-text">3.2.1动态规划算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-2%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="toc-number">3.2.2.</span> <span class="toc-text">3.2.2贪心算法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3%E5%9B%9E%E6%BA%AF%E6%B3%95"><span class="toc-number">3.3.</span> <span class="toc-text">3.3回溯法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC4%E7%AB%A0%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">第4章：操作系统基本原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">4.1.</span> <span class="toc-text">4.1基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-number">4.2.</span> <span class="toc-text">4.2进程管理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-1%E8%BF%9B%E7%A8%8B%E6%A6%82%E5%BF%B5"><span class="toc-number">4.2.1.</span> <span class="toc-text">4.2.1进程概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-2%E8%BF%9B%E7%A8%8B%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">4.2.2.</span> <span class="toc-text">4.2.2进程执行流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-3%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%B8%8EPV%E6%93%8D%E4%BD%9C"><span class="toc-number">4.2.3.</span> <span class="toc-text">4.2.3信号量与PV操作</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">4.2.3.1.</span> <span class="toc-text">信号量</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.2.3.2.</span> <span class="toc-text">互斥模型</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.2.3.3.</span> <span class="toc-text">同步模型</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-4%E5%89%8D%E9%A9%B1%E5%9B%BE%E4%B8%8EPV%E6%93%8D%E4%BD%9C"><span class="toc-number">4.2.4.</span> <span class="toc-text">4.2.4前驱图与PV操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-5%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98"><span class="toc-number">4.2.5.</span> <span class="toc-text">4.2.5死锁问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-6%E8%BF%9B%E7%A8%8B%E8%B5%84%E6%BA%90%E5%9B%BE"><span class="toc-number">4.2.6.</span> <span class="toc-text">4.2.6进程资源图</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-number">4.3.</span> <span class="toc-text">4.3存储管理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-1%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="toc-number">4.3.1.</span> <span class="toc-text">4.3.1段页式存储</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="toc-number">4.3.1.1.</span> <span class="toc-text">页式存储</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%AE%B5%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="toc-number">4.3.1.2.</span> <span class="toc-text">段式存储</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="toc-number">4.3.1.3.</span> <span class="toc-text">段页式存储</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86"><span class="toc-number">4.4.</span> <span class="toc-text">4.4磁盘管理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-4-1%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1"><span class="toc-number">4.4.1.</span> <span class="toc-text">4.4.1先来先服务</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-4-2%E6%9C%80%E7%9F%AD%E5%AF%BB%E9%81%93%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88"><span class="toc-number">4.4.2.</span> <span class="toc-text">4.4.2最短寻道时间优先</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86"><span class="toc-number">4.5.</span> <span class="toc-text">4.5文件管理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-5-1%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">4.5.1.</span> <span class="toc-text">4.5.1基本概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-5-2%E6%A0%91%E5%BD%A2%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="toc-number">4.5.2.</span> <span class="toc-text">4.5.2树形目录结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-5-3%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-number">4.5.3.</span> <span class="toc-text">4.5.3索引文件结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-5-4%E4%BD%8D%E8%A7%86%E5%9B%BE"><span class="toc-number">4.5.4.</span> <span class="toc-text">4.5.4位视图</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-6%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86"><span class="toc-number">4.6.</span> <span class="toc-text">4.6设备管理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-6-1-IO%E7%9A%84%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86"><span class="toc-number">4.6.1.</span> <span class="toc-text">4.6.1 IO的设备管理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-6-2%E5%8D%95%E7%BC%93%E5%86%B2%E5%99%A8%E8%AE%A1%E7%AE%97%E9%97%AE%E9%A2%98"><span class="toc-number">4.6.2.</span> <span class="toc-text">4.6.2单缓冲器计算问题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-7%E5%BE%AE%E5%86%85%E6%A0%B8%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">4.7.</span> <span class="toc-text">4.7微内核操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-7-1%E6%A6%82%E5%BF%B5"><span class="toc-number">4.7.1.</span> <span class="toc-text">4.7.1概念</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-8%E6%80%BB%E7%BB%93"><span class="toc-number">4.8.</span> <span class="toc-text">4.8总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80"><span class="toc-number">5.</span> <span class="toc-text">第5章：计算机网络基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">5.1.</span> <span class="toc-text">5.1计算机网络的分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">5.2.</span> <span class="toc-text">5.2七层网络体系结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%BE%E5%A4%87"><span class="toc-number">5.3.</span> <span class="toc-text">5.3网络的设备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4TCP-IP%E5%8D%8F%E8%AE%AE%E6%97%8F"><span class="toc-number">5.4.</span> <span class="toc-text">5.4TCP&#x2F;IP协议族</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5IP%E5%9C%B0%E5%9D%80%E5%92%8CIPv6%E7%AE%80%E4%BB%8B"><span class="toc-number">5.5.</span> <span class="toc-text">5.5IP地址和IPv6简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-6Internet%E6%9C%8D%E5%8A%A1"><span class="toc-number">5.6.</span> <span class="toc-text">5.6Internet服务</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">6.</span> <span class="toc-text">第6章：数据库系统基础知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0%EF%BC%9A%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">7.</span> <span class="toc-text">第7章：程序设计语言基础知识</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/a7101757.html" title="网络技术三级"><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240317231657176.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="网络技术三级"/></a><div class="content"><a class="title" href="/post/a7101757.html" title="网络技术三级">网络技术三级</a><time datetime="2024-03-16T16:00:00.000Z" title="发表于 2024-03-17 00:00:00">2024-03-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/7a7dea22.html" title="软考中级"><img src="https://raw.githubusercontent.com/Liooser/Liooser.github.io/main/images/index/ruankaozhongji.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="软考中级"/></a><div class="content"><a class="title" href="/post/7a7dea22.html" title="软考中级">软考中级</a><time datetime="2024-03-08T16:00:00.000Z" title="发表于 2024-03-09 00:00:00">2024-03-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/ee7dbeea.html" title="数据库三级【故障管理、备份与恢复】"><img src="https://raw.githubusercontent.com/Liooser/Liooser.github.io/main/images/index/Database_level_3.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据库三级【故障管理、备份与恢复】"/></a><div class="content"><a class="title" href="/post/ee7dbeea.html" title="数据库三级【故障管理、备份与恢复】">数据库三级【故障管理、备份与恢复】</a><time datetime="2023-09-17T16:00:00.000Z" title="发表于 2023-09-18 00:00:00">2023-09-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/61cdd72.html" title="数据库三级【数据库运行维护和优化】"><img src="https://raw.githubusercontent.com/Liooser/Liooser.github.io/main/images/index/Database_level_3.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据库三级【数据库运行维护和优化】"/></a><div class="content"><a class="title" href="/post/61cdd72.html" title="数据库三级【数据库运行维护和优化】">数据库三级【数据库运行维护和优化】</a><time datetime="2023-09-17T16:00:00.000Z" title="发表于 2023-09-18 00:00:00">2023-09-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/e570cd86.html" title="数据库三级【安全管理】"><img src="https://raw.githubusercontent.com/Liooser/Liooser.github.io/main/images/index/Database_level_3.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据库三级【安全管理】"/></a><div class="content"><a class="title" href="/post/e570cd86.html" title="数据库三级【安全管理】">数据库三级【安全管理】</a><time datetime="2023-09-16T16:00:00.000Z" title="发表于 2023-09-17 00:00:00">2023-09-17</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Liooser</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="富强,民主,文明,和谐,自由,平等,公正,法治,爱国,敬业,诚信,友善" data-fontsize="15px" data-random="true" async="async"></script><script>(function(d, w, c) {
    w.ChatraID = 'SYuwBgxFrsHfNGEue';
    var s = d.createElement('script');
    w[c] = w[c] || function() {
        (w[c].q = w[c].q || []).push(arguments);
    };
    s.async = true;
    s.src = 'https://call.chatra.io/chatra.js';
    if (d.head) d.head.appendChild(s);
})(document, window, 'Chatra');

if (true) {
  var chatBtnFn = () => {
    var chatBtn = document.getElementById("chat_btn")
    chatBtn.addEventListener("click", function(){
      Chatra('openChat')
    });
  }
  chatBtnFn()
} else {
  if (true) {
    function chatBtnHide () {
      Chatra('hide')
    }
    function chatBtnShow () {
      Chatra('show')
    }
  }
}</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var qweather_key = 'b16a1fa0e63c46a4b8f28abfb06ae3fe';
  var gaud_map_key = 'e2b04289e870b005374ee030148d64fd&s=rsv3';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '112.982279,28.19409';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><!-- hexo injector body_end end --></body></html>