<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>day18 - File、递归、IO一 | Liooser's Blog</title><meta name="author" content="Liooser"><meta name="copyright" content="Liooser"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="1、目前是怎么样存储数据的？弊端是什么？ int a &#x3D; 10;int [] arr &#x3D; &amp;#123;1,2,3,4,5&amp;#125;;List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();   在内存中存储的数据是用来处理、修改、运算的，不能长久保存。  2、计算机中，有没有一块硬件可以永久存储数据的？  磁盘中数据的形式就是文件，文件是数据的载体。">
<meta property="og:type" content="article">
<meta property="og:title" content="day18 - File、递归、IO一">
<meta property="og:url" content="https://liooser.github.io/post/2edfce22.html">
<meta property="og:site_name" content="Liooser&#39;s Blog">
<meta property="og:description" content="1、目前是怎么样存储数据的？弊端是什么？ int a &#x3D; 10;int [] arr &#x3D; &amp;#123;1,2,3,4,5&amp;#125;;List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();   在内存中存储的数据是用来处理、修改、运算的，不能长久保存。  2、计算机中，有没有一块硬件可以永久存储数据的？  磁盘中数据的形式就是文件，文件是数据的载体。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/Liooser/Liooser.github.io/main/images/index/b2.jpg">
<meta property="article:published_time" content="2022-10-29T16:00:00.000Z">
<meta property="article:modified_time" content="2023-08-22T11:32:37.022Z">
<meta property="article:author" content="Liooser">
<meta property="article:tag" content="java,面向对象进阶,File,递归,IO">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/Liooser/Liooser.github.io/main/images/index/b2.jpg"><link rel="shortcut icon" href="https://raw.githubusercontent.com/Liooser/Liooser.github.io/main/images/index/a2.png"><link rel="canonical"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"top-right"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'day18 - File、递归、IO一',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-08-22 19:32:37'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css" /><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://raw.githubusercontent.com/Liooser/Liooser.github.io/main/images/index/5.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">39</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">33</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/timeline/"><i class="fa-fw fa fa-bell"></i><span> 日志</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 菜单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about"><i class="fa-fw /about/"></i><span> 0</span></a></li><li><a class="site-page child" href="/myself"><i class="fa-fw /myself/"></i><span> 1</span></a></li><li><a class="site-page child" href="/butterfly"><i class="fa-fw https://github.com/jerryc127/hexo-theme-butterfly/"></i><span> 2</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://raw.githubusercontent.com/Liooser/Liooser.github.io/main/images/index/top_1.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Liooser's Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/timeline/"><i class="fa-fw fa fa-bell"></i><span> 日志</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 菜单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about"><i class="fa-fw /about/"></i><span> 0</span></a></li><li><a class="site-page child" href="/myself"><i class="fa-fw /myself/"></i><span> 1</span></a></li><li><a class="site-page child" href="/butterfly"><i class="fa-fw https://github.com/jerryc127/hexo-theme-butterfly/"></i><span> 2</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">day18 - File、递归、IO一</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-10-29T16:00:00.000Z" title="发表于 2022-10-30 00:00:00">2022-10-30</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-08-22T11:32:37.022Z" title="更新于 2023-08-22 19:32:37">2023-08-22</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">11.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>43分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="day18 - File、递归、IO一"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><strong>1、目前是怎么样存储数据的？弊端是什么？</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> [] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<ul>
<li>在内存中存储的数据是用来处理、修改、运算的，不能长久保存。</li>
</ul>
<p><strong>2、计算机中，有没有一块硬件可以永久存储数据的？</strong></p>
<ul>
<li>磁盘中数据的形式就是文件，文件是数据的载体。</li>
</ul>
<p>1、先要定位文件</p>
<ul>
<li><p>File类可以定位文件：进行删除、获取文本本身信息等操作<strong>。</strong></p>
</li>
<li><p><strong>但是不能读写文件内容。</strong></p>
</li>
</ul>
<p>2、读写文件数据</p>
<ul>
<li>IO流技术可以对硬盘中的文件进行读写</li>
</ul>
<p>3、今日总体学习思路</p>
<ul>
<li><p><strong>先学会使用File类定位文件以及操作文件本身</strong></p>
</li>
<li><p><strong>然后学习IO流读写文件数据。</strong></p>
</li>
</ul>
<h3 id="1-File类概述"><a href="#1-File类概述" class="headerlink" title="1.File类概述"></a>1.File类概述</h3><p><strong>File类概述</strong></p>
<ul>
<li><p>File类在包java.io.File下、代表操作系统的文件对象（文件、文件夹）。</p>
</li>
<li><p>File类提供了诸如：定位文件，获取文件本身的信息、删除文件、创建文件（文件夹）等功能。</p>
</li>
</ul>
<p><strong>File类创建对象</strong></p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>public</strong> File(String  pathname)</td>
<td>根据文件路径创建文件对象</td>
</tr>
<tr>
<td><strong>public</strong> File(String  parent, String child)</td>
<td>从父路径名字符串和子路径名字符串创建文件对象</td>
</tr>
<tr>
<td><strong>public</strong> File(File parent, String child)</td>
<td>根据父路径对应文件对象和子路径名字符串创建文件对象</td>
</tr>
</tbody></table>
<ul>
<li><p>File对象可以定位文件和文件夹</p>
</li>
<li><p>File封装的对象仅仅是一个路径名，这个路径可以是存在的，也可以是不存在的。</p>
</li>
</ul>
<p><strong>绝对路径和相对路径</strong></p>
<ul>
<li>绝对路径：从盘符开始</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(“D:\\itheima\\a.txt”); </span><br></pre></td></tr></table></figure>

<ul>
<li>相对路径：不带盘符，默认直接到当前工程下的目录寻找文件。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(“模块名\\a.txt”);</span><br></pre></td></tr></table></figure>

<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1、创建File对象（指定了文件的路径）</span></span><br><span class="line"><span class="comment">// 路径写法：D:\\resources\\xueshan.jpeg</span></span><br><span class="line">        <span class="comment">// D:/resources/xueshan.jpeg</span></span><br><span class="line">        <span class="comment">// File.separator(转义的方法 = \\)</span></span><br><span class="line"><span class="comment">//      File f = new File(&quot;D:\\resources\\xueshan.jpeg&quot;);</span></span><br><span class="line"><span class="comment">//      File f = new File(&quot;D:/resources/xueshan.jpeg&quot;);</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:&quot;</span> + File.separator+<span class="string">&quot;resources&quot;</span>+ File.separator +<span class="string">&quot;xueshan.jpeg&quot;</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> f.length(); <span class="comment">// 是文件的字节大小</span></span><br><span class="line">        System.out.println(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、File创建对象，支持绝对路径 支持相对路径（重点）</span></span><br><span class="line">		<span class="comment">// 绝对路径:从盘符开始</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\resources\\beauty.jpeg&quot;</span>); </span><br><span class="line">        System.out.println(f1.length());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 相对路径：一般定位模块中的文件的。 相对到工程下！！</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;file-io-app/src/data.txt&quot;</span>);</span><br><span class="line">        System.out.println(f2.length());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、File创建对象 ，可以是文件也可以是文件夹</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\resources&quot;</span>);</span><br><span class="line">        System.out.println(f3.exists()); <span class="comment">// 判断这个路径是否存在，这个文件夹存在否</span></span><br></pre></td></tr></table></figure>

<h3 id="2-File类的常用API"><a href="#2-File类的常用API" class="headerlink" title="2.File类的常用API"></a>2.File类的常用API</h3><h4 id="1-判断文件类型、获取文件信息"><a href="#1-判断文件类型、获取文件信息" class="headerlink" title="1.判断文件类型、获取文件信息"></a>1.判断文件类型、获取文件信息</h4><p><strong>File类的判断文件类型、获取文件信息功能</strong></p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public  boolean isDirectory()</td>
<td>测试此抽象路径名表示的File是否为文件夹</td>
</tr>
<tr>
<td>public  boolean isFile()</td>
<td>测试此抽象路径名表示的File是否为文件</td>
</tr>
<tr>
<td>public  boolean  exists()</td>
<td>测试此抽象路径名表示的File是否存在</td>
</tr>
<tr>
<td>public  String getAbsolutePath()</td>
<td>返回此抽象路径名的绝对路径名字符串</td>
</tr>
<tr>
<td>public  String getPath()</td>
<td>将此抽象路径名转换为路径名字符串</td>
</tr>
<tr>
<td>public  String getName()</td>
<td>返回由此抽象路径名表示的文件或文件夹的名称</td>
</tr>
<tr>
<td>public  long lastModified()</td>
<td>返回文件最后修改的时间毫秒值</td>
</tr>
</tbody></table>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.绝对路径创建一个文件对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/resources/xueshan.jpeg&quot;</span>);</span><br><span class="line">        <span class="comment">// a.获取它的绝对路径。</span></span><br><span class="line">        System.out.println(f1.getAbsolutePath());</span><br><span class="line">        <span class="comment">// b.获取文件定义的时候使用的路径。</span></span><br><span class="line">        System.out.println(f1.getPath());</span><br><span class="line">        <span class="comment">// c.获取文件的名称：带后缀。</span></span><br><span class="line">        System.out.println(f1.getName()); <span class="comment">//xueshan.jpeg</span></span><br><span class="line">        <span class="comment">// d.获取文件的大小：字节个数。</span></span><br><span class="line">        System.out.println(f1.length()); <span class="comment">//字节大小</span></span><br><span class="line">        <span class="comment">// e.获取文件的最后修改时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> f1.lastModified();</span><br><span class="line">        System.out.println(<span class="string">&quot;最后修改时间：&quot;</span> + <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy/MM/dd HH:mm:ss&quot;</span>).format(time));</span><br><span class="line">        <span class="comment">// f、判断是否是文件</span></span><br><span class="line">        System.out.println(f1.isFile()); <span class="comment">// true</span></span><br><span class="line">		<span class="comment">//判断是否是文件夹</span></span><br><span class="line">        System.out.println(f1.isDirectory()); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.相对路径创建一个文件对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;file-io-app\\src\\data.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// a.获取它的绝对路径。</span></span><br><span class="line">        System.out.println(f2.getAbsolutePath());</span><br><span class="line">        <span class="comment">// b.获取文件定义的时候使用的路径。</span></span><br><span class="line">        System.out.println(f2.getPath());</span><br><span class="line">        <span class="comment">// c.获取文件的名称：带后缀。</span></span><br><span class="line">        System.out.println(f2.getName());</span><br><span class="line">        <span class="comment">// d.获取文件的大小：字节个数。</span></span><br><span class="line">        System.out.println(f2.length()); <span class="comment">// 字节大小</span></span><br><span class="line">        <span class="comment">// e.获取文件的最后修改时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">time1</span> <span class="operator">=</span> f2.lastModified();</span><br><span class="line">        System.out.println(<span class="string">&quot;最后修改时间：&quot;</span> + <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy/MM/dd HH:mm:ss&quot;</span>).format(time1));</span><br><span class="line">        <span class="comment">// f、判断是否是文件</span></span><br><span class="line">        System.out.println(f2.isFile()); <span class="comment">// true</span></span><br><span class="line">		<span class="comment">//判断是否是文件夹</span></span><br><span class="line">        System.out.println(f2.isDirectory()); <span class="comment">// false</span></span><br><span class="line">		<span class="comment">//判断这个路径是否存在</span></span><br><span class="line">        System.out.println(f2.exists()); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/&quot;</span>);</span><br><span class="line">        System.out.println(file.isFile()); <span class="comment">// false</span></span><br><span class="line">        System.out.println(file.isDirectory()); <span class="comment">// true</span></span><br><span class="line">        System.out.println(file.exists()); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/aaa&quot;</span>);</span><br><span class="line">        System.out.println(file1.isFile()); <span class="comment">// false</span></span><br><span class="line">        System.out.println(file1.isDirectory()); <span class="comment">// false</span></span><br><span class="line">        System.out.println(file1.exists()); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h4 id="2-创建文件、删除文件功能"><a href="#2-创建文件、删除文件功能" class="headerlink" title="2.创建文件、删除文件功能"></a>2.创建文件、删除文件功能</h4><p><strong>File类创建文件的功能</strong></p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public boolean createNewFile()</td>
<td>创建一个新的空的文件</td>
</tr>
<tr>
<td>public boolean mkdir()</td>
<td>只能创建一级文件夹</td>
</tr>
<tr>
<td>public boolean mkdirs()</td>
<td>可以创建多级文件夹</td>
</tr>
</tbody></table>
<p><strong>File类删除文件的功能</strong></p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public  boolean delete()</td>
<td>删除由此抽象路径名表示的文件或空文件夹</td>
</tr>
</tbody></table>
<ul>
<li><p><strong>delete方法默认只能删除文件和空文件夹。</strong></p>
</li>
<li><p><strong>delete方法直接删除不走回收站</strong></p>
</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.创建新文件，createNewFile,创建成功返回true ,反之 ,不需要这个，以后文件写出去的时候都会自动创建		</span></span><br><span class="line">		<span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;file-io-app\\src\\data.txt&quot;</span>);</span><br><span class="line">        System.out.println(f.createNewFile());</span><br><span class="line"></span><br><span class="line">        <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;file-io-app\\src\\data02.txt&quot;</span>);</span><br><span class="line">        System.out.println(f1.createNewFile()); <span class="comment">// （几乎不用的，因为以后文件都是自动创建的！）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// b.mkdir创建一级目录</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/resources/aaa&quot;</span>);</span><br><span class="line">        System.out.println(f2.mkdir());</span><br><span class="line"></span><br><span class="line"><span class="comment">// c.mkdirs创建多级目录(重点)</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/resources/ccc/ddd/eee/ffff&quot;</span>);</span><br><span class="line">		<span class="comment">//System.out.println(f3.mkdir()); //mkdirs</span></span><br><span class="line">        System.out.println(f3.mkdirs()); <span class="comment">// 支持多级创建</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// d.删除文件或者空文件夹</span></span><br><span class="line">        System.out.println(f1.delete());</span><br><span class="line">        <span class="type">File</span> <span class="variable">f4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/resources/xueshan.jpeg&quot;</span>);</span><br><span class="line">        System.out.println(f4.delete()); <span class="comment">// 占用一样可以删除</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只能删除空文件夹,不能删除非空文件夹(多级文件夹).</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/resources/aaa&quot;</span>);</span><br><span class="line">        System.out.println(f5.delete()); </span><br></pre></td></tr></table></figure>

<h4 id="3-遍历文件夹"><a href="#3-遍历文件夹" class="headerlink" title="3.遍历文件夹"></a>3.遍历文件夹</h4><p><strong>File类的遍历功能</strong></p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public String[] list()</td>
<td>获取当前目录下所有的”一级文件名称”到一个字符串数组中去返回。</td>
</tr>
<tr>
<td>public File[] listFiles()(常用)</td>
<td>获取当前目录下所有的”一级文件对象”到一个文件对象数组中去返回（重点）</td>
</tr>
</tbody></table>
<p><strong>listFiles方法注意事项：</strong></p>
<ul>
<li><p>当调用者不存在时，返回null</p>
</li>
<li><p>当调用者是一个文件时，返回null</p>
</li>
<li><p>当调用者是一个空文件夹时，返回一个长度为0的数组</p>
</li>
<li><p>当调用者是一个有内容的文件夹时，将里面所有文件和文件夹的路径放在File数组中返回</p>
</li>
<li><p>当调用者是一个有隐藏文件的文件夹时，将里面所有文件和文件夹的路径放在File数组中返回，包含隐藏内容</p>
</li>
<li><p>当调用者是一个需要权限才能进入的文件夹时，返回null</p>
</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：File针对目录的遍历</span></span><br><span class="line"><span class="comment">    - public String[] list()：</span></span><br><span class="line"><span class="comment">         获取当前目录下所有的&quot;一级文件名称&quot;到一个字符串数组中去返回。</span></span><br><span class="line"><span class="comment">         </span></span><br><span class="line"><span class="comment">    - public File[] listFiles()(常用)：（重点）</span></span><br><span class="line"><span class="comment">         获取当前目录下所有的&quot;一级文件对象&quot;到一个文件对象数组中去返回</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、定位一个目录</span></span><br><span class="line">		<span class="comment">//获取当前目录下所有的&quot;一级文件名称&quot;到一个字符串数组中去返回。</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/resources&quot;</span>);</span><br><span class="line">        String[] names = f1.list();</span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.一级文件对象</span></span><br><span class="line">        <span class="comment">// 获取当前目录下所有的&quot;一级文件对象&quot;到一个文件对象数组中去返回（重点）</span></span><br><span class="line">		<span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/resources&quot;</span>);</span><br><span class="line">        File[] files = f1.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File f : files) &#123;</span><br><span class="line">            System.out.println(f.getAbsolutePath());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意事项</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">dir1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:/resources&quot;</span>); <span class="comment">//当调用者不存在时，返回null</span></span><br><span class="line">		</span><br><span class="line">		<span class="type">File</span> <span class="variable">dir2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/resources/xueshan&quot;</span>); <span class="comment">//当调用者是一个文件时，返回null</span></span><br><span class="line"></span><br><span class="line">		<span class="type">File</span> <span class="variable">dir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/resources/ddd&quot;</span>); <span class="comment">//首先目录存在，当调用者是一个空文件夹时，返回一个长度为0的数组</span></span><br><span class="line">		File[] fi = f1.listFiles();</span><br><span class="line">        System.out.println(Arrays.toString(fi)); <span class="comment">// [] </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-方法递归"><a href="#3-方法递归" class="headerlink" title="3.方法递归"></a>3.方法递归</h3><h4 id="3-1递归的形式和特点"><a href="#3-1递归的形式和特点" class="headerlink" title="3.1递归的形式和特点"></a>3.1递归的形式和特点</h4><p><strong>什么是方法递归?</strong></p>
<ul>
<li><p>方法直接调用自己或者间接调用自己的形式称为方法递归（ recursion）。</p>
</li>
<li><p>递归做为一种<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%AE%97%E6%B3%95">算法</a>在<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">程序设计语言</a>中广泛应用。</p>
</li>
</ul>
<p><strong>递归的形式</strong></p>
<ul>
<li><p>直接递归：方法自己调用自己。</p>
</li>
<li><p>间接递归：方法调用其他方法，其他方法又回调方法自己。</p>
</li>
</ul>
<p><strong>方法递归存在的问题？</strong></p>
<ul>
<li>递归如果没有控制好终止，会出现递归死循环，导致栈内存溢出现象。</li>
</ul>
<h4 id="3-2递归的算法流程、核心要素"><a href="#3-2递归的算法流程、核心要素" class="headerlink" title="3.2递归的算法流程、核心要素"></a>3.2递归的算法流程、核心要素</h4><p><strong>递归解决问题的思路：</strong></p>
<ul>
<li>把一个复杂的问题层层转化为一个<strong>与原问题相似的规模较小</strong>的问题来求解。</li>
</ul>
<p><strong>递归算法三要素大体可以总结为：</strong></p>
<ul>
<li><p><strong>递归的公式：</strong> <strong>f(n) &#x3D; f(n-1) * n</strong></p>
</li>
<li><p><strong>递归的终结点：f(1)</strong> </p>
</li>
<li><p><strong>递归的方向必须走向终结点：</strong></p>
</li>
</ul>
<h4 id="3-3递归常见案例"><a href="#3-3递归常见案例" class="headerlink" title="3.3递归常见案例"></a>3.3递归常见案例</h4><p><strong>递归案例导学-计算1-n的阶乘</strong></p>
<p><strong>需求：</strong></p>
<p>计算1-n的阶乘的结果，使用递归思想解决，我们先从数学思维上理解递归的流程和核心点。</p>
<p><strong>分析:</strong></p>
<p>①假如我们认为存在一个公式是 f(n) &#x3D; 1<em>2</em>3<em>4</em>5<em>6</em>7*…(n-1)*n;</p>
<p>②那么公式等价形式就是： f(n) &#x3D; f(n-1) *n</p>
<p>③如果求的是 1-5的阶乘 的结果，我们手工应该应该如何应用上述公式计算。</p>
<p>④f(5) &#x3D; f(4) * 5<br> f(4) &#x3D; f(3) * 4<br> f(3) &#x3D; f(2) * 3<br> f(2) &#x3D; f(1) * 2<br> f(1) &#x3D; 1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">      目标：递归的算法和执行流程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RecursionDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(f(<span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> f(n - <span class="number">1</span>) * n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>递归案例导学-计算1–n的和</strong></p>
<p><strong>需求：</strong></p>
<p>计算1-n的和的结果，使用递归思想解决，我们先从数学思维上理解递归的流程和核心点。</p>
<p><strong>分析:</strong></p>
<p>①假如我们认为存在一个公式是 f(n) &#x3D; 1 + 2 + 3 + 4 + 5 + 6 + 7 + …(n-1) + n;</p>
<p>②那么公式等价形式就是： f(n) &#x3D; f(n-1) + n</p>
<p>③递归的终结点：f(1) &#x3D; 1</p>
<p>④如果求的是 1-5的和 的结果，应该如何计算。</p>
<p>⑤f(5) &#x3D; f(4)  + 5<br> f(4) &#x3D; f(3)  + 4<br> f(3) &#x3D; f(2)  + 3<br> f(2) &#x3D; f(1)  + 2<br> f(1) &#x3D; 1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">      目标：1 - n求和</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RecursionDemo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(f(<span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> f(n - <span class="number">1</span>)  + n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-4递归的经典问题"><a href="#3-4递归的经典问题" class="headerlink" title="3.4递归的经典问题"></a>3.4递归的经典问题</h4><p><strong>猴子吃桃问题</strong></p>
<p>猴子第一天摘下若干桃子，当即吃了一半，觉得好不过瘾，于是又多吃了一个</p>
<p>第二天又吃了前天剩余桃子数量的一半，觉得好不过瘾，于是又多吃了一个</p>
<p>以后每天都是吃前天剩余桃子数量的一半，觉得好不过瘾，又多吃了一个</p>
<p>等到第10天的时候发现桃子只有1个了。</p>
<p>需求：请问猴子第一天摘了多少个桃子？</p>
<p><strong>分析：</strong></p>
<p>①整体来看，每一天都是做同一个事件，典型的规律化问题，考虑递归三要素：</p>
<p>②递归公式： </p>
<p>③递归终结点：</p>
<p>④递归方向：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     目标 猴子吃桃。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     公式（合理的）： f(x) - f(x)/2 - 1 = f(x+1)</span></span><br><span class="line"><span class="comment">                   2f(x) - f(x) - 2 = 2f(x + 1)</span></span><br><span class="line"><span class="comment">                   f(x) = 2f(x + 1) + 2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    求f(1) = ?</span></span><br><span class="line"><span class="comment">    终结点： f（10） = 1</span></span><br><span class="line"><span class="comment">    递归的方向：合理的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RecursionDemo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(f(<span class="number">1</span>));</span><br><span class="line">        System.out.println(f(<span class="number">2</span>));</span><br><span class="line">        System.out.println(f(<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">10</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span> * f(n + <span class="number">1</span>) + <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-5非规律化递归案例-文件搜索"><a href="#3-5非规律化递归案例-文件搜索" class="headerlink" title="3.5非规律化递归案例-文件搜索"></a>3.5非规律化递归案例-文件搜索</h4><p><strong>文件搜索：</strong></p>
<p><strong>需求：</strong></p>
<p>文件搜索、从C:盘中，搜索出某个文件名称并输出绝对路径。</p>
<p><strong>分析：</strong></p>
<p>①先定位出的应该是一级文件对象</p>
<p>②遍历全部一级文件对象，判断是否是文件</p>
<p>③如果是文件，判断是否是自己想要的</p>
<p>④如果是文件夹，需要继续递归进去重复上述过程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：去D判断搜索 eDiary.exe文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RecursionDemo05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 2、传入目录 和  文件名称</span></span><br><span class="line">        searchFile(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/&quot;</span>) , <span class="string">&quot;eDiary.exe&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1、搜索某个目录下的全部文件，找到我们想要的文件。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dir  被搜索的源目录</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fileName 被搜索的文件名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">searchFile</span><span class="params">(File dir,String fileName)</span>&#123;</span><br><span class="line">        <span class="comment">// 3、判断dir是否是目录</span></span><br><span class="line">        <span class="keyword">if</span>(dir != <span class="literal">null</span> &amp;&amp; dir.isDirectory())&#123;</span><br><span class="line">            <span class="comment">// 可以找了</span></span><br><span class="line">            <span class="comment">// 4、提取当前目录下的一级文件对象</span></span><br><span class="line">            File[] files = dir.listFiles(); <span class="comment">// null  []</span></span><br><span class="line">            <span class="comment">// 5、判断是否存在一级文件对象，存在才可以遍历</span></span><br><span class="line">            <span class="keyword">if</span>(files != <span class="literal">null</span> &amp;&amp; files.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">                    <span class="comment">// 6、判断当前遍历的一级文件对象是文件 还是 目录</span></span><br><span class="line">                    <span class="keyword">if</span>(file.isFile())&#123;</span><br><span class="line">                        <span class="comment">// 7、是不是咱们要找的，是把其路径输出即可</span></span><br><span class="line">                        <span class="keyword">if</span>(file.getName().contains(fileName))&#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;找到了：&quot;</span> + file.getAbsolutePath());</span><br><span class="line">                            <span class="comment">// 启动它。</span></span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                <span class="type">Runtime</span> <span class="variable">r</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line">                                r.exec(file.getAbsolutePath());</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                                e.printStackTrace();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 8、是文件夹，需要继续递归寻找</span></span><br><span class="line">                        searchFile(file, fileName);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;对不起，当前搜索的位置不是文件夹！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-6非规律化递归案例-啤酒问题"><a href="#3-6非规律化递归案例-啤酒问题" class="headerlink" title="3.6非规律化递归案例-啤酒问题"></a>3.6非规律化递归案例-啤酒问题</h4><p><strong>啤酒问题:</strong></p>
<p><strong>需求：</strong></p>
<p>啤酒2元1瓶，4个盖子可以换一瓶，2个空瓶可以换一瓶，</p>
<p>请问10元钱可以喝多少瓶酒，剩余多少空瓶和盖子。</p>
<p><strong>答案：</strong></p>
<p>15瓶 3盖子 1瓶子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：啤酒2元1瓶，4个盖子可以换一瓶，2个空瓶可以换一瓶，</span></span><br><span class="line"><span class="comment">        请问10元钱可以喝多少瓶酒，剩余多少空瓶和盖子。</span></span><br><span class="line"><span class="comment">        答案：15瓶 3盖子 1瓶子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RecursionDemo06</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个静态的成员变量用于存储可以买的酒数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> totalNumber; <span class="comment">// 总数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> lastBottleNumber; <span class="comment">// 记录每次剩余的瓶子个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> lastCoverNumber; <span class="comment">// 记录每次剩余的盖子个数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、拿钱买酒</span></span><br><span class="line">        buy(<span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;总数：&quot;</span> + totalNumber);</span><br><span class="line">        System.out.println(<span class="string">&quot;剩余盖子数：&quot;</span> + lastCoverNumber);</span><br><span class="line">        System.out.println(<span class="string">&quot;剩余瓶子数：&quot;</span> + lastBottleNumber);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">buy</span><span class="params">(<span class="type">int</span> money)</span>&#123;</span><br><span class="line">        <span class="comment">// 2、看可以立马买多少瓶</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">buyNumber</span> <span class="operator">=</span> money / <span class="number">2</span>; <span class="comment">// 5</span></span><br><span class="line">        totalNumber += buyNumber;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、把盖子 和瓶子换算成钱</span></span><br><span class="line">        <span class="comment">// 统计本轮总的盖子数  和 瓶子数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">coverNumber</span> <span class="operator">=</span> lastCoverNumber + buyNumber;</span><br><span class="line">        <span class="type">int</span> <span class="variable">bottleNumber</span> <span class="operator">=</span> lastBottleNumber + buyNumber;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 统计可以换算的钱</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">allMoney</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(coverNumber &gt;= <span class="number">4</span>)&#123;</span><br><span class="line">            allMoney += (coverNumber / <span class="number">4</span>) * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lastCoverNumber = coverNumber % <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(bottleNumber &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">            allMoney += (bottleNumber / <span class="number">2</span>) * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lastBottleNumber = bottleNumber % <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(allMoney &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">            buy(allMoney);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Integer[] arr2 = <span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>&#125;;</span><br><span class="line">        Arrays.sort(arr2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-字符集"><a href="#4-字符集" class="headerlink" title="4.字符集"></a>4.字符集</h3><h4 id="4-1常见字符集介绍"><a href="#4-1常见字符集介绍" class="headerlink" title="4.1常见字符集介绍"></a>4.1常见字符集介绍</h4><p><strong>字符集基础知识：</strong></p>
<ul>
<li><p>计算机底层不可以直接存储字符的。计算机中底层只能存储<strong>二进制(0、1)</strong></p>
</li>
<li><p>二进制是可以转换成十进制的</p>
</li>
</ul>
<p>11 &#x3D; 1<em>2^1 + 1</em>2^0 &#x3D; 2 + 1 &#x3D; 3<br>10 &#x3D; 1<em>2^1 + 0</em>2^0 &#x3D; 2 + 0 &#x3D; 2<br> 01 &#x3D; 0<em>2^1 + 1</em>2^0 &#x3D; 0 + 1 &#x3D; 1<br> 00 &#x3D; 0<em>2^1 + 0</em>2^0 &#x3D; 0 + 0 &#x3D; 0</p>
<p>‭01100001‬ &#x3D; 97</p>
<p>‭01100010‬ &#x3D; 98</p>
<p><strong>结论：计算机底层可以表示十进制编号。计算机可以给人类字符进行编号存储，这套编号规则就是字符集。</strong></p>
<p><strong>ASCII字符集：</strong></p>
<ul>
<li><p>ASCII(American Standard Code for Information Interchange，美国信息交换标准代码)：包括了数字、英文、符号。</p>
</li>
<li><p>ASCII使用1个字节存储一个字符，一个字节是8位，总共可以表示128个字符信息，对于英文，数字来说是够用的。</p>
</li>
</ul>
<p>01100001‬ &#x3D; 97 &#x3D;&gt; a</p>
<p>‭01100010‬ &#x3D; 98 &#x3D;&gt; b</p>
<p><strong>GBK：</strong></p>
<ul>
<li><p>window系统默认的码表。兼容ASCII码表，也包含了几万个汉字，并支持繁体汉字以及部分日韩文字。</p>
</li>
<li><p>注意：GBK是中国的码表，一个中文以<strong>两个字节</strong>的形式存储。但不包含世界上所有国家的文字。</p>
</li>
</ul>
<p><strong>Unicode码表：</strong></p>
<ul>
<li><p>unicode（又称统一码、万国码、单一码）是计算机科学领域里的一项业界字符编码标准。</p>
</li>
<li><p>容纳世界上大多数国家的所有常见文字和符号。</p>
</li>
<li><p>由于Unicode会先通过UTF-8，UTF-16，以及 UTF-32的编码成二进制后再存储到计算机，其中最为常见的就是UTF-8。</p>
</li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li><p>Unicode是万国码，以UTF-8编码后一个中文一般以<strong>三个字节</strong>的形式存储。</p>
</li>
<li><p>UTF-8也要兼容ASCII编码表。</p>
</li>
<li><p>技术人员都应该使用UTF-8的字符集编码。</p>
</li>
<li><p>编码前和编码后的字符集需要一致，否则会出现中文乱码。</p>
</li>
</ul>
<h4 id="4-2字符集的编码、解码操作"><a href="#4-2字符集的编码、解码操作" class="headerlink" title="4.2字符集的编码、解码操作"></a>4.2字符集的编码、解码操作</h4><p><strong>String编码</strong></p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>byte[] getBytes()</td>
<td>使用平台的默认字符集将该  String编码为一系列字节，将结果存储到新的字节数组中</td>
</tr>
<tr>
<td>byte[] getBytes(String charsetName)</td>
<td>使用指定的字符集将该 String编码为一系列字节，将结果存储到新的字节数组中</td>
</tr>
</tbody></table>
<p><strong>String解码</strong></p>
<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>String(byte[] bytes)</td>
<td>通过使用平台的默认字符集解码指定的字节数组来构造新的  String</td>
</tr>
<tr>
<td>String(byte[] bytes, String charsetName)</td>
<td>通过指定的字符集解码指定的字节数组来构造新的 String</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     目标：学会自己进行文字的编码和解码，为以后可能用到的场景做准备。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、编码：把文字转换成字节</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;abc我爱你中国&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 以当前代码默认字符集进行编码 （UTF-8）</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = name.getBytes(); </span><br><span class="line">        System.out.println(bytes.length); <span class="comment">//18</span></span><br><span class="line">        System.out.println(Arrays.toString(bytes)); </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 指定编码</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = name.getBytes(<span class="string">&quot;GBK&quot;</span>); </span><br><span class="line">        System.out.println(bytes.length); <span class="comment">//13</span></span><br><span class="line">        System.out.println(Arrays.toString(bytes));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、解码：把字节转换成对应的中文形式（编码前 和 编码后的字符集必须一致，否则乱码 ）</span></span><br><span class="line">        <span class="comment">// 默认的UTF-8</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes); </span><br><span class="line">        <span class="comment">// 指定GBK解码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="string">&quot;GBK&quot;</span>); </span><br><span class="line">        System.out.println(rs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-IO流概述"><a href="#5-IO流概述" class="headerlink" title="5.IO流概述"></a>5.IO流概述</h3><p><strong>IO流概述</strong></p>
<ul>
<li><p>I 表示intput，是数据从硬盘文件读入到内存的过程，称之输入，负责读。</p>
</li>
<li><p>O表示output，是内存程序的数据从内存到写出到硬盘文件的过程，称之输出，负责写。</p>
</li>
</ul>
<p><strong>IO流的作用</strong></p>
<ul>
<li>读写文件数据</li>
</ul>
<p><strong>IO流的分类</strong></p>
<ol>
<li><p><strong>字节流（Byte Streams）</strong>：字节流以字节为单位进行数据的输入和输出。它们适用于处理二进制数据或字符数据，不关心数据的具体含义。在Java中，<code>InputStream</code>和<code>OutputStream</code>是字节流的基本抽象类。</p>
<ul>
<li><code>InputStream</code>：用于从数据源（如文件、网络等）读取字节数据。</li>
<li><code>OutputStream</code>：用于将字节数据写入目标（如文件、网络等）。</li>
</ul>
</li>
<li><p><strong>字符流（Character Streams）</strong>：字符流以字符为单位进行数据的输入和输出，可以更方便地处理文本数据。在处理字符数据时，字符流会考虑字符的编码方式，如UTF-8、UTF-16等。在Java中，<code>Reader</code>和<code>Writer</code>是字符流的基本抽象类。</p>
<ul>
<li><code>Reader</code>：用于从数据源读取字符数据。</li>
<li><code>Writer</code>：用于将字符数据写入目标。</li>
</ul>
</li>
<li><p><strong>节点流（Node Streams）</strong>：节点流直接与数据源或目标进行连接，是I&#x2F;O流的最基本形式。例如，从文件中读取数据的<code>FileInputStream</code>和向文件写入数据的<code>FileOutputStream</code>就是节点流。</p>
</li>
<li><p><strong>处理流（Filter Streams）</strong>：处理流是建立在节点流之上的，它们提供了一些额外的功能，如缓冲、数据转换等。处理流可以通过链式结构进行组合，将多个处理流串联起来以实现更复杂的数据处理操作。例如，<code>BufferedReader</code>和<code>BufferedWriter</code>就是处理流的例子，它们可以用来缓冲字符流的输入和输出。</p>
</li>
<li><p><strong>对象流（Object Streams）</strong>：对象流可以用来读写Java对象，而不仅仅是字节或字符数据。这对于在应用程序之间传递复杂的数据结构非常有用。<code>ObjectInputStream</code>和<code>ObjectOutputStream</code>用于实现对象流。</p>
</li>
<li><p><strong>数据流（Data Streams）</strong>：数据流允许以基本数据类型（如整数、浮点数等）的形式进行读写操作，而不必考虑字节的表示。<code>DataInputStream</code>和<code>DataOutputStream</code>提供了数据流的功能。</p>
</li>
<li><p><strong>输入流和输出流</strong>：根据数据流的方向，可以将I&#x2F;O流分为输入流和输出流。输入流用于读取数据，输出流用于写入数据。</p>
</li>
</ol>
<p><strong>总结流的四大类:</strong></p>
<ul>
<li><p>字节输入流：以内存为基准，来自磁盘文件&#x2F;网络中的数据以字节的形式读入到内存中去的流称为字节输入流。</p>
</li>
<li><p>字节输出流：以内存为基准，把内存中的数据以字节写出到磁盘文件或者网络中去的流称为字节输出流。</p>
</li>
<li><p>字符输入流：以内存为基准，来自磁盘文件&#x2F;网络中的数据以字符的形式读入到内存中去的流称为字符输入流。</p>
</li>
<li><p>字符输出流：以内存为基准，把内存中的数据以字符写出到磁盘文件或者网络介质中去的流称为字符输出流。</p>
</li>
</ul>
<p><strong>IO流体系</strong></p>
<ol>
<li><strong>字节流（Byte Streams）</strong>： 字节流操作以字节为单位进行读写，适用于处理任何类型的数据，包括文本和二进制数据。主要的字节流类有：<ul>
<li><code>InputStream</code>：字节输入流的基类。</li>
<li><code>OutputStream</code>：字节输出流的基类。</li>
<li><code>FileInputStream</code>：从文件中读取字节数据的输入流。</li>
<li><code>FileOutputStream</code>：向文件写入字节数据的输出流。</li>
<li><code>BufferedInputStream</code> 和 <code>BufferedOutputStream</code>：带有缓冲功能的字节流。</li>
<li><code>DataInputStream</code> 和 <code>DataOutputStream</code>：用于读写基本数据类型的字节流。</li>
</ul>
</li>
<li><strong>字符流（Character Streams）</strong>： 字符流操作以字符为单位进行读写，适用于处理文本数据。字符流会自动处理字符编码和解码，以确保正确处理各种字符集。主要的字符流类有：<ul>
<li><code>Reader</code>：字符输入流的基类。</li>
<li><code>Writer</code>：字符输出流的基类。</li>
<li><code>FileReader</code>：从文件中读取字符数据的输入流。</li>
<li><code>FileWriter</code>：向文件写入字符数据的输出流。</li>
<li><code>BufferedReader</code> 和 <code>BufferedWriter</code>：带有缓冲功能的字符流。</li>
<li><code>InputStreamReader</code> 和 <code>OutputStreamWriter</code>：将字节流转换为字符流的桥梁。</li>
</ul>
</li>
</ol>
<h3 id="6-字节流的使用"><a href="#6-字节流的使用" class="headerlink" title="6.字节流的使用"></a>6.字节流的使用</h3><h4 id="6-1文件字节输入流：FileInputStream"><a href="#6-1文件字节输入流：FileInputStream" class="headerlink" title="6.1文件字节输入流：FileInputStream"></a>6.1文件字节输入流：FileInputStream</h4><p><strong>注意：读数据会自己换行</strong></p>
<p><strong>构造器</strong></p>
<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public  <strong>FileInputStream</strong>(File file)</td>
<td>创建字节输入流管道与源文件对象接通</td>
</tr>
<tr>
<td>public  <strong>FileInputStream</strong>(String pathname)</td>
<td>创建字节输入流管道与源文件路径接通</td>
</tr>
</tbody></table>
<h5 id="6-1-1每次读取一个字节"><a href="#6-1-1每次读取一个字节" class="headerlink" title="6.1.1每次读取一个字节"></a>6.1.1每次读取一个字节</h5><ul>
<li>作用：以内存为基准，把磁盘文件中的数据以字节的形式读取到内存中去。</li>
</ul>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public int  read()</td>
<td>每次读取一个字节返回，如果字节已经没有可读的返回-1</td>
</tr>
</tbody></table>
<p><strong>每次读取一个字节存在什么问题？</strong></p>
<ul>
<li><p><strong>性能较慢</strong></p>
</li>
<li><p><strong>读取中文字符输出无法避免乱码问题。</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：字节输入流的使用。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    IO流的体系：</span></span><br><span class="line"><span class="comment">                    字节流                                     字符流</span></span><br><span class="line"><span class="comment">        字节输入流             字节输出流               字符输入流         字符输出流</span></span><br><span class="line"><span class="comment">        InputStream          OutputStream            Reader           Writer  (抽象类)</span></span><br><span class="line"><span class="comment">        FileInputStream      FileOutputStream        FileReader       FileWriter(实现类，可以使用的)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    小结：</span></span><br><span class="line"><span class="comment">        一个一个字节读取中文数据输出其实是被淘汰的，性能极差！</span></span><br><span class="line"><span class="comment">         一个一个字节读取中文数据输出，会出现截断中文字节的情况，无法避免读取中文输出乱码的问题。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileInputStreamDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建一个文件字节输入流管道与源文件接通。</span></span><br><span class="line">        <span class="comment">// InputStream is = new FileInputStream(new File(&quot;file-io-app\\src\\data.txt&quot;));</span></span><br><span class="line">        <span class="comment">// 简化写法</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;file-io-app\\src\\data.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、读取一个字节返回 （每次读取一滴水）</span></span><br><span class="line"><span class="comment">//        int b1 = is.read();</span></span><br><span class="line"><span class="comment">//        System.out.println((char)b1);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        int b2 = is.read();</span></span><br><span class="line"><span class="comment">//        System.out.println((char)b2);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        int b3 = is.read();</span></span><br><span class="line"><span class="comment">//        System.out.println((char)b3);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        int b4 = is.read(); // 读取完毕返回-1</span></span><br><span class="line"><span class="comment">//        System.out.println(b4);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、使用循环改进</span></span><br><span class="line">        <span class="comment">// 定义一个变量记录每次读取的字节    a  b  3    爱</span></span><br><span class="line">        <span class="comment">//                              o  o  o   [ooo]</span></span><br><span class="line">        <span class="type">int</span> b;</span><br><span class="line">        <span class="keyword">while</span> (( b = is.read() ) != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print((<span class="type">char</span>) b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6-1-2每次读取一个字节数组"><a href="#6-1-2每次读取一个字节数组" class="headerlink" title="6.1.2每次读取一个字节数组"></a>6.1.2每次读取一个字节数组</h5><ul>
<li>作用：以内存为基准，把磁盘文件中的数据以字节的形式读取到内存中去。</li>
</ul>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public int read(byte[] buffer)</td>
<td>每次读取一个字节数组返回，如果字节已经没有可读的返回-1</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   目标：使用文件字节输入流每次读取一个字节数组的数据。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileInputStreamDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建一个文件字节输入流管道与源文件接通</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;file-io-app/src/data02.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、定义一个字节数组，用于读取字节数组</span></span><br><span class="line"><span class="comment">//        byte[] buffer = new byte[3]; // 3B</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//        int len = is.read(buffer); // 3</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;读取了几个字节：&quot; + len); / 3</span></span><br><span class="line"><span class="comment">//        String rs = new String(buffer);</span></span><br><span class="line"><span class="comment">//        System.out.println(rs);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        int len1 = is.read(buffer);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;读取了几个字节：&quot; + len1);</span></span><br><span class="line"><span class="comment">//        String rs1 = new String(buffer);</span></span><br><span class="line"><span class="comment">//        System.out.println(rs1);</span></span><br><span class="line"><span class="comment">//        // buffer = [a b c]</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        // buffer = [a b c]  ==&gt;  [c d c]</span></span><br><span class="line"><span class="comment">//        int len2 = is.read(buffer);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;读取了几个字节：&quot; + len2);</span></span><br><span class="line"><span class="comment">//        // 读取多少倒出多少</span></span><br><span class="line"><span class="comment">//        String rs2 = new String(buffer,0 ,len2);</span></span><br><span class="line"><span class="comment">//        System.out.println(rs2);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        int len3 = is.read(buffer);</span></span><br><span class="line"><span class="comment">//        System.out.println(len3); // 读取完毕返回-1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、改进使用循环，每次读取一个字节数组</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="type">int</span> len; <span class="comment">// 记录每次读取的字节数。</span></span><br><span class="line">        <span class="keyword">while</span> ((len = is.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 读取多少倒出多少</span></span><br><span class="line">            System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(buffer, <span class="number">0</span> , len));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6-1-3一次读完全部字节"><a href="#6-1-3一次读完全部字节" class="headerlink" title="6.1.3一次读完全部字节"></a>6.1.3一次读完全部字节</h5><p>1、如何使用字节输入流读取中文内容输出不乱码呢？</p>
<ul>
<li><strong>定义一个与文件一样大的字节数组，一次性读取完文件的全部字节。</strong></li>
</ul>
<p>2、直接把文件数据全部读取到一个字节数组可以避免乱码，是否存在问题？</p>
<ul>
<li><strong>如果文件过大，字节数组可能引起内存溢出。</strong></li>
</ul>
<p><strong>方式一</strong></p>
<ul>
<li>自己定义一个字节数组与文件的大小一样大，然后使用读取字节数组的方法，一次性读取完成。</li>
</ul>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public int  read(byte[] buffer)</td>
<td>每次读取一个字节数组返回，如果字节已经没有可读的返回-1</td>
</tr>
</tbody></table>
<p><strong>方式二</strong></p>
<ul>
<li>官方为字节输入流InputStream提供了如下<strong>API</strong>可以直接把文件的全部数据读取到一个字节数组中</li>
</ul>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public byte[] readAllBytes() throws IOException</td>
<td>直接将当前字节输入流对应的文件对象的字节数据装到一个字节数组返回</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   目标：使用文件字节输入流一次读完文件的全部字节。可以解决乱码问题。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileInputStreamDemo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建一个文件字节输入流管道与源文件接通</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;file-io-app/src/data03.txt&quot;</span>);</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(f);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方法一:定义一个字节数组与文件的大小刚刚一样大。</span></span><br><span class="line">        <span class="comment">// f.length()为long 型，需要强转</span></span><br><span class="line"><span class="comment">//        byte[] buffer = new byte[(int) f.length()]; </span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//        int len = is.read(buffer); //(int) f.length()</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;读取了多少个字节：&quot; + len); </span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;文件大小：&quot; + f.length());</span></span><br><span class="line"><span class="comment">//        System.out.println(new String(buffer));</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方法二:官方APIreadAllBytes，读取全部字节数组</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = is.readAllBytes();</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(buffer));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-2文件字节输出流：FileOutputStream"><a href="#6-2文件字节输出流：FileOutputStream" class="headerlink" title="6.2文件字节输出流：FileOutputStream"></a>6.2文件字节输出流：FileOutputStream</h4><p><strong>写字节数据到文件</strong></p>
<ul>
<li>作用：以内存为基准，把内存中的数据以字节的形式写出到磁盘文件中去的流。</li>
</ul>
<p><strong>构造器</strong></p>
<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public <strong>FileOutputStream</strong>(File file , boolean append)</td>
<td>创建一个追加数据的字节输出流管道通向目标文件对象。</td>
</tr>
<tr>
<td>public <strong>FileOutputStream</strong>(String filepath，boolean append)</td>
<td>创建字节输出流管道与源文件路径接通，可追加数据</td>
</tr>
</tbody></table>
<p><strong>FileOutputStream写数据出去的API</strong></p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public void write(int a)</td>
<td>写一个字节出去</td>
</tr>
<tr>
<td>public void write(byte[] buffer)</td>
<td>写一个字节数组出去</td>
</tr>
<tr>
<td>public void write(byte[] buffer , int pos , int len)</td>
<td>写一个字节数组的一部分出去。</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：字节输出流的使用。</span></span><br><span class="line"><span class="comment">         把内存数据按照字节写出到磁盘文件中去。</span></span><br><span class="line"><span class="comment">         </span></span><br><span class="line"><span class="comment">-- 构造器：</span></span><br><span class="line"><span class="comment">         public FileOutputStream(File file):创建一个字节输出流管道通向目标文件对象。</span></span><br><span class="line"><span class="comment">         public FileOutputStream(String file):创建一个字节输出流管道通向目标文件路径。</span></span><br><span class="line"><span class="comment">         public FileOutputStream(File file , boolean append):创建一个追加数据的字节输出流管道通向目标文件对象。</span></span><br><span class="line"><span class="comment">         public FileOutputStream(String file , boolean append):创建一个追加数据的字节输出流管道通向目标文件路径。</span></span><br><span class="line"><span class="comment">         </span></span><br><span class="line"><span class="comment">-- 方法：</span></span><br><span class="line"><span class="comment">         public void write(int a):写一个字节出去 。</span></span><br><span class="line"><span class="comment">         public void write(byte[] buffer):写一个字节数组出去。</span></span><br><span class="line"><span class="comment">         public void write(byte[] buffer , int pos , int len):写一个字节数组的一部分出去。</span></span><br><span class="line"><span class="comment">         参数一，字节数组；参数二：起始字节索引位置，参数三：写多少个字节数出去。</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">         换行：  os.write(&quot;\r\n&quot;.getBytes()); // 换行</span></span><br><span class="line"><span class="comment">   追加数据管道： OutputStream os = new FileOutputStream(&quot;day10_demo/out01.txt&quot; , true); // 追加管道！！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OutputStreamDemo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">	<span class="comment">// 1、创建一个文件字节输出流管道与目标文件接通</span></span><br><span class="line">        <span class="comment">// 追加数据管道</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;file-io-app/src/out04.txt&quot;</span> , <span class="literal">true</span>); </span><br><span class="line">        <span class="comment">// 先清空之前的数据，写新数据进入</span></span><br><span class="line">        <span class="comment">//OutputStream os = new FileOutputStream(&quot;file-io-app/src/out04.txt&quot;); </span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2、写数据出去</span></span><br><span class="line">        <span class="comment">// a.public void write(int a):写一个字节出去</span></span><br><span class="line">        os.write(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        os.write(<span class="number">98</span>);</span><br><span class="line">        os.write(<span class="string">&quot;\r\n&quot;</span>.getBytes()); <span class="comment">// 换行</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// b.public void write(byte[] buffer):写一个字节数组出去。</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = &#123;<span class="string">&#x27;a&#x27;</span> , <span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>&#125;;</span><br><span class="line">        os.write(buffer);</span><br><span class="line">        os.write(<span class="string">&quot;\r\n&quot;</span>.getBytes()); <span class="comment">// 换行</span></span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] buffer2 = <span class="string">&quot;我是中国人&quot;</span>.getBytes();</span><br><span class="line">        <span class="comment">//byte[] buffer2 = &quot;我是中国人&quot;.getBytes(&quot;GBK&quot;);</span></span><br><span class="line">        os.write(buffer2);</span><br><span class="line">        os.write(<span class="string">&quot;\r\n&quot;</span>.getBytes()); <span class="comment">// 换行</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// c. public void write(byte[] buffer , int pos , int len):写一个字节数组的一部分出去。</span></span><br><span class="line">        <span class="type">byte</span>[] buffer3 = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>&#125;;</span><br><span class="line">        os.write(buffer3, <span class="number">0</span> , <span class="number">3</span>); <span class="comment">//从索引0开始 ，三个字节</span></span><br><span class="line">        os.write(<span class="string">&quot;\r\n&quot;</span>.getBytes()); <span class="comment">// 换行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>流的关闭与刷新</strong> </p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>flush</strong>()</td>
<td>刷新流，还可以继续写数据</td>
</tr>
<tr>
<td><strong>close</strong>()</td>
<td>关闭流，释放资源，但是在关闭之前会先刷新流。一旦关闭，就不能再写数据</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写数据必须，刷新数据 可以继续使用流</span></span><br><span class="line">os.flush();</span><br><span class="line"><span class="comment">// 释放资源，包含了刷新的！关闭后流不可以使用了</span></span><br><span class="line">os.close(); </span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<p>字节输出流如何实现写出去的数据能换行?</p>
<ul>
<li><strong>os.write(“\r\n”.getBytes());</strong></li>
</ul>
<p>如何让写出去的数据能成功生效？</p>
<ul>
<li><p><strong>flush()刷新数据</strong></p>
</li>
<li><p><strong>close()方法是关闭流，关闭包含刷新，关闭后流不可以继续使用了。</strong></p>
</li>
</ul>
<h4 id="6-3文件拷贝"><a href="#6-3文件拷贝" class="headerlink" title="6.3文件拷贝"></a>6.3文件拷贝</h4><p><strong>文件拷贝</strong></p>
<p><strong>需求：</strong></p>
<p>把某个视频复制到其他目录下的“b.avi”</p>
<p><strong>思路</strong>：</p>
<p>①根据数据源创建字节输入流对象</p>
<p>②根据目的地创建字节输出流对象</p>
<p>③读写数据，复制视频</p>
<p>④释放资源</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *   目标：学会使用字节流完成文件的复制（支持一切文件类型的复制）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopyDemo05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1、创建一个字节输入流管道与原视频接通</span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;file-io-app/src/out04.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2、创建一个字节输出流管道与目标文件接通</span></span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;file-io-app/src/out05.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3、定义一个字节数组转移数据</span></span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> len; <span class="comment">// 记录每次读取的字节数。</span></span><br><span class="line">            <span class="keyword">while</span> ((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                os.write(buffer, <span class="number">0</span> , len);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            System.out.println(<span class="string">&quot;复制完成了！&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4、关闭流。</span></span><br><span class="line">            os.close();</span><br><span class="line">            is.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-资源释放的方式"><a href="#7-资源释放的方式" class="headerlink" title="7.资源释放的方式"></a>7.资源释放的方式</h3><h4 id="7-1try-catch-finally"><a href="#7-1try-catch-finally" class="headerlink" title="7.1try-catch-finally"></a>7.1try-catch-finally</h4><p><strong>try-catch-finally</strong></p>
<ul>
<li><p>finally：在异常处理时提供finally块来执行所有清除操作，比如说IO流中的释放资源</p>
</li>
<li><p><strong>特点：被finally控制的语句最终一定会执行，除非JVM退出</strong></p>
</li>
<li><p>异常处理标准格式：<strong>try….catch…finally</strong></p>
</li>
</ul>
<p><strong>try-catch-finally格式</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//手动释放资源</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	可能出现异常的代码;</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类名 变量名)&#123;</span><br><span class="line">	异常的处理代码;</span><br><span class="line"> &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">	执行所有资源释放操作;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//代码繁琐</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *   目标：学会使用finally释放资源。</span></span><br><span class="line"><span class="comment"> 		  try….catch…finally</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TryCatchFinallyDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// System.out.println(10/ 0);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1、创建一个字节输入流管道与原视频接通</span></span><br><span class="line">             is = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;file-io-app/src/out04.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2、创建一个字节输出流管道与目标文件接通</span></span><br><span class="line">             os = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;file-io-app/src/out05.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3、定义一个字节数组转移数据</span></span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> len; <span class="comment">// 记录每次读取的字节数。</span></span><br><span class="line">            <span class="keyword">while</span> ((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                os.write(buffer, <span class="number">0</span> , len);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;复制完成了！&quot;</span>);</span><br><span class="line"></span><br><span class="line">         <span class="comment">//   System.out.println( 10 / 0);</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 无论代码是正常结束，还是出现异常都要最后执行这里</span></span><br><span class="line">            System.out.println(<span class="string">&quot;========finally=========&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 4、关闭流。</span></span><br><span class="line">                <span class="keyword">if</span>(os!=<span class="literal">null</span>)os.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(is != <span class="literal">null</span>) is.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(test(<span class="number">10</span>, <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a , <span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a / b;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">111111</span>; <span class="comment">// 计算出现bug.</span></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;--finally--&quot;</span>);</span><br><span class="line">            <span class="comment">// 哪怕上面有return语句执行，也必须先执行完这里才可以！</span></span><br><span class="line">            <span class="comment">// 开发中不建议在这里加return ，如果加了，返回的永远是这里的数据了，这样会出问题！</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-2try-with-resource-改进方案"><a href="#7-2try-with-resource-改进方案" class="headerlink" title="7.2try-with-resource(改进方案)"></a>7.2try-with-resource(改进方案)</h4><p><strong>JDK7 和 JDK9 中都简化了资源释放操作</strong></p>
<p><strong>JDK7改进方案(较常用)：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//资源用完最终自动释放</span></span><br><span class="line"><span class="keyword">try</span>(定义流对象)&#123;</span><br><span class="line">	可能出现异常的代码;</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类名 变量名)&#123;</span><br><span class="line">	异常的处理代码;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *   目标：学会使用JDK 7的新方式释放资源 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TryCatchResouceDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">// 这里面只能放置资源对象，用完会自动关闭：自动调用资源对象的close方法关闭资源（即使出现异常也会做关闭操作）</span></span><br><span class="line">                <span class="comment">// 1、创建一个字节输入流管道与原视频接通</span></span><br><span class="line">               <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;file-io-app/src/out04.txt&quot;</span>);</span><br><span class="line">                <span class="comment">// 2、创建一个字节输出流管道与目标文件接通</span></span><br><span class="line">               <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;file-io-app/src/out05.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">               <span class="comment">// int age = 23; // 这里只能放资源</span></span><br><span class="line">                <span class="type">MyConnection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyConnection</span>(); <span class="comment">// 最终会自动调用资源的close方法</span></span><br><span class="line">                ) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3、定义一个字节数组转移数据</span></span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> len; <span class="comment">// 记录每次读取的字节数。</span></span><br><span class="line">            <span class="keyword">while</span> ((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                os.write(buffer, <span class="number">0</span> , len);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;复制完成了！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyConnection</span> <span class="keyword">implements</span> <span class="title class_">AutoCloseable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;连接资源被成功释放了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>JDK9改进方案：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//资源用完最终自动释放</span></span><br><span class="line">定义输入流对象;</span><br><span class="line">定义输出流对象;</span><br><span class="line"><span class="keyword">try</span>(输入流对象；输出流对象)&#123;</span><br><span class="line">	可能出现异常的代码;</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类名 变量名)&#123;</span><br><span class="line">	异常的处理代码;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *   目标：JDK 9释放资源的方式：可以了解下。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TryCatchResouceDemo3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123; <span class="comment">//这里必须抛出错误</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里面只能放置资源对象，用完会自动关闭：自动调用资源对象的close方法关闭资源（即使出现异常也会做关闭操作）</span></span><br><span class="line">        <span class="comment">// 1、创建一个字节输入流管道与原视频接通</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;file-io-app/src/out04.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 2、创建一个字节输出流管道与目标文件接通</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;file-io-app/src/out05.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> ( is ; os ) &#123;</span><br><span class="line">            <span class="comment">// 3、定义一个字节数组转移数据</span></span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> len; <span class="comment">// 记录每次读取的字节数。</span></span><br><span class="line">            <span class="keyword">while</span> ((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                os.write(buffer, <span class="number">0</span> , len);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;复制完成了！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<ul>
<li><p>JDK 7 以及 JDK 9的()中只能放置资源对象，否则报错</p>
</li>
<li><p>什么是资源呢？</p>
<p>资源都是实现了Closeable&#x2F;AutoCloseable接口的类对象</p>
</li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">InputStream</span> <span class="keyword">implements</span> <span class="title class_">Closeable</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">OutputStream</span> <span class="keyword">implements</span> <span class="title class_">Closeable</span>, Flushable&#123;&#125; </span><br></pre></td></tr></table></figure>

<p><strong>案例：</strong></p>
<p><strong>拷贝文件夹</strong></p>
<p>需求：</p>
<p>将某个磁盘的文件夹拷贝到另一个文件夹下去，包括文件夹中的全部信息</p>
<p>分析：</p>
<p>①：IO默认不可以拷贝文件夹</p>
<p>②：我们需要遍历文件夹，如果是文件则拷贝过去，如果是文件夹则要进行1-1创建，继续复制内容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   目标：拷贝文件夹</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">         <span class="comment">// D:\resources</span></span><br><span class="line">        copy(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\resources&quot;</span>) , <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\new&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copy</span><span class="params">(File src , File dest)</span>&#123;</span><br><span class="line">        <span class="comment">// 1、判断源目录是否存在</span></span><br><span class="line">        <span class="keyword">if</span>(src!= <span class="literal">null</span> &amp;&amp; src.exists() &amp;&amp; src.isDirectory())&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 2、目标目录需要创建一下  D:\new\resources</span></span><br><span class="line">            <span class="type">File</span> <span class="variable">destOne</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(dest , src.getName());</span><br><span class="line">            destOne.mkdirs(); <span class="comment">//创建多级</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3、提取原目录下的全部一级文件对象</span></span><br><span class="line">            File[] files = src.listFiles();</span><br><span class="line">            <span class="comment">// 4、判断是否存在一级文件对象</span></span><br><span class="line">            <span class="keyword">if</span>(files != <span class="literal">null</span> &amp;&amp; files.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 5、遍历一级文件对象</span></span><br><span class="line">                <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">                    <span class="comment">// 6、判断是文件还是文件夹，是文件直接复制过去</span></span><br><span class="line">                    <span class="keyword">if</span>(file.isFile())&#123;</span><br><span class="line">                        copyFile(file, <span class="keyword">new</span> <span class="title class_">File</span>(destOne , file.getName()));</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 7、当前遍历的是文件夹，递归复制</span></span><br><span class="line">                        copy(file, destOne);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copyFile</span><span class="params">(File srcFile, File destFile)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">// 1、创建一个字节输入流管道与原视频接通</span></span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcFile);</span><br><span class="line">                <span class="comment">// 2、创建一个字节输出流管道与目标文件接通</span></span><br><span class="line">                <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destFile);</span><br><span class="line">                ) &#123;</span><br><span class="line">            <span class="comment">// 3、定义一个字节数组转移数据</span></span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> len; <span class="comment">// 记录每次读取的字节数。</span></span><br><span class="line">            <span class="keyword">while</span> ((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                os.write(buffer, <span class="number">0</span> , len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-字符流的使用"><a href="#8-字符流的使用" class="headerlink" title="8.字符流的使用"></a>8.字符流的使用</h3><h4 id="8-1文件字符输入流"><a href="#8-1文件字符输入流" class="headerlink" title="8.1文件字符输入流"></a>8.1文件字符输入流</h4><p>1.字节流读取中文输出会存在什么问题？</p>
<ul>
<li><strong>会乱码。或者内存溢出。</strong></li>
</ul>
<p>2.读取中文输出，哪个流更合适，为什么？</p>
<ul>
<li><p><strong>字符流更合适，最小单位是按照单个字符读取的。</strong></p>
<p><strong>构造器  Reader</strong></p>
</li>
<li><p>作用：以内存为基准，把磁盘文件中的数据以字符的形式读取到内存中去。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public <strong>FileReader</strong>(File file)</td>
<td>创建字符输入流管道与源文件对象接通</td>
</tr>
<tr>
<td>public <strong>FileReader</strong>(String  pathname)</td>
<td>创建字符输入流管道与源文件路径接通</td>
</tr>
</tbody></table>
<h5 id="8-1-1一次读取一个字符"><a href="#8-1-1一次读取一个字符" class="headerlink" title="8.1.1一次读取一个字符"></a>8.1.1一次读取一个字符</h5><table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public int read()</td>
<td>每次读取一个字符返回，如果字符已经没有可读的返回-1</td>
</tr>
</tbody></table>
<p>1.字符流的好处。每次读取一个字符存在什么问题？</p>
<ul>
<li><p><strong>读取中文字符不会出现乱码（如果代码文件编码一致）</strong></p>
</li>
<li><p><strong>性能较慢</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     目标：字符输入流的使用。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		  读取文本文件内容到内存中去。</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">小结：</span></span><br><span class="line"><span class="comment">    字符流一个一个字符的读取文本内容输出，可以解决中文读取输出乱码的问题。</span></span><br><span class="line"><span class="comment">    字符流很适合操作文本文件内容。</span></span><br><span class="line"><span class="comment">    但是：一个一个字符的读取文本内容性能较差！！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileReaderDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 目标：每次读取一个字符。</span></span><br><span class="line">        <span class="comment">// 1、创建一个字符输入流管道与源文件接通</span></span><br><span class="line">        <span class="type">Reader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;file-io-app\\src\\data06.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、读取一个字符返回，没有可读的字符了返回-1</span></span><br><span class="line"><span class="comment">//        int code = fr.read();</span></span><br><span class="line"><span class="comment">//        System.out.print((char)code);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        int code1 = fr.read();</span></span><br><span class="line"><span class="comment">//        System.out.print((char)code1);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、使用循环读取字符</span></span><br><span class="line">        <span class="type">int</span> code;</span><br><span class="line">        <span class="keyword">while</span> ((code = fr.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print((<span class="type">char</span>) code);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="8-1-2文件字符输入流-一次读取一个字符数组"><a href="#8-1-2文件字符输入流-一次读取一个字符数组" class="headerlink" title="8.1.2文件字符输入流-一次读取一个字符数组"></a>8.1.2文件字符输入流-一次读取一个字符数组</h5><table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public int  read(char[] buffer)</td>
<td>每次读取一个字符数组，返回读取的字符数，如果字符已经没有可读的返回-1</td>
</tr>
</tbody></table>
<p>1.每次读取一个字符数组的优势？</p>
<ul>
<li><p><strong>读取的性能得到了提升</strong></p>
</li>
<li><p><strong>读取中文字符输出不会乱码。</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     目标：字符输入流的使用-按照字符数组读取。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		  读取文本文件内容到内存中去。</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">     小结：</span></span><br><span class="line"><span class="comment">         字符流按照字符数组循环读取数据，可以解决中文读取输出乱码的问题，而且性能也较好！！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileReaderDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建一个文件字符输入流与源文件接通</span></span><br><span class="line">        <span class="type">Reader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;file-io-app/src/data07.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、用循环，每次读取一个字符数组的数据。  1024 + 1024 + 8</span></span><br><span class="line">        <span class="type">char</span>[] buffer = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>]; <span class="comment">// 1K字符</span></span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = fr.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer, <span class="number">0</span>, len);</span><br><span class="line">            System.out.print(rs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-2文件字符输出流"><a href="#8-2文件字符输出流" class="headerlink" title="8.2文件字符输出流"></a>8.2文件字符输出流</h4><p><strong>构造器 FileWriter</strong></p>
<ul>
<li>作用：以内存为基准，把内存中的数据以字符的形式写出到磁盘文件中去的流。</li>
</ul>
<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public FileWriter(File file)</td>
<td>创建字符输出流管道与源文件对象接通</td>
</tr>
<tr>
<td>public FileWriter(File file，boolean append)</td>
<td>创建字符输出流管道与源文件对象接通，可追加数据</td>
</tr>
<tr>
<td>public FileWriter(String filepath)</td>
<td>创建字符输出流管道与源文件路径接通</td>
</tr>
<tr>
<td>public FileWriter(String filepath，boolean append)</td>
<td>创建字符输出流管道与源文件路径接通，可追加数据</td>
</tr>
</tbody></table>
<p><strong>（FileWriter）写数据出去的API</strong></p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void  write(int c)</td>
<td>写一个字符</td>
</tr>
<tr>
<td>void  write(char[] cbuf)</td>
<td>写入一个字符数组</td>
</tr>
<tr>
<td>void  write(char[] cbuf, int off, int len)</td>
<td>写入字符数组的一部分</td>
</tr>
<tr>
<td>void  write(String str)</td>
<td>写一个字符串</td>
</tr>
<tr>
<td>void  write(String str, int off, int len)</td>
<td>写一个字符串的一部分</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     目标：字符输出流的使用。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">	 作用：以内存为基准，把内存中的数据按照字符的形式写出到磁盘文件中去。</span></span><br><span class="line"><span class="comment">            </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     小结：</span></span><br><span class="line"><span class="comment">        字符输出流可以写字符数据出去，总共有5个方法写字符。</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">  覆盖管道：</span></span><br><span class="line"><span class="comment">             Writer fw = new FileWriter(&quot;Day10Demo/src/dlei03.txt&quot;); // 覆盖数据管道</span></span><br><span class="line"><span class="comment">        追加数据管道：</span></span><br><span class="line"><span class="comment">             Writer fw = new FileWriter(&quot;Day10Demo/src/dlei03.txt&quot;,true); // 追加数据管道</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">     换行：fw.write(&quot;\r\n&quot;); // 换行</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">     结论：读写字符文件数据建议使用字符流。复制文件建议使用字节流。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileWriterDemo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建一个字符输出流管道与目标文件接通</span></span><br><span class="line">        <span class="comment">// Writer fw = new FileWriter(&quot;file-io-app/src/out08.txt&quot;); // 覆盖管道，每次启动都会清空文件之前的数据</span></span><br><span class="line">        <span class="type">Writer</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;file-io-app/src/out08.txt&quot;</span>, <span class="literal">true</span>); <span class="comment">// 覆盖管道，每次启动都会清空文件之前的数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//      a.public void write(int c):写一个字符出去</span></span><br><span class="line">        fw.write(<span class="number">98</span>);</span><br><span class="line">        fw.write(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        fw.write(<span class="string">&#x27;徐&#x27;</span>); <span class="comment">// 不会出问题了</span></span><br><span class="line">        fw.write(<span class="string">&quot;\r\n&quot;</span>); <span class="comment">// 换行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//       b.public void write(String c)写一个字符串出去</span></span><br><span class="line">        fw.write(<span class="string">&quot;abc我是中国人&quot;</span>);</span><br><span class="line">        fw.write(<span class="string">&quot;\r\n&quot;</span>); <span class="comment">// 换行</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//       c.public void write(char[] buffer):写一个字符数组出去</span></span><br><span class="line">        <span class="type">char</span>[] chars = <span class="string">&quot;abc我是中国人&quot;</span>.toCharArray();</span><br><span class="line">        fw.write(chars);</span><br><span class="line">        fw.write(<span class="string">&quot;\r\n&quot;</span>); <span class="comment">// 换行</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//       d.public void write(String c ,int pos ,int len):写字符串的一部分出去</span></span><br><span class="line">        fw.write(<span class="string">&quot;abc我是中国人&quot;</span>, <span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">        fw.write(<span class="string">&quot;\r\n&quot;</span>); <span class="comment">// 换行</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//       e.public void write(char[] buffer ,int pos ,int len):写字符数组的一部分出去</span></span><br><span class="line">        fw.write(chars, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">        fw.write(<span class="string">&quot;\r\n&quot;</span>); <span class="comment">// 换行</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// fw.flush();// 刷新后流可以继续使用</span></span><br><span class="line">        fw.close(); <span class="comment">// 关闭包含刷线，关闭后流不能使用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>流的关闭与刷新 (同字节流)</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>flush()</td>
<td>刷新流，还可以继续写数据</td>
</tr>
<tr>
<td>close()</td>
<td>关闭流，释放资源，但是在关闭之前会先刷新流。一旦关闭，就不能再写数据</td>
</tr>
</tbody></table>
<p><strong>注意：</strong></p>
<p>1.字符输出流如何实现写出去的数据能换行</p>
<ul>
<li><strong>fw.write(“\r\n”)</strong></li>
</ul>
<p>2.字符输出流如何实现写出去的数据能换行</p>
<ul>
<li><p>flush()刷新数据</p>
</li>
<li><p>close()方法是关闭流，关闭包含刷新，关闭后流不可以继续使用了。</p>
</li>
</ul>
<p><strong>字节流、字符流如何选择使用？</strong></p>
<ul>
<li><p><strong>字节流适合做一切文件数据的拷贝（音视频，文本）</strong></p>
</li>
<li><p><strong>字节流不适合读取中文内容输出</strong></p>
</li>
<li><p><strong>你字符流适合做文本文件的操作（读，写）</strong></p>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://Liooser.github.io">Liooser</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://liooser.github.io/post/2edfce22.html">https://liooser.github.io/post/2edfce22.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://Liooser.github.io" target="_blank">Liooser's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6-File-%E9%80%92%E5%BD%92-IO/">java,面向对象进阶,File,递归,IO</a></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/Liooser/Liooser.github.io/main/images/index/b2.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/c0dc36c0.html"><img class="prev-cover" src="https://raw.githubusercontent.com/Liooser/Liooser.github.io/main/images/index/b4.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">day19 - Io二</div></div></a></div><div class="next-post pull-right"><a href="/post/ca240fc7.html"><img class="next-cover" src="https://raw.githubusercontent.com/Liooser/Liooser.github.io/main/images/index/b3.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">day17 - 日志框架、阶段项目</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://raw.githubusercontent.com/Liooser/Liooser.github.io/main/images/index/5.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Liooser</div><div class="author-info__description">潮落之后是潮起</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">39</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">33</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://haiyong.site/moyu/"><i class="iconfont icon-youxishoubing"></i><span>摸鱼</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://Liooser.github.io" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content"><b><font color="#e66b6d">双</font> <font color="#e66d98">手</font> <font color="#e66cc6">合</font> <font color="#cc6de6">十</font> <font color="#9770e6">成</font> <font color="#6d93e6">为</font> <font color="#6fcde6">自</font> <font color="#72e6b6">己</font> <font color="#72e689">的</font> <font color="#99e670">神</font>, <font color="#cde670">自</font> <font color="#e6df72">己</font> <font color="#e6c073">所</font> <font color="#e6a271">信</font> <font color="#e6796f">念</font> <font color="#e65454">的</font> <font color="#e63333">即</font> <font color="#e62c2c">是</font> <font color="#e60101">信</font> <font color="#e60101">仰</font></b> <p align="center"><img src="https://haiyong.site/img/img-blog.csdnimg.cn/f7384c88956d4378b72e47548e19c9f8.gif" width="50" alt="mao"></p></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-File%E7%B1%BB%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">1.File类概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-File%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8API"><span class="toc-number">2.</span> <span class="toc-text">2.File类的常用API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%88%A4%E6%96%AD%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E3%80%81%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E4%BF%A1%E6%81%AF"><span class="toc-number">2.1.</span> <span class="toc-text">1.判断文件类型、获取文件信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6%E3%80%81%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E5%8A%9F%E8%83%BD"><span class="toc-number">2.2.</span> <span class="toc-text">2.创建文件、删除文件功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%81%8D%E5%8E%86%E6%96%87%E4%BB%B6%E5%A4%B9"><span class="toc-number">2.3.</span> <span class="toc-text">3.遍历文件夹</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%96%B9%E6%B3%95%E9%80%92%E5%BD%92"><span class="toc-number">3.</span> <span class="toc-text">3.方法递归</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1%E9%80%92%E5%BD%92%E7%9A%84%E5%BD%A2%E5%BC%8F%E5%92%8C%E7%89%B9%E7%82%B9"><span class="toc-number">3.1.</span> <span class="toc-text">3.1递归的形式和特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2%E9%80%92%E5%BD%92%E7%9A%84%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B%E3%80%81%E6%A0%B8%E5%BF%83%E8%A6%81%E7%B4%A0"><span class="toc-number">3.2.</span> <span class="toc-text">3.2递归的算法流程、核心要素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3%E9%80%92%E5%BD%92%E5%B8%B8%E8%A7%81%E6%A1%88%E4%BE%8B"><span class="toc-number">3.3.</span> <span class="toc-text">3.3递归常见案例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4%E9%80%92%E5%BD%92%E7%9A%84%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98"><span class="toc-number">3.4.</span> <span class="toc-text">3.4递归的经典问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5%E9%9D%9E%E8%A7%84%E5%BE%8B%E5%8C%96%E9%80%92%E5%BD%92%E6%A1%88%E4%BE%8B-%E6%96%87%E4%BB%B6%E6%90%9C%E7%B4%A2"><span class="toc-number">3.5.</span> <span class="toc-text">3.5非规律化递归案例-文件搜索</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6%E9%9D%9E%E8%A7%84%E5%BE%8B%E5%8C%96%E9%80%92%E5%BD%92%E6%A1%88%E4%BE%8B-%E5%95%A4%E9%85%92%E9%97%AE%E9%A2%98"><span class="toc-number">3.6.</span> <span class="toc-text">3.6非规律化递归案例-啤酒问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%AD%97%E7%AC%A6%E9%9B%86"><span class="toc-number">4.</span> <span class="toc-text">4.字符集</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1%E5%B8%B8%E8%A7%81%E5%AD%97%E7%AC%A6%E9%9B%86%E4%BB%8B%E7%BB%8D"><span class="toc-number">4.1.</span> <span class="toc-text">4.1常见字符集介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2%E5%AD%97%E7%AC%A6%E9%9B%86%E7%9A%84%E7%BC%96%E7%A0%81%E3%80%81%E8%A7%A3%E7%A0%81%E6%93%8D%E4%BD%9C"><span class="toc-number">4.2.</span> <span class="toc-text">4.2字符集的编码、解码操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-IO%E6%B5%81%E6%A6%82%E8%BF%B0"><span class="toc-number">5.</span> <span class="toc-text">5.IO流概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%AD%97%E8%8A%82%E6%B5%81%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">6.</span> <span class="toc-text">6.字节流的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1%E6%96%87%E4%BB%B6%E5%AD%97%E8%8A%82%E8%BE%93%E5%85%A5%E6%B5%81%EF%BC%9AFileInputStream"><span class="toc-number">6.1.</span> <span class="toc-text">6.1文件字节输入流：FileInputStream</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6-1-1%E6%AF%8F%E6%AC%A1%E8%AF%BB%E5%8F%96%E4%B8%80%E4%B8%AA%E5%AD%97%E8%8A%82"><span class="toc-number">6.1.1.</span> <span class="toc-text">6.1.1每次读取一个字节</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-1-2%E6%AF%8F%E6%AC%A1%E8%AF%BB%E5%8F%96%E4%B8%80%E4%B8%AA%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84"><span class="toc-number">6.1.2.</span> <span class="toc-text">6.1.2每次读取一个字节数组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-1-3%E4%B8%80%E6%AC%A1%E8%AF%BB%E5%AE%8C%E5%85%A8%E9%83%A8%E5%AD%97%E8%8A%82"><span class="toc-number">6.1.3.</span> <span class="toc-text">6.1.3一次读完全部字节</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2%E6%96%87%E4%BB%B6%E5%AD%97%E8%8A%82%E8%BE%93%E5%87%BA%E6%B5%81%EF%BC%9AFileOutputStream"><span class="toc-number">6.2.</span> <span class="toc-text">6.2文件字节输出流：FileOutputStream</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3%E6%96%87%E4%BB%B6%E6%8B%B7%E8%B4%9D"><span class="toc-number">6.3.</span> <span class="toc-text">6.3文件拷贝</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E8%B5%84%E6%BA%90%E9%87%8A%E6%94%BE%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">7.</span> <span class="toc-text">7.资源释放的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1try-catch-finally"><span class="toc-number">7.1.</span> <span class="toc-text">7.1try-catch-finally</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2try-with-resource-%E6%94%B9%E8%BF%9B%E6%96%B9%E6%A1%88"><span class="toc-number">7.2.</span> <span class="toc-text">7.2try-with-resource(改进方案)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%AD%97%E7%AC%A6%E6%B5%81%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">8.</span> <span class="toc-text">8.字符流的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1%E6%96%87%E4%BB%B6%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E6%B5%81"><span class="toc-number">8.1.</span> <span class="toc-text">8.1文件字符输入流</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#8-1-1%E4%B8%80%E6%AC%A1%E8%AF%BB%E5%8F%96%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6"><span class="toc-number">8.1.1.</span> <span class="toc-text">8.1.1一次读取一个字符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-1-2%E6%96%87%E4%BB%B6%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E6%B5%81-%E4%B8%80%E6%AC%A1%E8%AF%BB%E5%8F%96%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84"><span class="toc-number">8.1.2.</span> <span class="toc-text">8.1.2文件字符输入流-一次读取一个字符数组</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2%E6%96%87%E4%BB%B6%E5%AD%97%E7%AC%A6%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-number">8.2.</span> <span class="toc-text">8.2文件字符输出流</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/61cdd72.html" title="数据库三级【运行维护与优化】"><img src="https://raw.githubusercontent.com/Liooser/Liooser.github.io/main/images/index/Database_level_3.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据库三级【运行维护与优化】"/></a><div class="content"><a class="title" href="/post/61cdd72.html" title="数据库三级【运行维护与优化】">数据库三级【运行维护与优化】</a><time datetime="2023-09-17T16:00:00.000Z" title="发表于 2023-09-18 00:00:00">2023-09-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/e570cd86.html" title="数据库三级【安全管理】"><img src="https://raw.githubusercontent.com/Liooser/Liooser.github.io/main/images/index/Database_level_3.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据库三级【安全管理】"/></a><div class="content"><a class="title" href="/post/e570cd86.html" title="数据库三级【安全管理】">数据库三级【安全管理】</a><time datetime="2023-09-16T16:00:00.000Z" title="发表于 2023-09-17 00:00:00">2023-09-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/24d51f4c.html" title="数据库三级【数据库及数据库对象】"><img src="https://raw.githubusercontent.com/Liooser/Liooser.github.io/main/images/index/Database_level_3.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据库三级【数据库及数据库对象】"/></a><div class="content"><a class="title" href="/post/24d51f4c.html" title="数据库三级【数据库及数据库对象】">数据库三级【数据库及数据库对象】</a><time datetime="2023-09-16T16:00:00.000Z" title="发表于 2023-09-17 00:00:00">2023-09-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/6699cf8.html" title="数据库三级【数据库后台编程技术】"><img src="https://raw.githubusercontent.com/Liooser/Liooser.github.io/main/images/index/Database_level_3.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据库三级【数据库后台编程技术】"/></a><div class="content"><a class="title" href="/post/6699cf8.html" title="数据库三级【数据库后台编程技术】">数据库三级【数据库后台编程技术】</a><time datetime="2023-09-14T16:00:00.000Z" title="发表于 2023-09-15 00:00:00">2023-09-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/d47651.html" title="常用工具类库"><img src="https://raw.githubusercontent.com/Liooser/Liooser.github.io/main/images/index/b7.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="常用工具类库"/></a><div class="content"><a class="title" href="/post/d47651.html" title="常用工具类库">常用工具类库</a><time datetime="2023-08-15T16:00:00.000Z" title="发表于 2023-08-16 00:00:00">2023-08-16</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Liooser</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="富强,民主,文明,和谐,自由,平等,公正,法治,爱国,敬业,诚信,友善" data-fontsize="15px" data-random="true" async="async"></script><script>(function(d, w, c) {
    w.ChatraID = 'SYuwBgxFrsHfNGEue';
    var s = d.createElement('script');
    w[c] = w[c] || function() {
        (w[c].q = w[c].q || []).push(arguments);
    };
    s.async = true;
    s.src = 'https://call.chatra.io/chatra.js';
    if (d.head) d.head.appendChild(s);
})(document, window, 'Chatra');

if (true) {
  var chatBtnFn = () => {
    var chatBtn = document.getElementById("chat_btn")
    chatBtn.addEventListener("click", function(){
      Chatra('openChat')
    });
  }
  chatBtnFn()
} else {
  if (true) {
    function chatBtnHide () {
      Chatra('hide')
    }
    function chatBtnShow () {
      Chatra('show')
    }
  }
}</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var qweather_key = 'b16a1fa0e63c46a4b8f28abfb06ae3fe';
  var gaud_map_key = 'e2b04289e870b005374ee030148d64fd&s=rsv3';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '112.982279,28.19409';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><!-- hexo injector body_end end --></body></html>