<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>day22 - 单元测试、反射、注解、动态代理 | Liooser's Blog</title><meta name="author" content="Liooser"><meta name="copyright" content="Liooser"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="1.单元测试1.1单元测试概述单元测试  单元测试就是针对最小的功能单元编写测试代码，Java程序最小的功能单元是方法，因此，单元测试就是针对Java方法的测试，进而检查方法的正确性。  目前测试方法是怎么进行的，存在什么问题  只有一个main方法，如果一个方法的测试失败了，其他方法测试会受到影响。  无法得到测试的结果报告，需要程序员自己去观察测试是否成功。  无法实现自动化测试。   Jun">
<meta property="og:type" content="article">
<meta property="og:title" content="day22 - 单元测试、反射、注解、动态代理">
<meta property="og:url" content="https://liooser.github.io/post/a44e5d86.html">
<meta property="og:site_name" content="Liooser&#39;s Blog">
<meta property="og:description" content="1.单元测试1.1单元测试概述单元测试  单元测试就是针对最小的功能单元编写测试代码，Java程序最小的功能单元是方法，因此，单元测试就是针对Java方法的测试，进而检查方法的正确性。  目前测试方法是怎么进行的，存在什么问题  只有一个main方法，如果一个方法的测试失败了，其他方法测试会受到影响。  无法得到测试的结果报告，需要程序员自己去观察测试是否成功。  无法实现自动化测试。   Jun">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/Liooser/Liooser.github.io/main/images/index/b4.jpg">
<meta property="article:published_time" content="2022-11-03T16:00:00.000Z">
<meta property="article:modified_time" content="2023-08-22T11:33:13.117Z">
<meta property="article:author" content="Liooser">
<meta property="article:tag" content="java,面向对象进阶,单元测试,反射,注解,动态代理">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/Liooser/Liooser.github.io/main/images/index/b4.jpg"><link rel="shortcut icon" href="https://raw.githubusercontent.com/Liooser/Liooser.github.io/main/images/index/a2.png"><link rel="canonical"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"top-right"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'day22 - 单元测试、反射、注解、动态代理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-08-22 19:33:13'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css" /><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://raw.githubusercontent.com/Liooser/Liooser.github.io/main/images/index/5.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">42</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">34</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/timeline/"><i class="fa-fw fa fa-bell"></i><span> 日志</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 菜单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about"><i class="fa-fw /about/"></i><span> 0</span></a></li><li><a class="site-page child" href="/myself"><i class="fa-fw /myself/"></i><span> 1</span></a></li><li><a class="site-page child" href="/butterfly"><i class="fa-fw https://github.com/jerryc127/hexo-theme-butterfly/"></i><span> 2</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://raw.githubusercontent.com/Liooser/Liooser.github.io/main/images/index/top_1.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Liooser's Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/timeline/"><i class="fa-fw fa fa-bell"></i><span> 日志</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 菜单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about"><i class="fa-fw /about/"></i><span> 0</span></a></li><li><a class="site-page child" href="/myself"><i class="fa-fw /myself/"></i><span> 1</span></a></li><li><a class="site-page child" href="/butterfly"><i class="fa-fw https://github.com/jerryc127/hexo-theme-butterfly/"></i><span> 2</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">day22 - 单元测试、反射、注解、动态代理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-11-03T16:00:00.000Z" title="发表于 2022-11-04 00:00:00">2022-11-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-08-22T11:33:13.117Z" title="更新于 2023-08-22 19:33:13">2023-08-22</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>36分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="day22 - 单元测试、反射、注解、动态代理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="1-单元测试"><a href="#1-单元测试" class="headerlink" title="1.单元测试"></a>1.单元测试</h3><h4 id="1-1单元测试概述"><a href="#1-1单元测试概述" class="headerlink" title="1.1单元测试概述"></a>1.1单元测试概述</h4><p><strong>单元测试</strong></p>
<ul>
<li>单元测试就是针对最小的功能单元编写测试代码，Java程序最小的功能单元是方法，因此，单元测试就是针对Java方法的测试，进而检查方法的正确性。</li>
</ul>
<p><strong>目前测试方法是怎么进行的，存在什么问题</strong></p>
<ul>
<li><p>只有一个main方法，如果一个方法的测试失败了，其他方法测试会受到影响。</p>
</li>
<li><p>无法得到测试的结果报告，需要程序员自己去观察测试是否成功。</p>
</li>
<li><p>无法实现自动化测试。</p>
</li>
</ul>
<p><strong>Junit单元测试框架</strong></p>
<ul>
<li><p>JUnit是使用Java语言实现的单元测试框架，它是开源的，Java开发者都应当学习并使用JUnit编写单元测试。</p>
</li>
<li><p>此外，几乎所有的IDE工具都集成了JUnit，这样我们就可以直接在IDE中编写并运行JUnit测试，JUnit目前最新版本是5。</p>
</li>
</ul>
<p><strong>JUnit优点</strong></p>
<ul>
<li><p>JUnit可以灵活的选择执行哪些测试方法，可以一键执行全部测试方法。</p>
</li>
<li><p>Junit可以生成全部方法的测试报告。</p>
</li>
<li><p>单元测试中的某个方法测试失败了，不会影响其他测试方法的测试。</p>
</li>
</ul>
<h4 id="1-2单元测试快速入门"><a href="#1-2单元测试快速入门" class="headerlink" title="1.2单元测试快速入门"></a>1.2单元测试快速入门</h4><p><strong>需求：</strong></p>
<p>使用单元测试进行业务方法预期结果、正确性测试的快速入门</p>
<p><strong>分析：</strong></p>
<ul>
<li><p>①将JUnit的jar包导入到项目中</p>
<ul>
<li>IDEA通常整合好了Junit框架，一般不需要导入。</li>
<li>如果IDEA没有整合好，需要自己手工导入如下2个JUnit的jar包到模块</li>
</ul>
</li>
<li><p>②编写测试方法：该测试方法必须是<strong>公共的无参数无返回值的非静态方法</strong>。</p>
</li>
<li><p>③在测试方法上<strong>使用@Test注解</strong>：标注该方法是一个测试方法</p>
</li>
<li><p>④在测试方法中完成被测试方法的预期正确性测试。</p>
</li>
<li><p>⑤选中测试方法，选择“JUnit运行” ，如果<strong>测试良好</strong>则是<strong>绿色</strong>；如果<strong>测试失败</strong>，则是<strong>红色</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   业务方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">loginName</span><span class="params">(String loginName , String passWord)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;admin&quot;</span>.equals(loginName) &amp;&amp; <span class="string">&quot;123456&quot;</span>.equals(passWord))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;登录成功&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;用户名或者密码有问题&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">selectNames</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="number">10</span>/<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;查询全部用户名称成功~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestUserService</span> &#123;</span><br><span class="line">    <span class="comment">// 修饰实例方法的</span></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===before方法执行一次===&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===after方法执行一次===&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修饰静态方法</span></span><br><span class="line">    <span class="meta">@BeforeClass</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">beforeClass</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===beforeClass方法执行一次===&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterClass</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">afterClass</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===afterClass方法执行一次===&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">       测试方法</span></span><br><span class="line"><span class="comment">       注意点：</span></span><br><span class="line"><span class="comment">            1、必须是公开的，无参数 无返回值的方法</span></span><br><span class="line"><span class="comment">            2、测试方法必须使用<span class="doctag">@Test</span>注解标记。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLoginName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//1.使用业务创建对象</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserService</span>(); </span><br><span class="line">        <span class="comment">//2.用对象调用需要测试的方法</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> userService.loginName(<span class="string">&quot;admin&quot;</span>,<span class="string">&quot;123456&quot;</span>); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进行预期结果的正确性测试：断言。</span></span><br><span class="line">        Assert.assertEquals(<span class="string">&quot;您的登录业务可能出现问题&quot;</span>, <span class="string">&quot;登录成功&quot;</span>, rs );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectNames</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserService</span>();</span><br><span class="line">        userService.selectNames();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-3单元测试常用注解"><a href="#1-3单元测试常用注解" class="headerlink" title="1.3单元测试常用注解"></a>1.3单元测试常用注解</h4><p><strong>Junit常用注解(Junit 4.xxxx版本)</strong></p>
<table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@Test</td>
<td>测试方法</td>
</tr>
<tr>
<td>@Before</td>
<td>用来修饰实例方法，该方法会在每一个测试方法执行之前执行一次。</td>
</tr>
<tr>
<td>@After</td>
<td>用来修饰实例方法，该方法会在每一个测试方法执行之后执行一次。</td>
</tr>
<tr>
<td>@BeforeClass</td>
<td>用来静态修饰方法，该方法会在所有测试方法之前只执行一次。</td>
</tr>
<tr>
<td>@AfterClass</td>
<td>用来静态修饰方法，该方法会在所有测试方法之后只执行一次。</td>
</tr>
</tbody></table>
<ul>
<li><p>开始执行的方法:初始化资源。</p>
</li>
<li><p>执行完之后的方法:释放资源。</p>
</li>
</ul>
<p><strong>Junit常用注解(Junit 5.xxxx版本)</strong></p>
<table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@Test</td>
<td>测试方法</td>
</tr>
<tr>
<td>@BeforeEach</td>
<td>用来修饰实例方法，该方法会在每一个测试方法执行之前执行一次。</td>
</tr>
<tr>
<td>@AfterEach</td>
<td>用来修饰实例方法，该方法会在每一个测试方法执行之后执行一次。</td>
</tr>
<tr>
<td>@BeforeAll</td>
<td>用来静态修饰方法，该方法会在所有测试方法之前只执行一次。</td>
</tr>
<tr>
<td>@AfterAll</td>
<td>用来静态修饰方法，该方法会在所有测试方法之后只执行一次。</td>
</tr>
</tbody></table>
<ul>
<li><p>开始执行的方法:初始化资源。</p>
</li>
<li><p>执行完之后的方法:释放资源。</p>
</li>
</ul>
<h3 id="2-反射"><a href="#2-反射" class="headerlink" title="2.反射"></a>2.反射</h3><h4 id="2-1反射概述"><a href="#2-1反射概述" class="headerlink" title="2.1反射概述"></a>2.1反射概述</h4><p><strong>反射概述</strong></p>
<ul>
<li><p>反射是指对于任何一个Class类，在”运行的时候”都可以直接得到这个类全部成分。</p>
</li>
<li><p>在运行时,可以直接得到这个类的构造器对象：Constructor</p>
</li>
<li><p>在运行时,可以直接得到这个类的成员变量对象：Field</p>
</li>
<li><p>在运行时,可以直接得到这个类的成员方法对象：Method</p>
</li>
<li><p>这种运行时动态获取类信息以及动态调用类中成分的能力称为Java语言的反射机制。</p>
</li>
</ul>
<p><strong>反射的关键：</strong></p>
<ul>
<li>反射的第一步都是先得到编译后的Class类对象，然后就可以得到Class的全部成分。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HelloWorld.java -&gt; javac -&gt; HelloWorld.class</span><br><span class="line">Class c = HelloWorld.class;</span><br></pre></td></tr></table></figure>

<h4 id="2-2反射获取类对象"><a href="#2-2反射获取类对象" class="headerlink" title="2.2反射获取类对象"></a>2.2反射获取类对象</h4><p><strong>获取Class类的对象的三种方法</strong></p>
<p><strong>使用对象的getClass()方法</strong>：如果已经有一个对象，可以使用该对象的getClass()方法来获取它的Class类对象。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javaCopy <span class="type">codeMyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">Class&lt;?&gt; clazz = obj.getClass();</span><br></pre></td></tr></table></figure>

<p><strong>使用类的.class属性</strong>：每个类都有一个特殊的属性，通过在类名后面加上”.class”来获取该类的Class类对象。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javaCopy code</span><br><span class="line">Class&lt;?&gt; clazz = MyClass.class;</span><br></pre></td></tr></table></figure>

<p><strong>使用Class类的forName()方法</strong>：可以通过提供类的全限定名（包括包名）来使用Class类的forName()方法来获取Class类对象。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javaCopy code</span><br><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.example.MyClass&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个学生类</span></span><br><span class="line"><span class="keyword">package</span> com.itheima.d2_reflect_class;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   目标：反射的第一步：获取学生类的Class对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、Class类中的一个静态方法：forName(全限名：包名 + 类名)</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.itheima.d2_reflect_class.Student&quot;</span>);</span><br><span class="line">        System.out.println(c); <span class="comment">// Student.class</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、类名.class (常用)</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> Student.class;</span><br><span class="line">        System.out.println(c1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、对象.getClass() 获取对象对应类的Class对象。</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        <span class="type">Class</span> <span class="variable">c2</span> <span class="operator">=</span> s.getClass();</span><br><span class="line">        System.out.println(c2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3反射获取构造器对象"><a href="#2-3反射获取构造器对象" class="headerlink" title="2.3反射获取构造器对象"></a>2.3反射获取构造器对象</h4><p><strong>使用反射技术获取构造器对象并使用</strong></p>
<p>反射是一种在运行时检查、访问和操作类、接口、字段、方法等程序元素的能力。在Java中，您可以使用反射技术来获取构造器对象并使用它来创建新的实例。下面是一个使用反射获取构造器对象并创建实例的示例：</p>
<p>假设有一个类 <code>Person</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javaCopy codepublic <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">introduce</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, I&#x27;m &quot;</span> + name + <span class="string">&quot; and I&#x27;m &quot;</span> + age + <span class="string">&quot; years old.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用以下代码来使用反射获取构造器对象并创建 <code>Person</code> 类的实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javaCopy code<span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectionExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取Person类的Class对象</span></span><br><span class="line">        Class&lt;Person&gt; personClass = Person.class;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取带有两个参数的构造器</span></span><br><span class="line">        Constructor&lt;Person&gt; constructor = personClass.getConstructor(String.class, <span class="type">int</span>.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用构造器创建实例</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> constructor.newInstance(<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用实例方法</span></span><br><span class="line">        person.introduce();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用反射技术获取构造器对象并使用</strong></p>
<ul>
<li><p>反射的第一步是先得到类对象，然后从类对象中获取类的成分对象。</p>
</li>
<li><p>Class类中用于获取构造器的方法</p>
</li>
<li><p>获取构造器的作用依然是初始化一个对象返回。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Constructor&lt;?&gt;[]  <strong>getConstructors</strong>()</td>
<td>返回<strong>所有 public</strong> 修饰的构造器对象的数组</td>
</tr>
<tr>
<td>Constructor&lt;?&gt;[]  <strong>getDeclaredConstructors</strong>()</td>
<td>返回<strong>所有构造器对象</strong>的数组，存在就能拿到</td>
</tr>
<tr>
<td>Constructor<T>  <strong>getConstructor</strong>(Class&lt;?&gt;…  parameterTypes)</td>
<td>返回<strong>单个 public</strong> 修饰构造器对象</td>
</tr>
<tr>
<td>Constructor<T>  <strong>getDeclaredConstructor</strong>(Class&lt;?&gt;…  parameterTypes)</td>
<td>返回<strong>单个构造器对象</strong>，存在就能拿到</td>
</tr>
</tbody></table>
<p><strong>Constructor类中用于创建对象的方法</strong></p>
<table>
<thead>
<tr>
<th>符号</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>T <strong>newInstance</strong>(Object…  initargs)</td>
<td>根据指定的构造器创建对象</td>
</tr>
<tr>
<td>public  void <strong>setAccessible</strong>(boolean  flag)</td>
<td>设置为true,表示取消访问检查，进行暴力反射</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个学生类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Student</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;无参数构造器执行！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;有参数构造器执行！&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>获取<Constructor>构造器对象</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：反射_获取&lt;Constructor&gt;构造器对象.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    反射的第一步是先得到Class类对象。（Class文件）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">小结：</span></span><br><span class="line"><span class="comment">        2获取类的全部构造器对象： Constructor[] getDeclaredConstructors()</span></span><br><span class="line"><span class="comment">            -- 获取所有申明的构造器，只要你写我就能拿到，无所谓权限。建议使用！</span></span><br><span class="line"><span class="comment">        4获取类的某个构造器对象：Constructor getDeclaredConstructor(Class... parameterTypes)</span></span><br><span class="line"><span class="comment">            -- 根据参数匹配获取某个构造器，只要申明就可以定位，不关心权限修饰符，建议使用！</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStudent01</span> &#123;</span><br><span class="line">    <span class="comment">// 1. getConstructors</span></span><br><span class="line">    <span class="comment">//获取全部的构造器：只能获取public修饰的构造器。</span></span><br><span class="line">    <span class="comment">// Constructor[] - getConstructors()</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getConstructors</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// a.第一步：获取类对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Student.class;</span><br><span class="line">        <span class="comment">// b.提取类中的全部的构造器对象(这里只能拿public修饰)</span></span><br><span class="line">        Constructor[] constructors = c.getConstructors();</span><br><span class="line">        <span class="comment">// c.遍历构造器</span></span><br><span class="line">        <span class="keyword">for</span> (Constructor constructor : constructors) &#123;</span><br><span class="line">            System.out.println(constructor.getName() + <span class="string">&quot;===&gt;&quot;</span> + constructor.getParameterCount());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.getDeclaredConstructors():</span></span><br><span class="line">    <span class="comment">// 获取全部的构造器数组：只要你敢写，这里就能拿到，无所谓权限是否可及。</span></span><br><span class="line">    <span class="comment">//Constructor[] - getDeclaredConstructors()</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getDeclaredConstructors</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// a.第一步：获取类对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Student.class;</span><br><span class="line">        <span class="comment">// b.提取类中的全部的构造器对象</span></span><br><span class="line">        Constructor[] constructors = c.getDeclaredConstructors();</span><br><span class="line">        <span class="comment">// c.遍历构造器</span></span><br><span class="line">        <span class="keyword">for</span> (Constructor constructor : constructors) &#123;</span><br><span class="line">            System.out.println(constructor.getName() + <span class="string">&quot;===&gt;&quot;</span> + constructor.getParameterCount());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.getConstructor(Class... parameterTypes)</span></span><br><span class="line">    <span class="comment">// 获取某个构造器：只能拿public修饰的某个构造器</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getConstructor</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// a.第一步：获取类对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Student.class;</span><br><span class="line">        <span class="comment">// b.定位单个构造器对象 (按照参数定位无参数构造器 只能拿public修饰的某个构造器)</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">cons</span> <span class="operator">=</span> c.getConstructor();</span><br><span class="line">        System.out.println(cons.getName() + <span class="string">&quot;===&gt;&quot;</span> + cons.getParameterCount());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.getConstructor(Class... parameterTypes)</span></span><br><span class="line">    <span class="comment">// 获取某个构造器：只要你敢写，这里就能拿到，无所谓权限是否可及。</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getDeclaredConstructor</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// a.第一步：获取类对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Student.class;</span><br><span class="line">        <span class="comment">// b.定位单个构造器对象 (按照参数定位无参数构造器)</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">cons</span> <span class="operator">=</span> c.getDeclaredConstructor();</span><br><span class="line">        System.out.println(cons.getName() + <span class="string">&quot;===&gt;&quot;</span> + cons.getParameterCount());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// c.定位某个有参构造器</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">cons1</span> <span class="operator">=</span> c.getDeclaredConstructor(String.class, <span class="type">int</span>.class);</span><br><span class="line">        System.out.println(cons1.getName() + <span class="string">&quot;===&gt;&quot;</span> + cons1.getParameterCount());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><Constructor>构造器初始化对象</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标: 反射_获取Constructor构造器然后通过这个构造器初始化对象。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    反射获取Class中的构造器对象Constructor作用：</span></span><br><span class="line"><span class="comment">            也是初始化并得到类的一个对象返回。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Constructor的API:</span></span><br><span class="line"><span class="comment">         1. T newInstance(Object... initargs)</span></span><br><span class="line"><span class="comment">                创建对象，注入构造器需要的数据。</span></span><br><span class="line"><span class="comment">         2. void setAccessible(true)</span></span><br><span class="line"><span class="comment">                修改访问权限，true代表暴力攻破权限，false表示保留不可访问权限(暴力反射)</span></span><br><span class="line"><span class="comment">    小结：</span></span><br><span class="line"><span class="comment">        可以通过定位类的构造器对象。</span></span><br><span class="line"><span class="comment">        如果构造器对象没有访问权限可以通过：void setAccessible(true)打开权限</span></span><br><span class="line"><span class="comment">        构造器可以通过T newInstance(Object... initargs)调用自己，传入参数！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStudent02</span> &#123;</span><br><span class="line">    <span class="comment">// 1.调用构造器得到一个类的对象返回。</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getDeclaredConstructor</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// a.第一步：获取类对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Student.class;</span><br><span class="line">        <span class="comment">// b.定位单个构造器对象 </span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">cons</span> <span class="operator">=</span> c.getDeclaredConstructor(); <span class="comment">//按照参数定位无参数构造器</span></span><br><span class="line">        System.out.println(cons.getName() + <span class="string">&quot;===&gt;&quot;</span> + cons.getParameterCount());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果遇到了私有的构造器，可以暴力反射</span></span><br><span class="line">        cons.setAccessible(<span class="literal">true</span>); <span class="comment">// 权限被打开</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> (Student) cons.newInstance(); <span class="comment">//创建无参构造器对象</span></span><br><span class="line">        System.out.println(s);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// c.定位某个有参构造器</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">cons1</span> <span class="operator">=</span> c.getDeclaredConstructor(String.class, <span class="type">int</span>.class); <span class="comment">//按照参数定位有参构造器</span></span><br><span class="line">        System.out.println(cons1.getName() + <span class="string">&quot;===&gt;&quot;</span> + cons1.getParameterCount());</span><br><span class="line"></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> (Student) cons1.newInstance(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">1000</span>); <span class="comment">//创建有参构造器对象</span></span><br><span class="line">        System.out.println(s1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-4反射获取成员变量对象"><a href="#2-4反射获取成员变量对象" class="headerlink" title="2.4反射获取成员变量对象"></a>2.4反射获取成员变量对象</h4><p><strong>使用反射技术获取成员变量对象并使用</strong></p>
<p>假设有一个名为<code>Person</code>的类，其中包含一个成员变量<code>name</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javaCopy codepublic <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用反射来获取并操作<code>Person</code>类的成员变量<code>name</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javaCopy code<span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectionExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line">        <span class="comment">// 创建一个Person对象</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取Person类的Class对象</span></span><br><span class="line">        Class&lt;Person&gt; personClass = Person.class;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取名为 &quot;name&quot; 的成员变量</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">nameField</span> <span class="operator">=</span> personClass.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置允许访问私有字段</span></span><br><span class="line">        nameField.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取字段的值</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">nameValue</span> <span class="operator">=</span> (String) nameField.get(person);</span><br><span class="line">            System.out.println(<span class="string">&quot;Original Name: &quot;</span> + nameValue);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 修改字段的值</span></span><br><span class="line">            nameField.set(person, <span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">newNameValue</span> <span class="operator">=</span> (String) nameField.get(person);</span><br><span class="line">            System.out.println(<span class="string">&quot;New Name: &quot;</span> + newNameValue);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用反射技术获取成员变量对象并使用</strong></p>
<ul>
<li><p>反射的第一步是先得到类对象，然后从类对象中获取类的成分对象。</p>
</li>
<li><p>Class类中用于获取成员变量的方法</p>
</li>
<li><p>获取成员变量的作用依然是在某个对象中取值、赋值</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Field[]  <strong>getFields</strong>()</td>
<td>返回所有成员变量对象的数组（只能拿public的）</td>
</tr>
<tr>
<td>Field[]  <strong>getDeclaredFields</strong>()</td>
<td>返回所有成员变量对象的数组，存在就能拿到</td>
</tr>
<tr>
<td>Field  <strong>getField</strong>(String  name)</td>
<td>返回单个成员变量对象（只能拿public的）</td>
</tr>
<tr>
<td>Field  <strong>getDeclaredField</strong>(String  name)</td>
<td>返回单个成员变量对象，存在就能拿到</td>
</tr>
</tbody></table>
<p><strong>Field类中用于取值、赋值的方法</strong></p>
<table>
<thead>
<tr>
<th>符号</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void  <strong>set</strong>(Object obj, Object value)：</td>
<td>赋值</td>
</tr>
<tr>
<td>Object  <strong>get</strong>(Object obj)</td>
<td>获取值。</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个学生类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name; </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String schoolName;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">COUNTTRY</span> <span class="operator">=</span> <span class="string">&quot;中国&quot;</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;无参数构造器执行！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;有参数构造器执行！&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>获取<Field>成员变量对象</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     目标：反射_获取Field成员变量对象。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     反射的第一步是先得到Class类对象。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     1、Field getField(String name);</span></span><br><span class="line"><span class="comment">            根据成员变量名获得对应Field对象，只能获得public修饰</span></span><br><span class="line"><span class="comment">     2.Field getDeclaredField(String name);</span></span><br><span class="line"><span class="comment">            根据成员变量名获得对应Field对象，只要申明了就可以得到</span></span><br><span class="line"><span class="comment">     3.Field[] getFields();</span></span><br><span class="line"><span class="comment">            获得所有的成员变量对应的Field对象，只能获得public的</span></span><br><span class="line"><span class="comment">     4.Field[] getDeclaredFields();</span></span><br><span class="line"><span class="comment">            获得所有的成员变量对应的Field对象，只要申明了就可以得到</span></span><br><span class="line"><span class="comment">     小结：</span></span><br><span class="line"><span class="comment">        获取全部成员变量：getDeclaredFields</span></span><br><span class="line"><span class="comment">        获取某个成员变量：getDeclaredField</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FieldDemo01</span> &#123;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">//1.获取全部的成员变量。</span></span><br><span class="line">     <span class="comment">//Field[] - getDeclaredFields();</span></span><br><span class="line">     <span class="comment">//获得所有的成员变量对应的Field对象，只要申明了就可以得到</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getDeclaredFields</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// a.定位Class对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Student.class;</span><br><span class="line">        <span class="comment">// b.定位全部成员变量</span></span><br><span class="line">        Field[] fields = c.getDeclaredFields();</span><br><span class="line">        <span class="comment">// c.遍历一下</span></span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            System.out.println(field.getName() + <span class="string">&quot;==&gt;&quot;</span> + field.getType());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">———————————————————————————————————————————————————————————————————————————————————————————————————————————— </span><br><span class="line">    </span><br><span class="line">        <span class="comment">//2.获取某个成员变量对象</span></span><br><span class="line">        <span class="comment">//Field - getDeclaredField(String name);</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getDeclaredField</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// a.定位Class对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Student.class;</span><br><span class="line">        <span class="comment">// b.根据名称定位某个成员变量</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">        System.out.println(f.getName() +<span class="string">&quot;===&gt;&quot;</span> + f.getType());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><Field>成员变量对象赋值</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：反射获取成员变量: 取值和赋值。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Field的方法：给成员变量赋值和取值</span></span><br><span class="line"><span class="comment">        void set(Object obj, Object value)：给对象注入某个成员变量数据</span></span><br><span class="line"><span class="comment">        Object get(Object obj):获取对象的成员变量的值。</span></span><br><span class="line"><span class="comment">        void setAccessible(true);暴力反射，设置为可以直接访问私有类型的属性。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FieldDemo02</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setField</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// a.反射第一步，获取类对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Student.class;</span><br><span class="line">        <span class="comment">// b.提取某个成员变量</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">ageF</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ageF.setAccessible(<span class="literal">true</span>); <span class="comment">// 暴力打开权限</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// c.赋值</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        ageF.set(s , <span class="number">18</span>);  <span class="comment">// s.setAge(18);</span></span><br><span class="line">        System.out.println(s);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// d、取值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> (<span class="type">int</span>) ageF.get(s);</span><br><span class="line">        System.out.println(age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-5反射获取方法对象"><a href="#2-5反射获取方法对象" class="headerlink" title="2.5反射获取方法对象"></a>2.5反射获取方法对象</h4><p><strong>使用反射技术获取方法对象并使用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectionExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Class&lt;?&gt; targetClass = Class.forName(<span class="string">&quot;com.example.TargetClass&quot;</span>); <span class="comment">// 替换成目标类名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> <span class="string">&quot;methodName&quot;</span>; <span class="comment">// 替换成方法名</span></span><br><span class="line">        Class&lt;?&gt;[] parameterTypes = &#123;String.class, <span class="type">int</span>.class&#125;; <span class="comment">// 替换成参数类型</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> targetClass.getDeclaredMethod(methodName, parameterTypes);</span><br><span class="line">        method.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> targetClass.getDeclaredConstructor().newInstance();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(instance, <span class="string">&quot;argument1&quot;</span>, <span class="number">42</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Result: &quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用反射技术获取方法对象并使用</strong></p>
<ul>
<li><p>反射的第一步是先得到类对象，然后从类对象中获取类的成分对象。</p>
</li>
<li><p>Class类中用于获取成员方法的方法</p>
</li>
<li><p>获取成员方法的作用依然是在某个对象中进行执行此方法</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Method[]  <strong>getMethods</strong>()</td>
<td>返回所有成员方法对象的数组（只能拿public的）</td>
</tr>
<tr>
<td>Method[]  <strong>getDeclaredMethods</strong>()</td>
<td>返回所有成员方法对象的数组，存在就能拿到</td>
</tr>
<tr>
<td>Method  <strong>getMethod</strong>(String  name, Class&lt;?&gt;… parameterTypes)</td>
<td>返回单个成员方法对象（只能拿public的）</td>
</tr>
<tr>
<td>Method  <strong>getDeclaredMethod</strong>(String  name, Class&lt;?&gt;… parameterTypes)</td>
<td>返回单个成员方法对象，存在就能拿到</td>
</tr>
</tbody></table>
<p><strong>Method类中用于触发执行的方法</strong></p>
<table>
<thead>
<tr>
<th>符号</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Object <strong>invoke</strong>(Object obj, Object… args)</td>
<td>运行方法                                                                                                                                                                             参数一：<strong>用obj对象调用该方法</strong>                                                                                                                                           参数二：<strong>调用方法传递的参数</strong>（如果没有就不写）                                                                                                               返回值：<strong>方法的返回值</strong>（如果没有就不写）</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个dog类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name ;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗跑的贼快~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗吃骨头&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">eat</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗吃&quot;</span> + name);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;吃的很开心！&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">inAddr</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;在黑马学习Java!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>获取<Method>方法对象</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：反射——获取Method方法对象</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    反射获取类的Method方法对象：</span></span><br><span class="line"><span class="comment">         1、Method getMethod(String name,Class...args);</span></span><br><span class="line"><span class="comment">             根据方法名和参数类型获得对应的方法对象，只能获得public的</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         2、Method getDeclaredMethod(String name,Class...args);</span></span><br><span class="line"><span class="comment">             根据方法名和参数类型获得对应的方法对象，包括private的</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         3、Method[] getMethods();</span></span><br><span class="line"><span class="comment">             获得类中的所有成员方法对象，返回数组，只能获得public修饰的且包含父类的</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         4、Method[] getDeclaredMethods();</span></span><br><span class="line"><span class="comment">            获得类中的所有成员方法对象，返回数组,只获得本类申明的方法。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Method的方法执行：</span></span><br><span class="line"><span class="comment">        Object invoke(Object obj, Object... args)</span></span><br><span class="line"><span class="comment">          参数一：触发的是哪个对象的方法执行。</span></span><br><span class="line"><span class="comment">          参数二： args：调用方法时传递的实际参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodDemo01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.获得类中的所有成员方法对象</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getDeclaredMethods</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// a.获取类对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Dog.class;</span><br><span class="line">        <span class="comment">// b.提取全部方法；包括私有的</span></span><br><span class="line">        Method[] methods = c.getDeclaredMethods();</span><br><span class="line">        <span class="comment">// c.遍历全部方法</span></span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            System.out.println(method.getName() +<span class="string">&quot; 返回值类型：&quot;</span> + method.getReturnType() + <span class="string">&quot; 参数个数：&quot;</span> + method.getParameterCount());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   ————————————————————————————————————————————————————————————————————————————————————————————————————————————</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2. 获取某个方法对象</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getDeclardMethod</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// a.获取类对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Dog.class;</span><br><span class="line">        <span class="comment">// b.提取单个方法对象</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> c.getDeclaredMethod(<span class="string">&quot;eat&quot;</span>); <span class="comment">//方法名</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">m2</span> <span class="operator">=</span> c.getDeclaredMethod(<span class="string">&quot;eat&quot;</span>, String.class); <span class="comment">//方法名，传入参数类型</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 暴力打开权限了</span></span><br><span class="line">        m.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        m2.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// c.触发方法的执行</span></span><br><span class="line">        <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="comment">// 注意：方法如果是没有结果回来的，那么返回的是null.</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> m.invoke(d);</span><br><span class="line">        System.out.println(result);</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result2</span> <span class="operator">=</span> m2.invoke(d, <span class="string">&quot;骨头&quot;</span>); <span class="comment">//对象，传入参数</span></span><br><span class="line">        System.out.println(result2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-6反射的作用-绕过编译阶段为集合添加数据"><a href="#2-6反射的作用-绕过编译阶段为集合添加数据" class="headerlink" title="2.6反射的作用-绕过编译阶段为集合添加数据"></a>2.6反射的作用-绕过编译阶段为集合添加数据</h4><p><strong>反射的作用-绕过编译阶段为集合添加数据</strong></p>
<ul>
<li>反射是作用在运行时的技术，此时集合的泛型将不能产生约束了，此时是可以为集合存入其他任意类型的元素的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="number">100</span>);</span><br><span class="line"><span class="comment">// list.add(“黑马&quot;); // 报错</span></span><br><span class="line">list.add(<span class="number">99</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>泛型只是在编译阶段可以约束集合只能操作某种数据类型，在编译成Class文件进入运行阶段的时候，其真实类型都是ArrayList了，泛型相当于被擦除了。</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 需求：反射实现泛型擦除后，加入其他类型的元素</span></span><br><span class="line">        ArrayList&lt;String&gt; lists1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; lists2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        System.out.println(lists1.getClass());</span><br><span class="line">        System.out.println(lists2.getClass());</span><br><span class="line"></span><br><span class="line">        System.out.println(lists1.getClass() ==  lists2.getClass());  <span class="comment">// 运行阶段的，泛型将不存在，其真实类型都是ArrayList，都具有相同地址</span></span><br><span class="line"></span><br><span class="line">————————————————————————————————————————————————————————————————————————————————————————————————————————————</span><br><span class="line">    </span><br><span class="line">        ArrayList&lt;Integer&gt; lists3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        lists3.add(<span class="number">23</span>); </span><br><span class="line">        lists3.add(<span class="number">22</span>);</span><br><span class="line">        <span class="comment">// lists3.add(&quot;黑马&quot;); //此时不能添加String类型</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//a.获取lists3集合类的对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> lists3.getClass(); <span class="comment">// ArrayList.class  ===&gt; public boolean add(E e)</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//b.定位c类中的add方法</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">add</span> <span class="operator">=</span> c.getDeclaredMethod(<span class="string">&quot;add&quot;</span>, Object.class);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//c.调用invoke触发执行的方法,执行add添加内容</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">rs</span> <span class="operator">=</span> (<span class="type">boolean</span>) add.invoke(lists3, <span class="string">&quot;黑马&quot;</span>);</span><br><span class="line">        System.out.println(rs);</span><br><span class="line"></span><br><span class="line">        System.out.println(lists3);</span><br><span class="line"></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">list4</span> <span class="operator">=</span> lists3;</span><br><span class="line">        list4.add(<span class="string">&quot;白马&quot;</span>);</span><br><span class="line">        list4.add(<span class="literal">false</span>);</span><br><span class="line">        System.out.println(lists3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-7反射的作用-通用框架的底层原理"><a href="#2-7反射的作用-通用框架的底层原理" class="headerlink" title="2.7反射的作用-通用框架的底层原理"></a>2.7反射的作用-通用框架的底层原理</h4><p><strong>反射做通用框架</strong></p>
<p><strong>需求：</strong></p>
<p>给你任意一个对象，在不清楚对象字段的情况可以，可以把对象的字段名称和对应值存储到文件中去。</p>
<p><strong>需求</strong></p>
<ul>
<li>给你任意一个对象，在不清楚对象字段的情况可以，可以把对象的字段名称和对应值存储到文件中去。</li>
</ul>
<p><strong>分析</strong></p>
<p>①定义一个方法，可以接收任意类的对象。</p>
<p>②每次收到一个对象后，需要解析这个对象的全部成员变量名称。</p>
<p>③这个对象可能是任意的，那么怎么样才可以知道这个对象的全部成员变量名称呢？</p>
<p>④使用反射获取对象的Class类对象，然后获取全部成员变量信息。</p>
<p>⑤遍历成员变量信息，然后提取本成员变量在对象中的具体值</p>
<p>⑥存入成员变量名称和值到文件中去即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建学生类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span> sex;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String className;</span><br><span class="line">    <span class="keyword">private</span> String hobby;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">char</span> sex, <span class="type">int</span> age, String className, String hobby)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.className = className;</span><br><span class="line">        <span class="built_in">this</span>.hobby = hobby;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">getSex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSex</span><span class="params">(<span class="type">char</span> sex)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getClassName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> className;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setClassName</span><span class="params">(String className)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.className = className;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getHobby</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> hobby;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHobby</span><span class="params">(String hobby)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.hobby = hobby;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建老师类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span> sex;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> salary;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Teacher</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Teacher</span><span class="params">(String name, <span class="type">char</span> sex, <span class="type">double</span> salary)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">        <span class="built_in">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">getSex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSex</span><span class="params">(<span class="type">char</span> sex)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getSalary</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSalary</span><span class="params">(<span class="type">double</span> salary)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    创建save方法 </span></span><br><span class="line"><span class="comment">    保存任意类型的对象到文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;junit-reflect-annotation-proxy-app/src/data.txt&quot;</span>, <span class="literal">true</span>));</span><br><span class="line">        )&#123;</span><br><span class="line">            <span class="comment">// 1、提取这个对象的全部成员变量：只有反射可以解决</span></span><br><span class="line">            <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> obj.getClass();  </span><br><span class="line">            <span class="comment">// c.getSimpleName()获取当前类名   c.getName获取全限名：包名+类名</span></span><br><span class="line">            ps.println(<span class="string">&quot;================&quot;</span> + c.getSimpleName() + <span class="string">&quot;================&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2、提取它的全部成员变量</span></span><br><span class="line">            Field[] fields = c.getDeclaredFields(); </span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 3、遍历 获取成员变量的信息</span></span><br><span class="line">            <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> field.getName();</span><br><span class="line">                <span class="comment">// 提取本成员变量在obj对象中的值（取值）</span></span><br><span class="line">                field.setAccessible(<span class="literal">true</span>); <span class="comment">//暴力反射</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> field.get(obj) + <span class="string">&quot;&quot;</span>;</span><br><span class="line">                ps.println(name  + <span class="string">&quot;=&quot;</span> + value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   目标：提供一个通用框架，支持保存所有对象的具体信息。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        s.setName(<span class="string">&quot;猪八戒&quot;</span>);</span><br><span class="line">        s.setClassName(<span class="string">&quot;西天跑路1班&quot;</span>);</span><br><span class="line">        s.setAge(<span class="number">1000</span>);</span><br><span class="line">        s.setHobby(<span class="string">&quot;吃，睡&quot;</span>);</span><br><span class="line">        s.setSex(<span class="string">&#x27;男&#x27;</span>);</span><br><span class="line">        MybatisUtil.save(s);</span><br><span class="line"></span><br><span class="line">        <span class="type">Teacher</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>();</span><br><span class="line">        t.setName(<span class="string">&quot;波仔&quot;</span>);</span><br><span class="line">        t.setSex(<span class="string">&#x27;男&#x27;</span>);</span><br><span class="line">        t.setSalary(<span class="number">6000</span>);</span><br><span class="line">        MybatisUtil.save(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-注解"><a href="#3-注解" class="headerlink" title="3.注解"></a>3.注解</h3><h4 id="3-1注解概述"><a href="#3-1注解概述" class="headerlink" title="3.1注解概述"></a>3.1注解概述</h4><p><strong>注解概述、作用</strong></p>
<ul>
<li><p>Java 注解（Annotation）又称 Java 标注，是 JDK5.0 引入的一种注释机制。</p>
</li>
<li><p>Java 语言中的类、构造器、方法、成员变量、参数等都可以被注解进行标注。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceTest</span> &#123;</span><br><span class="line">	<span class="meta">@Test</span> <span class="comment">//注解（Annotation）</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLogin</span><span class="params">()</span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="meta">@Test</span> <span class="comment">//注解（Annotation）</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testChu</span><span class="params">()</span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解的作用是什么呢？</strong></p>
<ul>
<li><p>对Java中类、方法、成员变量做<strong>标记，然后进行特殊处理</strong>，至于到底做何种处理由业务需求来决定。</p>
</li>
<li><p>例如：JUnit框架中，标记了注解@Test的方法就可以被当成测试方法执行，而没有标记的就不能当成测试方法执行。</p>
</li>
</ul>
<h4 id="3-2自定义注解"><a href="#3-2自定义注解" class="headerlink" title="3.2自定义注解"></a>3.2自定义注解</h4><p><strong>自定义注解</strong> <strong>—</strong> <strong>格式</strong></p>
<ul>
<li>自定义注解就是自己做一个注解来使用。</li>
</ul>
<p>属性类型：Java支持的数据类型基本上都支持</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> 注解名称 &#123; <span class="comment">// @interface为自定义注解</span></span><br><span class="line">	<span class="keyword">public</span>(可省略) 属性类型 属性名() <span class="keyword">default</span> 默认值 ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>特殊属性</strong></p>
<ul>
<li><p>value属性，如果只有一个value属性的情况下，使用value属性的时候可以省略value名称不写!!</p>
</li>
<li><p>但是如果有多个属性, 且多个属性没有默认值，那么value名称是不能省略的。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Book &#123;  <span class="comment">// @interface注解标识</span></span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>; <span class="comment">// 特殊属性</span></span><br><span class="line">    <span class="type">double</span> <span class="title function_">price</span><span class="params">()</span> ;</span><br><span class="line">    <span class="comment">//double price() default 9.9; // 默认值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   目标：学会自定义注解。掌握其定义格式和语法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//注解</span></span><br><span class="line"><span class="meta">@MyBook(name=&quot;《精通JavaSE》&quot;,authors = &#123;&quot;黑马&quot;, &quot;dlei&quot;&#125; , price = 199.5)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationDemo1</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//注解</span></span><br><span class="line">    <span class="meta">@MyBook(name=&quot;《精通JavaSE2》&quot;,authors = &#123;&quot;黑马&quot;, &quot;dlei&quot;&#125; , price = 199.5)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">AnnotationDemo1</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注解</span></span><br><span class="line">    <span class="meta">@MyBook(name=&quot;《精通JavaSE1》&quot;,authors = &#123;&quot;黑马&quot;, &quot;dlei&quot;&#125; , price = 199.5)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//注解</span></span><br><span class="line">        <span class="meta">@MyBook(name=&quot;《精通JavaSE2》&quot;,authors = &#123;&quot;黑马&quot;, &quot;dlei&quot;&#125; , price = 199.5)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">21</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3元注解"><a href="#3-3元注解" class="headerlink" title="3.3元注解"></a>3.3元注解</h4><p><strong>元注解</strong></p>
<ul>
<li>元注解：就是注解注解的注解。</li>
</ul>
<p><strong>元注解常用的两个：</strong></p>
<ul>
<li><p><strong>@Target</strong>: 约束自定义注解只能在哪些地方使用，</p>
</li>
<li><p><strong>@Retention</strong>：申明注解的生命周期</p>
</li>
</ul>
<p>@Target中可使用的值定义在ElementType枚举类中，常用值如下</p>
<ul>
<li><p>TYPE，类，接口</p>
</li>
<li><p>FIELD, 成员变量</p>
</li>
<li><p>METHOD, 成员方法</p>
</li>
<li><p>PARAMETER, 方法参数</p>
</li>
<li><p>CONSTRUCTOR, 构造器</p>
</li>
<li><p>LOCAL_VARIABLE, 局部变量</p>
</li>
</ul>
<p>@Retention中可使用的值定义在RetentionPolicy枚举类中，常用值如下</p>
<ul>
<li><p>SOURCE： 注解只作用在源码阶段，生成的字节码文件中不存在</p>
</li>
<li><p>CLASS： 注解作用在源码阶段，字节码文件阶段，运行阶段不存在，默认值.</p>
</li>
<li><p><strong>RUNTIME</strong>：注解作用在源码阶段，字节码文件阶段，运行阶段（开发常用）</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个元注解, 注解注解的注解。 </span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD,ElementType.FIELD&#125;)</span> <span class="comment">// 元注解 (METHOD注解成员方法，FIELD注解成员变量)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span> <span class="comment">// 一直活着，在运行阶段这个注解也不消失</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyTest &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   目标：认识元注解</span></span><br><span class="line"><span class="comment">   <span class="doctag">@MyTest</span> 只能注解方法和成员变量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//@MyTest //元注解未提供TYPE，此时不可以注解类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationDemo2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MyTest</span>  <span class="comment">//注解成员变量</span></span><br><span class="line">    <span class="keyword">private</span> String name; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">         <span class="meta">@MyTest</span>  <span class="comment">//注解成员方法</span></span><br><span class="line">   		 <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">   		 &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-4注解解析"><a href="#3-4注解解析" class="headerlink" title="3.4注解解析"></a>3.4注解解析</h4><p><strong>注解的解析</strong></p>
<ul>
<li>注解的操作中经常需要进行解析，注解的解析就是判断是否存在注解，存在注解就解析出内容。</li>
</ul>
<p><strong>与注解解析相关的接口</strong></p>
<ul>
<li><p><strong>Annotation: 注解的顶级接口</strong>，注解都是Annotation类型的对象</p>
</li>
<li><p>AnnotatedElement:该接口定义了与注解解析相关的解析方法</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Annotation[]  <strong>getDeclaredAnnotations</strong>()</td>
<td>获得当前对象上使用的所有注解，返回注解数组。</td>
</tr>
<tr>
<td>T <strong>getDeclaredAnnotation</strong>(Class<T>  annotationClass)</td>
<td>根据注解类型获得对应注解对象</td>
</tr>
<tr>
<td>boolean <strong>isAnnotationPresent</strong>(Class<Annotation>  annotationClass)</td>
<td>判断当前对象是否使用了指定的注解，如果使用了则返回true，否则false</td>
</tr>
</tbody></table>
<ul>
<li>所有的类成分Class, Method , Field , Constructor，都实现了AnnotatedElement接口他们都拥有解析注解的能力：</li>
</ul>
<p><strong>解析注解的技巧</strong></p>
<ul>
<li><p>注解在哪个成分上，我们就先拿哪个成分对象。</p>
</li>
<li><p>比如注解作用成员方法，则要获得该成员方法对应的Method对象，再来拿上面的注解</p>
</li>
<li><p>比如注解作用在类上，则要该类的Class对象，再来拿上面的注解</p>
</li>
<li><p>比如注解作用在成员变量上，则要获得该成员变量对应的Field对象，再来拿上面的注解</p>
</li>
</ul>
<p><strong>案例:</strong></p>
<p><strong>需求：</strong></p>
<p>注解解析的案例</p>
<p><strong>分析</strong></p>
<p>①定义注解Bookk，要求如下：<br>     - 包含属性：String value()  书名<br>     - 包含属性：double price() 价格，默认值为 100<br>     - 包含属性：String[] authors() 多位作者<br>     - 限制注解使用的位置：类和成员方法上<br>     - 指定注解的有效范围：RUNTIME</p>
<p>②定义BookStore类，在类和成员方法上使用Bookk注解</p>
<p>③定义AnnotationDemo01测试类获取Bookk注解上的数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义注解Bookk</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span> <span class="comment">//注解 类和方法</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Bookk &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">double</span> <span class="title function_">price</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">100</span>;</span><br><span class="line">    String[] author();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义BookStore类，在类和成员方法上使用Bookk注解</span></span><br><span class="line"><span class="comment">//1.注解类</span></span><br><span class="line"><span class="meta">@Bookk(value = &quot;《情深深雨濛濛》&quot;, price = 99.9, author = &#123;&quot;琼瑶&quot;, &quot;dlei&quot;&#125;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BookStore</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.注解方法</span></span><br><span class="line">    <span class="meta">@Bookk(value = &quot;《三少爷的剑》&quot;, price = 399.9, author = &#123;&quot;古龙&quot;, &quot;熊耀华&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   目标：完成注解的解析</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationDemo3</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parseClass</span><span class="params">()</span>&#123; <span class="comment">// 解析类</span></span><br><span class="line">        <span class="comment">// a.先得到类对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> BookStore.class;</span><br><span class="line">        <span class="comment">// b.判断这个类上面是否存在这个注解</span></span><br><span class="line">        <span class="keyword">if</span>(c.isAnnotationPresent(Bookk.class))&#123;</span><br><span class="line">            <span class="comment">//c.直接获取该注解对象</span></span><br><span class="line">            <span class="type">Bookk</span> <span class="variable">book</span> <span class="operator">=</span> (Bookk) c.getDeclaredAnnotation(Bookk.class);</span><br><span class="line">            System.out.println(book.value());</span><br><span class="line">            System.out.println(book.price());</span><br><span class="line">            System.out.println(Arrays.toString(book.author()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parseMethod</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123; <span class="comment">// 解析方法</span></span><br><span class="line">        <span class="comment">// a.先得到类对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> BookStore.class;</span><br><span class="line"></span><br><span class="line">        <span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> c.getDeclaredMethod(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// b.判断这个类上面是否存在这个注解</span></span><br><span class="line">        <span class="keyword">if</span>(m.isAnnotationPresent(Bookk.class))&#123;</span><br><span class="line">            <span class="comment">//c.直接获取该注解对象</span></span><br><span class="line">            <span class="type">Bookk</span> <span class="variable">book</span> <span class="operator">=</span> (Bookk) m.getDeclaredAnnotation(Bookk.class);</span><br><span class="line">            System.out.println(book.value());</span><br><span class="line">            System.out.println(book.price());</span><br><span class="line">            System.out.println(Arrays.toString(book.author()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-5注解的应用场景一：junit框架"><a href="#3-5注解的应用场景一：junit框架" class="headerlink" title="3.5注解的应用场景一：junit框架"></a>3.5注解的应用场景一：junit框架</h4><p><strong>案例：</strong></p>
<p>模拟Junit框架</p>
<p><strong>需求</strong></p>
<ul>
<li>定义若干个方法，只要加了MyTest注解，就可以在启动时被触发执行</li>
</ul>
<p><strong>分析</strong></p>
<p>①定义一个自定义注解MyTest，只能注解方法，存活范围是一直都在。</p>
<p>②定义若干个方法，只要有@MyTest注解的方法就能在启动时被触发执行，没有这个注解的方法不能执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个自定义注解MyTest</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD,ElementType.FIELD&#125;)</span> <span class="comment">// 元注解</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span> <span class="comment">// 一直活着，在运行阶段这个注解也不消失</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyTest &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationDemo4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===test1===&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MyTest</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===test2===&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MyTest</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===test3===&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      启动菜单：有注解的才被调用。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">AnnotationDemo4</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationDemo4</span>();</span><br><span class="line">        <span class="comment">// a.获取类对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> AnnotationDemo4.class;</span><br><span class="line">        <span class="comment">// b.提取全部方法</span></span><br><span class="line">        Method[] methods = c.getDeclaredMethods();</span><br><span class="line">        <span class="comment">// c.遍历方法，看是否有MyTest注解，有就跑它</span></span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            <span class="keyword">if</span>(method.isAnnotationPresent(MyTest.class))&#123;</span><br><span class="line">                <span class="comment">// 跑它</span></span><br><span class="line">                method.invoke(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-动态代理"><a href="#4-动态代理" class="headerlink" title="4.动态代理"></a>4.动态代理</h3><h4 id="4-1准备案例、提出问题"><a href="#4-1准备案例、提出问题" class="headerlink" title="4.1准备案例、提出问题"></a>4.1准备案例、提出问题</h4><p><strong>案例：</strong></p>
<p>模拟企业业务功能开发，并完成每个功能的性能统计</p>
<p><strong>需求</strong></p>
<ul>
<li>模拟某企业用户管理业务，需包含用户登录，用户删除，用户查询功能，并要统计每个功能的耗时。</li>
</ul>
<p><strong>分析</strong></p>
<p>①定义一个UserService表示用户业务接口，规定必须完成用户登录，用户删除，用户查询功能。</p>
<p>②定义一个实现类UserServiceImpl实现UserService，并完成相关功能，且统计每个功能的耗时。</p>
<p>③定义测试类，创建实现类对象，调用方法。</p>
<p><strong>本案例存在哪些问题？</strong></p>
<p>答：业务对象的的每个方法都要进行性能统计，存在大量重复的代码。</p>
<h4 id="4-2使用动态代理解决问题"><a href="#4-2使用动态代理解决问题" class="headerlink" title="4.2使用动态代理解决问题"></a>4.2使用动态代理解决问题</h4><p>动态代理</p>
<ul>
<li>代理就是被代理者没有能力或者不愿意去完成某件事情，需要找个人代替自己去完成这件事，动态代理就是用来对业务功能（方法）进行代理的。</li>
</ul>
<p><strong>关键步骤</strong></p>
<ul>
<li><p><strong>必须有接口，实现类要实现接口</strong>（代理通常是基于接口实现的）。</p>
</li>
<li><p><strong>创建一个实现类的对象</strong>，该对象为业务对象，紧接着为业务对象做一个代理对象。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	定义接口</span></span><br><span class="line"><span class="comment">   模拟用户业务功能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    String <span class="title function_">login</span><span class="params">(String loginName , String passWord)</span> ;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">selectUsers</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">deleteUsers</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">updateUsers</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	定义实现类，实现UserService接口</span></span><br><span class="line"><span class="comment">   模拟用户业务功能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">login</span><span class="params">(String loginName, String passWord)</span>  &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;admin&quot;</span>.equals(loginName) &amp;&amp; <span class="string">&quot;1234&quot;</span>.equals(passWord)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;登录名和密码可能有毛病&quot;</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">selectUsers</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;查询了100个用户数据！&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">deleteUsers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;删除100个用户数据！&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUsers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;修改100个用户数据！&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    public static Object newProxyInstance(ClassLoader loader,  Class&lt;?&gt;[] interfaces, InvocationHandler h)</span></span><br><span class="line"><span class="comment">    参数一：类加载器，负责加载代理类到内存中使用。</span></span><br><span class="line"><span class="comment">    参数二：获取被代理对象实现的全部接口。代理要为全部接口的全部方法进行代理</span></span><br><span class="line"><span class="comment">    参数三：代理的核心处理逻辑</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyUtil</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      生成业务对象的代理对象。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T  <span class="title function_">getProxy</span><span class="params">(T obj)</span> &#123; <span class="comment">// 参数类型和返回值类型都为任意类型</span></span><br><span class="line">        <span class="comment">// 1.调用Proxy.newProxyInstance创建一个实现类的对象，返回一个代理对象</span></span><br><span class="line">        <span class="keyword">return</span> (T)Proxy.newProxyInstance(obj.getClass().getClassLoader(),</span><br><span class="line">                obj.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                        <span class="comment">// 参数一：代理对象本身。一般不管</span></span><br><span class="line">                        <span class="comment">// 参数二：正在被代理的方法</span></span><br><span class="line">                        <span class="comment">// 参数三：被代理方法，应该传入的参数</span></span><br><span class="line">                       <span class="type">long</span> <span class="variable">startTimer</span> <span class="operator">=</span> System .currentTimeMillis(); <span class="comment">// 创建开始时间</span></span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 2.触发方法的真正执行。(触发真正的业务功能)</span></span><br><span class="line">                        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(obj, args); <span class="comment">//obj真实业务对象</span></span><br><span class="line"></span><br><span class="line">                        <span class="type">long</span> <span class="variable">endTimer</span> <span class="operator">=</span> System.currentTimeMillis(); <span class="comment">// 创建结束时间</span></span><br><span class="line">                        System.out.println(method.getName() + <span class="string">&quot;方法耗时：&quot;</span> + (endTimer - startTimer) / <span class="number">1000.0</span> + <span class="string">&quot;s&quot;</span>); <span class="comment">// 计算时间差</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 3.把业务功能方法执行的结果返回给调用者</span></span><br><span class="line">                        <span class="keyword">return</span> result;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、把业务对象，直接做成一个代理对象返回，代理对象的类型也是 UserService类型</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> ProxyUtil.getProxy(<span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>());</span><br><span class="line">        System.out.println(userService.login(<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;1234&quot;</span>));</span><br><span class="line">        System.out.println(userService.deleteUsers());</span><br><span class="line">        userService.selectUsers();</span><br><span class="line">        userService.updateUsers(); <span class="comment">// 走代理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>动态代理的优点</strong></p>
<ul>
<li><p>非常的灵活，支持任意接口类型的实现类对象做代理，也可以直接为接本身做代理。</p>
</li>
<li><p>可以为被代理对象的所有方法做代理。</p>
</li>
<li><p>可以在不改变方法源码的情况下，实现对方法功能的增强。</p>
</li>
<li><p>不仅简化了编程工作、提高了软件系统的可扩展性，同时也提高了开发效率。</p>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://Liooser.github.io">Liooser</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://liooser.github.io/post/a44e5d86.html">https://liooser.github.io/post/a44e5d86.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://Liooser.github.io" target="_blank">Liooser's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-%E5%8F%8D%E5%B0%84-%E6%B3%A8%E8%A7%A3-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/">java,面向对象进阶,单元测试,反射,注解,动态代理</a></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/Liooser/Liooser.github.io/main/images/index/b4.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/2f2fc17e.html"><img class="prev-cover" src="https://raw.githubusercontent.com/Liooser/Liooser.github.io/main/images/index/b2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">day23 - XML、xml解析、工厂模式、装饰模式</div></div></a></div><div class="next-post pull-right"><a href="/post/9d3e5e46.html"><img class="next-cover" src="https://raw.githubusercontent.com/Liooser/Liooser.github.io/main/images/index/b3.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">day21 - 网络编程</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://raw.githubusercontent.com/Liooser/Liooser.github.io/main/images/index/5.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Liooser</div><div class="author-info__description">潮落之后是潮起</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">42</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">34</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://haiyong.site/moyu/"><i class="iconfont icon-youxishoubing"></i><span>摸鱼</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://Liooser.github.io" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content"><b><font color="#e66b6d">双</font> <font color="#e66d98">手</font> <font color="#e66cc6">合</font> <font color="#cc6de6">十</font> <font color="#9770e6">成</font> <font color="#6d93e6">为</font> <font color="#6fcde6">自</font> <font color="#72e6b6">己</font> <font color="#72e689">的</font> <font color="#99e670">神</font>, <font color="#cde670">自</font> <font color="#e6df72">己</font> <font color="#e6c073">所</font> <font color="#e6a271">信</font> <font color="#e6796f">念</font> <font color="#e65454">的</font> <font color="#e63333">即</font> <font color="#e62c2c">是</font> <font color="#e60101">信</font> <font color="#e60101">仰</font></b> <p align="center"><img src="https://haiyong.site/img/img-blog.csdnimg.cn/f7384c88956d4378b72e47548e19c9f8.gif" width="50" alt="mao"></p></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-number">1.</span> <span class="toc-text">1.单元测试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">1.1单元测试概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="toc-number">1.2.</span> <span class="toc-text">1.2单元测试快速入门</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.3.</span> <span class="toc-text">1.3单元测试常用注解</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8F%8D%E5%B0%84"><span class="toc-number">2.</span> <span class="toc-text">2.反射</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1%E5%8F%8D%E5%B0%84%E6%A6%82%E8%BF%B0"><span class="toc-number">2.1.</span> <span class="toc-text">2.1反射概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E7%B1%BB%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.2.</span> <span class="toc-text">2.2反射获取类对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E6%9E%84%E9%80%A0%E5%99%A8%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.3.</span> <span class="toc-text">2.3反射获取构造器对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.4.</span> <span class="toc-text">2.4反射获取成员变量对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E6%96%B9%E6%B3%95%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.5.</span> <span class="toc-text">2.5反射获取方法对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6%E5%8F%8D%E5%B0%84%E7%9A%84%E4%BD%9C%E7%94%A8-%E7%BB%95%E8%BF%87%E7%BC%96%E8%AF%91%E9%98%B6%E6%AE%B5%E4%B8%BA%E9%9B%86%E5%90%88%E6%B7%BB%E5%8A%A0%E6%95%B0%E6%8D%AE"><span class="toc-number">2.6.</span> <span class="toc-text">2.6反射的作用-绕过编译阶段为集合添加数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7%E5%8F%8D%E5%B0%84%E7%9A%84%E4%BD%9C%E7%94%A8-%E9%80%9A%E7%94%A8%E6%A1%86%E6%9E%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">2.7.</span> <span class="toc-text">2.7反射的作用-通用框架的底层原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%B3%A8%E8%A7%A3"><span class="toc-number">3.</span> <span class="toc-text">3.注解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1%E6%B3%A8%E8%A7%A3%E6%A6%82%E8%BF%B0"><span class="toc-number">3.1.</span> <span class="toc-text">3.1注解概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3"><span class="toc-number">3.2.</span> <span class="toc-text">3.2自定义注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3%E5%85%83%E6%B3%A8%E8%A7%A3"><span class="toc-number">3.3.</span> <span class="toc-text">3.3元注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4%E6%B3%A8%E8%A7%A3%E8%A7%A3%E6%9E%90"><span class="toc-number">3.4.</span> <span class="toc-text">3.4注解解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E4%B8%80%EF%BC%9Ajunit%E6%A1%86%E6%9E%B6"><span class="toc-number">3.5.</span> <span class="toc-text">3.5注解的应用场景一：junit框架</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">4.动态代理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1%E5%87%86%E5%A4%87%E6%A1%88%E4%BE%8B%E3%80%81%E6%8F%90%E5%87%BA%E9%97%AE%E9%A2%98"><span class="toc-number">4.1.</span> <span class="toc-text">4.1准备案例、提出问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98"><span class="toc-number">4.2.</span> <span class="toc-text">4.2使用动态代理解决问题</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/7a7dea22.html" title="软考中级"><img src="https://raw.githubusercontent.com/Liooser/Liooser.github.io/main/images/index/ruankaozhongji.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="软考中级"/></a><div class="content"><a class="title" href="/post/7a7dea22.html" title="软考中级">软考中级</a><time datetime="2024-03-08T16:00:00.000Z" title="发表于 2024-03-09 00:00:00">2024-03-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/ee7dbeea.html" title="数据库三级【故障管理、备份与恢复】"><img src="https://raw.githubusercontent.com/Liooser/Liooser.github.io/main/images/index/Database_level_3.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据库三级【故障管理、备份与恢复】"/></a><div class="content"><a class="title" href="/post/ee7dbeea.html" title="数据库三级【故障管理、备份与恢复】">数据库三级【故障管理、备份与恢复】</a><time datetime="2023-09-17T16:00:00.000Z" title="发表于 2023-09-18 00:00:00">2023-09-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/61cdd72.html" title="数据库三级【数据库运行维护和优化】"><img src="https://raw.githubusercontent.com/Liooser/Liooser.github.io/main/images/index/Database_level_3.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据库三级【数据库运行维护和优化】"/></a><div class="content"><a class="title" href="/post/61cdd72.html" title="数据库三级【数据库运行维护和优化】">数据库三级【数据库运行维护和优化】</a><time datetime="2023-09-17T16:00:00.000Z" title="发表于 2023-09-18 00:00:00">2023-09-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/e570cd86.html" title="数据库三级【安全管理】"><img src="https://raw.githubusercontent.com/Liooser/Liooser.github.io/main/images/index/Database_level_3.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据库三级【安全管理】"/></a><div class="content"><a class="title" href="/post/e570cd86.html" title="数据库三级【安全管理】">数据库三级【安全管理】</a><time datetime="2023-09-16T16:00:00.000Z" title="发表于 2023-09-17 00:00:00">2023-09-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/c9b10525.html" title="数据库三级【数据仓库与数据挖掘】"><img src="https://raw.githubusercontent.com/Liooser/Liooser.github.io/main/images/index/Database_level_3.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据库三级【数据仓库与数据挖掘】"/></a><div class="content"><a class="title" href="/post/c9b10525.html" title="数据库三级【数据仓库与数据挖掘】">数据库三级【数据仓库与数据挖掘】</a><time datetime="2023-09-16T16:00:00.000Z" title="发表于 2023-09-17 00:00:00">2023-09-17</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Liooser</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="富强,民主,文明,和谐,自由,平等,公正,法治,爱国,敬业,诚信,友善" data-fontsize="15px" data-random="true" async="async"></script><script>(function(d, w, c) {
    w.ChatraID = 'SYuwBgxFrsHfNGEue';
    var s = d.createElement('script');
    w[c] = w[c] || function() {
        (w[c].q = w[c].q || []).push(arguments);
    };
    s.async = true;
    s.src = 'https://call.chatra.io/chatra.js';
    if (d.head) d.head.appendChild(s);
})(document, window, 'Chatra');

if (true) {
  var chatBtnFn = () => {
    var chatBtn = document.getElementById("chat_btn")
    chatBtn.addEventListener("click", function(){
      Chatra('openChat')
    });
  }
  chatBtnFn()
} else {
  if (true) {
    function chatBtnHide () {
      Chatra('hide')
    }
    function chatBtnShow () {
      Chatra('show')
    }
  }
}</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var qweather_key = 'b16a1fa0e63c46a4b8f28abfb06ae3fe';
  var gaud_map_key = 'e2b04289e870b005374ee030148d64fd&s=rsv3';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '112.982279,28.19409';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><!-- hexo injector body_end end --></body></html>