<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Vue3</title>
      <link href="/post/456f3b0z.html"/>
      <url>/post/456f3b0z.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-Vue是什么"><a href="#1-Vue是什么" class="headerlink" title="1.Vue是什么"></a>1.Vue是什么</h2><p>官网：cn.vuejs.org</p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240801170356299.png" alt="image-20240801170356299"></p><p>Vue是前端优秀框架， 是一套用于构建用户界面的<strong>渐进式框架</strong></p><h3 id="为什么要学习Vue"><a href="#为什么要学习Vue" class="headerlink" title="为什么要学习Vue"></a>为什么要学习Vue</h3><ol><li>Vue是目前前端最火的框架之一</li><li>Vue是目前企业技术栈中要求的知识点</li><li>Vue可以提升开发体验</li><li>Vue学习难度较低</li><li>…</li></ol><h3 id="Vue开发前的准备"><a href="#Vue开发前的准备" class="headerlink" title="Vue开发前的准备"></a>Vue开发前的准备</h3><p>方法一：</p><p>安装Vue工具</p><p>创建项目 npm init vue@latest   </p><p>下载依赖  cnpm install</p><p>运行项目</p><p>第一步：进入项目根目录<code>cd vue-demo</code></p><p>第二步：运行 npm run dev启动项目</p><p>方法二：</p><p>官方推荐方式。</p><p><strong>安装Vue工具 Vue CLI</strong>  </p><p>Vue CLI Vue.js 开发的标准工具， Vue CLI 是一个基于 Vue.js 进行快速 开发的完整系统 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g @vue/cli</span><br></pre></td></tr></table></figure><p>安装之后，你就可以在命令行中访问 vue 命令。你可以通过简单运 行 vue ，看看是否展示出了一份所有可用命令的帮助信息，来验证 它是否安装成功。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vue --version</span><br></pre></td></tr></table></figure><p><strong>创建一个项目</strong>  </p><p>运行以下命令来创建一个新项目 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vue create vue-demo</span><br></pre></td></tr></table></figure><blockquote><p>温馨提示 </p><p>在控制台中，可以用上下按键调整选择项 </p><p>在控制台中，可以用空格(spacebar)选择是否选中和取消选中 </p></blockquote><p>可以选择默认项目模板，或者选“手动选择特性”来选取需要的特性。 </p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240809095455670.png" alt="image-20240809095455670" style="zoom:33%;" /><p>我们选择 Babel 和 Progressive Web App (PWA) Support 两个选项即可</p><blockquote><p>温馨提示</p><p>在学习期间，不要选中 Linter &#x2F; Formatter 以避免不必要的错误提示</p></blockquote><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240809095556755.png" alt="image-20240809095556755" style="zoom:33%;" /><p>Vue目前有两个主流大版本 vue2 和 vue3 ，我们本套课程选择 vue3 最新版本</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240809095619318.png" alt="image-20240809095619318" style="zoom:33%;" /><p>配置放在哪里? In dedicated config files 专用配置文件或者 In package.json 在 package.json文件。</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240809095649884.png" alt="image-20240809095649884" style="zoom:33%;" /><p>将其保存为未来项目的预置? y 代表保存，并添加名字， n 不保存。</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240809095711303.png" alt="image-20240809095711303" style="zoom:33%;" /><p>项目创建成功如下提示信息</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240809095732872.png" alt="image-20240809095732872" style="zoom:33%;" /><p><strong>运行项目</strong> </p><p>第一步：进入项目根目录 cd vue-demo </p><p>第二步：运行 npm run serve 启动项目</p><h2 id="2-模板语法"><a href="#2-模板语法" class="headerlink" title="2.模板语法"></a>2.模板语法</h2><h3 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h3><p>数据绑定最常见的形式就是使用“Mustache” (双大括号) 语法的文本插值</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Message: &#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>一般配合<code>js</code> 中的<code>data()</code>设置数据</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;HelloWorld&#x27;</span>,</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">      <span class="attr">msg</span>:<span class="string">&quot;消息提示&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原始-HTML"><a href="#原始-HTML" class="headerlink" title="原始 HTML"></a>原始 HTML</h3><p>双大括号会将数据解释为普通文本，而非 HTML 代码。为了输出真正的 HTML，你需要使用<code>v-html</code> 指令</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Using mustaches: &#123;&#123; rawHtml &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Using v-html directive: <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-html</span>=<span class="string">&quot;rawHtml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">        <span class="attr">rawHtml</span>:<span class="string">&quot;&lt;a href=&#x27;https://www.itbaizhan.com&#x27;&gt;百战&lt;/a&gt;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="属性-Attribute"><a href="#属性-Attribute" class="headerlink" title="属性 Attribute"></a>属性 Attribute</h3><p>Mustache 语法不能在 HTML 属性中使用，然而，可以使用 <code>v-bind</code> 指令</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">&quot;dynamicId&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">        <span class="attr">dynamicId</span>:<span class="number">1001</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>温馨提示</strong></p><p><code>v-bind:</code> 可以简写成 <code>:</code></p></blockquote><h3 id="使用-JavaScript-表达式"><a href="#使用-JavaScript-表达式" class="headerlink" title="使用 JavaScript 表达式"></a>使用 JavaScript 表达式</h3><p>在我们的模板中，我们一直都只绑定简单的 property 键值，Vue.js 都提供了完全的 JavaScript 表达式支持</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;&#123; number + <span class="number">1</span> &#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123; ok ? <span class="string">&#x27;YES&#x27;</span> : <span class="string">&#x27;NO&#x27;</span> &#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123; message.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>) &#125;&#125;</span><br></pre></td></tr></table></figure><p>这些表达式会在当前活动实例的数据作用域下作为 JavaScript 被解析。有个限制就是，每个绑定都只能包含<strong>单个表达式</strong>，所以下面的例子都<strong>不会</strong>生效。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!--  这是语句，不是表达式：--&gt;</span><br><span class="line">&#123;&#123; <span class="keyword">var</span> a = <span class="number">1</span> &#125;&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- 流程控制也不会生效，请使用三元表达式 --&gt;</span><br><span class="line">&#123;&#123; <span class="keyword">if</span> (ok) &#123; <span class="keyword">return</span> message &#125; &#125;&#125;</span><br></pre></td></tr></table></figure><h2 id="3-条件渲染"><a href="#3-条件渲染" class="headerlink" title="3.条件渲染"></a>3.条件渲染</h2><h3 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h3><p><code>v-if</code> 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 <code>true</code> 值的时候被渲染。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">&quot;flag&quot;</span>&gt;</span>我是孙猴子<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">flag</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="v-else"><a href="#v-else" class="headerlink" title="v-else"></a>v-else</h3><p>你可以使用 <code>v-else</code> 指令来表示 <code>v-if</code> 的“else 块”</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">&quot;flag&quot;</span>&gt;</span>我是孙猴子<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-else</span>&gt;</span>你是傻猴子<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">flag</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h3><p>另一个用于条件性展示元素的选项是 <code>v-show</code> 指令</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-show</span>=<span class="string">&quot;ok&quot;</span>&gt;</span>Hello!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="v-if-vs-v-show-的区别"><a href="#v-if-vs-v-show-的区别" class="headerlink" title="v-if vs v-show 的区别"></a><code>v-if</code> vs <code>v-show</code> 的区别</h3><p><code>v-if</code> 是“真正”的条件渲染，因为它会确保在切换过程中，条件块内的事件监听器和子组件适当地被销毁和重建。</p><p><code>v-if</code> 也是<strong>惰性的</strong>：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p><p>相比之下，<code>v-show</code> 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。</p><p>一般来说，<code>v-if</code> 有更高的切换开销，而 <code>v-show</code> 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 <code>v-show</code> 较好；如果在运行时条件很少改变，则使用 <code>v-if</code> 较好</p><h2 id="4-列表渲染"><a href="#4-列表渲染" class="headerlink" title="4.列表渲染"></a>4.列表渲染</h2><p>我们可以使用 v-for 指令基于一个数组来渲染一个列表,v-for 指令的值需要使用 item in items 形式的特殊语法其中 items 是源数据的数组，而 item 是迭代项的别名.</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240801160126176.png" alt="image-20240801160126176" style="zoom:33%;" /><p>复杂属性：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240801161004711.png" alt="image-20240801161004711" style="zoom: 50%;" /><p>v-for 也支持使用可选的第二个参数表示当前项的位置索引</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240801161053496.png" alt="image-20240801161053496" style="zoom:33%;" /><p>可以使用 v-for 来遍历一个对象的所有属性</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240801161544914.png" alt="image-20240801161544914" style="zoom:33%;" /><h3 id="通过Key管理状态"><a href="#通过Key管理状态" class="headerlink" title="通过Key管理状态"></a>通过Key管理状态</h3><p>Vue 默认按照“就地更新”的策略来更新通过 vor 渲染的元素列表。当数据项的顺序改变时，Vue 不会随之移动 DOM 元素的顺序，而是就地更新每个元素，确保它们在原本指定的索引位置上渲染。</p><p>为了给 Vue 一个提示，以便它可以跟踪每个节点的标识，从而重用和重新排序现有的元素，你需要为每个元素对应的块提供一个唯一的 key attribute:</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240801161929308.png" alt="image-20240801161929308" style="zoom:33%;" /><blockquote><p>温馨提示</p><p>key 在这里是一个通过 v-bind 绑定的特殊 attribute</p><p>推荐在任何可行的时候为 v-for 提供一个key attribute</p><p>key 绑定的值期望是一个基础类型的值，例如字符串或 number 类型</p><p>key的来源：请不要使用 index 作为 key 的值，我们要确保每一条数据的唯一索引不会发生变化</p></blockquote><h2 id="5-事件处理–-v-on"><a href="#5-事件处理–-v-on" class="headerlink" title="5.事件处理– v-on"></a>5.事件处理– v-on</h2><p>我们可以使用 v-on 指令 (简写为 @)来监听 DOM 事件，并在事件触发时执行对应的JavaScript。</p><p>用法:v-on:click&#x3D;”methodName” 或@click&#x3D;”handler”</p><p>事件处理器的值可以是</p><ul><li><p>内联事件处理器:事件被触发时执行的内联JavaScript 语句(与 oncick 类似)</p></li><li><p>方法事件处理器:一个指向组件上定义的方法的属性名或是路径</p></li></ul><h3 id="内联事件处理器"><a href="#内联事件处理器" class="headerlink" title="内联事件处理器"></a>内联事件处理器</h3><p>  内联事件处理器通常用于简单场景</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240801162511678.png" alt="image-20240801162511678" style="zoom:33%;" /><h3 id="方法事件处理器"><a href="#方法事件处理器" class="headerlink" title="方法事件处理器"></a>方法事件处理器</h3><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240801162614219.png" alt="image-20240801162614219" style="zoom:33%;" /><h3 id="事件参数"><a href="#事件参数" class="headerlink" title="事件参数"></a>事件参数</h3><p>事件参数可以获取 event 对象和通过事件传递数据。</p><h4 id="获取Event对象"><a href="#获取Event对象" class="headerlink" title="获取Event对象"></a>获取Event对象</h4><p>Vue中的event对象就是Js中的event对象。</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240801162841230.png" alt="image-20240801162841230" style="zoom:33%;" /><h4 id="事件传参"><a href="#事件传参" class="headerlink" title="事件传参"></a>事件传参</h4><p><strong>普通传参</strong></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240801163645361.png" alt="image-20240801163645361" style="zoom:33%;" /><p><strong>列表传参：</strong></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240801163539647.png" alt="image-20240801163539647" style="zoom:33%;" /><h4 id="传递参数过程中获取event"><a href="#传递参数过程中获取event" class="headerlink" title="传递参数过程中获取event"></a>传递参数过程中获取event</h4><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240801163800587.png" alt="image-20240801163800587" style="zoom:33%;" /><h3 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h3><p>在处理事件时调用 dvent.preventDefaut0) 或 event.stopPropagation0 是很常见的。尽管我们可以直接在方法内调用，但如果方法能更专注于数据逻辑而不用去处理 DOM 事件的细节会更好</p><p>为解决这一问题，Vue 为 v-on 提供了事件修饰符，常用有以下几个!</p><ul><li><p>.stop</p></li><li><p>.prevent</p></li><li><p>.once</p></li><li><p>.enter</p></li><li><p>…</p></li></ul><blockquote><p>具体参考地址:<a href="https://cn.vuejs.orglguide/essentials/event-handling.html#event-modifiers">https://cn.vuejs.orglguide/essentials/event-handling.html#event-modifiers</a></p></blockquote><h4 id="阻止默认事件"><a href="#阻止默认事件" class="headerlink" title="阻止默认事件"></a>阻止默认事件</h4><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240801164055459.png" alt="image-20240801164055459" style="zoom:33%;" /><h4 id="阻止事件冒泡"><a href="#阻止事件冒泡" class="headerlink" title="阻止事件冒泡"></a>阻止事件冒泡</h4><p>触发子元素事件时，不会触发父元素。</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240801164207820.png" alt="image-20240801164207820" style="zoom:33%;" /><h2 id="6-表单输入绑定–v-model"><a href="#6-表单输入绑定–v-model" class="headerlink" title="6.表单输入绑定–v-model"></a>6.表单输入绑定–v-model</h2><p>在前端处理表单时，我们常常需要将表单输入框的内容同步给JavaScript 中相应的变量。手动连接值绑定和更改事件监听器可能会很麻烦，v-mode 指令帮我们简化了这一步骤。</p><p>可以用 <code>v-model</code> 指令在表单 <code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code> 及 <code>&lt;select&gt;</code> 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。尽管有些神奇，但 <code>v-model</code> 本质上不过是语法糖。它负责监听用户的输入事件来更新数据，并在某种极端场景下进行一些特殊处理。</p><h3 id="文本输入框"><a href="#文本输入框" class="headerlink" title="文本输入框"></a>文本输入框</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;from&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; v-model=&quot;message&quot;/&gt;</span><br><span class="line">&lt;p&gt;Message is: &#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;/from&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default&#123;</span><br><span class="line">data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        message:&quot;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="复选框"><a href="#复选框" class="headerlink" title="复选框"></a>复选框</h3><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240801144149768.png" alt="image-20240801144149768" style="zoom:33%;" /><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><h4 id="lazy"><a href="#lazy" class="headerlink" title=".lazy"></a><code>.lazy</code></h4><p>在默认情况下，<code>v-model</code> 在每次 <code>input</code> 事件触发后将输入框的值与数据进行同步 。你可以添加 <code>lazy</code> 修饰符，从而转为在 <code>change</code> 事件之后进行同步</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.lazy</span>=<span class="string">&quot;message&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Message is: &#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">message</span>:<span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="trim"><a href="#trim" class="headerlink" title=".trim"></a><code>.trim</code></h4><p>如果要自动过滤用户输入的首尾空白字符，可以给 <code>v-model</code> 添加 <code>trim</code> 修饰符</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.trim</span>=<span class="string">&quot;message&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">message</span>:<span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-数组变化侦测"><a href="#7-数组变化侦测" class="headerlink" title="7.数组变化侦测"></a>7.数组变化侦测</h2><h3 id="变更方法（会引起UI变化）"><a href="#变更方法（会引起UI变化）" class="headerlink" title="变更方法（会引起UI变化）"></a>变更方法（会引起UI变化）</h3><p>Vue 能够侦听响应式数组的变更方法，并在它们被调用时触发相关的更新。这些变更方法包括</p><ul><li>push()</li><li>pop()</li><li>shift()</li><li>unshift()</li><li>splice()</li><li>sort()</li><li>reverse()</li></ul><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240801164652524.png" alt="image-20240801164652524" style="zoom: 33%;" /><h3 id="替换一个数组"><a href="#替换一个数组" class="headerlink" title="替换一个数组"></a>替换一个数组</h3><p>变更方法，顾名思义，就是会对调用它们的原数组进行变更。相对地，也有一些不可变(immutable)方法，例filter和 concat和slice，这些都不会更改原数组，而<strong>总是返回一个新数组</strong>。<strong>当遇到的是非变更方法时，需要将旧日的数组替换为新的。</strong></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240801165115730.png" alt="image-20240801165115730" style="zoom: 33%;" /><h2 id="8-计算属性–computed"><a href="#8-计算属性–computed" class="headerlink" title="8.计算属性–computed"></a>8.计算属性–computed</h2><p>模板中的表达式虽然方便，但也只能用来做简单的操作。如果在板中写太多逻辑，会让模板变得臃肿，难以因此我们推荐使用计算属性来描述依赖响应式状态的复杂逻辑维护。</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240801165458186.png" alt="image-20240801165458186" style="zoom: 33%;" /><h3 id="使用计算属性"><a href="#使用计算属性" class="headerlink" title="使用计算属性"></a>使用计算属性</h3><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240801165618589.png" alt="image-20240801165618589" style="zoom: 33%;" /><h3 id="计算属性缓存-vs-方法"><a href="#计算属性缓存-vs-方法" class="headerlink" title="计算属性缓存 vs 方法"></a>计算属性缓存 vs 方法</h3><p>可能注意到我们在表达式中像这样调用一个函数也会获得和计算属性相同的结果</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240801165755433.png" alt="image-20240801165755433" style="zoom: 33%;" /><blockquote><p>重点区别:</p><p>计算属性:计算属性值会基于其响应式依赖被缓存。</p><p>一个计算属性仅会在其响应式依赖更新时才重新计算方法。</p><p>方法调用总是会在重渲染发生时再次执行函数。</p></blockquote><h2 id="9-Class绑定"><a href="#9-Class绑定" class="headerlink" title="9.Class绑定"></a>9.Class绑定</h2><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240801140146281.png" alt="image-20240801140146281" style="zoom: 33%;" /><h3 id="数组和对象嵌套"><a href="#数组和对象嵌套" class="headerlink" title="数组和对象嵌套"></a>数组和对象嵌套</h3><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240801140333180.png" alt="image-20240801140333180" style="zoom:33%;" /><h2 id="10-style绑定"><a href="#10-style绑定" class="headerlink" title="10.style绑定"></a>10.style绑定</h2><p>数据绑定的一个常见需求场景是操纵元素的 CSS style列表，因为 style是 attribute，我们可以和其他attribute 一样使用 v-bind 将它们和动态的字符串绑定。但是，在处理比较复杂的绑定时，通过拼接生成字符串是麻烦且易出错的。因此，Vue 专门为 style的 v-bind 用法提供了特殊的功能增强。除了字符串外，表达式的值也可以是对象或数组。</p><h3 id="绑定对象"><a href="#绑定对象" class="headerlink" title="绑定对象"></a>绑定对象</h3><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240801141122611.png" alt="image-20240801141122611" style="zoom: 33%;" /><h3 id="绑定数组（了解）"><a href="#绑定数组（了解）" class="headerlink" title="绑定数组（了解）"></a>绑定数组（了解）</h3><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240801141336505.png" alt="image-20240801141336505" style="zoom:33%;" /><h2 id="11-监听器–watch"><a href="#11-监听器–watch" class="headerlink" title="11.监听器–watch"></a>11.监听器–watch</h2><p>监听动态数据变化。</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240801142834485.png" alt="image-20240801142834485" style="zoom: 33%;" /><h2 id="12-组件组成"><a href="#12-组件组成" class="headerlink" title="12.组件组成"></a>12.组件组成</h2><p>组件最大的优势就是可复用性</p><p>当使用构建步骤时，我们一般会将 Vue 组件定义在一个单独的 vue文件中,，这被叫做单文件组件(简称 SFC)</p><h3 id="组件组成结构"><a href="#组件组成结构" class="headerlink" title="组件组成结构"></a>组件组成结构</h3><h4 id="创建组件"><a href="#创建组件" class="headerlink" title="创建组件"></a>创建组件</h4><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240801150632002.png" alt="image-20240801150632002" style="zoom:33%;" /><h4 id="组件引入–components"><a href="#组件引入–components" class="headerlink" title="组件引入–components"></a>组件引入–components</h4><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240801150536752.png" alt="image-20240801150536752" style="zoom:33%;" /><blockquote><p>template标签为组件必要的。</p><p>scoped：生效作用域，让当前样式只在当前组件生效。</p></blockquote><h3 id="组件的嵌套关系"><a href="#组件的嵌套关系" class="headerlink" title="组件的嵌套关系"></a>组件的嵌套关系</h3><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240801151336485.png" alt="image-20240801151336485" style="zoom: 50%;" /><p>组件允许我们将 U划分为独立的、可重用的部分，并且可以对每个部分进行单独的思考。在实际应用中，组件常常被组织成层层嵌套的树状结构。</p><p>这和我们嵌套 HTML元素的方式类似，Vue 实现了自己的组件模型，使我们可以在每个组件内封装自定义内容与逻辑。</p><h3 id="组件的注册方式"><a href="#组件的注册方式" class="headerlink" title="组件的注册方式"></a>组件的注册方式</h3><p>一个 Vue 组件在使用前需要先被“注册”，这样 Vue 才能在渲染模板时找到其对应的实现。</p><p><strong>组件注册有两种方式:全局注册和局部注册。</strong>之前全为局部注册。</p><h4 id="全局注册"><a href="#全局注册" class="headerlink" title="全局注册"></a>全局注册</h4><p>在main.js中全局注册</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240801152724152.png" alt="image-20240801152724152" style="zoom:33%;" /><p>组件中直接引入</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240801152656070.png" alt="image-20240801152656070" style="zoom:33%;" /><blockquote><p> 全局注册虽然很方便，但有以下几个问题:</p><p>全局注册，但并没有被使用的组件无法在生产打包时被自动移除(也叫“tree-shaking”)。如果你全局注册了一个组件，即使它并没有被实际使用，它仍然会出现在打包后的S 文件中。</p><p>全局注册在大型项目中使项目的依赖关系变得不那么明确。在父组件中使用子组件时，不太容易定位子组件的实现。和使用过多的全局变量一样，这可能会影响应用长期的可维护性。</p><p><strong>局部注册需要使用 components 选项。</strong></p></blockquote><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240801153316243.png" alt="image-20240801153316243" style="zoom: 33%;" /><h3 id="组件传递数据–Props父传子"><a href="#组件传递数据–Props父传子" class="headerlink" title="组件传递数据–Props父传子"></a>组件传递数据–Props父传子</h3><p>组件与组件之间不是完全独立的那就是组件与组件之间是可以传递数据的而是有交集的，传递数据的解决方案就是 <code>props</code>。</p><p>Prop传递参数其实是没有类型限制的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">  title: String,</span><br><span class="line">  likes: Number,</span><br><span class="line">  isPublished: Boolean,</span><br><span class="line">  commentIds: Array,</span><br><span class="line">  author: Object,</span><br><span class="line">  callback: Function</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态数据传递：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240801154406687.png" alt="image-20240801154406687" style="zoom: 33%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240801154223710.png" alt="image-20240801154223710" style="zoom: 33%;" /><p>动态数据传递:</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240801154616028.png" alt="image-20240801154616028" style="zoom: 33%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240801154223710.png" alt="image-20240801154223710" style="zoom: 33%;" /><blockquote><p>注意事项<br>props传递数据，只能从父级传递到子级，不能反其道而行</p></blockquote><h4 id="多种数据类型"><a href="#多种数据类型" class="headerlink" title="多种数据类型"></a>多种数据类型</h4><p>通过 props传递数据，不仅可以传递字符串类型的数据，还可以是其他类型，例如:数字、对象、数组等但实际上任何类型的值都可以作为 props 的值被传递。</p><p>Number:</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240801155424417.png" alt="image-20240801155424417" style="zoom: 33%;" /><p>Array:</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240801155622899.png" alt="image-20240801155622899" style="zoom: 33%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240801155628961.png" alt="image-20240801155628961" style="zoom: 33%;" /><p>Object:</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240801155747741.png" alt="image-20240801155747741" style="zoom: 33%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240801155812940.png" alt="image-20240801155812940" style="zoom: 33%;" /><h4 id="Props校验"><a href="#Props校验" class="headerlink" title="Props校验"></a>Props校验</h4><p>Vue 组件可以更细致地声明对传入的 props 的校验要求。</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240802132232707.png" alt="image-20240802132232707" style="zoom: 33%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240802132543990.png" alt="image-20240802132543990" style="zoom: 33%;" /><h5 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240802133215406.png" alt="image-20240802133215406" style="zoom: 33%;" /><blockquote><p>注意</p><p>数字和字符串可以直接default，但是如果是数组和对象必须通过工厂函数返回默认值</p></blockquote><h5 id="必选项"><a href="#必选项" class="headerlink" title="必选项"></a>必选项</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240802133648182.png" alt="image-20240802133648182" style="zoom: 33%;" /><blockquote><p>温馨提示</p><p>警告：prop 是只读的!</p><p>子组件中不能修改父组件中的数据。</p></blockquote><h3 id="组件事件"><a href="#组件事件" class="headerlink" title="组件事件"></a>组件事件</h3><p>在组件的模板表达式中，可以直接使用 $emit方法触发自定义事件。触发自定义事件的目的是组件之间传递数据。</p><p>自定义事件可以在组件中反向传递数据，<code>prop</code> 可以将数据从父组件传递到子组件，那么反向如何操作呢，就可以利用自定义事件实现 <code>$emit</code>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;h3&gt;单文件组件&lt;/h3&gt;</span><br><span class="line">    &lt;button @click=&quot;sendHandle&quot;&gt;发送数据&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    name: &quot;MyComponent&quot;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        sendHandle()&#123;</span><br><span class="line">            this.$emit(&quot;onCustom&quot;,&quot;数据&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">h3 &#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;my-componentVue @onCustom=&quot;getData&quot; /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">import MyComponentVue from &#x27;./components/MyComponent.vue&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;App&#x27;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    MyComponentVue</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    getData(data) &#123;</span><br><span class="line">      console.log(data);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="自定义事件–子传父"><a href="#自定义事件–子传父" class="headerlink" title="自定义事件–子传父"></a>自定义事件–子传父</h4><p>实现子传父</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240802141019078.png" alt="image-20240802141019078" style="zoom: 50%;" /><blockquote><p>温馨提示<br>        组件之间传递数据的方案:<br>        父传子:props<br>        子传父:自定义事件(this.$emit)</p></blockquote><h4 id="组件事件配合v-model"><a href="#组件事件配合v-model" class="headerlink" title="组件事件配合v-model"></a>组件事件配合v-model</h4><p>如果是用户输入，我们希望在获取数据的同时发送数据配合 v-model 来使用。</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240802141906652.png" alt="image-20240802141906652" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240802141849604.png" alt="image-20240802141849604" style="zoom:33%;" /><h3 id="组件事件传递–props子传父"><a href="#组件事件传递–props子传父" class="headerlink" title="组件事件传递–props子传父"></a>组件事件传递–props子传父</h3><p>我们之前讲解过了组件之间的数据传递props 和 自定义事件 两种方式</p><p>props:父传子</p><p>自定义事件:子传父</p><p>出了上述的方案,也可以实现子传父props。</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240802143325479.png" alt="image-20240802143325479" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240802143334377.png" alt="image-20240802143334377" style="zoom:33%;" /><h3 id="透传-attribute"><a href="#透传-attribute" class="headerlink" title="透传 attribute"></a>透传 attribute</h3><p>“透传 attribute”指的是传递给一个组件却没有被该组件声明为 props 或 emits 的 attribute 或者 v-on 事件监听器。</p><p>最常见的例子就是 cass、styie 和 id。</p><p><strong>当一个组件以单个元素为根作渲染时，透传的 attribute 会自动被添加到根元素上。</strong></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240802144540259.png" alt="image-20240802144540259" style="zoom:33%;" /><p><strong>禁用 attribute透传</strong></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240802144747093.png" alt="image-20240802144747093" style="zoom:33%;" /><h3 id="插槽Slot"><a href="#插槽Slot" class="headerlink" title="插槽Slot"></a>插槽Slot</h3><p>我们已经了解到组件能够接收任意类型的JavaScript 值作为 props，但组件要如何接收模板内容呢?</p><p>在某些场景中，我们可能想要为子组件传递一些模板片段，让子组件在它们的组件中染这些片段。</p><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240802150136922.png" alt="image-20240802150136922" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240802145826241.png" alt="image-20240802145826241" style="zoom: 50%;" /><h4 id="渲染作用域"><a href="#渲染作用域" class="headerlink" title="渲染作用域"></a>渲染作用域</h4><p>插槽内容可以访问到父组件的数据作用域，因为插槽内容本身是在父组件模板中定义的。</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240802150659090.png" alt="image-20240802150659090" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240802150620357.png" alt="image-20240802150620357" style="zoom:33%;" /><h4 id="默认内容"><a href="#默认内容" class="headerlink" title="默认内容"></a>默认内容</h4><p>在外部没有提供任何内容的情况下，可以为插槽指默认内容。</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240802150846898.png" alt="image-20240802150846898" style="zoom:33%;" /><h4 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h4><p>插槽较多的情况下，使用v-slot指定插槽。</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240802151357741.png" alt="image-20240802151357741" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240802151407322.png" alt="image-20240802151407322" style="zoom:33%;" /><p>v.slot 有对应的简写#，因此 template v-slot:header可以简写为template #headepr。其意思就是将这部分模板片段传入子组件的 header 插槽中。</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240802151935875.png" alt="image-20240802151935875" style="zoom:33%;" /><h4 id="插槽中的数据传递"><a href="#插槽中的数据传递" class="headerlink" title="插槽中的数据传递"></a>插槽中的数据传递</h4><p>在某些场景下插槽的内容可能想要同时使用父组件域内和子组件域内的数据。要做到这一点，我们需要一种方法来让子组件在渲染时将一部分数据提供给插槽。</p><p>可以像对组件传递 props 那样，向一个插槽的出口上传递 attributes。</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240802153338014.png" alt="image-20240802153338014" style="zoom: 50%;" /><h4 id="具名插槽传递数据"><a href="#具名插槽传递数据" class="headerlink" title="具名插槽传递数据"></a>具名插槽传递数据</h4><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240802153807075.png" alt="image-20240802153807075" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240802153811224.png" alt="image-20240802153811224" style="zoom:33%;" /><h3 id="组件生命周期"><a href="#组件生命周期" class="headerlink" title="组件生命周期"></a>组件生命周期</h3><p>每个组件在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做<strong>生命周期钩子</strong>的函数，这给了用户在不同阶段添加自己的代码的机会。</p><h4 id="生命周期流程"><a href="#生命周期流程" class="headerlink" title="生命周期流程"></a>生命周期流程</h4><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240805180928337.png" alt="image-20240805180928337" style="zoom: 50%;" /><p>为了方便记忆，我们可以将他们分类：</p><p>创建时：<code>beforeCreate</code>、<code>created</code></p><p>渲染时：<code>beforeMount</code>、<code>mounted</code></p><p>更新时：<code>beforeUpdate</code>、<code>updated</code></p><p>卸载时：<code>beforeUnmount</code>、<code>unmounted</code></p><h4 id="生命周期应用"><a href="#生命周期应用" class="headerlink" title="生命周期应用"></a>生命周期应用</h4><p>组件的生命周期会随着我们对 ve的了解越多，也会越来越重要，这里我们先讲两个常用的应用常见:</p><ul><li>通过ref 获取元素DOM结构。</li><li>模拟网络请求渲染数据。</li></ul><h5 id="通过ref获取元素DOM结构"><a href="#通过ref获取元素DOM结构" class="headerlink" title="通过ref获取元素DOM结构"></a>通过ref获取元素DOM结构</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240805182533225.png" alt="image-20240805182533225" style="zoom:33%;" /><p>模拟网络请求。</p><p>获取网页数据应在mounted时期。</p><h4 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h4><p>有些场景会需要在两个组件间来回切换，比如Tab 界面。</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240805192731441.png" alt="image-20240805192731441" style="zoom:33%;" /><h4 id="组件保持存活–keep-aive"><a href="#组件保持存活–keep-aive" class="headerlink" title="组件保持存活–keep-aive"></a>组件保持存活–keep-aive</h4><p>当使用 <a href="cmponent:is=&quot;…&quot;">cmponent:is=&quot;…&quot;</a>来在多个组件间作切换时，被切换掉的组件会被卸载。我们可以通过 <keep-aive> 组件强制被切换掉的组件仍然保持“存活”的状态。</p><p>组件被卸载：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240805184832246.png" alt="image-20240805184832246" style="zoom:33%;" /><p>保持存活：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240805192844575.png" alt="image-20240805192844575" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240805185305970.png" alt="image-20240805185305970" style="zoom:33%;" /><h4 id="异步组件–defineAsyncComponent"><a href="#异步组件–defineAsyncComponent" class="headerlink" title="异步组件–defineAsyncComponent"></a>异步组件–defineAsyncComponent</h4><p>在大型项目中，我们可能需要拆分应用为更小的块，并<strong>仅在需要时再从服务器加载相关组件</strong>。Vue 提供了<code>defineAsyncComponent</code> 方法来实现此功能。</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240805185941057.png" alt="image-20240805185941057" style="zoom:33%;" /><h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p>通常情况下，当我们需要从父组件向子组件传递数据时，会使用props 。想象一下这样的结构:有一些多层级嵌套的组件，形成了一颗巨大的组件树，而某个深层的子组件需要一个较远的祖先组件中的部分数据。在这种情况下，如果仅使用 props 则必须将其沿着组件链逐级传递下去，这会非常麻烦。</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240805190049615.png" alt="image-20240805190049615" style="zoom: 50%;" /><p>这一问题被称为“prop 逐级透传”</p><p>provide 和 iniec 可以帮助我们解决这一问题。 一个父组件相对于其所有的后代组件，会作为依赖提供者。任何后代的组件树，无论层级有多深，都可以注入由父组件提供给整条链路的依赖。</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240805190543269.png" alt="image-20240805190543269" style="zoom: 50%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240805193022518.png" alt="image-20240805193022518" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240805193109340.png" alt="image-20240805193109340" style="zoom:33%;" /><p>也可以将接收到的数据放入data载显示</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240805191230898.png" alt="image-20240805191230898" style="zoom:33%;" /><h4 id="注入全局数据"><a href="#注入全局数据" class="headerlink" title="注入全局数据"></a>注入全局数据</h4><p>在main,js中注入全局数据</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240805191656422.png" alt="image-20240805191656422" style="zoom: 50%;" /><p>在其他组件中读取</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240805192102117.png" alt="image-20240805192102117" style="zoom:33%;" /><blockquote><p>温馨提示</p><p>provide 和 inject 只能由上到下的传递，不能反向传递</p></blockquote><h3 id="模板引用"><a href="#模板引用" class="headerlink" title="模板引用"></a>模板引用</h3><p>获取DOM操作。</p><p>虽然 Vue 的声明性渲染模型为你抽象了大部分对 DOM 的直接操作，但在某些情况下，我们仍然需要直接访问底层 DOM 元素。要实现这一点，我们可以使用特殊的 ref attribute挂载结束后引用都会被暴露在 <code>this.$refs </code>之上。</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240802115939666.png" alt="image-20240802115939666" style="zoom:33%;" /><h2 id="12-Vue应用"><a href="#12-Vue应用" class="headerlink" title="12.Vue应用"></a>12.Vue应用</h2><p>执行流程：</p><p>main.js(执行createApp，加载app.vue文件)</p><p>–&gt;main.js(执行mount，挂载index.html，解析为浏览器可读的Js文件)</p><h3 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h3><p>每个 Vue 应用都是通过createApp 函数创建一个新的 应用实例</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240805194439338.png" alt="image-20240805194439338" style="zoom:33%;" /><h3 id="根组件"><a href="#根组件" class="headerlink" title="根组件"></a>根组件</h3><p>我们传入 createApp 的对象实际上是一个组件，每个应用都需要一个“根组件”，其他组件将作为其子组件。</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240805194424994.png" alt="image-20240805194424994" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240805194404937.png" alt="image-20240805194404937" style="zoom:33%;" /><h3 id="挂载应用"><a href="#挂载应用" class="headerlink" title="挂载应用"></a>挂载应用</h3><p>应用实例必须在调用了.mount() 方法后才会渲染出来。该方法接收一个“容器”参数，可以是一个实际的 DOM元素或是一个 CSS 选择器字符串。</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240805194552625.png" alt="image-20240805194552625" style="zoom:33%;" /><p>index.html：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240805194636599.png" alt="image-20240805194636599" style="zoom:33%;" /><p>浏览器可执行文件:</p><ol><li>HTML</li><li>2.CSS</li><li>JavaScript</li><li>Image</li></ol><p>构建工具:Webpack vite</p><h2 id="14-Vue引入第三方"><a href="#14-Vue引入第三方" class="headerlink" title="14.Vue引入第三方"></a>14.Vue引入第三方</h2><p>举例：</p><p>在Vue框架中引入Swiper两种方式：</p><ol><li>github搜索vue-Swiper。</li><li>在vue2 的官网cn.vuejs.org中的资源列表查找。</li></ol><h3 id="引入Swiper"><a href="#引入Swiper" class="headerlink" title="引入Swiper"></a>引入Swiper</h3><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240806143930344.png" alt="image-20240806143930344" style="zoom: 50%;" /><p><code>Swiper</code> 开源、免费、强大的触摸滑动插件</p><p><code>Swiper</code> 是纯javascript打造的滑动特效插件，面向手机、平板电脑等移动终端</p><p><code>Swiper</code> 能实现触屏焦点图、触屏Tab切换、触屏轮播图切换等常用效果</p><blockquote><p><strong>温馨提示</strong></p><p>官方文档：<a href="https://swiperjs.com/vue">https://swiperjs.com/vue</a></p><p>安装指定版本: <code>npm instal --save swiper@8.1.6</code></p></blockquote><h4 id="基础实现"><a href="#基础实现" class="headerlink" title="基础实现"></a>基础实现</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;hello&quot;&gt;</span><br><span class="line">    &lt;swiper class=&quot;mySwiper&quot;&gt;</span><br><span class="line">      &lt;swiper-slide&gt;Slide 1&lt;/swiper-slide&gt;</span><br><span class="line">      &lt;swiper-slide&gt;Slide 2&lt;/swiper-slide&gt;</span><br><span class="line">      &lt;swiper-slide&gt;Slide 3&lt;/swiper-slide&gt;</span><br><span class="line">    &lt;/swiper&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; Swiper, SwiperSlide &#125; from &#x27;swiper/vue&#x27;;</span><br><span class="line">import &#x27;swiper/css&#x27;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;HelloWorld&#x27;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    Swiper,</span><br><span class="line">    SwiperSlide,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="添加指示器"><a href="#添加指示器" class="headerlink" title="添加指示器"></a>添加指示器</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;hello&quot;&gt;</span><br><span class="line">    &lt;swiper class=&quot;mySwiper&quot; :modules=&quot;modules&quot; :pagination=&quot;&#123; clickable: true &#125;&quot;&gt;</span><br><span class="line">      &lt;swiper-slide&gt;</span><br><span class="line">        &lt;img src=&quot;../assets/logo.png&quot; alt=&quot;&quot;&gt;</span><br><span class="line">      &lt;/swiper-slide&gt;</span><br><span class="line">      &lt;swiper-slide&gt;</span><br><span class="line">        &lt;img src=&quot;../assets/logo.png&quot; alt=&quot;&quot;&gt;</span><br><span class="line">      &lt;/swiper-slide&gt;</span><br><span class="line">      &lt;swiper-slide&gt;</span><br><span class="line">        &lt;img src=&quot;../assets/logo.png&quot; alt=&quot;&quot;&gt;</span><br><span class="line">      &lt;/swiper-slide&gt;</span><br><span class="line">    &lt;/swiper&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; Pagination &#125; from &#x27;swiper&#x27;;</span><br><span class="line">import &#123; Swiper, SwiperSlide &#125; from &#x27;swiper/vue&#x27;;</span><br><span class="line">import &#x27;swiper/css&#x27;;</span><br><span class="line">import &#x27;swiper/css/pagination&#x27;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;HelloWorld&#x27;,</span><br><span class="line">  data()&#123;</span><br><span class="line">    return&#123;</span><br><span class="line">      modules: [ Pagination ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    Swiper,</span><br><span class="line">    SwiperSlide,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240806145648146.png" alt="image-20240806145648146" style="zoom: 67%;" /><h3 id="引入Axios网络请求"><a href="#引入Axios网络请求" class="headerlink" title="引入Axios网络请求"></a>引入Axios网络请求</h3><p>Axios 是一个基于 promise 的网络请求库</p><h4 id="安装和使用"><a href="#安装和使用" class="headerlink" title="安装和使用"></a>安装和使用</h4><p>Axios的应用是需要单独安装的 <code>npm install --save axios</code></p><p>组件中引入: <code>import axios from &quot;axios&quot;</code></p><p>全局引用: </p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>);</span><br><span class="line">app.<span class="property">config</span>.<span class="property">globalProperties</span>.<span class="property">$axios</span> = axios <span class="comment">//$axios为重命名</span></span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在组件中调用</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$axios</span></span><br></pre></td></tr></table></figure><h4 id="网络请求基本示例"><a href="#网络请求基本示例" class="headerlink" title="网络请求基本示例"></a>网络请求基本示例</h4><h5 id="get请求"><a href="#get请求" class="headerlink" title="get请求"></a>get请求</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&quot;get&quot;</span>,</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&quot;http://iwenwiki.com/api/blueberrypai/getChengpinDetails.php&quot;</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="property">data</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="post请求"><a href="#post请求" class="headerlink" title="post请求"></a>post请求</h5><blockquote><p><strong>温馨提示</strong></p><p>post请求参数是需要额外处理的</p><ol><li>安装依赖: <code>npm install --save querystring</code> 并引入</li><li>转换参数格式: <code>qs.stringify(&#123;&#125;)</code></li></ol></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">method</span>:<span class="string">&quot;post&quot;</span>,</span><br><span class="line">    <span class="attr">url</span>:<span class="string">&quot;http://iwenwiki.com/api/blueberrypai/login.php&quot;</span>,</span><br><span class="line">    <span class="attr">data</span>:qs.<span class="title function_">stringify</span>(&#123;</span><br><span class="line">        <span class="attr">user_id</span>:<span class="string">&quot;iwen@qq.com&quot;</span>,</span><br><span class="line">        <span class="attr">password</span>:<span class="string">&quot;iwen123&quot;</span>,</span><br><span class="line">        <span class="attr">verification_code</span>:<span class="string">&quot;crfvw&quot;</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="property">data</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="快捷方案"><a href="#快捷方案" class="headerlink" title="快捷方案"></a>快捷方案</h5><h5 id="get请求-1"><a href="#get请求-1" class="headerlink" title="get请求"></a>get请求</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.<span class="title function_">get</span>(<span class="string">&quot;http://iwenwiki.com/api/blueberrypai/getChengpinDetails.php&quot;</span>)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span>&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="property">data</span>);</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><h5 id="post请求-1"><a href="#post请求-1" class="headerlink" title="post请求"></a>post请求</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.<span class="title function_">post</span>(<span class="string">&quot;http://iwenwiki.com/api/blueberrypai/login.php&quot;</span>, qs.<span class="title function_">stringify</span>(&#123;</span><br><span class="line">      <span class="attr">user_id</span>: <span class="string">&quot;iwen@qq.com&quot;</span>,</span><br><span class="line">      <span class="attr">password</span>: <span class="string">&quot;iwen123&quot;</span>,</span><br><span class="line">      <span class="attr">verification_code</span>: <span class="string">&quot;crfvw&quot;</span></span><br><span class="line">    &#125;))</span><br><span class="line">      .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="property">data</span>);</span><br><span class="line">      &#125;)</span><br></pre></td></tr></table></figure><h4 id="Axios网络请求封装"><a href="#Axios网络请求封装" class="headerlink" title="Axios网络请求封装"></a>Axios网络请求封装</h4><p>在日常应用过程中，一个项目中的网络请求会很多，此时一般采取的方案是将网络请求封装起来。</p><p>参考文档:<a href="https://www.kancloud.cn/yunye/axios/234845">https://www.kancloud.cn/yunye/axios/234845</a></p><p>在<code>src</code>目录下创建文件夹<code>utils</code>，并创建文件<code>request.js</code>，用来存储网络请求对象 <code>axios</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//request.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span></span><br><span class="line"><span class="keyword">import</span> qs <span class="keyword">from</span> <span class="string">&quot;querystring&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">errorHandle</span> = (<span class="params">status,info</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">switch</span>(status)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">400</span>:</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;语义有误&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">401</span>:</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;服务器认证失败&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">403</span>:</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;服务器拒绝访问&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">404</span>:</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;地址错误&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">500</span>:</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;服务器遇到意外&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">502</span>:</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;服务器无响应&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="attr">default</span>:</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(info);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">    <span class="comment">// 网络请求的公共配置</span></span><br><span class="line">    <span class="attr">timeout</span>:<span class="number">5000</span>  </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置拦截器</span></span><br><span class="line"><span class="comment">// 发送数据之前</span></span><br><span class="line">instance.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>( </span><br><span class="line">    <span class="comment">// 网络请求成功 </span></span><br><span class="line">    <span class="function"><span class="params">config</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(config.<span class="property">method</span> === <span class="string">&quot;post&quot;</span>)&#123; <span class="comment">// post请求参数是需要额外处理的</span></span><br><span class="line">            config.<span class="property">data</span> = qs.<span class="title function_">stringify</span>(config.<span class="property">data</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// config包含网络请求的所有信息</span></span><br><span class="line">        <span class="keyword">return</span> config;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 网络请求失败</span></span><br><span class="line">    <span class="function"><span class="params">error</span> =&gt;</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error) <span class="comment">// Promise.resolve()是JavaScript的一个特性，用于创建一个新的 Promise 对象</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取数据之前</span></span><br><span class="line">instance.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(</span><br><span class="line">    <span class="comment">// 网络请求成功</span></span><br><span class="line">    <span class="comment">// resolve返回成功，reject返回失败</span></span><br><span class="line">    <span class="function"><span class="params">response</span> =&gt;</span> response.<span class="property">status</span> === <span class="number">200</span> ? <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(response) : <span class="title class_">Promise</span>.<span class="title function_">reject</span>(response),</span><br><span class="line">    <span class="comment">// 网络请求失败</span></span><br><span class="line">    <span class="function"><span class="params">error</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; response &#125; = error; <span class="comment">// 等价于const response = error.response;</span></span><br><span class="line">        <span class="title function_">errorHandle</span>(response.<span class="property">status</span>,response.<span class="property">info</span>) <span class="comment">// 调用errorHandle返回错误</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> instance;</span><br></pre></td></tr></table></figure><p>在<code>src</code>目录下创建文件夹<code>api</code>，并创建文件<code>index</code>和<code>path</code>分别用来存放网络请求方法和请求路径</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// path.js</span></span><br><span class="line"><span class="keyword">const</span> base = &#123;</span><br><span class="line">    <span class="attr">baseUrl</span>:<span class="string">&quot;http://iwenwiki.com&quot;</span>,</span><br><span class="line">    <span class="attr">chengpin</span>:<span class="string">&quot;/api/blueberrypai/getChengpinDetails.php&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> base</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">&quot;./path&quot;</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&quot;../utils/request&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="title function_">getChengpin</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> axios.<span class="title function_">get</span>(path.<span class="property">baseUrl</span> + path.<span class="property">chengpin</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在组件中直接调用网络请求</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> api <span class="keyword">from</span> <span class="string">&quot;../api/index&quot;</span></span><br><span class="line"></span><br><span class="line">api.<span class="title function_">getChengpin</span>().<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="property">data</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="网络请求跨域问题"><a href="#网络请求跨域问题" class="headerlink" title="网络请求跨域问题"></a>网络请求跨域问题</h4><p>JS采取的是同源策略</p><p>同源策略是浏览器的一项安全策略，浏览器只允许js 代码请求和当前所在服务器域名,端口,协议相同的数据接口上的数据,这就是同源策略.</p><p>也就是说，当协议、域名、端口任意一个不相同时，都会产生跨域问题，所以又应该如何解决跨域问题呢</p><h5 id="跨域错误提示信息"><a href="#跨域错误提示信息" class="headerlink" title="跨域错误提示信息"></a>跨域错误提示信息</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240806160603889.png" alt="image-20240806160603889" style="zoom: 50%;" /><h5 id="目前主流的跨域解决方案"><a href="#目前主流的跨域解决方案" class="headerlink" title="目前主流的跨域解决方案"></a>目前主流的跨域解决方案</h5><ol><li>后台解决：cors</li><li>前台解决：proxy</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="attr">proxy</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;/api&#x27;</span>: &#123;</span><br><span class="line">        <span class="attr">target</span>: <span class="string">&#x27;&lt;url&gt;&#x27;</span>,</span><br><span class="line">        <span class="attr">changeOrigin</span>: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在vue.config.js，添加devServer</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240806161232789.png" alt="image-20240806161232789" style="zoom:33%;" /><p>删掉模块中的域名</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240806161214591.png" alt="image-20240806161214591" style="zoom:33%;" /><blockquote><p><strong>温馨提示</strong></p><p>解决完跨域配置之后，要重启服务器</p></blockquote><h3 id="引入路由配置"><a href="#引入路由配置" class="headerlink" title="引入路由配置"></a>引入路由配置</h3><p>官方文档：cn.vuejs.org</p><p>在Vue中，我们可以通过<code>vue-router</code>路由管理页面之间的关系</p><p>Vue Router 是 Vue.js 的官方路由。它与 Vue.js 核心深度集成，让用 Vue.js 构建单页应用变得轻而易举</p><h4 id="在Vue中引入路由"><a href="#在Vue中引入路由" class="headerlink" title="在Vue中引入路由"></a>在Vue中引入路由</h4><p>第一步：安装路由 <code>npm install --save vue-router</code></p><p>第二步：配置独立的路由文件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; createRouter, createWebHashHistory &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="comment">// import &#123; createRouter, createWebHistory &#125; from &#x27;vue-router&#x27; </span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">HomeView</span> <span class="keyword">from</span> <span class="string">&#x27;../views/HomeView.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">AboutView</span> <span class="keyword">from</span> <span class="string">&#x27;../views/AboutView.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置路由</span></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;home&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="title class_">HomeView</span>   <span class="comment">// 绑定组件</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;about&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="title class_">AboutView</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将路由添加到路由对象</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">  <span class="attr">history</span>: <span class="title function_">createWebHashHistory</span>(), <span class="comment">// history：访问方式</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  createWebHashHistory</span></span><br><span class="line"><span class="comment">home:http://localhost:8080/#/</span></span><br><span class="line"><span class="comment">about:http://localhost:8080/#/about</span></span><br><span class="line"><span class="comment">原理:a标签锚点连接</span></span><br><span class="line"><span class="comment">createWebHistory</span></span><br><span class="line"><span class="comment">home:http://localhost:8080/</span></span><br><span class="line"><span class="comment">about:http://localhost:8080/about</span></span><br><span class="line"><span class="comment">此种方式，需要后台配合做重定向，否则会出现404问题</span></span><br><span class="line"><span class="comment">原理:H5 pushstate()</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">  routes</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure><p>第三步：引入路由到项目</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span></span><br><span class="line">app.<span class="title function_">use</span>(router)</span><br></pre></td></tr></table></figure><p>第四步：指定路由显示入口 <code>&lt;router-view/&gt;</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//app.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;router-view/&gt;</span><br><span class="line">&lt;template&gt;</span><br></pre></td></tr></table></figure><p>第五步：指定路由跳转</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//app.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;router-link to=&quot;/&quot;&gt;Home&lt;/router-link&gt; |</span><br><span class="line">&lt;router-link to=&quot;/about&quot;&gt;About&lt;/router-link&gt;</span><br><span class="line">&lt;router-view&gt;&lt;router-view/&gt;</span><br><span class="line">&lt;template&gt;</span><br></pre></td></tr></table></figure><h4 id="路由传递参数"><a href="#路由传递参数" class="headerlink" title="路由传递参数"></a>路由传递参数</h4><p>页面跳转过程中，是可以携带参数的，这也是很常见的业务</p><p>例如：在一个列表项，点击进入查看每个列表项的详情</p><p>第一步：在路由配置中指定参数的<code>key</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">path</span>:<span class="string">&quot;/list/:name&quot;</span>, <span class="comment">// :name接收参数的key</span></span><br><span class="line">    <span class="attr">name</span>:<span class="string">&quot;list&quot;</span>, <span class="comment">// 可以省略</span></span><br><span class="line">    <span class="attr">component</span>:<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;../views/ListView.vue&quot;</span>) <span class="comment">// 异步导入组件，减少资源消耗</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步：在跳转过程中携带参数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;li&gt;&lt;router-link to=&quot;/list/内蒙&quot;&gt;内蒙旅游十大景区&lt;/router-link&gt;&lt;/li&gt; // 参数传递给:name</span><br><span class="line">&lt;li&gt;&lt;router-link to=&quot;/list/北京&quot;&gt;北京旅游十大景区&lt;/router-link&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;router-link to=&quot;/list/四川&quot;&gt;四川旅游十大景区&lt;/router-link&gt;&lt;/li&gt;</span><br></pre></td></tr></table></figure><p>第三步：在详情页面读取路由携带的参数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;&#123;&#123; $route.params.name &#125;&#125;城市旅游景区详情&lt;/p&gt;</span><br></pre></td></tr></table></figure><h4 id="嵌套路由配置"><a href="#嵌套路由配置" class="headerlink" title="嵌套路由配置"></a>嵌套路由配置</h4><p>二级路由</p><p>路由嵌套是非常常见的需求</p><p>第一步：创建子路由要加载显示的页面</p><p>第二步：在路由配置文件中添加子路由配置</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">path</span>:<span class="string">&quot;/news&quot;</span>,</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&quot;news&quot;</span>,</span><br><span class="line">    <span class="comment">// 重定向配置</span></span><br><span class="line">    <span class="attr">redirect</span>:<span class="string">&quot;/news/baidu&quot;</span>,</span><br><span class="line">    <span class="attr">component</span>:<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;../views/NewsView.vue&quot;</span>),</span><br><span class="line">        <span class="comment">// 配置二级路由，路径不加/</span></span><br><span class="line">    <span class="attr">children</span>:[</span><br><span class="line">       &#123;</span><br><span class="line">       <span class="attr">path</span>:<span class="string">&quot;baidu&quot;</span>,</span><br><span class="line">            <span class="attr">component</span>:<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;../views/NewsList/BaiduNews.vue&quot;</span>),</span><br><span class="line">       &#125;,</span><br><span class="line">       &#123;</span><br><span class="line">            <span class="attr">path</span>:<span class="string">&quot;wangyi&quot;</span>,</span><br><span class="line">            <span class="attr">component</span>:<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;../views/NewsList/WangyiNews.vue&quot;</span>),</span><br><span class="line">       &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三步：指定子路由显示位置<code>&lt;router-view&gt;&lt;/router-view&gt;</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// news.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>第四步：添加子路由跳转链接</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div class=&quot;about&quot;&gt;</span><br><span class="line">&lt;router-link to=&quot;/news/baidu&quot;&gt;百度新闻&lt;/router-link&gt; | </span><br><span class="line">&lt;router-link to=&quot;/news/wangyi&quot;&gt;网易新闻&lt;/router-link&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>第五步：重定向配置，默认显示的页面</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">redirect</span>:<span class="string">&quot;/news/baidu&quot;</span>,</span><br></pre></td></tr></table></figure><h3 id="引入Vue状态管理-Vuex"><a href="#引入Vue状态管理-Vuex" class="headerlink" title="引入Vue状态管理(Vuex)"></a>引入Vue状态管理(Vuex)</h3><p>Vuex 是一个专为 Vue.js 应用程序开发的<strong>状态管理模式 + 库</strong>。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p><p>简单来说，状态管理可以理解成为了更方便的管理组件之间的数据交互，提供了一个集中式的管理方案，任何组件都可以按照指定的方式进行读取和改变数据</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240807152218569.png" alt="image-20240807152218569" style="zoom: 50%;" /><h4 id="引入Vuex的步骤"><a href="#引入Vuex的步骤" class="headerlink" title="引入Vuex的步骤"></a>引入Vuex的步骤</h4><p>第一步：安装Vuex <code>npm install --save vuex</code></p><p>第二步：创建store文件夹和index.js文件，配置Vuex文件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 简化写法</span></span><br><span class="line"><span class="comment">// Vuex核心作用管理组件的状态</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">createStore</span>(&#123;</span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">      <span class="attr">counter</span>:<span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">const state = createStore(&#123;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">&#125;)</span></span><br><span class="line"><span class="comment">export default state;</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure><p>第三步：在主文件中引入Vuex</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span></span><br><span class="line">app.<span class="title function_">use</span>(store)</span><br></pre></td></tr></table></figure><p>第四步：在组件中读取状态</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;counter:&#123;&#123; $store.state.counter &#125;&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 或者</span><br><span class="line">import &#123; mapState &#125; from &#x27;vuex&#x27;; // 快捷读取数据</span><br><span class="line">computed:&#123; // 属性计算</span><br><span class="line">    ...mapState([&quot;counter&quot;])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 直接读取</span><br><span class="line">&lt;p&gt;&#123;&#123; counter &#125;&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure><h4 id="Vue状态管理核心-Vuex"><a href="#Vue状态管理核心-Vuex" class="headerlink" title="Vue状态管理核心(Vuex)"></a>Vue状态管理核心(Vuex)</h4><p>最常用的核心概念包含: <code>State</code>、<code>Getter</code>、<code>Mutation</code>、<code>Action</code></p><h5 id="Getter"><a href="#Getter" class="headerlink" title="Getter"></a>Getter</h5><p>对Vuex中的数据进行过滤</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">createStore</span>(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">counter</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">getters</span>: &#123;</span><br><span class="line">    <span class="title function_">getCount</span>(<span class="params">state</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> state.<span class="property">counter</span> &gt; <span class="number">0</span> ? state.<span class="property">counter</span> : <span class="string">&quot;counter小于0，不符合要求&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapState,mapGetters &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span>;</span><br><span class="line"><span class="attr">computed</span>:&#123;</span><br><span class="line">    ...<span class="title function_">mapGetters</span>([<span class="string">&quot;getCount&quot;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Mutation"><a href="#Mutation" class="headerlink" title="Mutation"></a>Mutation</h5><p>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的事件类型 (type)和一个回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">createStore</span>(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">counter</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">getters</span>: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="title function_">setCounter</span>(<span class="params">state, num</span>) &#123;</span><br><span class="line">      state.<span class="property">counter</span> += num</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapState,mapMutations &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line">    ...<span class="title function_">mapMutations</span>([<span class="string">&quot;setCounter&quot;</span>]),</span><br><span class="line">    <span class="title function_">clickHandler</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="comment">// this.$store.commit(&quot;setCounter&quot;,20)</span></span><br><span class="line">  <span class="comment">// 或者</span></span><br><span class="line">      <span class="comment">// this.setCounter(10)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h5><p>Action 类似于 mutation，不同在于：</p><ul><li>Action 提交的是 mutation，而不是直接变更状态</li><li>Action 可以包含任意异步操作</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">createStore</span>(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">counter</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">getters</span>: &#123;</span><br><span class="line">    <span class="title function_">getCount</span>(<span class="params">state</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> state.<span class="property">counter</span> &gt; <span class="number">0</span> ? state.<span class="property">counter</span> : <span class="string">&quot;counter小于0，不符合要求&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="title function_">setCounter</span>(<span class="params">state, num</span>) &#123;</span><br><span class="line">      state.<span class="property">counter</span> += num</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">    <span class="title function_">asyncSetCount</span>(<span class="params">&#123; commit &#125;</span>)&#123; <span class="comment">// 对象结构赋值</span></span><br><span class="line">      axios.<span class="title function_">get</span>(<span class="string">&quot;http://iwenwiki.com/api/generator/list.php&quot;</span>)</span><br><span class="line">      .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="title function_">commit</span>(<span class="string">&quot;setCounter&quot;</span>,res.<span class="property">data</span>[<span class="number">0</span>])</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapState,mapMutations,mapGetters,mapActions &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line">    ...<span class="title function_">mapActions</span>([<span class="string">&quot;asyncSetCount&quot;</span>]),</span><br><span class="line">    <span class="title function_">clickAsyncHandler</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="comment">// this.$store.dispatch(&quot;asyncSetCount&quot;)</span></span><br><span class="line">        <span class="comment">// 或者</span></span><br><span class="line">        <span class="comment">// this.asyncSetCount()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="15-Vue3新特性1"><a href="#15-Vue3新特性1" class="headerlink" title="15.Vue3新特性1"></a>15.Vue3新特性1</h2><p>Vue3是目前Vue的最新版本，自然也是新增了很多新特性</p><h3 id="六大亮点"><a href="#六大亮点" class="headerlink" title="六大亮点"></a>六大亮点</h3><ul><li>Performance：性能更比Vue 2.0强。</li><li>Tree shaking support：可以将无用模块“剪辑”，仅打包需要的。</li><li><strong>Composition API：组合API</strong></li><li>Fragment, Teleport, Suspense：“碎片”，Teleport即Protal传送门，“悬念”</li><li>Better TypeScript support：更优秀的Ts支持</li><li>Custom Renderer API：暴露了自定义渲染API</li></ul><h3 id="ref或者reactive"><a href="#ref或者reactive" class="headerlink" title="ref或者reactive"></a>ref或者reactive</h3><p>在2.x中通过组件data的方法来定义一些当前组件的数据</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;iwen&#x27;</span>,</span><br><span class="line">    <span class="attr">list</span>: [],</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在3.x中通过ref或者reactive创建响应式对象</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref,reactive &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;HelloWorld&#x27;</span>,</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="keyword">const</span> name = <span class="title function_">ref</span>(<span class="string">&quot;iwen&quot;</span>)</span><br><span class="line">      <span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">          <span class="attr">list</span>:[]</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 外部要访问，必须return</span></span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">        name,</span><br><span class="line">        state</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="methods中定义的方法写在setup"><a href="#methods中定义的方法写在setup" class="headerlink" title="methods中定义的方法写在setup()"></a>methods中定义的方法写在setup()</h3><p>在2.x中methods来定义一些当前组件内部方法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line">    <span class="title function_">clickHandle</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在3.x中直接在setup方法中定义并return</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">clickHandle</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      clickHandle</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="setup-中使用props和context"><a href="#setup-中使用props和context" class="headerlink" title="setup()中使用props和context"></a>setup()中使用props和context</h3><p>在2.x中，组件的方法中可以通过this获取到当前组件的实例，并执行data变量的修改，方法的调用，组件的通信等等，但是在3.x中，setup()在beforeCreate和created时机就已调用，无法使用和2.x一样的this，但是可以通过接收setup(props,ctx)的方法，获取到当前组件的实例和props</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// 任然需要指定poprs的类型</span></span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="title class_">String</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  <span class="title function_">setup</span>(<span class="params">props,ctx</span>) &#123;  <span class="comment">// 接收参数,ctx为当前实例对象</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(props.<span class="property">name</span>)</span><br><span class="line">    ctx.<span class="title function_">emit</span>(<span class="string">&#x27;event&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="16-Vue3新特性2"><a href="#16-Vue3新特性2" class="headerlink" title="16.Vue3新特性2"></a>16.Vue3新特性2</h2><h3 id="在setup中使生命周期函数"><a href="#在setup中使生命周期函数" class="headerlink" title="在setup中使生命周期函数"></a>在setup中使生命周期函数</h3><p>你可以通过在生命周期钩子前面加上 “on” 来访问组件的生命周期钩子。</p><p>下表包含如何在 setup () 内部调用生命周期钩子</p><table><thead><tr><th>Options API</th><th>Hook inside setup</th></tr></thead><tbody><tr><td>beforeCreate</td><td>Not needed*</td></tr><tr><td>created</td><td>Not needed*</td></tr><tr><td>beforeMount</td><td>onBeforeMount</td></tr><tr><td>mounted</td><td>onMounted</td></tr><tr><td>beforeUpdate</td><td>onBeforeUpdate</td></tr><tr><td>updated</td><td>onUpdated</td></tr><tr><td>beforeUnmount</td><td>onBeforeUnmount</td></tr><tr><td>unmounted</td><td>onUnmounted</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; onMounted &#125;<span class="keyword">from</span> <span class="string">&quot;Vue&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 此时可以存在多个onMounted</span></span><br><span class="line">    <span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Component is mounted!&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Component is mounted!&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Provide-Inject"><a href="#Provide-Inject" class="headerlink" title="Provide &#x2F; Inject"></a>Provide &#x2F; Inject</h3><ul><li>provide() 和 inject() 可以实现嵌套组件之间的数据传递。</li><li>这两个函数只能在 setup() 函数中使用。</li><li>父级组件中使用 provide() 函数向下传递数据。</li><li>子级组件中使用 inject() 获取上层传递过来的数据。</li><li>不限层级</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line"><span class="keyword">import</span> &#123; provide &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">provide</span>(<span class="string">&quot;customVal&quot;</span>, <span class="string">&quot;我是父组件向子组件传递的值&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子组件</span></span><br><span class="line"><span class="keyword">import</span> &#123; inject &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> customVal = <span class="title function_">inject</span>(<span class="string">&quot;customVal&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      customVal</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h3><p>Fragment翻译为：“碎片”</p><ul><li>不再限于模板中的单个根节点</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 2.x</span><br><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;div&gt;</span><br><span class="line">   &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot;&gt;</span><br><span class="line">   &lt;HelloWorld msg=&quot;Welcome to Your Vue.js App&quot; /&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 3.x</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot;&gt;</span><br><span class="line">  &lt;HelloWorld msg=&quot;Welcome to Your Vue.js App&quot; /&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><h3 id="Vue3加载Element-plus"><a href="#Vue3加载Element-plus" class="headerlink" title="Vue3加载Element-plus"></a>Vue3加载Element-plus</h3><p>官网：element.eleme.cn</p><p>Element，一套为开发者、设计师和产品经理准备的基于 <code>Vue 2.0</code> 的桌面端组件库</p><p>Element Plus 基于 <code>Vue 3</code>，面向设计师和开发者的组件库</p><h4 id="安装Element-Plus"><a href="#安装Element-Plus" class="headerlink" title="安装Element-Plus"></a>安装Element-Plus</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install element-plus --save</span><br></pre></td></tr></table></figure><h4 id="完整引用"><a href="#完整引用" class="headerlink" title="完整引用"></a>完整引用</h4><p>如果你对打包后的文件大小不是很在乎，那么使用完整导入会更方便</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ElementPlus</span> <span class="keyword">from</span> <span class="string">&#x27;element-plus&#x27;</span> <span class="comment">// 引用ElementPlus</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;element-plus/dist/index.css&#x27;</span> <span class="comment">// 引用css</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title class_">ElementPlus</span>) <span class="comment">// 加载</span></span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="按需导入"><a href="#按需导入" class="headerlink" title="按需导入"></a>按需导入</h4><p>按需导入才是我们的最爱，毕竟在真实的应用场景中并不是每个组件都会用到，这会造成不小的浪费</p><p>首先你需要安装<code>unplugin-vue-components</code> 和 <code>unplugin-auto-import</code>这两款插件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install -D unplugin-vue-components unplugin-auto-<span class="keyword">import</span></span><br></pre></td></tr></table></figure><p>然后修改<code>vue.config.js</code>配置文件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; defineConfig &#125; = <span class="built_in">require</span>(<span class="string">&#x27;@vue/cli-service&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">AutoImport</span> = <span class="built_in">require</span>(<span class="string">&#x27;unplugin-auto-import/webpack&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Components</span> = <span class="built_in">require</span>(<span class="string">&#x27;unplugin-vue-components/webpack&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">ElementPlusResolver</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;unplugin-vue-components/resolvers&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">transpileDependencies</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">configureWebpack</span>: &#123;</span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">      <span class="title class_">AutoImport</span>(&#123;</span><br><span class="line">        <span class="attr">resolvers</span>: [<span class="title class_">ElementPlusResolver</span>()]</span><br><span class="line">      &#125;),</span><br><span class="line">      <span class="title class_">Components</span>(&#123;</span><br><span class="line">        <span class="attr">resolvers</span>: [<span class="title class_">ElementPlusResolver</span>()]</span><br><span class="line">      &#125;)</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>最后，可以直接在组件中使用</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-button</span>&gt;</span>Default<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span>&gt;</span>Primary<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="17-Vue3加载Element-plus的字体图标"><a href="#17-Vue3加载Element-plus的字体图标" class="headerlink" title="17.Vue3加载Element-plus的字体图标"></a>17.Vue3加载Element-plus的字体图标</h2><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240807163718727.png" alt="image-20240807163718727" style="zoom: 50%;" /><p><code>Element-plus</code>不仅仅是提供了各种组件，同时还提供了一整套的字体图标方便开发者使用</p><h3 id="安装icons字体图标"><a href="#安装icons字体图标" class="headerlink" title="安装icons字体图标"></a>安装<code>icons</code>字体图标</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install @element-plus/icons-vue</span><br></pre></td></tr></table></figure><h3 id="全局注册-1"><a href="#全局注册-1" class="headerlink" title="全局注册"></a>全局注册</h3><p>在项目根目录下，创建<code>plugins</code>文件夹，在文件夹下创建文件<code>icons.js</code>文件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> components <span class="keyword">from</span> <span class="string">&quot;@element-plus/icons-vue&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">install</span>: <span class="function">(<span class="params">app</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> components) &#123;</span><br><span class="line">            <span class="keyword">const</span> componentConfig = components[key];</span><br><span class="line">            app.<span class="title function_">component</span>(componentConfig.<span class="property">name</span>, componentConfig);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="引入文件"><a href="#引入文件" class="headerlink" title="引入文件"></a>引入文件</h3><p>在<code>main.js</code>中引入<code>icons.js</code>文件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> elementIcon <span class="keyword">from</span> <span class="string">&quot;./plugins/icons&quot;</span>;</span><br><span class="line">app.<span class="title function_">use</span>(elementIcon)</span><br></pre></td></tr></table></figure><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>接下来就可以直接在组件中引入使用了</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-icon</span> <span class="attr">class</span>=<span class="string">&quot;expand&quot;</span> <span class="attr">color</span>=<span class="string">&quot;#409EFC&quot;</span> <span class="attr">:size</span>=<span class="string">&quot;30&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">expand</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-icon</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软考大题</title>
      <link href="/post/456f3b0e.html"/>
      <url>/post/456f3b0e.html</url>
      
        <content type="html"><![CDATA[<h3 id="第一大题"><a href="#第一大题" class="headerlink" title="第一大题"></a>第一大题</h3><h4 id="第三问：寻找缺失数据流"><a href="#第三问：寻找缺失数据流" class="headerlink" title="第三问：寻找缺失数据流"></a>第三问：寻找缺失数据流</h4><p>寻找缺失数据流：</p><p>1.父图子图平衡。</p><p>2.加工既有输入数据流，也有输出数据流。</p><p>3.功能在子图中都有实现。</p><h4 id="第四问："><a href="#第四问：" class="headerlink" title="第四问："></a>第四问：</h4><h5 id="结构化开发语言："><a href="#结构化开发语言：" class="headerlink" title="结构化开发语言："></a>结构化开发语言：</h5><p>IF</p><p>​THEN</p><p>ELSE</p><p>ENDIF</p><h5 id="数据流的组成"><a href="#数据流的组成" class="headerlink" title="数据流的组成"></a>数据流的组成</h5><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240515211941252.png" alt="image-20240515211941252"></p><h5 id="保持数据流图平衡"><a href="#保持数据流图平衡" class="headerlink" title="保持数据流图平衡"></a>保持数据流图平衡</h5><p> <img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240515205348962.png" alt="image-20240515205348962"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240506194427034.png" alt="image-20240506194427034"></p><h5 id="加工的三种常见错误"><a href="#加工的三种常见错误" class="headerlink" title="加工的三种常见错误"></a>加工的三种常见错误</h5><p>黑洞、白洞、灰洞</p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240515204636285.png" alt="image-20240515204636285"></p><h3 id="第二大题"><a href="#第二大题" class="headerlink" title="第二大题"></a>第二大题</h3><h4 id="第二问：根据关系模式补全属性"><a href="#第二问：根据关系模式补全属性" class="headerlink" title="第二问：根据关系模式补全属性"></a>第二问：根据关系模式补全属性</h4><p>根据关系模式补全属性：</p><p>技巧</p><ol><li><p>1对1的联系，将1端实体的主键，加入*方的关系模式去。</p></li><li><p>*对 * 的联系，转换成独立的关系模式。</p></li></ol><h4 id="第三问：主键与外键-完整性约束"><a href="#第三问：主键与外键-完整性约束" class="headerlink" title="第三问：主键与外键(完整性约束)"></a>第三问：主键与外键(完整性约束)</h4><p><strong>实体完整性—&gt;主键</strong></p><p><strong>参照完整性—&gt;外键</strong></p><p>实体：</p><ul><li>主键：当前实体的唯一标识。</li><li>外键：当前实体中的，其他实体主键。</li></ul><p>联系（*对 *）：</p><ul><li>主键：多方实体的主键组成的属性组。带括号（…，…）</li><li>外键：当前实体中的，多方实体的主键。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240423202450240.png" alt="image-20240423202450240"></p><h4 id="第四问：关系模式存在的问题"><a href="#第四问：关系模式存在的问题" class="headerlink" title="第四问：关系模式存在的问题"></a>第四问：关系模式存在的问题</h4><p>2020</p><h5 id="数据冗余："><a href="#数据冗余：" class="headerlink" title="数据冗余："></a>数据冗余：</h5><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240420201150670.png" alt="image-20240420201150670"></p><p>不满足2NF：</p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240420211358058.png" alt="image-20240420211358058"></p><p>分解满足2NF：</p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240420211657307.png" alt="image-20240420211657307"></p><h5 id="传递函数依赖："><a href="#传递函数依赖：" class="headerlink" title="传递函数依赖："></a>传递函数依赖：</h5><p>X–&gt;Y，Y–&gt;Z  &#x3D;&gt; X(主属性)–&gt;Z(非主属性)</p><p>存在非主属性对主属性的传递函数依赖。</p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240423204114558.png" alt="image-20240423204114558"></p><h5 id="是否需要新加实体"><a href="#是否需要新加实体" class="headerlink" title="是否需要新加实体"></a>是否需要新加实体</h5><p>如果实体之间是多对多的关系，则可以不新加实体，而是在多方实体之间建立独立的关系模式，然后将多方主键加入联系中。</p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240501213937431.png" alt="image-20240501213937431"></p><h3 id="第三大题："><a href="#第三大题：" class="headerlink" title="第三大题："></a>第三大题：</h3><h4 id="第二问："><a href="#第二问：" class="headerlink" title="第二问："></a>第二问：</h4><h5 id="基本-备选事件流"><a href="#基本-备选事件流" class="headerlink" title="基本&#x2F;备选事件流"></a>基本&#x2F;备选事件流</h5><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240426213429332.png" alt="image-20240426213429332"></p><h5 id="类图确定类名"><a href="#类图确定类名" class="headerlink" title="类图确定类名"></a>类图确定类名</h5><p>找出类图中的类名。</p><p>技巧：看箭头指向可以确定</p><ul><li>泛化关系和实现关系：儿子指向父亲，子类指向父类。</li></ul><p>扩展知识：</p><p>看+、-、# 可以确定访问修饰符</p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240426214129188.png" alt="image-20240426214129188"></p><h4 id="第三问："><a href="#第三问：" class="headerlink" title="第三问："></a>第三问：</h4><h5 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h5><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240501214941410.png" alt="image-20240501214941410"></p><h5 id="包含与扩展的含义"><a href="#包含与扩展的含义" class="headerlink" title="包含与扩展的含义"></a>包含与扩展的含义</h5><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240516203507043.png" alt="image-20240516203507043"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 软考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软考选择</title>
      <link href="/post/58c57250.html"/>
      <url>/post/58c57250.html</url>
      
        <content type="html"><![CDATA[<h4 id="错题集"><a href="#错题集" class="headerlink" title="错题集"></a>错题集</h4><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240513224024695.png" alt="image-20240513224024695"></p><h5 id="计算机基本原理"><a href="#计算机基本原理" class="headerlink" title="计算机基本原理"></a>计算机基本原理</h5><h6 id="浮点数对阶"><a href="#浮点数对阶" class="headerlink" title="浮点数对阶"></a><strong>浮点数对阶</strong></h6><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240502170846594.png" alt="image-20240502170846594"></p><h6 id="浮点数表示范围"><a href="#浮点数表示范围" class="headerlink" title="浮点数表示范围"></a>浮点数表示范围</h6><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240510211055563.png" alt="image-20240510211055563"></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240507175409093.png" style="zoom: 67%;" /><h6 id="海明码"><a href="#海明码" class="headerlink" title="海明码"></a><strong>海明码</strong></h6><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240502171611470.png" alt="image-20240502171611470"></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240503165000451.png" alt="image-20240503165000451" style="zoom:67%;" /><h6 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h6><p><strong>吞吐率：最长流水段操作时间的倒数。</strong></p><p><strong>流水线周期：执行时间最长的一段。</strong></p><p><em><em>流水线计算公式：1条指令完成时间 + （指令条数 - 1）</em> 流水线周期</em>*</p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240502180912020.png" alt="image-20240502180912020"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240510213031765.png" alt="image-20240510213031765"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240510213631561.png" alt="image-20240510213631561"></p><h6 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h6><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240427172613771.png" alt="image-20240427172613771" style="zoom: 50%;" /><h6 id="DRAM和SRAM存储器"><a href="#DRAM和SRAM存储器" class="headerlink" title="DRAM和SRAM存储器"></a>DRAM和SRAM存储器</h6><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240516182927004.png" alt="image-20240516182927004" style="zoom: 50%;" /><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240503164512948.png"></p><h6 id="RISC和CISC"><a href="#RISC和CISC" class="headerlink" title="RISC和CISC"></a>RISC和CISC</h6><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240516183617850.png" alt="image-20240516183617850" style="zoom: 50%;" /><h6 id="输入输出控制"><a href="#输入输出控制" class="headerlink" title="输入输出控制"></a>输入输出控制</h6><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240503165545621.png" alt="image-20240503165545621"></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240505164821755.png" alt="image-20240505164821755" style="zoom:150%;" /><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240511180045202.png" alt="image-20240511180045202"></p><h5 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h5><h6 id="排序算法复杂度"><a href="#排序算法复杂度" class="headerlink" title="排序算法复杂度"></a>排序算法复杂度</h6><p>记忆技巧：3，2，1</p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240510212850594.png" alt="image-20240510212850594"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240503181625437.png" alt="image-20240503181625437"></p><h6 id="时间复杂度递归式"><a href="#时间复杂度递归式" class="headerlink" title="时间复杂度递归式"></a>时间复杂度递归式</h6><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240511191151745.png" alt="image-20240511191151745"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240514200213321.png" alt="image-20240514200213321"></p><h6 id="0-1-部分背包问题、"><a href="#0-1-部分背包问题、" class="headerlink" title="0-1&#x2F;部分背包问题、"></a>0-1&#x2F;部分背包问题、</h6><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240508182239436.png" alt="image-20240508182239436"></p><h6 id="拓扑序列"><a href="#拓扑序列" class="headerlink" title="拓扑序列"></a>拓扑序列</h6><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240507191341512.png" alt="image-20240507191341512"></p><h6 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h6><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240510222958927.png" alt="image-20240510222958927"></p><h6 id="短路运算"><a href="#短路运算" class="headerlink" title="短路运算"></a>短路运算</h6><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240518171631746.png" alt="image-20240518171631746"></p><h6 id="算数表达式栈运算"><a href="#算数表达式栈运算" class="headerlink" title="算数表达式栈运算"></a>算数表达式栈运算</h6><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240518175401578.png" alt="image-20240518175401578"></p><h6 id="有向图存储"><a href="#有向图存储" class="headerlink" title="有向图存储"></a>有向图存储</h6><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240518175849749.png" alt="image-20240518175849749"></p><h5 id="操作系统基本原理"><a href="#操作系统基本原理" class="headerlink" title="操作系统基本原理"></a>操作系统基本原理</h5><h6 id="文件存储"><a href="#文件存储" class="headerlink" title="文件存储"></a>文件存储</h6><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240502183359245.png" alt="image-20240502183359245"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240503171435513.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240503172454425.png" alt="image-20240503172454425"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240505172703001.png" alt="image-20240505172703001"></p><h6 id="IO系统层次结构"><a href="#IO系统层次结构" class="headerlink" title="IO系统层次结构"></a>IO系统层次结构</h6><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240502183552530.png" alt="image-20240502183552530"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240508172946634.png" alt="image-20240508172946634"></p><h6 id="缓冲时间计算"><a href="#缓冲时间计算" class="headerlink" title="缓冲时间计算"></a>缓冲时间计算</h6><p>单缓冲区使用公式计算，双缓冲区使用流水线方式计算。</p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240509140616875.png" alt="image-20240509140616875"></p><h6 id="信号量与PV操作"><a href="#信号量与PV操作" class="headerlink" title="信号量与PV操作"></a>信号量与PV操作</h6><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240511193838090.png" alt="image-20240511193838090"></p><h6 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h6><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240517181905693.png" alt="image-20240517181905693"></p><h5 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h5><h6 id="数据库三级模式"><a href="#数据库三级模式" class="headerlink" title="数据库三级模式"></a>数据库三级模式</h6><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240427170012783.png" alt="image-20240427170012783" style="zoom:67%;" /><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240503175207226.png" alt="image-20240503175207226"></p><h6 id="数据库基本概念"><a href="#数据库基本概念" class="headerlink" title="数据库基本概念"></a>数据库基本概念</h6><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240427170320855.png" alt="image-20240427170320855" style="zoom:67%;" /><h6 id="UML中的关系"><a href="#UML中的关系" class="headerlink" title="UML中的关系"></a>UML中的关系</h6><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240503174150082.png" alt="image-20240503174150082"></p><h6 id="模式分解"><a href="#模式分解" class="headerlink" title="模式分解"></a>模式分解</h6><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240510222401755.png" alt="image-20240510222401755"></p><h5 id="网络技术"><a href="#网络技术" class="headerlink" title="网络技术"></a>网络技术</h5><h6 id="iso七层模型"><a href="#iso七层模型" class="headerlink" title="iso七层模型"></a>iso七层模型</h6><p>应用层</p><p>表示层</p><p>会话层</p><p>传输层 IP</p><p>网络层 TCP&#x2F;UDP</p><p>数据链路层</p><p>物理层</p><h6 id="地址计算"><a href="#地址计算" class="headerlink" title="地址计算"></a>地址计算</h6><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240511192349981.png" alt="image-20240511192349981"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240513213917482.png" alt="image-20240513213917482"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240512184017735.png" alt="image-20240512184017735"></p><h6 id="TCP-IP协议"><a href="#TCP-IP协议" class="headerlink" title="TCP&#x2F;IP协议"></a>TCP&#x2F;IP协议</h6><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240507194326758.png" alt="image-20240507194326758"></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240427201045864.png" alt="image-20240427201045864" style="zoom: 33%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240505183037718.png" alt="image-20240505183037718" style="zoom: 50%;" /><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240513224623452.png" alt="image-20240513224623452"></p><h6 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h6><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240502191303489.png" alt="image-20240502191303489"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240505182842232.png" alt="image-20240505182842232"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240507194718565.png" alt="image-20240507194718565"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240507195242158.png" alt="image-20240507195242158"></p><h6 id="层次化局域网模型"><a href="#层次化局域网模型" class="headerlink" title="层次化局域网模型"></a>层次化局域网模型</h6><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240509222817770.png" alt="image-20240509222817770"></p><h6 id="DMZ公用服务器"><a href="#DMZ公用服务器" class="headerlink" title="DMZ公用服务器"></a>DMZ公用服务器</h6><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240511193151515.png" alt="image-20240511193151515"></p><h6 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h6><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240513215058343.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240513214606522.png" alt="image-20240513214606522"></p><h5 id="软件工程"><a href="#软件工程" class="headerlink" title="软件工程"></a>软件工程</h5><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240510214102701.png" alt="image-20240510214102701"></p><h6 id="三要素"><a href="#三要素" class="headerlink" title="三要素"></a>三要素</h6><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240510213707882.png" alt="image-20240510213707882"></p><h6 id="CMMI"><a href="#CMMI" class="headerlink" title="CMMI"></a>CMMI</h6><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240427211835173.png" alt="image-20240427211835173" style="zoom: 50%;" /><h6 id="软件质量"><a href="#软件质量" class="headerlink" title="软件质量"></a>软件质量</h6><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240427212106036.png" alt="image-20240427212106036" style="zoom: 50%;" /><h6 id="软件维护"><a href="#软件维护" class="headerlink" title="软件维护"></a><strong>软件维护</strong></h6><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240427163428039.png" alt="image-20240427163428039" style="zoom:67%;" /><h6 id="COCOMO"><a href="#COCOMO" class="headerlink" title="COCOMO"></a><strong>COCOMO</strong></h6><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240414150617607.png" alt="image-20240414150617607" style="zoom: 50%;" /><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240511181736191.png" alt="image-20240511181736191"></p><h6 id="COCOMOⅡ模型"><a href="#COCOMOⅡ模型" class="headerlink" title="COCOMOⅡ模型"></a><strong>COCOMOⅡ模型</strong></h6><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240414151223116.png" alt="image-20240414151223116"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240507180708577.png" alt="image-20240507180708577"></p><h6 id="软件过程模型"><a href="#软件过程模型" class="headerlink" title="软件过程模型"></a>软件过程模型</h6><p>统一过程UP</p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240511183117862.png" alt="image-20240511183117862"></p><h6 id="可用可靠可维护性"><a href="#可用可靠可维护性" class="headerlink" title="可用可靠可维护性"></a>可用可靠可维护性</h6><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240514192121363.png" alt="image-20240514192121363"></p><h6 id="判定表"><a href="#判定表" class="headerlink" title="判定表"></a>判定表</h6><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240517183041814.png" alt="image-20240517183041814"></p><hr><h5 id="面向对象设计"><a href="#面向对象设计" class="headerlink" title="面向对象设计"></a>面向对象设计</h5><h6 id="面向对象主要活动"><a href="#面向对象主要活动" class="headerlink" title="面向对象主要活动"></a>面向对象主要活动</h6><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240428153524103.png" alt="image-20240428153524103" style="zoom:67%;" /><h6 id="回归测试"><a href="#回归测试" class="headerlink" title="回归测试"></a>回归测试</h6><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240512174955131.png" alt="image-20240512174955131"></p><h6 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h6><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240427163934688.png" alt="image-20240427163934688" style="zoom:67%;" /><h6 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h6><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240517180643775.png" alt="image-20240517180643775"></p><h5 id="程序设计语言"><a href="#程序设计语言" class="headerlink" title="程序设计语言"></a>程序设计语言</h5><h6 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h6><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240508174811683.png" alt="image-20240508174811683"></p><h6 id="上下文无关文法"><a href="#上下文无关文法" class="headerlink" title="上下文无关文法"></a>上下文无关文法</h6><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240502190211153.png" alt="image-20240502190211153"></p><h6 id="编译-解释执行"><a href="#编译-解释执行" class="headerlink" title="编译&#x2F;解释执行"></a>编译&#x2F;解释执行</h6><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240502181918849.png" alt="image-20240502181918849"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240502181428132.png" alt="image-20240502181428132"></p><h6 id="常见的中间代码"><a href="#常见的中间代码" class="headerlink" title="常见的中间代码"></a>常见的中间代码</h6><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240513210601245.png" alt="image-20240513210601245"></p><h5 id="信息安全"><a href="#信息安全" class="headerlink" title="信息安全"></a>信息安全</h5><h6 id="网络攻击"><a href="#网络攻击" class="headerlink" title="网络攻击"></a>网络攻击</h6><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240503170026736.png" alt="image-20240503170026736"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240503170236271.png" alt="image-20240503170236271"></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240503170305895.png" alt="image-20240503170305895" style="zoom:67%;" /><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240509132235765.png" alt="image-20240509132235765"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240514190855015.png" alt="image-20240514190855015"></p><h6 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h6><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240505170241302.png" alt="image-20240505170241302"></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240507175725709.png" alt="image-20240507175725709" style="zoom:67%;" /><p>​               </p><h5 id="标准化与软件知识产权"><a href="#标准化与软件知识产权" class="headerlink" title="标准化与软件知识产权"></a>标准化与软件知识产权</h5><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240509133522499.png" alt="image-20240509133522499"></p><p>​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            </p><h5 id="结构化开发"><a href="#结构化开发" class="headerlink" title="结构化开发"></a>结构化开发</h5><h6 id="结构化分析与设计"><a href="#结构化分析与设计" class="headerlink" title="结构化分析与设计"></a>结构化分析与设计</h6><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240505171237767.png" alt="image-20240505171237767"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240507180336124.png" alt="image-20240507180336124"></p><h6 id="耦合内聚"><a href="#耦合内聚" class="headerlink" title="耦合内聚"></a>耦合内聚</h6><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240505174817571.png" alt="image-20240505174817571"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240514191921954.png" alt="image-20240514191921954"></p><h6 id="数据字典"><a href="#数据字典" class="headerlink" title="数据字典"></a>数据字典</h6><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240502175702364.png" alt="image-20240502175702364"></p><h6 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h6><p>私钥：数字签名。</p><p>公钥：消息验证。</p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240502172943570.png" alt="image-20240502172943570"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240505170542985.png" alt="image-20240505170542985"></p><img src="../Pictures/记事本操作教程/微信图片_20240427163045.jpg" alt="微信图片_20240427163045" style="zoom:50%;" /><h4 id="23种设计模式"><a href="#23种设计模式" class="headerlink" title="23种设计模式"></a>23种设计模式</h4><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/微信图片_20240427163112.jpg" alt="微信图片_20240427163045" style="zoom: 67%;" /><h4 id="面向对象设计7大原则"><a href="#面向对象设计7大原则" class="headerlink" title="面向对象设计7大原则"></a>面向对象设计7大原则</h4><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240428152359072.png"></p><h5 id="创建型设计模式"><a href="#创建型设计模式" class="headerlink" title="创建型设计模式"></a>创建型设计模式</h5><table><thead><tr><th>创建型（类）</th><th align="left"></th></tr></thead><tbody><tr><td>工厂方法模式</td><td align="left">定义一个用于创建对象的接口，让<strong>子类决定实例化</strong>哪一个类。工厂方法模式使一个类的实例化延迟到其子类。</td></tr><tr><td></td><td align="left"></td></tr><tr><td><strong>创建型（对象）</strong></td><td align="left"></td></tr><tr><td>抽象工厂</td><td align="left">提供一个<strong>创建一系列相关或相互依赖对象的接口</strong>，而无须指定它们具体的类。</td></tr><tr><td>生成器模式</td><td align="left">将一个<strong>复杂对象的构建与它的表示分离</strong>，使得同样的构建过程可以创建不同的表示。</td></tr><tr><td>原型模式</td><td align="left">用原型实例指定创建对象的种类，并且通过<strong>复制</strong>这些原型创建新的对象。</td></tr><tr><td>单例模式</td><td align="left">保证<strong>一个类仅有一个实例</strong>，并提供一个访问它的全局访问点。</td></tr></tbody></table><h5 id="结构性设计模式"><a href="#结构性设计模式" class="headerlink" title="结构性设计模式"></a>结构性设计模式</h5><table><thead><tr><th><strong>结构性（类）</strong></th><th></th></tr></thead><tbody><tr><td>适配器模式(类)</td><td>多重继承。非重点</td></tr><tr><td><strong>结构性对象</strong></td><td></td></tr><tr><td>适配器模式(对象)</td><td>将一个类的<strong>接口转换成客户希望的另外一个接口</strong>。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</td></tr><tr><td>桥接模式</td><td>将<strong>抽象部分与其实现部分分离</strong>，使它们都可以独立地变化。</td></tr><tr><td>组合模式</td><td>将对象组合成树型结构，以<strong>表示“部分-整体“的层次结构</strong>。使得用户对单个对象和组合对象的使用具有一致性。例如文件夹和子文件。</td></tr><tr><td>装饰模式</td><td><strong>动态地给一个对象添加一些额外的职责</strong>。就增加功能而言，Decorator 模式比生成子类更加灵活。</td></tr><tr><td>外观模式</td><td>为子系统中的一组接口<strong>提供一个一致的界面</strong>，Facade 模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</td></tr><tr><td>享元模式</td><td><strong>运用共享技术有效地支持大量细粒度的对象创建</strong>。适用于一个应用程序使用了大量的对象，造成很大的存储开销。例如：棋盘中黑子白字对象</td></tr><tr><td>代理模式</td><td>为其他对象提供一种代理，以<strong>控制对这个对象的访问</strong>。</td></tr></tbody></table><h5 id="行为型设计模式"><a href="#行为型设计模式" class="headerlink" title="行为型设计模式"></a>行为型设计模式</h5><table><thead><tr><th><strong>行为型(类)</strong></th><th></th></tr></thead><tbody><tr><td>解释器模式(Interpreter)了解</td><td>给定一个语言，<strong>定义它的文法的一种表示</strong>，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</td></tr><tr><td>模板方法模式(TemplateMethod)</td><td>定义一个操作中的<strong>算法骨架，而将一些步骤延迟到子类中</strong>。Template Method 使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</td></tr><tr><td><strong>行为型(对象)</strong></td><td></td></tr><tr><td>责任链模式(Chainof Responsibility)</td><td><strong>使多个对象都有机会处理请求</strong>，从而避免请求的发送者和接收者之间的耦合关系。<strong>将这些对象连成一条链</strong>，并沿着这条链传递该请求，直到有一个对象处理它为止。例如异常处理的抛出过程。</td></tr><tr><td>命令模式(Command)</td><td><strong>将一个请求封装为一个对象</strong>，从而使得可以用不同的请求<strong>对客户端进行参数化</strong>；对请求排队或记录请求日志，以及支持可撤销的操作。</td></tr><tr><td>迭代器模式(lterator)</td><td>提供一种方法<strong>顺序访问一个聚合对象中的各个元素</strong>，且不需要暴露该对象的内部表示。</td></tr><tr><td>中介者模式(Mediator)</td><td>用一个中介对象来<strong>封装一系列的对象交互</strong>。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</td></tr><tr><td>备忘录模式(Memento)</td><td>在不破坏封装性的前提下<strong>捕获一个对象的内部状态，并在对象之外保存这个状态</strong>。这样以后就可以将对象恢复到原先保存的状态。</td></tr><tr><td>观察者模式(Observer)</td><td>定义对象间的一种一对多的依赖关系，当一个<strong>对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新</strong>。</td></tr><tr><td>状态模式(State)</td><td>允许一个对象在其<strong>内部状态改变时改变它的行为</strong>。对象看起来似乎修改了它的类。</td></tr><tr><td>策略模式(Strategy)</td><td><strong>定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。</strong>此模式使得算法可以独立于使用它们的客户而变化。</td></tr><tr><td>访问器模式(Visitor)</td><td><strong>表示一个作用于某对象结构中的各元素的操作</strong>。它允许在不改变各元素的类的前提下定义作用于这些元素的新操作。</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> 软考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络技术三级</title>
      <link href="/post/a7101757.html"/>
      <url>/post/a7101757.html</url>
      
        <content type="html"><![CDATA[<p>相关笔记</p><p><a href="https://blog.csdn.net/ZGHS_ZG/article/details/122744098">计算机三级网络技术最全知识点总结-CSDN博客</a></p><p><a href="https://zhuanlan.zhihu.com/p/56552345">计算机三级网络技术开挂笔记 - 知乎</a></p><h3 id="1-选择题"><a href="#1-选择题" class="headerlink" title="1.选择题"></a>1.选择题</h3><h4 id="BGP"><a href="#BGP" class="headerlink" title="BGP"></a>BGP</h4><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240315205020070.png" alt="image-20240315205020070" style="zoom:50%;" /><h4 id="IPS"><a href="#IPS" class="headerlink" title="IPS"></a>IPS</h4><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240315205341649.png" alt="image-20240315205341649" style="zoom:50%;" /><h4 id="OSPF"><a href="#OSPF" class="headerlink" title="OSPF"></a>OSPF</h4><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240315203939356.png" alt="image-20240315203939356" style="zoom:50%;" /><h4 id="弹性分组环–PRP技术"><a href="#弹性分组环–PRP技术" class="headerlink" title="弹性分组环–PRP技术"></a>弹性分组环–PRP技术</h4><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240315210516512.png" alt="image-20240315210516512" style="zoom:50%;" /><h4 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h4><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240316141132346.png" style="zoom: 50%;" /><h4 id="虚拟局域网VLAN"><a href="#虚拟局域网VLAN" class="headerlink" title="虚拟局域网VLAN"></a>虚拟局域网VLAN</h4><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240317233041905.png" alt="image-20240317233041905" style="zoom:50%;" /><h4 id="IEEE标准"><a href="#IEEE标准" class="headerlink" title="IEEE标准"></a>IEEE标准</h4><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240317172632524.png" alt="image-20240317172632524" style="zoom: 50%;" /><h4 id="无线局域网设备的用法和区别"><a href="#无线局域网设备的用法和区别" class="headerlink" title="无线局域网设备的用法和区别"></a>无线局域网设备的用法和区别</h4><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240317173254570.png" alt="image-20240317173254570" style="zoom: 50%;" /><h4 id="布线"><a href="#布线" class="headerlink" title="布线"></a>布线</h4><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240317212812105.png" alt="image-20240317212812105" style="zoom: 67%;" /><h4 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h4><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240317212824798.png" alt="image-20240317212824798" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240317214427753.png" alt="image-20240317214427753" style="zoom:67%;" /><h4 id="生成树协议STP"><a href="#生成树协议STP" class="headerlink" title="生成树协议STP"></a>生成树协议STP</h4><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240317214933811.png" alt="image-20240317214933811" style="zoom: 67%;" /><h4 id="Cisco-Pix525"><a href="#Cisco-Pix525" class="headerlink" title="Cisco Pix525"></a>Cisco Pix525</h4><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240317220751916.png" alt="image-20240317220751916" style="zoom:67%;" /><h4 id="Serv-U-FTP服务器"><a href="#Serv-U-FTP服务器" class="headerlink" title="Serv-U FTP服务器"></a>Serv-U FTP服务器</h4><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240317220807136.png" alt="image-20240317220807136" style="zoom: 67%;" /><h4 id="WWW-服务器"><a href="#WWW-服务器" class="headerlink" title="WWW 服务器"></a>WWW 服务器</h4><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240317220932856.png" alt="image-20240317220932856" style="zoom:67%;" /><h4 id="E-mail服务器"><a href="#E-mail服务器" class="headerlink" title="E-mail服务器"></a>E-mail服务器</h4><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240318171039402.png" alt="image-20240318171039402" style="zoom: 67%;" /><h4 id="DNS-服务器"><a href="#DNS-服务器" class="headerlink" title="DNS 服务器"></a>DNS 服务器</h4><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240319194255460.png" alt="image-20240319194255460" style="zoom:67%;" /><h4 id="高频选择题"><a href="#高频选择题" class="headerlink" title="高频选择题"></a>高频选择题</h4><h5 id="可用性与停机时间"><a href="#可用性与停机时间" class="headerlink" title="可用性与停机时间"></a>可用性与停机时间</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240316142141819.png" alt="image-20240316142141819" style="zoom: 33%;" /><h5 id="IP地址转换子网掩码"><a href="#IP地址转换子网掩码" class="headerlink" title="IP地址转换子网掩码"></a>IP地址转换子网掩码</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240316142843521.png" alt="image-20240316142843521" style="zoom:33%;" /><h5 id="ITU标准和传输速率"><a href="#ITU标准和传输速率" class="headerlink" title="ITU标准和传输速率"></a>ITU标准和传输速率</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240316142942539.png" alt="image-20240316142942539" style="zoom:33%;" /><h5 id="IPV6"><a href="#IPV6" class="headerlink" title="IPV6"></a>IPV6</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240316144013447.png" alt="image-20240316144013447" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240317181110020.png" alt="image-20240317181110020" style="zoom: 80%;" /><h5 id="数据包"><a href="#数据包" class="headerlink" title="数据包"></a>数据包</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240316145938541.png" alt="image-20240316145938541" style="zoom:33%;" /><h5 id="网络地址转换NAT"><a href="#网络地址转换NAT" class="headerlink" title="网络地址转换NAT"></a>网络地址转换NAT</h5><p><strong>形式一</strong></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240316150548405.png" alt="image-20240316150548405" style="zoom:33%;" /><p><strong>形式二</strong></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240316150907574.png" alt="image-20240316150907574" style="zoom: 33%;" /><h5 id="更新路由表"><a href="#更新路由表" class="headerlink" title="更新路由表"></a>更新路由表</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240317232806961.png" alt="image-20240317232806961" style="zoom: 67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240316153000432.png" style="zoom: 33%;" /><h5 id="计算交换机带宽"><a href="#计算交换机带宽" class="headerlink" title="计算交换机带宽"></a>计算交换机带宽</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240316153633350.png" alt="image-20240316153633350" style="zoom:33%;" /><h5 id="三种备份的比较"><a href="#三种备份的比较" class="headerlink" title="三种备份的比较"></a>三种备份的比较</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240316154232178.png" alt="image-20240316154232178" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240316154211342.png" alt="image-20240316154211342" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240316154507170.png" alt="image-20240316154507170" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240316154724909.png" alt="image-20240316154724909" style="zoom:33%;" /><h5 id="IP地址块聚合"><a href="#IP地址块聚合" class="headerlink" title="IP地址块聚合"></a>IP地址块聚合</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240316155008825.png" alt="image-20240316155008825" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240316155645557.png" alt="image-20240316155645557" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240316160028072.png" alt="image-20240316160028072" style="zoom:33%;" /><p><strong>&#x2F;后数值全相同</strong></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240316160433322.png" alt="image-20240316160433322" style="zoom: 33%;" /><p><strong>总结：</strong></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240316160850229.png" alt="image-20240316160850229" style="zoom:33%;" /><h3 id="2-大题填空"><a href="#2-大题填空" class="headerlink" title="2.大题填空"></a>2.大题填空</h3><h4 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h4><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240318171134681.png" alt="image-20240318171134681" style="zoom: 50%;" /><p>子网掩码，网络位为1，主机位为0</p><h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240314175549968.png" alt="image-20240314175549968" style="zoom:25%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240314175618684.png" alt="image-20240314175618684" style="zoom:25%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240314175812764.png" alt="image-20240314175812764" style="zoom:25%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240314175934040.png" alt="image-20240314175934040" style="zoom:25%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240314180227035.png" style="zoom: 25%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240315140922776.png" alt="image-20240315140922776" style="zoom: 50%;" /><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240314182247590.png" alt="image-20240314182247590"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240314182327720.png" alt="image-20240314182327720"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240314182533595.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240314182715250.png" alt="image-20240314182715250"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240314183555491.png" alt="image-20240314183555491"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240314183836051.png" alt="image-20240314183836051"></p><h4 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h4><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240314184031039.png" alt="image-20240314184031039"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240314184043341.png" alt="image-20240314184043341"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240314184058247.png" alt="image-20240314184058247"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240314184519461.png" alt="image-20240314184519461"></p><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240314184308824.png" alt="image-20240314184308824"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240314184423255.png" alt="image-20240314184423255"></p><p><strong>1&#x2F;40概率天选命题</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240320231459905.png" alt="image-20240320231459905"></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240320231203740.png" alt="image-20240320231203740" style="zoom:67%;" /><h4 id="填表"><a href="#填表" class="headerlink" title="填表"></a>填表</h4><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240314201819167.png" alt="image-20240314201819167"></p><p><strong>聚合：相同位保持不变，不同位变为0</strong></p><p>左边S0，右边S1</p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240314202740623.png" alt="image-20240314202740623"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240314202847172.png" alt="image-20240314202847172"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240314202945739.png" alt="image-20240314202945739"></p><h3 id="3-划分子网"><a href="#3-划分子网" class="headerlink" title="3.划分子网"></a>3.划分子网</h3><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240314203516083.png" alt="image-20240314203516083"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240314203931860.png" alt="image-20240314203931860"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240319182729458.png" alt="image-20240319182729458"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240314205111982.png" alt="image-20240314205111982"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240315153413975.png" alt="image-20240315153413975"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240317210530375.png" alt="image-20240317210530375"></p><h3 id="4-DHCP"><a href="#4-DHCP" class="headerlink" title="4.DHCP"></a>4.DHCP</h3><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240315163523243.png" alt="image-20240315163523243"></p><h4 id="一般情况"><a href="#一般情况" class="headerlink" title="一般情况"></a>一般情况</h4><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240315154430658.png" alt="image-20240315154430658"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240315163629538.png" alt="image-20240315163629538"></p><h4 id="获取参数信息–执行ipconfig-all"><a href="#获取参数信息–执行ipconfig-all" class="headerlink" title="获取参数信息–执行ipconfig&#x2F;all"></a>获取参数信息–执行ipconfig&#x2F;all</h4><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240315154636357.png" alt="image-20240315154636357"></p><h4 id="续约–执行ipconfig-renew"><a href="#续约–执行ipconfig-renew" class="headerlink" title="续约–执行ipconfig&#x2F;renew"></a>续约–执行ipconfig&#x2F;renew</h4><p><strong>续约是从一般情况的第三步开始的</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240315154728827.png" alt="image-20240315154728827"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240315155119560.png" alt="image-20240315155119560"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240315155204934.png" alt="image-20240315155204934"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240315155335355.png" alt="image-20240315155335355"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240315160216903.png" alt="image-20240315160216903"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240315160428241.png" alt="image-20240315160428241"></p><h4 id="释放并重获地址–依次执行ipconfig-release和ipconfig和renew"><a href="#释放并重获地址–依次执行ipconfig-release和ipconfig和renew" class="headerlink" title="释放并重获地址–依次执行ipconfig&#x2F;release和ipconfig和renew"></a>释放并重获地址–依次执行ipconfig&#x2F;release和ipconfig和renew</h4><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240315160658935.png" alt="image-20240315160658935"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240315162315899.png" alt="image-20240315162315899"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240315163000483.png" alt="image-20240315163000483"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240315163103569.png" alt="image-20240315163103569"></p><h3 id="5-域名解析和tracert过程"><a href="#5-域名解析和tracert过程" class="headerlink" title="5.域名解析和tracert过程"></a>5.域名解析和tracert过程</h3><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240321203613195.png" alt="image-20240321203613195" style="zoom: 33%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240321203634211.png" alt="image-20240321203634211" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240321203649271.png" alt="image-20240321203649271" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240321204842060.png" alt="image-20240321204842060" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240321204916399.png" alt="image-20240321204916399" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240321205054763.png" alt="image-20240321205054763" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240321205434111.png" alt="image-20240321205434111" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240321205643670.png" alt="image-20240321205643670" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240321210011561.png" alt="image-20240321210011561" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240321210029741.png" alt="image-20240321210029741" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240321210420204.png" alt="image-20240321210420204" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240321210611895.png" alt="image-20240321210611895" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240321210643693.png" alt="image-20240321210643693" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240321210736364.png" alt="image-20240321210736364" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240321210906657.png" alt="image-20240321210906657" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240321210923638.png" alt="image-20240321210923638" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240321211000254.png" alt="image-20240321211000254" style="zoom:67%;" /> <img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240321211033438.png" alt="image-20240321211033438" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240321211552676.png" alt="image-20240321211552676" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240321212234381.png" alt="image-20240321212234381" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240321212340928.png" alt="image-20240321212340928" style="zoom: 67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240321212426353.png" alt="image-20240321212426353" style="zoom: 67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240321212734705.png" alt="image-20240321212734705" style="zoom: 67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240321212807817.png" alt="image-20240321212807817" style="zoom: 67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240321212859808.png" alt="image-20240321212859808" style="zoom: 67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240321213059907.png" alt="image-20240321213059907" style="zoom: 67%;" /><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240321213505303.png" alt="image-20240321213505303"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240321213720115.png" alt="image-20240321213720115"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240321213744221.png" alt="image-20240321213744221"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240321214328397.png" alt="image-20240321214328397"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240321215347648.png" alt="image-20240321215347648"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240321215020420.png" alt="image-20240321215020420"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240321215217393.png" alt="image-20240321215217393"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240315170102213.png" alt="image-20240315170102213"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240315170008842.png" alt="image-20240315170008842"></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240315170137514.png" alt="image-20240315170137514" style="zoom:50%;" /><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240317204704250.png" alt="image-20240317204704250"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 网络技术,三级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软考中级</title>
      <link href="/post/7a7dea22.html"/>
      <url>/post/7a7dea22.html</url>
      
        <content type="html"><![CDATA[<h3 id="第1章：计算机组成原理与体系结构基础知识"><a href="#第1章：计算机组成原理与体系结构基础知识" class="headerlink" title="第1章：计算机组成原理与体系结构基础知识"></a>第1章：计算机组成原理与体系结构基础知识</h3><h4 id="1-数据的表示"><a href="#1-数据的表示" class="headerlink" title="1.数据的表示"></a>1.数据的表示</h4><h5 id="1-1进制转换"><a href="#1-1进制转换" class="headerlink" title="1.1进制转换"></a>1.1进制转换</h5><p>任意进制–&gt;十进制</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240304195622340.png" alt="image-20240304195622340" style="zoom: 67%;" /><p>二进制&lt;–&gt;八、十六进制</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240304200015583.png" alt="image-20240304200015583" style="zoom: 50%;" /><p>十进制–&gt;任意进制</p><p>十进制转R进制使用短除法。</p><h5 id="1-2真值与机器数"><a href="#1-2真值与机器数" class="headerlink" title="1.2真值与机器数"></a>1.2真值与机器数</h5><p>真值：符合人剋习惯的数字。</p><p><strong>机器数：数字实际存到机器里的形式，正负号需要被“数字化“</strong></p><p>定点数 vs 浮点数</p><p>定点数:小数点的位置固定          Eg: 996.007-常规计数</p><p>浮点数:小数点的位置不固定      Eg:9.96007<em>10</em>10-科学计数法</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240304202011683.png" alt="image-20240304202011683" style="zoom: 50%;" /><p>无符号数:整个机器字长的全部二进制位均为数值位没有符号位相当于数的绝对值。通常只有无符号整数，而没有无符号小数。</p><p>二进制（B）、八进制（O）、十进制（D）、十六进制（H）</p><p><mark><strong>原码:用数值部分表示真值的绝对值，符号位“0&#x2F;1”对应“正&#x2F;负。</strong></mark></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240304202403019.png" alt="image-20240304202403019" style="zoom:50%;" /><p><mark><strong>反码: 若符号位为0，则反码与原码相同。若符号位为1，则数值位全部取反。</strong></mark></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240304202519132.png" alt="image-20240304202519132" style="zoom:50%;" /><p><mark><strong>补码:正数的补码 &#x3D; 原码，负数的补码 &#x3D; 反码末位+1 (要考虑进位）</strong></mark></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240304202832355.png" alt="image-20240304202832355" style="zoom:50%;" /><p><mark><strong>移码:补码的基础上将符号位取反。注意: 移码只能用于表示整数</strong></mark></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240304202937781.png" alt="image-20240304202937781" style="zoom:50%;" /><p><strong>真值0有+0和-0两种</strong></p><p>[+0]原&#x3D; 00000000</p><p>[+0]反&#x3D; 00000000</p><p>[-0]原&#x3D; 10000000</p><p>[-0]反 &#x3D; 11111111</p><p>[+0]补 &#x3D; [-0]补 &#x3D; 00000000</p><p>[+0]移 &#x3D; [-0]移 &#x3D; 10000000</p><p>例题：</p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240427151954569.png" alt="image-20240427151954569"></p><p><strong>浮点数</strong></p><p>浮点数是小数点位置不固定的数，它能表示更大范围的数。浮点数的表示格式如图</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240304203139763.png" alt="image-20240304203139763" style="zoom:50%;" /><p>N&#x3D;M*R^E</p><p>其中，M称为尾数，R称为基数，E称为阶码</p><p>阶码，决定浮点数所能表示的数值范围</p><p>尾数，决定浮点数所能表示的数值精度</p><h4 id="2-校验码"><a href="#2-校验码" class="headerlink" title="2.校验码"></a>2.校验码</h4><p>奇偶校验和循环几余校验码(了解)</p><p>奇偶校验是一种简单有效的校验方法。其基本思想是: 通过在编码中增加一位校验位来使编码中 1 的个数为奇数(奇校验)或者为偶数(偶校验)，从而使码距变为 2。对于奇校验,它可以检测代码中奇数位出错的编码，但不能发现偶数位出错的情况，即当合法编码中奇数位发生了错误，也就是编码中的 1 变成0或0 变成1，则该编码中1的个数的奇偶性就发生了变化，从而可以发现错误。</p><p>常用的奇偶校验码有 3 种:水平奇偶校验码、垂直奇偶校验码和水平垂直奇偶校验码。</p><p><strong>海明码</strong><br>海明码的构成方法是: 在数据为之间插入 k 个校验码，通过扩大码距来实现讲错和纠错。</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240304203538348.png" alt="image-20240304203538348" style="zoom:50%;" /><p>选C</p><h4 id="3-计算机体系结构"><a href="#3-计算机体系结构" class="headerlink" title="3.计算机体系结构"></a>3.计算机体系结构</h4><h5 id="3-1五大部件"><a href="#3-1五大部件" class="headerlink" title="3.1五大部件"></a>3.1五大部件</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240304204222011.png" alt="image-20240304204222011" style="zoom: 25%;" /><h5 id="3-2主存储器"><a href="#3-2主存储器" class="headerlink" title="3.2主存储器"></a>3.2主存储器</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240304204708090.png" alt="image-20240304204708090" style="zoom: 50%;" /><p>存储单元:每个存储单元存放一串二进制代码</p><p>存储字(word): 存储单元中二进制代码的组合</p><p>存储字长:存储单元中二进制代码的位数</p><p>存储元:即存储二进制的电子元件，每个存储元可存 1bit</p><p>MAR:地址寄存器</p><p>MDR:数据寄存器</p><h5 id="3-3CPU"><a href="#3-3CPU" class="headerlink" title="3.3CPU"></a>3.3CPU</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240304204728203.png" alt="image-20240304204728203" style="zoom: 67%;" /><p>ACC:累加器，用于存放操作数，或运算结果</p><p>MQ:乘商寄存器，在乘、除运算时，用于存放操作数或运算结果</p><p>X:通用的操作数寄存器，用于存放操作数</p><p>ALU:算术逻辑单元，通过内部复杂的电路实现算数运算、逻辑运算</p><p>DR:数据缓存寄存器</p><p>PSW: 状态条件寄存器，用来保存指令运行标志</p><h5 id="3-4控制器-重点"><a href="#3-4控制器-重点" class="headerlink" title="3.4控制器(重点)"></a>3.4控制器(重点)</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240304204841944.png" alt="image-20240304204841944" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240419172340067.png" alt="image-20240419172340067" style="zoom: 80%;" /><p>CU:控制单元，分析指令，给出控制信号</p><p>**IR:指令寄存器(Instruction register)**，存放当前执行的指令</p><p>**ID:指令译码器(Instruction decoder)**，对操作码进行分析</p><p>**PC:程序计数器(Program counter)**，存放下一条指令地址，有自动加1功能</p><p>**AR:地址寄存器(Address register)**，保存当前CPU所访问的内存单元地址</p><h5 id="3-5Flynn分类法"><a href="#3-5Flynn分类法" class="headerlink" title="3.5Flynn分类法"></a>3.5Flynn分类法</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240304205237326.png" alt="image-20240304205237326" style="zoom: 33%;" /><p>Single单一的</p><p>Multiple倍数，多样的</p><h4 id="4-指令系统"><a href="#4-指令系统" class="headerlink" title="4.指令系统"></a>4.指令系统</h4><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240304205028912.png" alt="image-20240304205028912" style="zoom:50%;" /><h5 id="4-1指令格式"><a href="#4-1指令格式" class="headerlink" title="4.1指令格式"></a>4.1指令格式</h5><p>一条指令就是机器语言的一个语句，它是一组有意义的二进制代码</p><p>一条指令通常要包括操作码字段和地址码字段两部分</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240304205533590.png" alt="image-20240304205533590" style="zoom: 67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240304205446506.png" alt="image-20240304205446506" style="zoom: 67%;" /><h5 id="4-2寻址方式"><a href="#4-2寻址方式" class="headerlink" title="4.2寻址方式"></a>4.2寻址方式</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240304205555125.png" alt="image-20240304205555125" style="zoom: 50%;" /><p><strong>寻址方式（数据寻址）</strong></p><ul><li><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240509131509534.png" alt="image-20240509131509534"></li></ul><h5 id="4-3CISC和RISC"><a href="#4-3CISC和RISC" class="headerlink" title="4.3CISC和RISC"></a>4.3CISC和RISC</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240304205805214.png" alt="image-20240304205805214" style="zoom:50%;" /><h5 id="4-4指令的流水方式"><a href="#4-4指令的流水方式" class="headerlink" title="4.4指令的流水方式"></a>4.4指令的流水方式</h5><p>指令控制方式有顺序方式、重叠方式和流水方式三种</p><p>流水方式:是指并行性或并发性嵌入计算机系统里的一种形式，它把重复的顺序处理过程分解为若千子过程，每个子过程能在专用的独立模块上有效地并发工作。</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240304205907482.png" alt="image-20240304205907482" style="zoom: 67%;" /><p>在概念上“流水”可以看成是“重叠”的延伸。差别仅在于“一次重叠”只是把一条指令解释分解为两个子过程，而“流水”则是分解为更多的子过程。</p><h5 id="4-5流水线计算-重点"><a href="#4-5流水线计算-重点" class="headerlink" title="4.5流水线计算(重点)"></a>4.5流水线计算(重点)</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240428152817383.png" alt="image-20240428152817383" style="zoom: 50%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240304210021669.png" alt="image-20240304210021669" style="zoom:50%;" /><p>答：周期2ns,全部时间2+2+1+(100-1)*2&#x3D;203s</p><p>流水线的吞吐率(Though Put rate,TP):是指在单位时间内流水线所完成的任务数量或输出的结果数量。</p><p><mark><strong>计算流水线吞吐率的最基本的公式如下:</strong></mark></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240304210303420.png" alt="image-20240304210303420" style="zoom:50%;" /><p>流水线开始工作后，须经过一定时间才能达到最大吞吐率，这就是建立时间若m个子过程所用时间一样，均为t，则建立时间T&#x3D;m*t.</p><p>完成同样一批任务，不使用流水线所用的时间与使用流水线所用的时间之比称为流水线的加速比。</p><p><strong>计算流水线加速比的基本公式如下:</strong></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240304210507760.png" alt="image-20240304210507760" style="zoom: 67%;" /><h4 id="5-存储系统"><a href="#5-存储系统" class="headerlink" title="5.存储系统"></a>5.存储系统</h4><h5 id="5-1层次结构"><a href="#5-1层次结构" class="headerlink" title="5.1层次结构"></a>5.1层次结构</h5><p>把U盘、光盘等称为“外存”有的教材把安装在电脑内部的磁盘称为“辅存”也有的教材把磁盘、U盘、光盘等统称为“辅存”或“外存</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240305133940347.png" alt="image-20240305133940347" style="zoom:50%;" /><p>1.<strong>寄存器是中央处理器内的组成部份。</strong>寄存器Q 是有限存贮容量的高速存贮部件，它们可用来暂存指令、数据和位址。在中央处理器的控制部件中，包含的寄存器有指令寄存器(IR)和程序计数器(PC)。在中央处理器的算术及逻辑部件中，包含的寄存器有累加器(ACC)。<strong>寄存器拥有非常高的读写速度，所以在寄存器之间的数据传送非常快。</strong></p><p>2.Cache: <strong>即高速缓冲存储器，是位于CPU与主内存间的一种容量较小但速度很高的存储器。</strong>由于CPU的速度远高于主内存，CPU直接从内存中存取数据要等待一定时间周期，Cache中保存着CPU刚用过或循环使用的一部分数据，当CPU再次使用该部分数据时可从Cache中直接调用,这样就减少了CPU的等待时间,提高了系统的效率。Cache又分为一级Cache(L1 Cache)和二级Cache(L2Cache)，L1 Cache集成在CPU内部，L2 Cache早期一般是焊在主板上,现在也都集成在CPU内部常见的容量有256KB或512KB L2 Cache。</p><p>3.内存包含的范围非常广，一般分为只读存储器 (ROM) 、随机存储器 (RAM)和高速缓存存储器(cache) 。</p><p>主存一辅存:实现虚拟存储系统，解决了主存容量不够的问题.</p><p>cpu—Cache—主存:解决了主存与CPU速度不匹配的问题。</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240305134111329.png" alt="image-20240305134111329" style="zoom:50%;" /><h5 id="5-2存储器的分类"><a href="#5-2存储器的分类" class="headerlink" title="5.2存储器的分类"></a>5.2存储器的分类</h5><p>1、按位置分类，可分为内存和外存</p><ul><li><p>内存(主存): 用来存储当前运行所需要的程序和数据，速度快，容量小。</p></li><li><p>外存(辅存)::用来存储当前不参与运行的数据，容量大但速度慢。</p></li></ul><p>2.按材料分类，可分为磁存储器、半导体存储器和光存储器磁存储器</p><ul><li><p>磁存储器：用磁性介质做成，如磁芯、磁泡、磁盘、磁带等</p></li><li><p>半导体存储器: 根据所用元件又可分为双极型和MOS型两类；根据是否需要刷新又可分为静态和动态两类。</p></li><li><p>光存储器:由光学、电学和机械部件等组成，如光盘存储器。</p></li></ul><p>3.按工作方式，可分为读&#x2F;写存储器和只读存储器</p><ul><li><p>读&#x2F;写存储器(RAM)：它指既能读取数据也能存入数据的存储器</p></li><li><p>只读存储器(ROM)：工作过程中仅能读取的存储器。</p></li></ul><p>根据数据的写入方式，又可细分为ROM、PROM、EPROM和EEPROM等类型。</p><ul><li><p>固定只读存储器(ROM)。这种存储器是在厂家生产时就写好数据的，其内容只能读出，不能改变。一般用于存放系统程序BIOS和用于微程序控制。</p></li><li><p>可编程的只读存储器(PROM)。其中的内容可以由用户一次性地写入，写入后不能再修改。</p></li><li><p>可擦除可编程的只读存储器(EPROM)。其中的内容既可以读出，也可以由用户写入，写入后还可以修改，紫外线照射擦除信息。</p></li><li><p>电擦除可编程的只读存储器(EEPROM)。与EPROM相似，EEPROM 中的内容既可以读出，也可以进行改写，电擦除的方法进行数据的改写。</p></li><li><p>闪速存储器(Flash Memory)。简称闪存闪存的特性于EPROM和EEPROM之类似于EEPROM,也可使用电信号进行信息的擦除操作。整块闪存可以在数秒内删除，速度远快于EPROM。</p></li></ul><h5 id="5-3高速缓存Cache"><a href="#5-3高速缓存Cache" class="headerlink" title="5.3高速缓存Cache"></a>5.3高速缓存Cache</h5><p><strong>程序访问的局部性原理</strong></p><ul><li><p>空间局部性：在最近的未来要用到的信息（指令和数据），很可能与现在正在使用的信息在存储空间上是邻近的.</p><p>eg：数据元组、顺序执行的指令代码。</p></li><li><p>时间局部性：在最近的未来要用到的信息，很可能是现在正在使用的信息.</p><p>eg：循环结构里的指令代码。</p><p>高速缓冲技术是利用程序访问的局部性原理，把程序中正在使用的部分存放在一个高速的、容量较小的Cache中，使CPU的访存操作大多数针对Cache进行，从而大大提高程序的执行速度。</p></li></ul><p>要把主存种的地址映射为Cache存储器里面的地址，地址映像方法有三</p><ul><li>直接映像:就是主存的块与Cache中块的对应关系是固定的。这种方式的优点是<strong>地址变换很简单</strong>，缺点是<strong>灵活性差</strong>。</li></ul><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240305152001220.png" alt="image-20240305152001220" style="zoom: 67%;" /><ul><li>全相联映像:<strong>允许主存的任一块可以调入Cache的任一块的空间</strong>。这种方式的优点是主存的块调入Cache的<strong>位置不受限制，十分灵活</strong>。其缺点是<strong>无法从主存块号中直接获得Cache的块号，变换比较复杂，速度比较慢。</strong></li></ul><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240305152147304.png" alt="image-20240305152147304" style="zoom:67%;" /><ul><li>组相联映像:这种方式是前面两种方式的折中。具体方法是将Cache先分成组再分块组相联映像就是<strong>组间采用直接映像方式</strong>，而<strong>组内的块采用全相联映像方式。</strong></li></ul><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240305152252334.png" alt="image-20240305152252334" style="zoom:67%;" /><p><strong>选择替换算法的目标是使Cache获得最高的命中率。常用的替换算法有以下几种：</strong></p><ul><li>1、随机替换(RAND)算法: 用随机数发生器产生一个要替换的块号，将该块替换出去</li><li>2、先进先出(FIFO)算法: 将最先进入的Cache信息块替换出去。</li><li>3、近期最少使用(LRU)算法: 将近期最少使用的Cache中的信息块替换出去。这种算法较先进先出算法要好些，但此法也不能保证过去不常用的将来也不常用。</li><li>4、优化替换OPT)算法: 先执行一次程序，统计Cache的替换情况。有了这样的先验信息，在第二次执行该程序时便可以用最有效的方式来替换，达到最优目的。</li></ul><p><strong>Cache的性能分析：</strong></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240305152538828.png" alt="image-20240305152538828" style="zoom:67%;" /><p><strong>例题：</strong></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240305152625647.png" alt="image-20240305152625647" style="zoom:67%;" /><p>选A、D</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240305152842388.png" alt="image-20240305152842388" style="zoom:67%;" /><p>选A</p><h5 id="5-4主存的编址"><a href="#5-4主存的编址" class="headerlink" title="5.4主存的编址"></a>5.4主存的编址</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240305153428082.png" alt="image-20240305153428082" style="zoom: 50%;" /><p>例题：</p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240305153744081.png" alt="image-20240305153744081"></p><p>（C7FFFH+1）- AC000H &#x3D; 1C000 H</p><p>1C000H &#x3D; 114688D</p><p>114688&#x2F;2^10&#x3D;112</p><p>(112k * 16b)&#x2F;28 * 16k &#x3D; 4b</p><h5 id="5-6硬盘"><a href="#5-6硬盘" class="headerlink" title="5.6硬盘"></a>5.6硬盘</h5><p>存取时间&#x3D;寻道时间+等待时间(平均定位时间+转动延迟</p><p>注意:寻道时间是指磁头移动到磁道所需的时间；</p><p>等待时间为等待读写的扇区转到磁头下方所用的时间。</p><h4 id="6-总线系统"><a href="#6-总线系统" class="headerlink" title="6.总线系统"></a>6.总线系统</h4><p><strong>总线分类</strong></p><p>1、片内总线</p><p>片内总线是芯片内部的总线。 它是CPU芯片内部寄存器与寄存器之间、寄存器与ALU之间的公共连接线。</p><p>2、系统总线<br>系统总线是计算机系统内各功能部件(CPU、主存、I&#x2F;0接口)之间相互连接的总线。按系统总线传输信息内容的不同，又可分为3类: 数据总线、地址总线和控制总线。</p><p>3、通信总线</p><h4 id="7-输入输出技术"><a href="#7-输入输出技术" class="headerlink" title="7.输入输出技术"></a>7.输入输出技术</h4><p><strong>CPU与外设之间的数据传送方式</strong></p><p><strong>1、直接程序控制方式</strong></p><p>直接程序控制方式是指在完成数据的输入&#x2F;输出中，整个输入&#x2F;输出过程是在CPU执行程序的控制下完成的。</p><p>这种方式还可以分为以下两种:</p><p>(1)无条件传送方式:无条件地与CPU交换数据。</p><p>(2)程序查询方式:先通过CPU查询外设状态，准备好之后再与CPU交换数据。</p><p><strong>2、中断方式</strong></p><p><strong>3、直接存储器存取方式</strong></p><p>直接存储器存取(Direct Memory Access， DMA)方式是在存储器与&#x2F;0设备间直接传送数据，即在内存与I&#x2F;0设备之间传送一个数据块的过程中，<strong>不需要CPU的任何干涉，是一种完全由DMA硬件完成I&#x2F;O操作的方式。</strong></p><p>例题：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240305155813487.png" alt="image-20240305155813487" style="zoom:50%;" /><p>选D</p><h4 id="8-可靠性-重点"><a href="#8-可靠性-重点" class="headerlink" title="8.可靠性(重点)"></a>8.可靠性(重点)</h4><p><strong>计算机系统的可靠性是指从它开始运行(t&#x3D;)到某个时刻t这段时间内能正常运行的概率，用R(t)表示。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240305160046422.png" alt="image-20240305160046422"></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240305160122410.png" alt="image-20240305160122410" style="zoom:50%;" /><p>失效率 &#x3D; 1 - 可靠的</p><p>选B</p><h4 id="9-中断"><a href="#9-中断" class="headerlink" title="9.中断"></a>9.中断</h4><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240419224514296.png" alt="image-20240419224514296"></p><h3 id="第2章：数据结构与算法基础"><a href="#第2章：数据结构与算法基础" class="headerlink" title="第2章：数据结构与算法基础"></a>第2章：数据结构与算法基础</h3><h4 id="1-基本概念与三要素"><a href="#1-基本概念与三要素" class="headerlink" title="1.基本概念与三要素"></a>1.基本概念与三要素</h4><h5 id="1-1数据的基本概念"><a href="#1-1数据的基本概念" class="headerlink" title="1.1数据的基本概念"></a>1.1数据的基本概念</h5><p>数据是信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号的集合。数据是计算机程序加工的原料。</p><p><strong>数据元素、数据项</strong>: <mark><strong>数据元素是数据的基本单位</strong></mark>，通常作为一个整体进行考虑和处理。 <mark>一个数据元素可由若干数据项组成，数据项是构成数据元素的不可分割的最小单位。</mark></p><p><strong>数据结构是相互之间存在一种或多种特定关系的数据元素的集合。</strong></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240305181703309.png" alt="image-20240305181703309" style="zoom:50%;" /><h5 id="1-2数据结构三要素"><a href="#1-2数据结构三要素" class="headerlink" title="1.2数据结构三要素"></a>1.2数据结构三要素</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240305181835399.png" alt="image-20240305181835399" style="zoom: 67%;" /><p><strong>逻辑结构的四种表示方式</strong></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240305181852844.png" alt="image-20240305181852844" style="zoom: 80%;" /><ul><li><p>集合:各个元素同属一个集合，别无其他关系</p></li><li><p>线性结构:数据元素之间是一对一的关系。除了第一个元素，所有元素</p></li><li><p>有唯前驱;除了最后一个元素，所有元素都有唯一后继</p></li><li><p>树形结构:数据元素之间是一对多的关系</p></li><li><p>图结构:数据元素之间是多对多的关系</p></li></ul><p><strong>物理结构</strong></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240305182500727.png" alt="image-20240305182500727" style="zoom:67%;" /><h4 id="2-算法"><a href="#2-算法" class="headerlink" title="2.算法"></a>2.算法</h4><h5 id="2-1什么是算法"><a href="#2-1什么是算法" class="headerlink" title="2.1什么是算法"></a>2.1什么是算法</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240305182543990.png" alt="image-20240305182543990" style="zoom:67%;" /><p>五个特性</p><ul><li><p>有穷性:一个算法必须总在执行有穷步之后结束，且每一步都可在有穷时间内完成。</p></li><li><p>确定性:算法中每条指令必须有确切的含义，对于<strong>相同的输入只能得出相同的输出。</strong></p></li><li><p>可行性:算法中描述的操作都可以通过已经实现的<strong>基本运算执行有限次来实现。</strong></p></li><li><p>输入:<strong>一个算法有零个或多个输入</strong>，这些输入取自于某个特定的对象的集合</p></li><li><p>输出:<strong>一个算法有一个或多个输出</strong>，这些输出是与输入有着某种特定关系的量。</p></li></ul><h5 id="2-2算法效率的度量"><a href="#2-2算法效率的度量" class="headerlink" title="2.2算法效率的度量"></a>2.2算法效率的度量</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240305183124686.png" alt="image-20240305183124686" style="zoom:67%;" /><p><strong>时间复杂度</strong></p><p>只在乎n的最高次数（算法循环次数）</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240305183809014.png" alt="image-20240305183809014" style="zoom: 33%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240305183824953.png" alt="image-20240305183824953" style="zoom: 67%;" /><p><strong>空间复杂度</strong></p><p>只在乎储存空间大小（算法所储存变量个数）</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240305184800349.png" alt="image-20240305184800349" style="zoom: 50%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240305184827267.png" alt="image-20240305184827267" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240305184526616.png" alt="image-20240305184526616" style="zoom:67%;" /><h4 id="3-线性表"><a href="#3-线性表" class="headerlink" title="3.线性表"></a>3.线性表</h4><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240305193451605.png" alt="image-20240305193451605" style="zoom: 67%;" /><h5 id="3-1定义"><a href="#3-1定义" class="headerlink" title="3.1定义"></a>3.1定义</h5><p>线性表是具有相同数据类型的n(n&gt;&#x3D;0)个数据元素的有限序列，其n为表长，当n&#x3D;0时，线性表是一个空表。</p><p>若用L命名线性表，则其一般表为:L&#x3D;(a1, a2,…,ai,ai+1,..an)</p><p><strong>几个概念：</strong></p><ul><li><p><strong>ai是线性表中的“第i个”元素线性表中的位序。</strong></p></li><li><p><strong>a1是表头元素；an是表尾元素。</strong></p></li><li><p><strong>除第一个元素外，每个元素有且仅有一个直接前驱；除最后一个元素外每个元素有且仅有一个直接后继。</strong></p></li></ul><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240306180042672.png" alt="image-20240306180042672" style="zoom: 67%;" /><h5 id="3-2存储结构"><a href="#3-2存储结构" class="headerlink" title="3.2存储结构"></a>3.2存储结构</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240306180150852.png" alt="image-20240306180150852" style="zoom:67%;" /><p><strong>顺序存储与链式存储比较</strong></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240306180244036.png" alt="image-20240306180244036" style="zoom:67%;" /><p><strong>顺序存储与链式存储的基本操作</strong></p><p>顺序存储</p><ul><li><p>插入元素前要移动元素以挪出空的存储单元，然后再插入元素</p></li><li><p>删除元素时同样需要移动元素，以填充被删除元素的存储单元。</p></li></ul><p>链式存储</p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240306180414983.png" alt="image-20240306180414983"></p><h4 id="4-栈和队列"><a href="#4-栈和队列" class="headerlink" title="4.栈和队列"></a>4.栈和队列</h4><h5 id="4-1栈定义"><a href="#4-1栈定义" class="headerlink" title="4.1栈定义"></a>4.1栈定义</h5><p>线性表是具有相同数据类型的n(nz0)个数据元素的有限序列，其中n为表长，当n&#x3D;0时线 性表是一个空表。若用L命名线性表，则其一般表示为:</p><p>L&#x3D;(a1, a2,…, ai, ai+1,.,an)</p><p><mark><strong>栈(Stack)是只允许在一端进行插入或删除操作的线性表。</strong></mark></p><p><strong>栈实现嵌套调用（递归调用）函数的正确返回。</strong></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240306181028017.png" alt="image-20240306181028017" style="zoom: 80%;" /><h5 id="4-2队列定义"><a href="#4-2队列定义" class="headerlink" title="4.2队列定义"></a>4.2队列定义</h5><p><mark><strong>队列是一种先进先出(FIFO)的线性表，它只允许在表的一端插入元素，而在表的另一端删除元素。</strong></mark>在队列中，允许插入元素的一端称为队尾(Rear)，允许删除元素的一端称为队头(Front)。</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240306181202107.png" alt="image-20240306181202107" style="zoom:67%;" /><p><strong>循环队列</strong></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240306181259016.png" alt="image-20240306181259016" style="zoom:80%;" /><p><strong>例题</strong></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240306181313852.png" alt="image-20240306181313852" style="zoom: 67%;" /><p>选D</p><h4 id="5-串、数组、矩阵和广义表"><a href="#5-串、数组、矩阵和广义表" class="headerlink" title="5.串、数组、矩阵和广义表"></a>5.串、数组、矩阵和广义表</h4><h5 id="5-1串"><a href="#5-1串" class="headerlink" title="5.1串"></a>5.1串</h5><p>串是仅由字符构成的有限序列，是取值范围受限的线性表。般记为S&#x3D; ‘a1 a2…an’，其中S是串名，a1a2…an是串值。</p><p><strong>五种串的定义：</strong></p><ul><li><p>(1)空串：长度为零的串，空串不包合任何字符。</p></li><li><p>(2)空格串：由一个或多个空格组成的串。含有子串的串</p></li><li><p>(3)子串：由串中任意长度的连续字符构成的序列。称为主串。子串在主串中的位置指子串首次出现时，该子串的第一个字符在主串中的位置。<mark><strong>空串是任意串的子串</strong>。</mark></p></li><li><p>(4)<mark><strong>串相等：指两个串长度相等且对应位置上的字符也相同。</strong></mark></p></li><li><p>(5)<mark><strong>串比较：两个串比较大小时以字符的ASCII码值作为依据。</strong></mark>比较操作从两个串的第一个字符开始进行，字符的ASCI码值大者所在–个串先结束，则以串长较大者为大。</p></li></ul><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240306181819681.png" alt="image-20240306181819681" style="zoom: 50%;" /><p><strong>对串进行的基本操作</strong></p><ul><li><p>赋值操作StrAssign(s,)：将串t的值赋给串s</p></li><li><p>连接操作Concat(s,t)：将串t接续在串s的尾部，形成一个新串。</p></li><li><p>求串长StrLength(s)：返回串s的长度。</p></li><li><p>串比较StrCompare(s.t)：比较两个串的大小。</p></li><li><p>求子串SubString(,tart,len)：返回串s中从start开始的、长度为len的字符序列。</p></li></ul><p><strong>串的存储结构</strong></p><ul><li><p>串的顺序存储：定长存储结构</p></li><li><p>串的链式存储：块链</p></li></ul><p>  <strong>子串的定位操作通常称为串的模式匹配</strong>，它是各种串处理系统中最重要的运算之一。子串也称为模式串。</p><h5 id="5-2数组"><a href="#5-2数组" class="headerlink" title="5.2数组"></a>5.2数组</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240306182429126.png" alt="image-20240306182429126" style="zoom: 67%;" /><p><strong>例题：</strong></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240306182442694.png" alt="image-20240306182442694" style="zoom:67%;" /><p>答：26</p><p><strong>二维数组计算</strong>（没有原理，只有技巧）</p><ul><li><p><mark>按行优先，首地址+副对角线相乘再相加</mark></p></li><li><p><mark>按列优先，首地址+主对角线相乘再相加</mark></p></li></ul><p><strong>注意：</strong></p><p><mark>首地址从0开始A[0,0]</mark></p><ul><li><mark><strong>元素数字不变</strong></mark></li></ul><p><mark>首地址从1开始A[1,1]</mark></p><ul><li><mark><strong>元素</strong>A需行减-1，列-1</mark></li></ul><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240305203308565.png" alt="image-20240305203308565" style="zoom: 33%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240305203511539.png" alt="image-20240305203511539" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240305203657165.png" alt="image-20240305203657165" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/Snipaste_2024-03-05_20-41-44.png" alt="Snipaste_2024-03-05_20-41-44" style="zoom:33%;" /><h5 id="5-3矩阵"><a href="#5-3矩阵" class="headerlink" title="5.3矩阵"></a>5.3矩阵</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240306182842250.png" alt="image-20240306182842250" style="zoom: 67%;" /><p><strong>例题：</strong></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240306182906824.png" alt="image-20240306182906824" style="zoom:67%;" /><p>答：使用代入法，由于三角矩阵首地址A[0,0]，压缩在数组首地址M[1]中，可得出A[0,0]&#x3D;M[1]，既i&#x3D;0,j&#x3D;0，A和D选项满足条件，又由于三角矩阵第二行首地址为A[1,0]，压缩在数组第二个地址M[2]中，既i&#x3D;1,j&#x3D;0，A满足条件。</p><p><strong>例题：</strong></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240327224752852.png" alt="image-20240327224752852" style="zoom: 67%;" /><p>【解析】存储矩阵的一般方法是采用二维数组，其优点是可以随机地访问每一个元素，因而能够较容易地实现矩阵的各种运算。</p><p>但对于稀疏矩阵而言，若用二维数组来表示，会重复存储了很多个0了，浪费空间，而且要花费时间来进行零元素的无效计算。所以必须考虑对稀疏矩阵进行压缩存储。<mark>稀疏矩阵的三元组表的顺序存储结构称为三无组顺序表，三元组表的链式存储结构是十字链表。</mark></p><h5 id="5-3广义表"><a href="#5-3广义表" class="headerlink" title="5.3广义表"></a>5.3广义表</h5><p>广义表是n个表元素组成的有限序列，是线性表的推广。通常用递归的形式进行定义，记做:LS&#x3D;(ao,a1…，an)。</p><p><strong>定义：</strong></p><ul><li><p>其中LS是表名，a：是表元素，它可以是表(称做子表)，也可以是数据元素(称为原子)。</p></li><li><p>其中n是广义表的长度(也就是最外层包含的元素个数)，n&#x3D;0的广义表为空表。</p></li><li><p>而递归定义的重数就是广义表的深度，直观地说，就是定义中所含括号的重数(原子的深度为0，空表的深度为1)。</p></li></ul><p><strong>基本运算</strong></p><ul><li><p>取表头head(Ls)和取表尾tail(Ls)。</p></li><li><p>若有:LS1 &#x3D; (a，(b，c)，(d，e))</p><p>head(Ls1) &#x3D; a</p><p>tail(Ls1) &#x3D; ((b，c)，(d，e))</p></li></ul><p><strong>重点：</strong></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240308183743533.png" alt="image-20240308183743533" style="zoom: 50%;" /><p><strong>例题：</strong></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240308183832607.png" alt="image-20240308183832607" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240308183933222.png" alt="image-20240308183933222" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240306184236384.png" alt="image-20240306184236384" style="zoom:67%;" /><p>答：1.长度5，深度2</p><ol start="2"><li>先取表尾tail(LS1)，再执行取表头head(tail(LS1))，再取表头head(head(tail(Ls1)))</li></ol><h4 id="6-树和二叉树"><a href="#6-树和二叉树" class="headerlink" title="6.树和二叉树"></a>6.树和二叉树</h4><h5 id="6-1树的基本概念"><a href="#6-1树的基本概念" class="headerlink" title="6.1树的基本概念"></a>6.1<strong>树的基本概念</strong></h5><p>1.结点的度</p><p>2.树的度</p><p>3.叶子结点</p><p>4.分支结点</p><p>5.内部结点</p><p>6.父结点</p><p>7.子结点</p><p>8.兄弟结点</p><p>9.层次</p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240308193922788.png" alt="image-20240308193922788"></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240308193951620.png" alt="image-20240308193951620"  /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240308194007549.png" alt="image-20240308194007549" style="zoom: 67%;" /><p>例题：</p><p>具有3个结点的二又树有5种，可推测出具有4个结点的二叉树有( )种？</p><p>使用卡特兰数列计算公式：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240327224459691.png" alt="image-20240327224459691" style="zoom: 67%;" /><p>代入计算的n&#x3D;14。</p><h5 id="6-2二叉树的遍历"><a href="#6-2二叉树的遍历" class="headerlink" title="6.2二叉树的遍历"></a>6.2二叉树的遍历</h5><ul><li><p>前序遍历:根左右</p></li><li><p>中序遍历:左根右</p></li><li><p>后序遍历:左右根</p></li><li><p>层次遍历：按层遍历</p></li></ul><p><strong>反向构造二叉树</strong></p><p><strong>例题：</strong></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240308194654024.png" alt="image-20240308194654024" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240308194733081.png" alt="image-20240308194733081" style="zoom:50%;" /><h5 id="6-3树、二叉树、森林的转换"><a href="#6-3树、二叉树、森林的转换" class="headerlink" title="6.3树、二叉树、森林的转换"></a>6.3树、二叉树、森林的转换</h5><p><strong>树—&gt;二叉树</strong></p><p>兄弟相连留长子，兄弟变为右孩子。</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240308175839513.png" alt="image-20240308175839513" style="zoom:50%;" /><p><strong>二叉树—&gt;树</strong></p><p>右孩子变兄弟，兄弟不连留长子。</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240308180135071.png" alt="image-20240308180135071" style="zoom:50%;" /><p><strong>森林—&gt;二叉树</strong></p><p>兄弟相连留长子，兄弟变为右孩子，连接所有根节点。（树变二叉根相连）</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240308180826070.png" alt="image-20240308180826070" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240308180903594.png" alt="image-20240308180903594" style="zoom: 25%;" /><p><strong>二叉树—&gt;森林</strong></p><p>右孩子变兄弟，兄弟不连留长子，根不连。</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240308181253836.png" alt="image-20240308181253836" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240308181831273.png" alt="image-20240308181831273" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240307210816-17098170018274.jpg" alt="微信图片_20240307210816" style="zoom:25%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240307210624-17098171043856.jpg" alt="微信图片_20240307210624" style="zoom:25%;" /><h5 id="6-4查找二叉树-二叉排序树"><a href="#6-4查找二叉树-二叉排序树" class="headerlink" title="6.4查找二叉树(二叉排序树)"></a>6.4查找二叉树(二叉排序树)</h5><p><strong>特点：左孩子小于根，右孩子大于根。</strong></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240308195126757.png" alt="image-20240308195126757" style="zoom: 67%;" /><p>插入结点：</p><p>①若该键值结点已存在,则不再插入，如: 48.</p><p>②)若查找二叉树为空树,则以新结点为查找二叉树。</p><p>③将要插入结点键值与插入后父结点键值比较，就能确定新结点是父结点的左子结点,还是右子结点。</p><p>删除结点：</p><p>①若待删除结点是叶子结点,则直接删除。</p><p>②若待删除结点只有一个子结点,则将这个子结点与待删除结点的父结点直接连接，如:56。</p><p>③若待删除的结点p有两个子结点，则在其左子树上，用中序遍历寻找关键值最大的结点s,用结点s的值代替结点p的值，然后删除节点s，节点s必属于上述①，②情况之一，如89。</p><h5 id="6-5构造Huffman树-带权路径长度最小"><a href="#6-5构造Huffman树-带权路径长度最小" class="headerlink" title="6.5构造Huffman树(带权路径长度最小)"></a>6.5构造Huffman树(带权路径长度最小)</h5><p><mark>特点：Huffman树没有度为一的节点。</mark></p><p><mark>Huffman树构造不唯一，因此编码也不唯一，但是带权路径长度（WLP）唯一。</mark></p><p><strong>构造方法：</strong></p><p>选取数组中权值最小的两个数构成叶子节点，将相加和再次放入数组中，从下到上依次重复执行。</p><p><strong>例题1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240308195725295.png" alt="image-20240308195725295"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240308195740361.png" alt="image-20240308195740361"></p><p><strong>例题2：</strong></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240307210149.jpg" alt="微信图片_20240307210149" style="zoom:25%;" /><h5 id="6-6线索二叉树"><a href="#6-6线索二叉树" class="headerlink" title="6.6线索二叉树"></a>6.6线索二叉树</h5><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240308200313628.png" alt="image-20240308200313628"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240308200323522.png" alt="image-20240308200323522"></p><p><strong>画线索技巧：</strong></p><p><mark><strong>某节点若没有左孩子，则线索指向它的前驱；</strong></mark></p><p><mark><strong>某节点若没有右孩子，则线索指向它的后继。</strong></mark></p><p><strong>例题：</strong></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240308172852440.png" alt="image-20240308172852440" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240308172954917.png" alt="image-20240308172954917" style="zoom:50%;" /><h5 id="6-7平衡二叉树"><a href="#6-7平衡二叉树" class="headerlink" title="6.7平衡二叉树"></a>6.7平衡二叉树</h5><p><strong>定义：任意结点的左右子树深度相差不超过1，每结点的平衡度只能为-1、0或1。</strong></p><p>提出的原因：</p><p>例:对数列{1,5,7,9,8,39,73,88}构造排序二叉树，可以构造出多棵形式不同的排序二叉树。</p><p>不平衡：</p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240308201352076.png" alt="image-20240308201352076"></p><p>平衡：</p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240308201502167.png" alt="image-20240308201502167"></p><h4 id="7-图"><a href="#7-图" class="headerlink" title="7.图"></a>7.图</h4><h5 id="7-1基本概念"><a href="#7-1基本概念" class="headerlink" title="7.1基本概念"></a>7.1基本概念</h5><p>1、有向图</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240308202126615.png" alt="image-20240308202126615" style="zoom: 50%;" /><p>2、无向图</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240308202137900.png" alt="image-20240308202137900" style="zoom:50%;" /><p>3、完全图</p><ul><li>在无向图中，若每对顶点之间都有一条边相连，则称该图为完全图。</li><li>在有向图中,若每对顶点之间都有二条有向边相互连接,则称该图为完全图。</li></ul><p>4、度，入度与出度</p><h5 id="7-2储存结构"><a href="#7-2储存结构" class="headerlink" title="7.2储存结构"></a>7.2储存结构</h5><p><strong>邻接矩阵</strong></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240308202236491.png" alt="image-20240308202236491" style="zoom: 50%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240308202244742.png" alt="image-20240308202244742" style="zoom:50%;" /><p><mark>当无向图采用邻接矩阵存储时，无论无向图有多少边，当有n个顶点，吧矩阵大小为n^2。</mark></p><h5 id="7-3图的遍历"><a href="#7-3图的遍历" class="headerlink" title="7.3图的遍历"></a>7.3图的遍历</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240308202354444.png" alt="image-20240308202354444" style="zoom:50%;" /><h5 id="7-4拓扑排序"><a href="#7-4拓扑排序" class="headerlink" title="7.4拓扑排序"></a>7.4拓扑排序</h5><p><strong>拓扑排序概念：</strong></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240308190153589.png" alt="image-20240308190153589" style="zoom: 50%;" /><p><strong>拓扑序列不唯一。</strong></p><p><strong>拓扑排序过程：</strong></p><ul><li><mark>在有向图中选一个无前驱的顶点且输出它。</mark></li><li><mark>从图中删除该顶点和所有以它为尾的张。</mark></li><li><mark>重复(1)和(2)，直至不存在无前驱的顶点。</mark></li><li><mark>若此时输出的顶点数小于有向图中的顶点数，则说明有向图中存在环。否则输出的顶点序列即为一个拓扑序列。</mark></li></ul><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240308202516122.png" alt="image-20240308202516122" style="zoom:50%;" /><p><strong>例题：</strong></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240308190625058.png" alt="image-20240308190625058" style="zoom: 50%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240308190722695.png" alt="image-20240308190722695" style="zoom: 67%;" /><h5 id="7-5最小生成树"><a href="#7-5最小生成树" class="headerlink" title="7.5最小生成树"></a>7.5最小生成树</h5><p><strong>概念：</strong></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240308202937992.png" alt="image-20240308202937992" style="zoom:50%;" /><p><strong>prim算法（加点法）</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240308203209735.png" alt="image-20240308203209735"></p><p><strong>kruakal算法（加边法）</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240308203256316.png" alt="image-20240308203256316"></p><p>当存在权值相等的边时，最小生成树可能不唯一。</p><p><strong>例题1：</strong></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240308203824319.png" alt="image-20240308203824319" style="zoom:50%;" /><p><strong>例题2：</strong></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240308204259371.png" alt="image-20240308204259371" style="zoom:50%;" /><h4 id="8-查找"><a href="#8-查找" class="headerlink" title="8.查找"></a>8.查找</h4><p>在数据集合中寻找满足某种条件的数据元素的过程称为查找。</p><p>查找表(查找结构)–用于查找的数据集合称为查找表，它由同一类型的类据元素(或记录)组成。</p><p>数据元素中唯一标识该元素的某个数据项的值，使用基于关键字关键字–查找，查找结果应该是唯一的。</p><p>查找长度–在查找运算中，需要对比关键字的次数称为查找长度。</p><p>平均查找长度(ASL，Average Search Length)– 所有查找过程中进行关键字的比较次数的平均值。</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240309213542009.png" alt="image-20240309213542009" style="zoom:50%;" /><h5 id="8-1顺序查找"><a href="#8-1顺序查找" class="headerlink" title="8.1顺序查找"></a>8.1顺序查找</h5><p>顺序查找，又叫“线性查找”，通常用于线性表。算法思想:从头到脚挨个找(或者反过来也OK)</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240309213604222.png" alt="image-20240309213604222" style="zoom:50%;" /><h5 id="8-2折半查找"><a href="#8-2折半查找" class="headerlink" title="8.2折半查找"></a>8.2折半查找</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240309213719521.png" alt="image-20240309213719521" style="zoom: 50%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240309213816391.png" alt="image-20240309213816391" style="zoom: 50%;" /><h5 id="8-3分块查找"><a href="#8-3分块查找" class="headerlink" title="8.3分块查找"></a>8.3分块查找</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240309213900092.png" alt="image-20240309213900092" style="zoom:50%;" /><p><strong>特点：块内无序、块间有序</strong></p><p>第一步在索引表中确定待查记录所在的块，第二步在块内顺序查找。</p><h5 id="8-4哈希表"><a href="#8-4哈希表" class="headerlink" title="8.4哈希表"></a>8.4哈希表</h5><p>散列表(Hash Table)又称哈希表。是一种数据结构，特点是:数据元素的关键字与其存储地址直接相关。</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240309214157554.png" alt="image-20240309214157554" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240309214206896.png" alt="image-20240309214206896" style="zoom:50%;" /><p><strong>冲突：若不同的关键字通过散列函数映射到同一个值，则称它们为“同义词通过散列函数确定的位置已经存放了其他元素，则称这种情况为“冲突”。</strong></p><p>解决冲突方法：开放地址法、链地址法、再哈希法、建立一个公共溢出区。</p><h4 id="9-排序"><a href="#9-排序" class="headerlink" title="9.排序"></a>9.排序</h4><h5 id="9-1冒泡排序"><a href="#9-1冒泡排序" class="headerlink" title="9.1冒泡排序"></a>9.1冒泡排序</h5><p> 冒泡排序(Bubble Sort)，又被称为气泡排序或泡沫排序。<strong>它会遍历若干次需要排序的数列，每次遍历时，它都会从前往后依次的<mark>比较相邻两个数的大小</mark>；如果<mark>前者比后者大，则交换它们的位置</mark>。这样，一次遍历之后，最大的元素就在数列的末尾！ 采用相同的方法再次遍历时，第二大的元素就被排列在最大元素之前。</strong>重复此操作，直到整个数列都有序为止。</p><p>冒泡排序升序：元素两两比较，小的在前，大的在后，交换位置，依次重复，最终从末端向左依次逐渐。</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/v2-33a947c71ad62b254cab62e5364d2813_b.gif" alt="v2-33a947c71ad62b254cab62e5364d2813_b" style="zoom: 67%;" /><p>假设待排序序列为 (5,1,4,2,8)，如果采用冒泡排序对其进行升序（由小到大）排序，则整个排序过程如下所示：</p><ol><li>第一轮排序，此时整个序列中的元素都位于待排序序列，依次扫描每对相邻的元素，并对顺序不正确的元素对交换位置，整个过程如图 1 所示。</li></ol><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240309210537956.png" alt="image-20240309210537956" style="zoom:50%;" /><p>从图 1 可以看到，经过第一轮冒泡排序，从待排序序列中找出了最大数 8，并将其放到了待排序序列的尾部，并入已排序序列中。</p><ol start="2"><li>第二轮排序，此时待排序序列只包含前 4 个元素，依次扫描每对相邻元素，对顺序不正确的元素对交换位置，整个过程如图 2 所示。</li></ol><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240309210630962.png" alt="image-20240309210630962" style="zoom:50%;" /><p>可以看到，经过第二轮冒泡排序，从待排序序列中找出了最大数 5，并将其放到了待排序序列的尾部，并入已排序序列中。</p><ol start="3"><li>第三轮排序，此时待排序序列包含前 3 个元素，依次扫描每对相邻元素，对顺序不正确的元素对交换位置，整个过程如图 3 所示。</li></ol><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240309210640333.png" alt="image-20240309210640333" style="zoom:50%;" /><p>经过本轮冒泡排序，从待排序序列中找出了最大数 4，并将其放到了待排序序列的尾部，并入已排序序列中。</p><ol start="4"><li>第四轮排序，此时待排序序列包含前 2 个元素，对其进行冒泡排序的整个过程如图 4 所示。</li></ol><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240309210701680.png" alt="image-20240309210701680" style="zoom:50%;" /><p>经过本轮冒泡排序，从待排序序列中找出了最大数 2，并将其放到了待排序序列的尾部，并入已排序序列中。</p><ol start="5"><li>当进行第五轮冒泡排序时，由于待排序序列中仅剩 1 个元素，无论再进行相邻元素的比较，因此直接将其并入已排序序列中，此时的序列就认定为已排序好的序列（如图 5 所示）。</li></ol><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240309210750236.png" alt="image-20240309210750236" style="zoom:50%;" /><h5 id="9-2选择排序"><a href="#9-2选择排序" class="headerlink" title="9.2选择排序"></a>9.2选择排序</h5><p>从头至尾扫描序列，找出最小的一个元素，和第一个元素交换，接着从剩下的元素中继续这种选择和交换方式，最终得到一个有序序列。</p><p>动图：<a href="https://pic1.zhimg.com/v2-1c7e20f306ddc02eb4e3a50fa7817ff4_b.webp">https://pic1.zhimg.com/v2-1c7e20f306ddc02eb4e3a50fa7817ff4_b.webp</a></p><p><strong>算法优化</strong></p><p>选择排序一趟只选取最小值，优化的办法就是<strong>一趟把最小值和最大值都选出来</strong>，<strong>最小的放在左边，最大的放在右边优化后的方法循环趟数将减半</strong>。</p><h5 id="9-3插入排序"><a href="#9-3插入排序" class="headerlink" title="9.3插入排序"></a>9.3插入排序</h5><p>插入排序算法常常被比作打牌：<mark>我们从第二个元素开始，此后的每个元素就像新拿到的一张牌，我们要做的事就是将这张牌与之前的所有手牌进行比较，把这张牌插到适合他的位置。</mark>这样，我们看过所有牌之后，他们的顺序自然就是从小到大或从大到小了~</p><p>从前往后，每次拿出一个元素，从后向前扫描，比较大小，找到相应位置并插入。</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/v2-91b76e8e4dab9b0cad9a017d7dd431e2_b.gif" alt="v2-91b76e8e4dab9b0cad9a017d7dd431e2_b" style="zoom: 67%;" /><h5 id="9-4希尔排序"><a href="#9-4希尔排序" class="headerlink" title="9.4希尔排序"></a>9.4希尔排序</h5><p>希尔排序就是升级版的插入排序，由D.L.Shell于1959年提出而得名希尔排序。<mark>它会从大到小，通过设置不同的间隔，优先对“子数列”进行插入排序，最后实现对整体进行排序。</mark>它对于计算机而言会更加“经济”，但是对于人来说，这未免更难以理解，毕竟我们都不是这么打牌的。</p><p><strong>基本思想：</strong></p><ul><li><p>将待排序数组按照一定的间隔分为多个子数组，每组分别进行插入排序。这里按照间隔分组指的不是取连续的一段数组，而是每跳跃一定间隔取一个值组成一组。</p></li><li><p>逐渐缩小间隔进行下一轮排序。</p></li><li><p>最后一轮时，取间隔为 1，也就相当于直接使用插入排序。但这时经过前面的「宏观调控」，数组已经基本有序了，所以此时的插入排序只需进行少量交换便可完成。</p></li></ul><p><strong>基本步骤：</strong></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240420131623478.png" alt="image-20240420131623478" style="zoom:67%;" />    <img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/6f304b5936f54b1fa34372de002b6e39.png" alt="6f304b5936f54b1fa34372de002b6e39" style="zoom: 80%;" /><p>  动图：<a href="https://img2018.cnblogs.com/blog/1258817/201904/1258817-20190420100142756-421005088.gif">https://img2018.cnblogs.com/blog/1258817/201904/1258817-20190420100142756-421005088.gif</a></p><h5 id="9-5快速排序"><a href="#9-5快速排序" class="headerlink" title="9.5快速排序"></a>9.5快速排序</h5><p>快速排序是C.R.A.Hoare于1962年提出的。</p><p><strong>基本思想：</strong></p><ul><li>先从数列中取出一个元素作为基准数。</li><li>扫描数列，将比基准数小的元素全部放到它的左边，大于或等于基准数的元素全部放到它的右边，得到左右两个区间。</li><li>再对左右区间重复第二步，直到各区间少于两个元素。</li></ul><p>动图：<a href="https://pic1.zhimg.com/v2-c411339b79f92499dcb7b5f304c826f4_b.webp">https://pic1.zhimg.com/v2-c411339b79f92499dcb7b5f304c826f4_b.webp</a></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240309200940816.png" alt="image-20240309200940816" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240309201004494.png" alt="image-20240309201004494" style="zoom: 67%;" /><h5 id="9-6归并排序"><a href="#9-6归并排序" class="headerlink" title="9.6归并排序"></a>9.6归并排序</h5><p>归并排序，是创建在归并操作上的一种有效的排序算法。算法是<strong>采用分治法</strong>（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。归并排序思路简单，速度仅次于快速排序，为稳定排序算法。</p><p><strong>基本思想</strong>：</p><ol><li><strong>将序列中待排序数字分为若干组，最终每个数字分为一组。（默认长度为1的序列是有序的）</strong></li><li><strong>将若干个组两两合并，保证合并后的组是有序的。（俩个子序列头部进行比较大小）</strong></li><li><strong>重复第二步操作直到只剩下一组，排序完成。</strong></li></ol><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240309192849272.png" alt="image-20240309192849272" style="zoom:50%;" /><h5 id="9-7堆排序"><a href="#9-7堆排序" class="headerlink" title="9.7堆排序"></a>9.7堆排序</h5><p><strong>基本思想：</strong></p><ul><li><p>首先，把要排序的数组变成一个大顶堆，这样最大的数就在堆的顶部。</p></li><li><p>接着，把堆顶的数和数组的最后一个数交换。现在，最大的数已经在数组的末尾，剩下的数组元素个数变为 n-1。</p></li><li><p>对剩下的 n-1 个数再次构建大顶堆，然后把新堆顶的数和 n-1 位置的数交换。不断重复这个过程，直到得到一个升序排列的数组。</p></li></ul><p><strong>注意</strong>：要得到升序排列的数组，用大顶堆；要得到降序排列的数组，用小顶堆（默认情况下，我们使用升序排序）。</p><p>动图：<a href="https://img2018.cnblogs.com/blog/1258817/201904/1258817-20190420150936225-1441021270.gif">https://img2018.cnblogs.com/blog/1258817/201904/1258817-20190420150936225-1441021270.gif</a></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240309194855331.png" alt="image-20240309194855331" style="zoom: 67%;" /><p><strong>现在我们已经构建了一个大顶堆，接下来进行排序。</strong></p><p><strong>首先，将堆顶元素（假设为9）与数组末尾元素（假设为4）交换位置</strong>。此时，数组末尾的数字是最大值。<strong>排除已经确定的最大元素，将剩下的元素重新构建成一个大顶堆。</strong></p><p><strong>以下是第一次交换的示意图：</strong></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240309195009037.png" alt="image-20240309195009037" style="zoom: 67%;" /><h5 id="9-8基数排序-桶排序"><a href="#9-8基数排序-桶排序" class="headerlink" title="9.8基数排序(桶排序)"></a>9.8基数排序(桶排序)</h5><p><strong>基本思想：</strong></p><p>将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240309200014247.png" alt="image-20240309200014247" style="zoom: 67%;" /><p>动图：<a href="https://upload-images.jianshu.io/upload_images/13587608-450e0c1edb8c7137.gif">https://upload-images.jianshu.io/upload_images/13587608-450e0c1edb8c7137.gif</a></p><h5 id="9-9计数排序（Counting-Sort）"><a href="#9-9计数排序（Counting-Sort）" class="headerlink" title="9.9计数排序（Counting Sort）"></a>9.9计数排序（Counting Sort）</h5><blockquote><p>计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p></blockquote><p><strong>算法描述</strong> - 找出待排序的数组中最大和最小的元素； - 统计数组中每个值为i的元素出现的次数，存入数组C的第i项； - 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）； - 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</p><p>动图：<img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/v2-3c7ddb59df2d21b287e42a7b908409cb_b.gif" alt="v2-3c7ddb59df2d21b287e42a7b908409cb_b" style="zoom:67%;" /></p><h5 id="算法复杂度-重点"><a href="#算法复杂度-重点" class="headerlink" title="算法复杂度(重点)"></a>算法复杂度(重点)</h5><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240510212850594.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240422231352803.png" alt="image-20240422231352803"></p><h3 id="第3章：算法分析与设计"><a href="#第3章：算法分析与设计" class="headerlink" title="第3章：算法分析与设计"></a>第3章：算法分析与设计</h3><h4 id="3-1分治法"><a href="#3-1分治法" class="headerlink" title="3.1分治法"></a>3.1分治法</h4><p>对于一个规模为n的问题,若该问题可以容易地解决(比如说规模n较小则直接解决，否则将其分解为k个规模较小的子问题，这些<mark>子问题互相独立且与原问题形式相同</mark>，递归地解这些子问题,然后将各子问题的解合并得到原问题的解。</p><p><strong>要求:</strong></p><ul><li>该问题的规模缩小到一定的程度就可以容易地解决</li><li>该问题可以分解为若干个规模较小的相同问题</li><li>利用该问题分解出的子问题的解可以合并为该问题的解</li><li><strong>该问题所分解出的各个子问题是相互独立的。</strong></li></ul><p><strong>递归算法：</strong></p><p>程序执行过程中自己调用自己。</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240310151450204.png" alt="image-20240310151450204" style="zoom: 50%;" /><p><strong>快速排序</strong></p><h4 id="3-2动态规划"><a href="#3-2动态规划" class="headerlink" title="3.2动态规划"></a>3.2动态规划</h4><h5 id="3-2-1动态规划算法"><a href="#3-2-1动态规划算法" class="headerlink" title="3.2.1动态规划算法"></a>3.2.1动态规划算法</h5><p><strong>基本思想</strong></p><p>将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。<mark>与分治法不同的是，适合于用动态规划法求解的问题，经分解得到的子问题往往不是独立的。</mark><mark>与贪心算法不同的是，找到的解是整体最优的解。</mark></p><p><strong>动态规划算法重要性质：</strong></p><p><strong>1. 最优子结构</strong></p><p>设计动态规划算法的第一步通常是要刻画最优解的结构。当问题的最优解包含了其子问题的最优解时，称该问题具有最优子结构性质。问题的最优子结构性质提供了该问题可用动态规划算法求解的重要线索。利用问题的最优子结构性质，以自底向上的方式递归地从子问题的最优解逐步构造出整个问题的最优解。</p><p><strong>2. 重叠子问题</strong></p><p>可用动态规划算法求解的问题应具备的另一基本要素是子问题的重叠性质。在用递归算法自顶向下解此问题时，每次产生的子问题并不总是新问题，有些子问题被反复计算多次。动态规划算法正是利用了这种子问题的重叠性质，<strong>对每一个子问题只解一次，而后将其解保存在一个表格中，当再次需要解此子问题时，只是简单地用常数时间查看一下结果</strong>。通常，不同的子问题个数随问题的大小呈多项式增长。因此，用动态规划算法通常只需要多项式时间，从而获得较高的解题效率。</p><p>动态规划算法通常用于求解具有某种最优性质的问题在这类问题中，可能会有许多可行解，每个解都对应于一个值，我们希望找到具有最优值的那个解。当然，最优解可能会有多个，动态规划算法能找出其中的一个最优解。</p><h6 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a><strong>0-1背包问题</strong></h6><p> 假设我们有n件物品，分别编号为1, 2…n。其中编号为i的物品价值为vi，它的重量为wi。为了简化问题，假定价值和重量都是整数值。现在，假设我们有一个背包，它能够承载的重量是W。现在，我们希望往包里装这些物品，使得包里装的物品价值最大化。</p><p>这个问题其实根据不同的情况可以归结为不同的解决方法。假定我们这里<strong>选取的物品每个都是独立的，不能选取部分</strong>。也就是说我们要么选取某个物品，要么不能选取，不能只选取一个物品的一部分。这种情况，我们称之为0-1背包问题。</p><p>举例说明：</p><p>设背包容量为5，有4个物品：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240310150356549.png" alt="image-20240310150356549" style="zoom: 33%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240310150525093.png" alt="image-20240310150525093" style="zoom:33%;" /><p><mark>动态规划本质：就是填表</mark>，一旦找出动态转移方程，就可以用方程把整个表都填满了。</p><p>这里我们先将空表画出来，<strong>i表示物品，j表示背包容量。</strong></p><p>容易看出，当J&#x3D;0(背包容量为0)时，背包价值永远为0，故第一列全为0；当i&#x3D;0(没有物品)时，背包价值永远为0，故第一行全为0。</p><p><mark>0-1背包问题：时间复杂度：O(nW)  （n：物品数量，W：最大装包容量）</mark></p><h5 id="3-2-2贪心算法"><a href="#3-2-2贪心算法" class="headerlink" title="3.2.2贪心算法"></a>3.2.2贪心算法</h5><p>总是做出在当前来说是最好的选择，而并不从整体上加以考虑,它所做的每步选择只是当前步骤的局部最优选择，但从整体来说不一定是最优的选择。由于它不必为了寻找最优解而穷尽所有可能解，因此其耗费时间少，一般可以快速得到满意的解，但得不到最优解。也常用于解决最优化的问题。</p><p><strong>贪心算法重要性质：</strong></p><p><strong>1. 最优子结构</strong></p><p>当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构。问题的最优子结构是该问题可以采用动态规划法或者贪心法求解的关键性质。</p><p><strong>2. 贪心选择性质</strong></p><p>指问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来得到。这是贪心法和动态规划法的主要区别。</p><h6 id="部分背包问题"><a href="#部分背包问题" class="headerlink" title="部分背包问题"></a><strong>部分背包问题</strong></h6><p>部分背包问题。有n个物体，第i个物体的重量为wi，价值为vi。在总重量不超过C的情况下让总价值尽量高。<strong>每一个物体都可以只取走一部分，价值和重量按比例计算</strong>。</p><p><mark>贪心策略本质：优先拿性价比高的，也就是vi &#x2F; wi大的，直到重量恰好为C。</mark></p><p>由于可以拿部分，因此一定能保证重量恰好为C(除非n个物体总重量不足C)，并且除了拿的最后一个物体可能是拿部分以外，其他拿的都是拿整个。</p><p><mark>部分背包问题：时间复杂度：O(nlogn)</mark></p><h4 id="3-3回溯法"><a href="#3-3回溯法" class="headerlink" title="3.3回溯法"></a>3.3回溯法</h4><p>回溯法是种选优搜索法,按选优条件向前搜索,以达到目标。但当搜索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择。这种走不通就退回再走的技术就是回溯法。</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240310152737384.png" alt="image-20240310152737384" style="zoom:50%;" /><h3 id="第4章：操作系统基本原理"><a href="#第4章：操作系统基本原理" class="headerlink" title="第4章：操作系统基本原理"></a>第4章：操作系统基本原理</h3><h4 id="4-1基本概念"><a href="#4-1基本概念" class="headerlink" title="4.1基本概念"></a>4.1基本概念</h4><p><strong>特征：</strong></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240310155920376.png" alt="image-20240310155920376" style="zoom: 33%;" /><p><strong>发展与分类：</strong></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240310160006326.png" alt="image-20240310160006326" style="zoom: 33%;" /><h4 id="4-2进程管理"><a href="#4-2进程管理" class="headerlink" title="4.2进程管理"></a>4.2进程管理</h4><h5 id="4-2-1进程概念"><a href="#4-2-1进程概念" class="headerlink" title="4.2.1进程概念"></a>4.2.1进程概念</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240310175533814.png" alt="image-20240310175533814" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240310175609911.png" alt="image-20240310175609911" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240310175635999.png" alt="image-20240310175635999" style="zoom:50%;" /><h5 id="4-2-2进程执行流程"><a href="#4-2-2进程执行流程" class="headerlink" title="4.2.2进程执行流程"></a>4.2.2进程执行流程</h5><p>三状态图：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240310175457737.png" alt="image-20240310175457737" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240310175709484.png" alt="image-20240310175709484" style="zoom:50%;" /><p>选C</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240310180425283.png" alt="image-20240310180425283" style="zoom:50%;" /><p>选C</p><p>五状态图：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240310180120927.png" alt="image-20240310180120927" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240310160127593.png" alt="image-20240310160127593" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240310155655980.png" alt="image-20240310155655980" style="zoom: 33%;" /><p><strong>进程同步机制:</strong></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240310160505935.png" alt="image-20240310160505935" style="zoom:33%;" /><p>读进程和写进程并发地运行，由于并发必然导致异步性，因此“写数读”和“读数据”两个操作执行的先后顺序是不确定的。而实际应用中又必须按照“写数据一读数据”的顺序来执行的。进程同步机制”所讨论的内容。就是如何解决这种异步问题。</p><p>同步：亦称直接制约关系，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。</p><h5 id="4-2-3信号量与PV操作"><a href="#4-2-3信号量与PV操作" class="headerlink" title="4.2.3信号量与PV操作"></a>4.2.3信号量与PV操作</h5><p><mark>临界资源就是互斥资源。</mark></p><p><strong>进程互斥机制：</strong></p><p>进程的“并发”需要“共享”的支持。各个并发执行的进程不可避免的需要共享一些系统资源(比如内存，又比如汀印机、摄像头这样的I&#x2F;0设备。</p><p><mark>我们把一个时间段内只允许一个进程使用的资源称为临界资源（互斥资源）。</mark>此外还有许多变量、数据、内存缓冲区等都属都属于临界资源。物理设备(比如摄像头、打印机)都属都属于临界资源。</p><p><mark>对临界资源访问，必须互斥的进行。</mark>互斥，亦称间接制约关系。进程必互斥指当一个进程访问某临界资源，另一个想要访问该临界资源的明须等待。当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源。</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240310181234260.png" alt="image-20240310181234260" style="zoom: 50%;" /><h6 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h6><p>信号量是一种特殊的变量。</p><ul><li><p>信号量为正数表示资源数量;</p></li><li><p>信号量为负数时，绝对值表示排队进程数（阻塞队列数量）。</p><p>P是荷兰语Passeren,V是荷兰语Verhoog.</p></li></ul><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240310182534445.png" alt="image-20240310182534445" style="zoom:50%;" /><p><mark>P：要资源；V：释放资源<mark></p><p>例题：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240310182838144.png" alt="image-20240310182838144" style="zoom:50%;" /><p>初值2；范围[-1,2]</p><h6 id="互斥模型"><a href="#互斥模型" class="headerlink" title="互斥模型"></a>互斥模型</h6><p><strong>多个进程共享（互斥）一台打印机问题</strong></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240310183305425.png" alt="image-20240310183305425" style="zoom:50%;" /><p>注:</p><ul><li><p><mark>互斥信号量S（资源数量）一般初值为1。</mark></p></li><li><p><mark>互斥信号量S的初值一般为非0。</mark></p></li><li><p><mark>访问权是一类特殊的互斥资源，同一时刻仅允许1个人用，则信号量初值为1。</mark></p></li><li><p><strong>先P后V</strong></p></li></ul><h6 id="同步模型"><a href="#同步模型" class="headerlink" title="同步模型"></a>同步模型</h6><p><strong>单缓冲区生产者、消费者问题</strong></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240311172833295.png" alt="image-20240311172833295" style="zoom: 50%;" /><p>S1：市场个数，初值为1；S2：产品数量，初值为0；</p><p>注：</p><ul><li><strong>同步信号量S的初值一般为0。</strong></li><li><strong>先V后P</strong></li></ul><p><strong>互斥模型和同步模型对比：</strong></p><p><mark>互斥模型先P后V，信号量初值S≠0；</mark></p><p><mark>同步模型先V后P，信号量初值S&#x3D;0。</mark></p><p>例题：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240311173858556.png" alt="image-20240311173858556" style="zoom:50%;" /><p>选B</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240311174044423.png" alt="image-20240311174044423" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240311174212942.png" alt="image-20240311174212942" style="zoom:50%;" /><p>选C、D</p><h5 id="4-2-4前驱图与PV操作"><a href="#4-2-4前驱图与PV操作" class="headerlink" title="4.2.4前驱图与PV操作"></a>4.2.4前驱图与PV操作</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240311174343812.png" alt="image-20240311174343812" style="zoom:50%;" /><p>技巧:</p><p>并发图中某活动<mark>有后继就有v操作释放资源</mark>，<mark>有前驱就有p操作消耗资源</mark>。</p><p><mark>实现并发的信号量初值一般为0。有几个箭头就有几个信号量。</mark></p><p>例题;</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240311174707693.png" alt="image-20240311174707693" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240311174748231.png" alt="image-20240311174748231" style="zoom:50%;" /><p>选C 、A</p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240420000837629.png" alt="image-20240420000837629"></p><h5 id="4-2-5死锁问题"><a href="#4-2-5死锁问题" class="headerlink" title="4.2.5死锁问题"></a>4.2.5死锁问题</h5><p>了解概念</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240311174858820.png" alt="image-20240311174858820" style="zoom:50%;" /><p><strong>考点：</strong></p><p>进程管理是操作系统的核心，但如果设计不当，就会出现死锁的问题。如果进程在等待一件不可能发生的事，则进程就死锁了。而如果多个进程产生死锁，就会造成系统死锁。</p><p><mark>系统可能发生死锁的最大资源数        (w-1)*m &lt;&#x3D;n</mark></p><p><mark>系统不可能发生死锁的最小资源数    (w-1)*m+1&lt;&#x3D;n</mark></p><p><strong>w：单个进程所需系统资源数；m：系统进程数</strong></p><p>例题：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240311175641436.png" alt="image-20240311175641436" style="zoom:50%;" /><p>答：求不可能发生死锁的最小资源数为16</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240311175859350.png" alt="image-20240311175859350" style="zoom:50%;" /><p>选D，（4-1）*3 &#x3D; 9 &gt; 8</p><h5 id="4-2-6进程资源图"><a href="#4-2-6进程资源图" class="headerlink" title="4.2.6进程资源图"></a>4.2.6进程资源图</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240311180608902.png" alt="image-20240311180608902" style="zoom:50%;" /><p><strong>考点：</strong></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240311180808593.png" alt="image-20240311180808593" style="zoom: 50%;" /><ul><li><p><strong>先分析资源分配情况，列出剩余可用资源：此时已分配1个R1给进程P，剩余1个R1可用。</strong></p></li><li><p><strong>再判断申请后进程是否能够执行：P进程申请1个R1，系统有1个R1可用，P进程可成功执行，执行后释放占用的2个R1。</strong></p></li></ul><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240311180844569.png" alt="image-20240311180844569" style="zoom:50%;" /><p><strong>解题思路：</strong></p><ul><li><p><mark>先确定定下的，即资源主动分派给进程的(R–&gt;P)，再确定进程被动向进程要的(P–&gt;R)。</mark></p></li><li><p><mark>进程被动向进程要资源，如果资源有剩余，进程就能要的到，该进程就为非阻塞，反之为阻塞。</mark></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240311183319553.png" alt="image-20240311183319553" style="zoom:50%;" /><p>如题所示，资源先分配进程，之后P1内R2要资源，R2中剩余一个资源，即P1不阻塞，P2向R1要资源，R1没有剩余资源，即P2阻塞，R3不阻塞。选D </p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240420001205044.png" alt="image-20240420001205044"></p></li></ul><h4 id="4-3存储管理"><a href="#4-3存储管理" class="headerlink" title="4.3存储管理"></a>4.3存储管理</h4><h5 id="4-3-1段页式存储"><a href="#4-3-1段页式存储" class="headerlink" title="4.3.1段页式存储"></a>4.3.1段页式存储</h5><h6 id="页式存储"><a href="#页式存储" class="headerlink" title="页式存储"></a>页式存储</h6><p><strong>将程序与内存均划分为同样大小的块，以页为单位将程序调入内存。</strong></p><p><strong>对于用户程序称为页，对于内存称为块。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240312174627061.png" alt="image-20240312174627061"></p><ul><li><p><strong>优点：利用率高，碎片小，分配及管理简单</strong></p></li><li><p><strong>缺点：增加了系统开销，可能产生抖动现象</strong></p></li></ul><p>高级程序语言使用逻辑地址；运行状态，内存中使用物理地址。</p><p><strong>逻辑地址&#x3D;页号+页内地址</strong></p><p><strong>物理地址&#x3D;页号+页内地址</strong></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240312174943787.png" alt="image-20240312174943787" style="zoom: 67%;" /><p>分析：每个页有2^12个 Byte，相当于2^12个地址，10为页号，110011011110为页内偏移量，页号(10)B&#x3D;2对应的页号为6&#x3D;(110)B</p><p><strong>注意：</strong></p><p><mark>对于段页式存储而言，逻辑地–&gt;物理地址，只改变页号为页帧号，页内偏移量不变。</mark></p><p>文件替换规律：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240312180418244.png" alt="image-20240312180418244" style="zoom:67%;" /><h6 id="段式存储"><a href="#段式存储" class="headerlink" title="段式存储"></a>段式存储</h6><p><strong>按用户作业中的自然段来划分逻辑空间，然后调入内存，段的长度可以不一样。</strong></p><p><mark>段式存储映射该段在内存中的起始位置（基址）。</mark></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240312181112318.png" alt="image-20240312181112318" style="zoom:67%;" /><ul><li><p><strong>优点：多道程序共享内存，各段程序修改互不影响</strong></p></li><li><p><strong>缺点：内存利用率低，内存碎片浪费大</strong></p></li></ul><h6 id="段页式存储"><a href="#段页式存储" class="headerlink" title="段页式存储"></a>段页式存储</h6><p><strong>段式与页式的综合体。先分段，再分页。</strong>1个程序有若干个段，每个段中可以有若干页，每个页的大小相同，但每个段的大小不同。</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240312181226761.png" alt="image-20240312181226761" style="zoom:67%;" /><ul><li><strong>优点：空间浪费小、存储共享容易、存储保护容易、能动态连接</strong></li><li><strong>缺点：由于管理软件的增加，复杂性和开销也随之增加，需要的硬件以及占用的内容也有所增加，使得执行速度大大下降</strong></li></ul><p>例题：</p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240503172454425.png"></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240312181538482.png" alt="image-20240312181538482" style="zoom:67%;" /><p>分析：逻辑地址2对应物理块4，页内偏移量不变，H为16进制。选C</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240312182133499.png" alt="image-20240312182133499" style="zoom:67%;" /><p>选A</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240312182455902.png" alt="image-20240312182455902" style="zoom:67%;" /><p>分析，看段号和段长，选B</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240312183317120.png" alt="image-20240312183317120" style="zoom:67%;" /><p>选B</p><h4 id="4-4磁盘管理"><a href="#4-4磁盘管理" class="headerlink" title="4.4磁盘管理"></a>4.4磁盘管理</h4><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240312183449242.png" alt="image-20240312183449242" style="zoom:67%;" /><p>多个磁片的同一个磁道形成一个柱面，所以磁道有时也叫做柱面。</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240313201447574.png" alt="image-20240313201447574" style="zoom:67%;" /><p><strong>读取磁盘数据的时间应包括以下三个部分：</strong></p><ul><li><mark>(1)找磁道的时间。</mark></li><li><mark>(2)找块(扇区)的时间，即旋转延迟时间。</mark></li><li><mark>(3)传输时间。</mark></li></ul><p>例题：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240313201924108.png" alt="image-20240313201924108" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240313202055233.png" alt="image-20240313202055233" style="zoom:67%;" /><h5 id="4-4-1先来先服务"><a href="#4-4-1先来先服务" class="headerlink" title="4.4.1先来先服务"></a>4.4.1先来先服务</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240313202306797.png" alt="image-20240313202306797" style="zoom: 67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240313202333375.png" alt="image-20240313202333375" style="zoom: 67%;" /><h5 id="4-4-2最短寻道时间优先"><a href="#4-4-2最短寻道时间优先" class="headerlink" title="4.4.2最短寻道时间优先"></a>4.4.2最短寻道时间优先</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240313202716975.png" alt="image-20240313202716975" style="zoom:67%;" /><p>例题：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240313202739489.png" alt="image-20240313202739489" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240313203014539.png" alt="image-20240313203014539" style="zoom:67%;" /><p>分析：磁盘旋转周期33ms对应11扇区，每块3ms，经过3ms读完R0，经过3ms处理缓冲区，3ms*10扇区+3ms+3ms+处理R0的6ms&#x3D;366ms；优化11 * (3+3)&#x3D;66ms</p><p>选B、B</p><h5 id="4-4-3最短移臂调度"><a href="#4-4-3最短移臂调度" class="headerlink" title="4.4.3最短移臂调度"></a>4.4.3最短移臂调度</h5><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240422211524333.png" alt="image-20240422211524333"></p><h4 id="4-5文件管理"><a href="#4-5文件管理" class="headerlink" title="4.5文件管理"></a>4.5文件管理</h4><h5 id="4-5-1基本概念"><a href="#4-5-1基本概念" class="headerlink" title="4.5.1基本概念"></a>4.5.1基本概念</h5><p>了解即可</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240313211017768.png" alt="image-20240313211017768" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240313211115552.png" alt="image-20240313211115552" style="zoom:67%;" /><p><strong>考点：</strong></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240313211245366.png" alt="image-20240313211245366" style="zoom:67%;" /><p>例题：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240313211309262.png" alt="image-20240313211309262" style="zoom:67%;" /><p>选A，BCD 为具体文件</p><h5 id="4-5-2树形目录结构"><a href="#4-5-2树形目录结构" class="headerlink" title="4.5.2树形目录结构"></a>4.5.2树形目录结构</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240313211537662.png" alt="image-20240313211537662" style="zoom:67%;" /><p>例题：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240313211601341.png" alt="image-20240313211601341" style="zoom:67%;" /><p>选C、B</p><h5 id="4-5-3索引文件结构"><a href="#4-5-3索引文件结构" class="headerlink" title="4.5.3索引文件结构"></a>4.5.3索引文件结构</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240313211655682.png" alt="image-20240313211655682" style="zoom:67%;" /><p>例题：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240313211954129.png" alt="image-20240313211954129" style="zoom:67%;" /><p>分析：假设从0开始，逻辑块4采用直接地址索引，5采用一级简介地址索引，7采用二级简介地址索引，选B；</p><p>计算：1KB &#x2F; 4 &#x3D; 256KB，既256个地址，</p><p>5+256 ** 2+255* * 255</p><p>一级5个 + 二级256*2 + 三级256^2 &#x3D; 66053，选D </p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240420000346393.png" alt="image-20240420000346393"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240503171435513.png" alt="image-20240503171435513"></p><h5 id="4-5-4位视图"><a href="#4-5-4位视图" class="headerlink" title="4.5.4位视图"></a>4.5.4位视图</h5><p>作用：标识物理块是否可用。</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240313212845963.png" alt="image-20240313212845963" style="zoom:67%;" /><p><strong>重点：1行为1个字</strong></p><p><strong>做题技巧：物理块(当前格子编号) &#x2F; 字长(向下取整)</strong>   </p><p> 注意：字号，字长都从0开始</p><p>例题：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240313213629412.png" style="zoom:67%;" /><p>分析：(300 * 1024MB) &#x2F; 32，选D</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240313213657603.png" alt="image-20240313213657603" style="zoom:67%;" /><p>分析：2053 &#x2F; 32 ，选C</p><h4 id="4-6设备管理"><a href="#4-6设备管理" class="headerlink" title="4.6设备管理"></a>4.6设备管理</h4><h5 id="4-6-1-IO的设备管理"><a href="#4-6-1-IO的设备管理" class="headerlink" title="4.6.1 IO的设备管理"></a>4.6.1 IO的设备管理</h5><p><strong>考点：流程图（背）</strong></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240313204937941.png" alt="image-20240313204937941" style="zoom:67%;" /><p>例题：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240313205143177.png" alt="image-20240313205143177" style="zoom:67%;" /><p>选D</p><h5 id="4-6-2缓冲器计算问题"><a href="#4-6-2缓冲器计算问题" class="headerlink" title="4.6.2缓冲器计算问题"></a>4.6.2缓冲器计算问题</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240313205718485.png" alt="image-20240313205718485" style="zoom:67%;" /><h6 id="单缓冲区"><a href="#单缓冲区" class="headerlink" title="单缓冲区"></a>单缓冲区</h6><p>由于缓冲区只有一个，所以每次经过缓冲区的输入输出都必须完整的做完，才能进行后续处理。</p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240509135931220.png" alt="image-20240509135931220"></p><h6 id="双缓冲区"><a href="#双缓冲区" class="headerlink" title="双缓冲区"></a>双缓冲区</h6><p>使用流水线计算方式。</p><p>例题：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240313205423717.png" alt="image-20240313205423717" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240313210930424.png" alt="image-20240313210930424" style="zoom: 33%;" /><p>分析：当缓冲区处理完数据，第二个文件就可以继续输入了，当处理最后一个数据时，还需要在工作区处理2μs，总计（10+6）+2μs。</p><h4 id="4-7微内核操作系统"><a href="#4-7微内核操作系统" class="headerlink" title="4.7微内核操作系统"></a>4.7微内核操作系统</h4><h5 id="4-7-1概念"><a href="#4-7-1概念" class="headerlink" title="4.7.1概念"></a>4.7.1概念</h5><p><strong>微内核操作系统是一种以微内核为核心的操作系统范式</strong>，与传统内核操作系统不同的是，<strong>它将操作系统的核心部分精简到最小，只包含了最基本和最核心的操作系统服务</strong>。这些服务采用了更为安全、可靠的方式，运行在系统的用户空间中，避免了传统操作系统中内核部分的单点故障风险。</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240313215257854.png" alt="image-20240313215257854" style="zoom: 50%;" /><h4 id="4-8总结"><a href="#4-8总结" class="headerlink" title="4.8总结"></a>4.8总结</h4><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240313214022640.png" alt="image-20240313214022640" style="zoom: 67%;" /><h3 id="第5章：计算机网络基础"><a href="#第5章：计算机网络基础" class="headerlink" title="第5章：计算机网络基础"></a>第5章：计算机网络基础</h3><p>题型少，设计不广</p><h4 id="5-1计算机网络的分类"><a href="#5-1计算机网络的分类" class="headerlink" title="5.1计算机网络的分类"></a>5.1计算机网络的分类</h4><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240313215800889.png" alt="image-20240313215800889" style="zoom:67%;" /><h4 id="5-2七层网络体系结构"><a href="#5-2七层网络体系结构" class="headerlink" title="5.2七层网络体系结构"></a>5.2七层网络体系结构</h4><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240313220334228.png" alt="image-20240313220334228" style="zoom:67%;" /><p>标准</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240313220421685.png" alt="image-20240313220421685" style="zoom: 33%;" /><h4 id="5-3网络的设备"><a href="#5-3网络的设备" class="headerlink" title="5.3网络的设备"></a>5.3网络的设备</h4><h4 id="5-4TCP-IP协议族"><a href="#5-4TCP-IP协议族" class="headerlink" title="5.4TCP&#x2F;IP协议族"></a>5.4TCP&#x2F;IP协议族</h4><p>TCP&#x2F;IP作为Internet的核心协议，被广泛应用于局域网和广域网中，目前已成为事实上的国际标准。</p><p>1、TCP&#x2F;IP分层模型TCP&#x2F;IP协议是Internet的基础和核心，和OSI参考模型一样，也是采用层次体系结构，从上而下分为应用层、传输层、网际层和网络接口层。</p><p>2、网络接口层协议</p><p>3、网际层协议一IP</p><p>ARP和RARP地址解析协议(Address Resolution Protocol, ARP)及反地址解析协议(RARP)。</p><p>ARP的作用是将IP地址转换为物理地址，RARP的作用是将物理地址转换为IP地址。</p><p>5、网际层协议一ICMP</p><p><strong>6、传输层协议一TCP</strong></p><p><mark>TCP(Transmission Control Protocol,传输控制协议)为应用程序提供了一个可靠的、面向连接的数据传输服务。</mark></p><p><strong>7.传输层协议一UDP</strong></p><p><mark>用户数据报协议(User Dataqram Protocol, UDP)是 一种不可靠的、无连接的协议可以保证应用程序进程间的通信。</mark></p><p><strong>TCP和UDP区别：</strong></p><ul><li><p>①<strong>TCP面向连接；UDP是无连接的。</strong></p></li><li><p>②TCP 提供可靠的服务，通过TCP连接传送的数据，无差错、不丢失、不重复，且按序到达;UDP尽最大努力交付，不保证可靠交付。</p></li><li><p>③TCP面向字节流；UDP是面向报文的，没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低。</p></li><li><p>④每一条TCP连接只能是点到点的；UDP支持一对一、一对多、多对一和多对多的交互通信。</p></li><li><p>⑤TCP首部开销20字节；UDP的首部开销小，只有8个字节。</p></li><li><p>⑥TCP的逻辑通信信道是全双工的可靠信道0；UDP则是不可靠信道，整体来看UDP开销较小。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240313221009168.png" alt="image-20240313221009168"></p><p>选B</p><h4 id="5-5IP地址和IPv6简介"><a href="#5-5IP地址和IPv6简介" class="headerlink" title="5.5IP地址和IPv6简介"></a>5.5IP地址和IPv6简介</h4><p>IP地址的长度为32位，分为4段，每段8位，可以用十进制数和二进制数表示。每段数字范围为0~255，段与段之间用句点隔开。<strong>IP 地址由两部分组成，一部分为网络地址，另一部分为主机地址。</strong></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240313221225107.png" alt="image-20240313221225107" style="zoom:67%;" /><p>IPV6简介</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240313221506911.png" alt="image-20240313221506911" style="zoom: 80%;" /><h4 id="5-6Internet服务"><a href="#5-6Internet服务" class="headerlink" title="5.6Internet服务"></a>5.6Internet服务</h4><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240313221630445.png" alt="image-20240313221630445" style="zoom: 67%;" /><p>例题：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240313221919525.png" alt="image-20240313221919525" style="zoom:67%;" /><p>选A</p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240420184258410.png" alt="image-20240420184258410"></p><h4 id="5-7DHCP"><a href="#5-7DHCP" class="headerlink" title="5.7DHCP"></a>5.7DHCP</h4><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240420183808660.png" alt="image-20240420183808660"></p><h4 id="5-8域名系统"><a href="#5-8域名系统" class="headerlink" title="5.8域名系统"></a>5.8域名系统</h4><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240420184457824.png" alt="image-20240420184457824"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240420184159907.png" alt="image-20240420184159907"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240420184607745.png" alt="image-20240420184607745"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240513215058343.png" alt="image-20240513215058343"></p><h3 id="第6章：数据库系统基础知识"><a href="#第6章：数据库系统基础知识" class="headerlink" title="第6章：数据库系统基础知识"></a>第6章：数据库系统基础知识</h3><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240404154150750.png" alt="image-20240404154150750" style="zoom: 67%;" /><h4 id="6-1数据库系统"><a href="#6-1数据库系统" class="headerlink" title="6.1数据库系统"></a>6.1数据库系统</h4><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240404154405192.png" alt="image-20240404154405192" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240404155012653.png" alt="image-20240404155012653" style="zoom:80%;" /><h4 id="6-2三级模式–两级映射"><a href="#6-2三级模式–两级映射" class="headerlink" title="6.2三级模式–两级映射"></a>6.2三级模式–两级映射</h4><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240404155548386.png" alt="image-20240404155548386"></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240404161646993.png" alt="image-20240404161646993" style="zoom:80%;" /><h4 id="6-3数据库设计"><a href="#6-3数据库设计" class="headerlink" title="6.3数据库设计"></a>6.3数据库设计</h4><p>考点：1.四个流程；2.流程的作用；3.流程的产出</p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240404162407961.png" alt="image-20240404162407961"></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240404161425304.png" alt="image-20240404161425304" style="zoom:80%;" /><p>例题：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240404162155774.png" alt="image-20240404162155774" style="zoom: 67%;" /><h6 id="E-R图的三种冲突"><a href="#E-R图的三种冲突" class="headerlink" title="E-R图的三种冲突"></a>E-R图的三种冲突</h6><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240420163834637.png" alt="image-20240420163834637"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240420163532900.png" alt="image-20240420163532900"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240420163518163.png" alt="image-20240420163518163"></p><h4 id="6-4数据模型"><a href="#6-4数据模型" class="headerlink" title="6.4数据模型"></a>6.4数据模型</h4><p>考点：数据模型三要素；必考ER模型</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240404162728867.png" alt="image-20240404162728867" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240404164037189.png" alt="image-20240404164037189" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240404164308877.png" alt="image-20240404164308877" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240404164324133.png" alt="image-20240404164324133" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240404164649025.png" alt="image-20240404164649025" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240404193359061.png" alt="image-20240404193359061" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240428152841706.png" alt="image-20240428152841706" style="zoom: 67%;" /><h4 id="6-5关系代数"><a href="#6-5关系代数" class="headerlink" title="6.5关系代数"></a>6.5关系代数</h4><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240404194208866.png" alt="image-20240404194208866" style="zoom: 80%;" /><h5 id="6-5-1笛卡尔积"><a href="#6-5-1笛卡尔积" class="headerlink" title="6.5.1笛卡尔积"></a>6.5.1笛卡尔积</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240404200757772.png" alt="image-20240404200757772" style="zoom:80%;" /><h5 id="6-5-2自然连接"><a href="#6-5-2自然连接" class="headerlink" title="6.5.2自然连接"></a>6.5.2自然连接</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240404195856941.png" alt="image-20240404195856941" style="zoom: 80%;" /><p>例题：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240404202722335.png" alt="image-20240404202722335" style="zoom:67%;" /><p><strong>左外、右外、完全连接</strong></p><p>例题：</p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240420180107094.png" alt="image-20240420180107094"></p><h4 id="6-6函数依赖"><a href="#6-6函数依赖" class="headerlink" title="6.6函数依赖"></a>6.6函数依赖</h4><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240404211848990.png" alt="image-20240404211848990" style="zoom: 80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240404212050029.png" alt="image-20240404212050029" style="zoom: 80%;" /><h4 id="6-7键与约束"><a href="#6-7键与约束" class="headerlink" title="6.7键与约束"></a>6.7键与约束</h4><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240405152221762.png" alt="image-20240405152221762" style="zoom:67%;" /><h4 id="6-8范式"><a href="#6-8范式" class="headerlink" title="6.8范式"></a>6.8范式</h4><p>范式强调了规范化的操作。</p><h5 id="6-8-1第一范式"><a href="#6-8-1第一范式" class="headerlink" title="6.8.1第一范式"></a>6.8.1第一范式</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240405152748554.png" alt="image-20240405152748554" style="zoom: 80%;" /><h5 id="6-8-2第二范式"><a href="#6-8-2第二范式" class="headerlink" title="6.8.2第二范式"></a>6.8.2第二范式</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240407211725054.png" alt="image-20240407211725054" style="zoom: 67%;" /><h5 id="6-8-3第三范式"><a href="#6-8-3第三范式" class="headerlink" title="6.8.3第三范式"></a>6.8.3第三范式</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240405154749968.png" alt="image-20240405154749968" style="zoom: 80%;" /><h5 id="6-8-4BC范式"><a href="#6-8-4BC范式" class="headerlink" title="6.8.4BC范式"></a>6.8.4BC范式</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240405170112507.png" alt="image-20240405170112507" style="zoom:67%;" /><p>例题：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240405163743385.png" alt="image-20240405163743385" style="zoom: 50%;" /><p>例题：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240405172231219.png" alt="image-20240405172231219" style="zoom:67%;" /><h4 id="6-9模式分解-重难点"><a href="#6-9模式分解-重难点" class="headerlink" title="6.9模式分解(重难点)"></a>6.9模式分解(重难点)</h4><h5 id="6-9-1无损分解"><a href="#6-9-1无损分解" class="headerlink" title="6.9.1无损分解"></a>6.9.1无损分解</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240405225356574.png" alt="image-20240405225356574" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240405231546884.png" alt="image-20240405231546884" style="zoom:67%;" /><h5 id="6-9-2保持函数依赖"><a href="#6-9-2保持函数依赖" class="headerlink" title="6.9.2保持函数依赖"></a>6.9.2保持函数依赖</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240405224221001.png" alt="image-20240405224221001" style="zoom: 80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240405223811107.png" alt="image-20240405223811107" style="zoom:67%;" /><p><strong>解题技巧：只要有一个依赖集的分解不保持，就是不保持函数依赖.</strong></p><p>例题：</p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240510222401755.png"></p><h4 id="6-10并发控制"><a href="#6-10并发控制" class="headerlink" title="6.10并发控制"></a>6.10并发控制</h4><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240407212442205.png" alt="image-20240407212442205" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240407212632383.png" alt="image-20240407212632383" style="zoom: 80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240407214821368.png" alt="image-20240407214821368" style="zoom: 80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240407213625269.png" alt="image-20240407213625269" style="zoom: 33%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240407213739137.png" alt="image-20240407213739137" style="zoom: 67%;" /><p>例题：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240407214747108.png" alt="image-20240407214747108" style="zoom:67%;" /><h5 id="6-11分布式数据库"><a href="#6-11分布式数据库" class="headerlink" title="6.11分布式数据库"></a>6.11分布式数据库</h5><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240420180431714.png" alt="image-20240420180431714"></p><h3 id="第7章：程序设计语言基础知识"><a href="#第7章：程序设计语言基础知识" class="headerlink" title="第7章：程序设计语言基础知识"></a>第7章：程序设计语言基础知识</h3><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240420143450175.png" alt="image-20240420143450175"></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240408185244286.png" alt="image-20240408185244286" style="zoom:67%;" /><h4 id="7-1程序设计语言概述"><a href="#7-1程序设计语言概述" class="headerlink" title="7.1程序设计语言概述"></a>7.1程序设计语言概述</h4><h5 id="7-1-1程序设计语言的基本概念"><a href="#7-1-1程序设计语言的基本概念" class="headerlink" title="7.1.1程序设计语言的基本概念"></a>7.1.1程序设计语言的基本概念</h5><p>考点：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240408190030897.png" alt="image-20240408190030897" style="zoom: 33%;" /><p>考点：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240408190932802.png" alt="image-20240408190932802" style="zoom: 80%;" /><h5 id="7-1-2程序设计语言的基本成分"><a href="#7-1-2程序设计语言的基本成分" class="headerlink" title="7.1.2程序设计语言的基本成分"></a>7.1.2程序设计语言的基本成分</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240408192613785.png" alt="image-20240408192613785" style="zoom: 80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240408192708815.png" alt="image-20240408192708815" style="zoom: 67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240408194200593.png" alt="image-20240408194200593" style="zoom: 80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240408195046131.png" alt="image-20240408195046131" style="zoom: 80%;" /><p>例题：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240408194643551.png" alt="image-20240408194643551" style="zoom: 80%;" /><p>例题：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240408200024225.png" alt="image-20240408200024225" style="zoom:67%;" /><h4 id="7-2语言处理程序基础"><a href="#7-2语言处理程序基础" class="headerlink" title="7.2语言处理程序基础"></a>7.2语言处理程序基础</h4><h5 id="7-2-1编译方式和解释方式"><a href="#7-2-1编译方式和解释方式" class="headerlink" title="7.2.1编译方式和解释方式"></a>7.2.1编译方式和解释方式</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240420145724999.png" alt="image-20240420145724999" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240408221105026.png" alt="image-20240408221105026" style="zoom:67%;" /><p><strong>特点：</strong></p><p>词法：扫描字符，识别单词、符号。</p><p>语法：语句合法性，句子结构是否正确。如缺括号、分号。</p><p>语义：类型检查，检查所有语义错误。如 int a &#x3D; “123”。</p><h6 id="动态语义分析"><a href="#动态语义分析" class="headerlink" title="动态语义分析"></a><strong>动态语义分析</strong></h6><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240420152920588.png" alt="image-20240420152920588" style="zoom:67%;" /><p>例题：</p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240420151619742.png" alt="image-20240420151619742"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240420151602092.png" alt="image-20240420151602092"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240420151544479.png" alt="image-20240420151544479"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240420151708350.png" alt="image-20240420151708350"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240420153051158.png" alt="image-20240420153051158"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240420153223023.png" alt="image-20240420153223023"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240420153245202.png" alt="image-20240420153245202"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240420153337121.png" alt="image-20240420153337121"></p><h6 id="中间代码生成"><a href="#中间代码生成" class="headerlink" title="中间代码生成"></a><strong>中间代码生成</strong></h6><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240420153647772.png" alt="image-20240420153647772"></p><p>例题：</p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240420153827515.png" alt="image-20240420153827515"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240420153850744.png" alt="image-20240420153850744"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240420154035604.png" alt="image-20240420154035604"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240420154059266.png" alt="image-20240420154059266"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240420154133635.png" alt="image-20240420154133635"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240503170948607.png" alt="image-20240503170948607"></p><p>B</p><h5 id="7-2-2后缀表达式"><a href="#7-2-2后缀表达式" class="headerlink" title="7.2.2后缀表达式"></a>7.2.2后缀表达式</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240408221158591.png" alt="image-20240408221158591" style="zoom:67%;" /><h5 id="7-2-3文法定义"><a href="#7-2-3文法定义" class="headerlink" title="7.2.3文法定义"></a>7.2.3文法定义</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240408221335218.png" alt="image-20240408221335218" style="zoom:67%;" /><h5 id="7-2-4有限自动机-词法分析工具"><a href="#7-2-4有限自动机-词法分析工具" class="headerlink" title="7.2.4有限自动机(词法分析工具)"></a>7.2.4有限自动机(词法分析工具)</h5><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240421123417465.png" alt="image-20240421123417465"></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240408221452608.png" alt="image-20240408221452608" style="zoom:67%;" /><p>例题：</p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240421123919294.png" alt="image-20240421123919294"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240421124124507.png" alt="image-20240421124124507"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240421124210131.png" alt="image-20240421124210131"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240421124248492.png" alt="image-20240421124248492"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240421124345896.png" alt="image-20240421124345896"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240421124540775.png" alt="image-20240421124540775"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240421125243671.png" alt="image-20240421125243671"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240421125519852.png" alt="image-20240421125519852"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240421125558788.png" alt="image-20240421125558788"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240421125746228.png" alt="image-20240421125746228"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240421125919265.png" alt="image-20240421125919265"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240421130349605.png" alt="image-20240421130349605"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240421130912283.png" alt="image-20240421130912283"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240421130956536.png" alt="image-20240421130956536"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240421131124809.png" alt="image-20240421131124809"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240421131432678.png" alt="image-20240421131432678"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240421131744329.png" alt="image-20240421131744329"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240421132801385.png" alt="image-20240421132801385"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240421132930378.png" alt="image-20240421132930378"></p><h5 id="7-2-5正规表达式"><a href="#7-2-5正规表达式" class="headerlink" title="7.2.5正规表达式"></a>7.2.5正规表达式</h5><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240420154842835.png" alt="image-20240420154842835"></p><p>例题：</p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240420155217642.png" alt="image-20240420155217642"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240420155437272.png" alt="image-20240420155437272"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240420155621192.png" alt="image-20240420155621192"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240420155826977.png" alt="image-20240420155826977"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240420160213605.png" alt="image-20240420160213605"></p><h5 id="7-2-6语法分析方法"><a href="#7-2-6语法分析方法" class="headerlink" title="7.2.6语法分析方法"></a>7.2.6语法分析方法</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240408221609310.png" alt="image-20240408221609310" style="zoom:67%;" /><h3 id="第8章：面向对象技术"><a href="#第8章：面向对象技术" class="headerlink" title="第8章：面向对象技术"></a>第8章：面向对象技术</h3><h4 id="8-1面向对象基础"><a href="#8-1面向对象基础" class="headerlink" title="8.1面向对象基础"></a>8.1面向对象基础</h4><h5 id="8-1-1基本概念"><a href="#8-1-1基本概念" class="headerlink" title="8.1.1基本概念"></a>8.1.1基本概念</h5><h6 id="封装"><a href="#封装" class="headerlink" title="封装"></a><strong>封装</strong></h6><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240326172512239.png" alt="image-20240326172512239" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240326172617147.png" alt="image-20240326172617147" style="zoom:80%;" /><p>选A，消息是外界传进来的；选D，D更合适</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240326172904601.png" alt="image-20240326172904601" style="zoom: 80%;" /><p>选C；B</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240326174211747.png" alt="image-20240326174211747" style="zoom: 80%;" /><p>例题</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240326174248229.png" alt="image-20240326174248229" style="zoom: 80%;" /><h6 id="继承"><a href="#继承" class="headerlink" title="继承"></a><strong>继承</strong></h6><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240326174529188.png" alt="image-20240326174529188" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240326175417663.png" alt="image-20240326175417663" style="zoom: 80%;" /><h6 id="多态"><a href="#多态" class="headerlink" title="多态"></a><strong>多态</strong></h6><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240326175623657.png" alt="image-20240326175623657" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240328181412251.png" alt="image-20240328181412251" style="zoom:50%;" /><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240420140107077.png" alt="image-20240420140107077"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240326175954561.png" alt="image-20240326175954561"></p><p>例题</p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240420140038537.png" alt="image-20240420140038537"></p><p>选C</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240326203015017.png" alt="image-20240326203015017" style="zoom: 80%;" /><p>选D</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240326203103883.png" alt="image-20240326203103883" style="zoom:80%;" /><p>选D、C</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240326203157987.png" alt="image-20240326203157987" style="zoom: 80%;" /><h5 id="8-1-2面向对象开发流程"><a href="#8-1-2面向对象开发流程" class="headerlink" title="8.1.2面向对象开发流程"></a>8.1.2面向对象开发流程</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240326204022912.png" alt="image-20240326204022912" style="zoom: 80%;" /><h6 id="面向对象分析"><a href="#面向对象分析" class="headerlink" title="面向对象分析"></a>面向对象分析</h6><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240428154539247.png" alt="image-20240428154539247" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240428160337747.png" alt="image-20240428160337747" style="zoom:67%;" /><p>例题：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240428160508063.png" alt="image-20240428160508063" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240428160437710.png" alt="image-20240428160437710" style="zoom: 50%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240428160249104.png" alt="image-20240428160249104" style="zoom:50%;" /><h6 id="面向对象设计"><a href="#面向对象设计" class="headerlink" title="面向对象设计"></a>面向对象设计</h6><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240428155232494.png" alt="image-20240428155232494" style="zoom: 50%;" /><p>例题：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240428160147252.png" alt="image-20240428160147252" style="zoom: 50%;" /><h6 id="面向对象程序设计"><a href="#面向对象程序设计" class="headerlink" title="面向对象程序设计"></a>面向对象程序设计</h6><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240428155703419.png" alt="image-20240428155703419" style="zoom:50%;" /><p>例题：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240428155854509.png" alt="image-20240428155854509" style="zoom: 50%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240428155958985.png" alt="image-20240428155958985" style="zoom:50%;" /><h6 id="面向对象测试"><a href="#面向对象测试" class="headerlink" title="面向对象测试"></a>面向对象测试</h6><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240428155452021.png" alt="image-20240428155452021" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240326204224084.png" alt="image-20240326204224084" style="zoom:80%;" /><p>选C</p><h5 id="8-1-3面向对象设计7大原则-重点"><a href="#8-1-3面向对象设计7大原则-重点" class="headerlink" title="8.1.3面向对象设计7大原则(重点)"></a><strong>8.1.3面向对象设计7大原则(重点)</strong></h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240428152359072.png" alt="image-20240428152359072" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240326205738654.png" alt="image-20240326205738654" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240326210735081.png" alt="image-20240326210735081" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240326211035752.png" alt="image-20240326211035752" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240326211218549.png" alt="image-20240326211218549" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240326211608050.png" alt="image-20240326211608050" style="zoom:80%;" /><p>选A</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240326211638905.png" alt="image-20240326211638905" style="zoom:80%;" /><p>选D</p><h4 id="8-2UML"><a href="#8-2UML" class="headerlink" title="8.2UML"></a>8.2UML</h4><h5 id="8-2-1UML的概念及分类"><a href="#8-2-1UML的概念及分类" class="headerlink" title="8.2.1UML的概念及分类"></a>8.2.1UML的概念及分类</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240328183137909.png" alt="image-20240328183137909" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240328185147372.png" alt="image-20240328185147372" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240328175332329.png" alt="image-20240328175332329" style="zoom: 80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240328175309474.png" alt="image-20240328175309474" style="zoom: 80%;" /><p>例题：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240328175557405.png" alt="image-20240328175557405" style="zoom: 80%;" /><p>选D</p><h5 id="8-2-2UML中关系"><a href="#8-2-2UML中关系" class="headerlink" title="8.2.2UML中关系"></a>8.2.2UML中关系</h5><p><strong>类图中的关系</strong></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240328180551266.png" alt="image-20240328180551266" style="zoom: 67%;" /><p>依赖：一个事务发生变化（独立事务），会影响另一个事务（依赖事务）。</p><p>关联：就是结构关系，描述了一组链，链是对象之间的连接。</p><ul><li><p><strong>聚合：部分与整体的生命周期不一致，整体消失了，部分依然存在，部分可以脱离整体的存在。</strong></p></li><li><p><strong>组合：部分与整体的生命周期一致，整体消失了，部分也消失，部分不可以脱离整体而存在。</strong></p></li></ul><p>泛化：父子关系。</p><p>实现：接口与实现类。</p><p>例题：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240424191556983.png" alt="image-20240424191556983" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240424191153326.png" alt="image-20240424191153326" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240328181447662.png" alt="image-20240328181447662" style="zoom:67%;" /><p><strong>用例图中的关系</strong></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240328181249806.png" alt="image-20240328181249806" style="zoom: 67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240328182422862.png" alt="image-20240328182422862" style="zoom:80%;" /><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240328182551962.png" alt="image-20240328182551962"></p><p>例题：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240328183243813.png" alt="image-20240328183243813" style="zoom:80%;" /><h5 id="8-2-3UML中的图-重点"><a href="#8-2-3UML中的图-重点" class="headerlink" title="8.2.3UML中的图(重点)"></a>8.2.3UML中的图(重点)</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240328183603533.png" alt="image-20240328183603533" style="zoom: 80%;" /><h6 id="8-2-3-1类图"><a href="#8-2-3-1类图" class="headerlink" title="8.2.3.1类图"></a>8.2.3.1类图</h6><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240330152530450.png" alt="image-20240330152530450" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240328184223517.png" alt="image-20240328184223517" style="zoom: 80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240328184134980.png" alt="image-20240328184134980" style="zoom: 67%;" /><h6 id="8-2-3-2对象图"><a href="#8-2-3-2对象图" class="headerlink" title="8.2.3.2对象图"></a>8.2.3.2对象图</h6><p><strong>对象图类似于类图，区别在于对象图的命名方式，对象名:类名</strong></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240330152142211.png" alt="image-20240330152142211" style="zoom: 50%;" /><p>例题：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240328185311668.png" alt="image-20240328185311668" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240328185019692.png" alt="image-20240328185019692" style="zoom: 67%;" /><p>选C、D</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240330151445444.png" alt="image-20240330151445444" style="zoom: 80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240330150414647.png" alt="image-20240330150414647" style="zoom: 80%;" /><p>例题：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240330150711488.png" alt="image-20240330150711488" style="zoom: 67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240330150928906.png" alt="image-20240330150928906" style="zoom:67%;" /><p>例题：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240330150940607.png" alt="image-20240330150940607" style="zoom: 80%;" /><p>选A，A更全面</p><h6 id="8-2-3-3顺序图"><a href="#8-2-3-3顺序图" class="headerlink" title="8.2.3.3顺序图"></a>8.2.3.3顺序图</h6><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240330153825825.png" alt="image-20240330153825825" style="zoom:80%;" /><p>Session调用CardReader中的readCard()方法</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240330153648772.png" alt="image-20240330153648772" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240330153210473.png" alt="image-20240330153210473" style="zoom: 50%;" /><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240512191231016.png" alt="image-20240512191231016"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240513221939604.png" alt="image-20240513221939604"></p><h6 id="8-2-3-4通信图"><a href="#8-2-3-4通信图" class="headerlink" title="8.2.3.4通信图"></a>8.2.3.4通信图</h6><p>通信图与顺序图都是描述了多个对象之间互相调用，实现某一个大功能。</p><p><strong>区别：通信图更加关注<mark>对象的整体结构。</mark></strong></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240330155303143.png" alt="image-20240330155303143" style="zoom: 80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240330155932262.png" alt="image-20240330155932262" style="zoom: 80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240330155740426.png" alt="image-20240330155740426" style="zoom:80%;" /><p>选C、A、D</p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240505175606755.png" alt="image-20240505175606755"></p><h6 id="8-2-3-5活动图"><a href="#8-2-3-5活动图" class="headerlink" title="8.2.3.5活动图"></a>8.2.3.5活动图</h6><p>顺序图和通信图侧重于代码层面怎么做，<strong>活动图侧重于业务逻辑怎么做</strong>。</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240330161602322.png" alt="image-20240330161602322" style="zoom: 33%;" /><p>双结束活动图</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240330160821004.png" alt="image-20240330160821004" style="zoom:50%;" /><p>泳道活动图</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240330160911711.png" alt="image-20240330160911711" style="zoom:50%;" /><p>例题：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240330161656559.png" alt="image-20240330161656559" style="zoom: 80%;" /><h6 id="8-2-3-6状态图"><a href="#8-2-3-6状态图" class="headerlink" title="8.2.3.6状态图"></a>8.2.3.6状态图</h6><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240330163030051.png" alt="image-20240330163030051" style="zoom: 80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240330163210848.png" alt="image-20240330163210848" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240330163301825.png" alt="image-20240330163301825" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240330163543412.png" alt="image-20240330163543412" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240330164032094.png" alt="image-20240330164032094" style="zoom: 80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240330164233782.png" alt="image-20240330164233782" style="zoom: 67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240330164507184.png" alt="image-20240330164507184" style="zoom: 80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240330164548733.png" alt="image-20240330164548733" style="zoom: 67%;" /><p>例题：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240330165533033.png" alt="image-20240330165533033" style="zoom:80%;" /><p>选C</p><h6 id="8-2-3-7构件图"><a href="#8-2-3-7构件图" class="headerlink" title="8.2.3.7构件图"></a>8.2.3.7构件图</h6><p><strong>组件与组件之间的关系，模块与模块之间关系。</strong></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240330165759642.png" alt="image-20240330165759642" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240330165905824.png" alt="image-20240330165905824" style="zoom: 80%;" /><p>例题：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240330170239375.png" alt="image-20240330170239375" style="zoom: 67%;" /><h6 id="8-2-3-8部署图"><a href="#8-2-3-8部署图" class="headerlink" title="8.2.3.8部署图"></a>8.2.3.8部署图</h6><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240330170531461.png" alt="image-20240330170531461"  /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240330170340655.png" alt="image-20240330170340655" style="zoom:80%;" /><h4 id="8-3设计模式"><a href="#8-3设计模式" class="headerlink" title="8.3设计模式"></a>8.3设计模式</h4><p>选择4分，大题15分</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240331145516419.png" alt="image-20240331145516419" style="zoom:80%;" /><h5 id="8-3-1设计模式的分类"><a href="#8-3-1设计模式的分类" class="headerlink" title="8.3.1设计模式的分类"></a>8.3.1设计模式的分类</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240331150332544.png" alt="image-20240331150332544" style="zoom:80%;" /><h5 id="8-3-2创建型-5种"><a href="#8-3-2创建型-5种" class="headerlink" title="8.3.2创建型(5种)"></a>8.3.2创建型(5种)</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240331150503354.png" alt="image-20240331150503354" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240331150713682.png" alt="image-20240331150713682" style="zoom:80%;" /><h6 id="工厂模式-Factory-Method"><a href="#工厂模式-Factory-Method" class="headerlink" title="工厂模式(Factory Method)"></a>工厂模式(Factory Method)</h6><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240427232328277.png" alt="image-20240427232328277" style="zoom: 33%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240427232152840.png" alt="image-20240427232152840" style="zoom: 50%;" /><p><u><em>生产一个对象</em></u></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240331152407442.png" alt="image-20240331152407442" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240331152445233.png" alt="image-20240331152445233" style="zoom:80%;" /><h6 id="抽象工厂模式-Abstract-Factory"><a href="#抽象工厂模式-Abstract-Factory" class="headerlink" title="抽象工厂模式(Abstract Factory)"></a>抽象工厂模式(Abstract Factory)</h6><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240428161654112.png" alt="image-20240428161654112" style="zoom:50%;" /><p><em><u>生产多个对象</u></em></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240428152609383.png" alt="image-20240428152609383" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240331151808864.png" alt="image-20240331151808864" style="zoom:80%;" /><p>例题：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240428164115417.png" alt="image-20240428164115417" style="zoom: 50%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240428164423793.png" alt="image-20240428164423793" style="zoom:50%;" /><h6 id="原型模式-Prototype"><a href="#原型模式-Prototype" class="headerlink" title="原型模式(Prototype)"></a>原型模式(Prototype)</h6><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240331153052788.png" alt="image-20240331153052788" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240331153059031.png" alt="image-20240331153059031" style="zoom:80%;" /><h6 id="单例模式-Singleton"><a href="#单例模式-Singleton" class="headerlink" title="单例模式(Singleton)"></a>单例模式(Singleton)</h6><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240331153707347.png" alt="image-20240331153707347" style="zoom:80%;" /><p>例题：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240428173341476.png" alt="image-20240428173341476" style="zoom: 50%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240428173447982.png" alt="image-20240428173447982" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240428173557205.png" alt="image-20240428173557205" style="zoom:50%;" /><h6 id="生成器模式-Builder"><a href="#生成器模式-Builder" class="headerlink" title="生成器模式(Builder)"></a>生成器模式(Builder)</h6><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240331154727012.png" alt="image-20240331154727012" style="zoom:80%;" /><p>例题1：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240331155053524.png" alt="image-20240331155053524" style="zoom:80%;" /><p>例题2：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240331155453950.png" alt="image-20240331155453950" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240331155651431.png" alt="image-20240331155651431" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240331160159650.png" alt="image-20240331160159650" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240428170518456.png" alt="image-20240428170518456" style="zoom: 50%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240428170954881.png" alt="image-20240428170954881" style="zoom:50%;" /><h5 id="8-3-3结构型-7种"><a href="#8-3-3结构型-7种" class="headerlink" title="8.3.3结构型(7种)"></a>8.3.3结构型(7种)</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240428174204526.png" alt="image-20240428174204526" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240331160723599.png" alt="image-20240331160723599" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240331160754834.png" alt="image-20240331160754834" style="zoom:80%;" /><h6 id="适配器-Adapter"><a href="#适配器-Adapter" class="headerlink" title="适配器(Adapter)"></a>适配器(Adapter)</h6><p><u><em>利用中间层，统一接口。</em></u></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240331161246179.png" alt="image-20240331161246179" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240331161322542.png" alt="image-20240331161322542" style="zoom:80%;" /><p>例题：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240428180401428.png" alt="image-20240428180401428" style="zoom:50%;" /><h6 id="桥接模式-Bridge"><a href="#桥接模式-Bridge" class="headerlink" title="桥接模式(Bridge)"></a>桥接模式(Bridge)</h6><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240331162107181.png" alt="image-20240331162107181" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240331162129200.png" alt="image-20240331162129200" style="zoom:80%;" /><h6 id="组合模式-Composite"><a href="#组合模式-Composite" class="headerlink" title="组合模式(Composite)"></a>组合模式(Composite)</h6><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240430190205734.png" alt="image-20240430190205734"></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240331162937047.png" alt="image-20240331162937047" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240331163021975.png" alt="image-20240331163021975" style="zoom:80%;" /><h6 id="装饰模式-Decorator"><a href="#装饰模式-Decorator" class="headerlink" title="装饰模式(Decorator)"></a>装饰模式(Decorator)</h6><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240331164035274.png" alt="image-20240331164035274" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240331163700995.png" alt="image-20240331163700995" style="zoom:80%;" /><h6 id="外观模式-Facade"><a href="#外观模式-Facade" class="headerlink" title="外观模式(Facade)"></a>外观模式(Facade)</h6><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240331164201271.png" alt="image-20240331164201271" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240331164210144.png" alt="image-20240331164210144" style="zoom:80%;" /><h6 id="享元模式-Flyweight"><a href="#享元模式-Flyweight" class="headerlink" title="享元模式(Flyweight)"></a>享元模式(Flyweight)</h6><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240331164814533.png" alt="image-20240331164814533" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240331164827200.png" alt="image-20240331164827200" style="zoom:80%;" /><h6 id="代理模式-Proxy"><a href="#代理模式-Proxy" class="headerlink" title="代理模式(Proxy)"></a>代理模式(Proxy)</h6><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240331165030688.png" alt="image-20240331165030688" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240331165039247.png" alt="image-20240331165039247" style="zoom:80%;" /><p>例题：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240331165222532.png" alt="image-20240331165222532" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240331165355778.png" alt="image-20240331165355778" style="zoom:80%;" /><h5 id="8-3-4行为型-11种"><a href="#8-3-4行为型-11种" class="headerlink" title="8.3.4行为型(11种)"></a>8.3.4行为型(11种)</h5><h6 id="观察者模式-Observer"><a href="#观察者模式-Observer" class="headerlink" title="观察者模式(Observer)"></a>观察者模式(Observer)</h6><p>主体和观察者一对多，主要作用：数据更新。</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240401180506119.png" alt="image-20240401180506119" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240401180549557.png" alt="image-20240401180549557" style="zoom:80%;" /><h6 id="访问器模式-Visitor"><a href="#访问器模式-Visitor" class="headerlink" title="访问器模式(Visitor)"></a>访问器模式(Visitor)</h6><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240401181908251.png" alt="image-20240401181908251" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240401181943697.png" alt="image-20240401181943697" style="zoom:80%;" /><h6 id="状态模式-State"><a href="#状态模式-State" class="headerlink" title="状态模式(State)"></a>状态模式(State)</h6><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240401182536192.png" alt="image-20240401182536192" style="zoom: 80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240401182544772.png" alt="image-20240401182544772" style="zoom:80%;" /><h6 id="职责链模式-Chain-of-Responsibility"><a href="#职责链模式-Chain-of-Responsibility" class="headerlink" title="职责链模式(Chain of Responsibility)"></a>职责链模式(Chain of Responsibility)</h6><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240401184313119.png" alt="image-20240401184313119" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240401184333626.png" alt="image-20240401184333626" style="zoom:80%;" /><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240503193900505.png" alt="image-20240503193900505"></p><h6 id="命令模式-Command"><a href="#命令模式-Command" class="headerlink" title="命令模式(Command)"></a>命令模式(Command)</h6><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240401201213032.png" alt="image-20240401201213032" style="zoom: 50%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240401185258605.png" alt="image-20240401185258605" style="zoom: 67%;" /><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240503195754720.png" alt="image-20240503195754720"></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240503200457918.png" alt="image-20240503200457918" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240503200713915.png" alt="image-20240503200713915" style="zoom:67%;" /><h6 id="解释器模式-Interpreter"><a href="#解释器模式-Interpreter" class="headerlink" title="解释器模式(Interpreter)"></a>解释器模式(Interpreter)</h6><p>难度较大，了解即可</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240401185456957.png" alt="image-20240401185456957" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240401185520905.png" alt="image-20240401185520905" style="zoom: 67%;" /><h6 id="迭代器模式-Iterator"><a href="#迭代器模式-Iterator" class="headerlink" title="迭代器模式(Iterator)"></a>迭代器模式(Iterator)</h6><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240401190613205.png" alt="image-20240401190613205" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240401191641357.png" alt="image-20240401191641357" style="zoom: 67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240503211540633.png" alt="image-20240503211540633" style="zoom: 50%;" /><h6 id="中介者模式-Mediator"><a href="#中介者模式-Mediator" class="headerlink" title="中介者模式(Mediator)"></a>中介者模式(Mediator)</h6><p>中介者和服务一对多，作用：解耦合，降低服务之间的联系。</p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240507205437760.png" alt="image-20240507205437760"></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240401192618549.png" alt="image-20240401192618549" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240401192629152.png" alt="image-20240401192629152" style="zoom: 67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240401192715622.png" alt="image-20240401192715622" style="zoom: 80%;" /><h6 id="备忘录模式-Memento"><a href="#备忘录模式-Memento" class="headerlink" title="备忘录模式(Memento)"></a>备忘录模式(Memento)</h6><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240401194528315.png" alt="image-20240401194528315" style="zoom: 80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240401194041588.png" alt="image-20240401194041588" style="zoom: 67%;" /><h6 id="策略模式-Strategy"><a href="#策略模式-Strategy" class="headerlink" title="策略模式(Strategy)"></a>策略模式(Strategy)</h6><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240401200243374.png" alt="image-20240401200243374" style="zoom: 80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240401194935657.png" alt="image-20240401194935657" style="zoom: 67%;" /><h6 id="模板方法模式-TemplateMethod"><a href="#模板方法模式-TemplateMethod" class="headerlink" title="模板方法模式(TemplateMethod)"></a>模板方法模式(TemplateMethod)</h6><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240401195815564.png" alt="image-20240401195815564" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240401200149816.png" alt="image-20240401200149816" style="zoom:67%;" /><p>例题：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240401200446605.png" alt="image-20240401200446605" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240401201324564.png" alt="image-20240401201324564" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240401201312545.png" alt="image-20240401201312545" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240401202052030.png" alt="image-20240401202052030" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240401202250977.png" alt="image-20240401202250977" style="zoom:67%;" /><h3 id="第九章：标准化与软件知识产权"><a href="#第九章：标准化与软件知识产权" class="headerlink" title="第九章：标准化与软件知识产权"></a>第九章：标准化与软件知识产权</h3><h5 id="9-1知识产权概述"><a href="#9-1知识产权概述" class="headerlink" title="9.1知识产权概述"></a>9.1知识产权概述</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240408183521932.png" alt="image-20240408183521932" style="zoom:67%;" /><h5 id="9-2保护期限"><a href="#9-2保护期限" class="headerlink" title="9.2保护期限"></a>9.2保护期限</h5><p>可能考点：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240408183616457.png" alt="image-20240408183616457" style="zoom: 80%;" /><h5 id="9-3知识产权人的确定"><a href="#9-3知识产权人的确定" class="headerlink" title="9.3知识产权人的确定"></a>9.3知识产权人的确定</h5><p>可能考点：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240408183719345.png" alt="image-20240408183719345" style="zoom: 80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240408183912512.png" alt="image-20240408183912512" style="zoom: 80%;" /><h5 id="9-4-侵权判定"><a href="#9-4-侵权判定" class="headerlink" title="9.4 侵权判定"></a>9.4 侵权判定</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240408183942926.png" alt="image-20240408183942926" style="zoom: 80%;" /><h5 id="9-5标准划分"><a href="#9-5标准划分" class="headerlink" title="9.5标准划分"></a>9.5标准划分</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240408184427475.png" alt="image-20240408184427475" style="zoom:67%;" /><p>例题：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240408184233456.png" alt="image-20240408184233456" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240408184413225.png" alt="image-20240408184413225" style="zoom:67%;" /><h3 id="第十章：软件工程"><a href="#第十章：软件工程" class="headerlink" title="第十章：软件工程"></a>第十章：软件工程</h3><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240416171358158.png" alt="image-20240416171358158" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240409163344302.png" alt="image-20240409163344302" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240409163644935.png" alt="image-20240409163644935" style="zoom:67%;" /><h4 id="10-1信息系统生命周期"><a href="#10-1信息系统生命周期" class="headerlink" title="10.1信息系统生命周期"></a>10.1信息系统生命周期</h4><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240409164324295.png" alt="image-20240409164324295"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240409163908874.png" alt="image-20240409163908874"></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240409165709533.png" alt="image-20240409165709533" style="zoom: 80%;" /><h4 id="10-2能力成熟度模型"><a href="#10-2能力成熟度模型" class="headerlink" title="10.2能力成熟度模型"></a>10.2能力成熟度模型</h4><h5 id="10-2-1软件能力成熟度模型-CMM"><a href="#10-2-1软件能力成熟度模型-CMM" class="headerlink" title="10.2.1软件能力成熟度模型(CMM)"></a>10.2.1软件能力成熟度模型(CMM)</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240409170801654.png" alt="image-20240409170801654" style="zoom: 80%;" /><p>例题：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240412174056783.png" alt="image-20240412174056783" style="zoom: 50%;" /><h5 id="10-2-2能力成熟度模型集成-CMMI"><a href="#10-2-2能力成熟度模型集成-CMMI" class="headerlink" title="10.2.2能力成熟度模型集成(CMMI)"></a>10.2.2能力成熟度模型集成(CMMI)</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240427211835173.png" alt="image-20240427211835173" style="zoom: 50%;" /><p> 例题：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240409173244360.png" alt="image-20240409173244360" style="zoom:67%;" /><h4 id="10-3软件过程模型"><a href="#10-3软件过程模型" class="headerlink" title="10.3软件过程模型"></a>10.3软件过程模型</h4><h5 id="10-3-1瀑布模型"><a href="#10-3-1瀑布模型" class="headerlink" title="10.3.1瀑布模型"></a>10.3.1瀑布模型</h5><p><strong>需求明确，功能清晰，需求变动少。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240409174150195.png" alt="image-20240409174150195"></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240409173702521.png" alt="image-20240409173702521" style="zoom: 80%;" /><p>例题：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240412182246986.png" alt="image-20240412182246986" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240412182501325.png" alt="image-20240412182501325" style="zoom: 67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240428152639484.png" alt="image-20240428152639484" style="zoom: 67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240412182827416.png" alt="image-20240412182827416" style="zoom:67%;" /><h5 id="10-3-2原型模型"><a href="#10-3-2原型模型" class="headerlink" title="10.3.2原型模型"></a>10.3.2原型模型</h5><p><strong>捕获用户需求，用户需求不明确，项目规模不大。</strong></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240409175915759.png" alt="image-20240409175915759" style="zoom: 80%;" /><p>例题：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240412183024289.png" alt="image-20240412183024289" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240412183521614.png" alt="image-20240412183521614" style="zoom:67%;" /><h5 id="10-3-3螺旋模型"><a href="#10-3-3螺旋模型" class="headerlink" title="10.3.3螺旋模型"></a>10.3.3螺旋模型</h5><p><strong>规模庞大，风险评估。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240409174448108.png" alt="image-20240409174448108"></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240409174603162.png" alt="image-20240409174603162" style="zoom: 80%;" /><p>例题：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240412184748672.png" alt="image-20240412184748672" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240412185131633.png" alt="image-20240412185131633" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240412190102188.png" alt="image-20240412190102188" style="zoom:67%;" /><h5 id="10-3-4V模型"><a href="#10-3-4V模型" class="headerlink" title="10.3.4V模型"></a>10.3.4V模型</h5><p><strong>质量保证，测试居多。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240409175612692.png" alt="image-20240409175612692"></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240409175647353.png" alt="image-20240409175647353" style="zoom: 80%;" /><h5 id="10-3-5增量模型"><a href="#10-3-5增量模型" class="headerlink" title="10.3.5增量模型"></a>10.3.5增量模型</h5><p><strong>短时间开发，核心功能首先开发，第一个增量成本低风险小，快速交付。</strong></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240409180425734.png" alt="image-20240409180425734" style="zoom: 80%;" /><p>例题：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240412180618731.png" alt="image-20240412180618731" style="zoom: 33%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240412180746347.png" alt="image-20240412180746347" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240412180953520.png" alt="image-20240412180953520" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240412181308320.png" alt="image-20240412181308320" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240412181653699.png" alt="image-20240412181653699" style="zoom:33%;" /><h5 id="10-3-6喷泉模型"><a href="#10-3-6喷泉模型" class="headerlink" title="10.3.6喷泉模型"></a>10.3.6喷泉模型</h5><p><strong>具有迭代性、无间隙性，适合面向对象的开发方法。</strong></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240412190627423.png" alt="image-20240412190627423" style="zoom:67%;" /><p>例题：</p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240412190741739.png" alt="image-20240412190741739"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240412190946379.png" alt="image-20240412190946379"></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240412191154522.png" alt="image-20240412191154522"  /><h5 id="10-3-7其他开发模型"><a href="#10-3-7其他开发模型" class="headerlink" title="10.3.7其他开发模型"></a>10.3.7其他开发模型</h5><p><strong>统一过程(up)模型</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240412191836286.png" alt="image-20240412191836286"></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240412192020009.png" alt="image-20240412192020009" style="zoom: 50%;" /><p>例题：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240412192125303.png" alt="image-20240412192125303" style="zoom: 50%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240412191227389.png" alt="image-20240412191227389" style="zoom:67%;" /><h4 id="10-4信息系统开发方法"><a href="#10-4信息系统开发方法" class="headerlink" title="10.4信息系统开发方法"></a>10.4信息系统开发方法</h4><h5 id="10-4-1结构化方法"><a href="#10-4-1结构化方法" class="headerlink" title="10.4.1结构化方法"></a>10.4.1结构化方法</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240409183452009.png" alt="image-20240409183452009" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240409182849019.png" alt="image-20240409182849019" style="zoom: 67%;" /><p>例题：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240412195818146.png" alt="image-20240412195818146" style="zoom:67%;" /><h5 id="10-4-2面向对象方法"><a href="#10-4-2面向对象方法" class="headerlink" title="10.4.2面向对象方法"></a>10.4.2面向对象方法</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240409183159040.png" alt="image-20240409183159040" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240409183322129.png" alt="image-20240409183322129" style="zoom:67%;" /><h5 id="10-4-3快速原型法"><a href="#10-4-3快速原型法" class="headerlink" title="10.4.3快速原型法"></a>10.4.3快速原型法</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240410173247223.png" alt="image-20240410173247223" style="zoom: 80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240410173920280.png" alt="image-20240410173920280" style="zoom: 80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240410174255159.png" alt="image-20240410174255159" style="zoom:67%;" /><h5 id="10-4-4敏捷开发-重点"><a href="#10-4-4敏捷开发-重点" class="headerlink" title="10.4.4敏捷开发(重点)"></a>10.4.4敏捷开发(重点)</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240410174347288.png" alt="image-20240410174347288"  /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240412193434567.png" alt="image-20240412193434567" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240410174856953.png" alt="image-20240410174856953"  /><p>五大原则：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240410182820324.png" alt="image-20240410182820324" style="zoom: 67%;" /><p>例题：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240412193240245.png" alt="image-20240412193240245" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240412193520380.png" alt="image-20240412193520380" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240412193652951.png" alt="image-20240412193652951" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240412194036291.png" alt="image-20240412194036291" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240412194420754.png" alt="image-20240412194420754" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240412194451834.png" alt="image-20240412194451834" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240412194846216.png" alt="image-20240412194846216" style="zoom:67%;" /><h6 id="敏捷统一过程UP"><a href="#敏捷统一过程UP" class="headerlink" title="敏捷统一过程UP"></a>敏捷统一过程UP</h6><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240410180229515.png" alt="image-20240410180229515" style="zoom: 67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240412195745296.png" alt="image-20240412195745296" style="zoom:67%;" /><p>例题：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240412195137367.png" alt="image-20240412195137367" style="zoom: 80%;" /><h4 id="10-5软件产品线"><a href="#10-5软件产品线" class="headerlink" title="10.5软件产品线"></a>10.5软件产品线</h4><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240410182118038.png" alt="image-20240410182118038" style="zoom:67%;" /><h4 id="10-6逆向工程"><a href="#10-6逆向工程" class="headerlink" title="10.6逆向工程"></a>10.6逆向工程</h4><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240410183653939.png" alt="image-20240410183653939" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240410183458352.png" alt="image-20240410183458352" style="zoom:67%;" /><h4 id="10-7开发工具与开发环境"><a href="#10-7开发工具与开发环境" class="headerlink" title="10.7开发工具与开发环境"></a>10.7开发工具与开发环境</h4><h5 id="10-7-1软件开发工具"><a href="#10-7-1软件开发工具" class="headerlink" title="10.7.1软件开发工具"></a>10.7.1软件开发工具</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240410191225777.png" alt="image-20240410191225777" style="zoom:67%;" /><h5 id="10-7-2软件开发环境"><a href="#10-7-2软件开发环境" class="headerlink" title="10.7.2软件开发环境"></a>10.7.2软件开发环境</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240410191314262.png" alt="image-20240410191314262" style="zoom:67%;" /><p>例题：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240410185335129.png" alt="image-20240410185335129" style="zoom: 50%;" /><h4 id="10-8软件需求"><a href="#10-8软件需求" class="headerlink" title="10.8软件需求"></a>10.8软件需求</h4><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240411121440440.png" alt="image-20240411121440440" style="zoom:67%;" /><h5 id="10-8-1需求分类"><a href="#10-8-1需求分类" class="headerlink" title="10.8.1需求分类"></a>10.8.1需求分类</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240411122244574.png" alt="image-20240411122244574" style="zoom: 67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240411122431903.png" alt="image-20240411122431903" style="zoom:67%;" /><p>例题：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240411110842745.png" alt="image-20240411110842745" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240413120817470.png" alt="image-20240413120817470"  /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240413121113327.png" alt="image-20240413121113327"  /><h5 id="10-8-2需求开发"><a href="#10-8-2需求开发" class="headerlink" title="10.8.2需求开发"></a>10.8.2需求开发</h5><h6 id="10-8-2-1需求获取"><a href="#10-8-2-1需求获取" class="headerlink" title="10.8.2.1需求获取"></a>10.8.2.1需求获取</h6><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240411111909017.png" alt="image-20240411111909017" style="zoom:67%;" /><p>例题：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240411112008305.png" alt="image-20240411112008305" style="zoom:67%;" /><h6 id="10-8-2-2需求分析"><a href="#10-8-2-2需求分析" class="headerlink" title="10.8.2.2需求分析"></a>10.8.2.2需求分析</h6><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240411113904489.png" alt="image-20240411113904489" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240411112335053.png" alt="image-20240411112335053" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240411112356056.png" alt="image-20240411112356056" style="zoom: 80%;" /><h6 id="10-8-2-3需求定义"><a href="#10-8-2-3需求定义" class="headerlink" title="10.8.2.3需求定义"></a>10.8.2.3需求定义</h6><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240411114132155.png" alt="image-20240411114132155" style="zoom:67%;" /><h6 id="10-8-2-4需求验证"><a href="#10-8-2-4需求验证" class="headerlink" title="10.8.2.4需求验证"></a>10.8.2.4需求验证</h6><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240411114504249.png" alt="image-20240411114504249" style="zoom:67%;" /><h5 id="10-8-2需求管理"><a href="#10-8-2需求管理" class="headerlink" title="10.8.2需求管理"></a>10.8.2需求管理</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240411114540161.png" alt="image-20240411114540161" style="zoom:67%;" /><h6 id="10-8-3-1需求变更"><a href="#10-8-3-1需求变更" class="headerlink" title="10.8.3.1需求变更"></a>10.8.3.1需求变更</h6><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240411115132886.png" alt="image-20240411115132886" style="zoom: 80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240411115226262.png" alt="image-20240411115226262" style="zoom:67%;" /><h6 id="10-8-3-2需求跟踪"><a href="#10-8-3-2需求跟踪" class="headerlink" title="10.8.3.2需求跟踪"></a>10.8.3.2需求跟踪</h6><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240411115931297.png" alt="image-20240411115931297" style="zoom:67%;" /><p>例题：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240411121114999.png" alt="image-20240411121114999" style="zoom:67%;" /><h4 id="10-9项目管理"><a href="#10-9项目管理" class="headerlink" title="10.9项目管理"></a>10.9项目管理</h4><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240411123317095.png" alt="image-20240411123317095" style="zoom:67%;" /><h5 id="10-9-1范围管理"><a href="#10-9-1范围管理" class="headerlink" title="10.9.1范围管理"></a>10.9.1范围管理</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240411125512692.png" alt="image-20240411125512692" style="zoom: 67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240411124435029.png" alt="image-20240411124435029" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240411125348914.png" alt="image-20240411125348914" style="zoom: 67%;" /><p>例题：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240411125241546.png" alt="image-20240411125241546" style="zoom: 67%;" /><h5 id="10-9-2进度管理"><a href="#10-9-2进度管理" class="headerlink" title="10.9.2进度管理"></a>10.9.2进度管理</h5><h6 id="进度管理概念"><a href="#进度管理概念" class="headerlink" title="进度管理概念"></a>进度管理概念</h6><p>非考试重点</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240411171058283.png" alt="image-20240411171058283" style="zoom: 80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240411212001646.png" alt="image-20240411212001646" style="zoom:80%;" /><h5 id="10-9-3软件项目估算规模"><a href="#10-9-3软件项目估算规模" class="headerlink" title="10.9.3软件项目估算规模"></a>10.9.3软件项目估算规模</h5><h6 id="COCOMO模型"><a href="#COCOMO模型" class="headerlink" title="COCOMO模型"></a><strong>COCOMO模型</strong></h6><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240414150617607.png" alt="image-20240414150617607" style="zoom:67%;" /><h6 id="COCOMOⅡ模型"><a href="#COCOMOⅡ模型" class="headerlink" title="COCOMOⅡ模型"></a><strong>COCOMOⅡ模型</strong></h6><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240414151223116.png" alt="image-20240414151223116"></p><p>例题：</p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240414151432091.png" alt="image-20240414151432091"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240414151420645.png" alt="image-20240414151420645"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240414151506162.png" alt="image-20240414151506162"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240414151702410.png" alt="image-20240414151702410"></p><h5 id="10-9-4工具与技术"><a href="#10-9-4工具与技术" class="headerlink" title="10.9.4工具与技术"></a>10.9.4工具与技术</h5><h6 id="甘特图和PERT图"><a href="#甘特图和PERT图" class="headerlink" title="甘特图和PERT图"></a>甘特图和PERT图</h6><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240411214001663.png" alt="image-20240411214001663" style="zoom: 80%;" /><p>例题：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240414152613903.png" alt="image-20240414152613903"  /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240414152658621.png" alt="image-20240414152658621"  /><h6 id="关键路径法-重点"><a href="#关键路径法-重点" class="headerlink" title="关键路径法(重点)"></a>关键路径法(重点)</h6><p><strong>任务完成最少时间&#x3D;关键路径上的时间</strong>。</p><p><strong>松弛时间&#x3D;0的节点&lt;–&gt;就是关键路径上的节点。</strong></p><p><strong>活动最晚可以晚X天，即活动松弛时间。</strong></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240411215509706.png" alt="image-20240411215509706" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240414163657398.png" alt="image-20240414163657398" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240428152712033.png" alt="image-20240428152712033" style="zoom:67%;" /><p>例题：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240411225307644.png" alt="image-20240411225307644" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240411233626768.png" alt="image-20240411233626768" style="zoom:67%;" /><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240414163410330.png" alt="image-20240414163410330"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240414164509441.png" alt="image-20240414164509441"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240414165359860.png" alt="image-20240414165359860"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240414165926895.png" alt="image-20240414165926895"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240415181156520.png" alt="image-20240415181156520"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240415181203419.png" alt="image-20240415181203419"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240415181255847.png" alt="image-20240415181255847"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240415181645267.png" alt="image-20240415181645267"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240415182123084.png" alt="image-20240415182123084"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240415182353631.png" alt="image-20240415182353631"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240415182724676.png" alt="image-20240415182724676"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240415183157567.png" alt="image-20240415183157567"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240415184029607.png" alt="image-20240415184029607"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240415180110475.png" alt="image-20240415180110475"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240415180713854.png"></p><h5 id="10-9-5软件配置管理"><a href="#10-9-5软件配置管理" class="headerlink" title="10.9.5软件配置管理"></a>10.9.5软件配置管理</h5><p>背多分</p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240415185805637.png" alt="image-20240415185805637"></p><p>例题：</p><p>考题年限远古，非考试重点。</p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240415185853420.png" alt="image-20240415185853420"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240415185937125.png" alt="image-20240415185937125"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240415190045637.png" alt="image-20240415190045637"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240415190113619.png" alt="image-20240415190113619"></p><h5 id="10-9-6风险管理"><a href="#10-9-6风险管理" class="headerlink" title="10.9.6风险管理"></a>10.9.6风险管理</h5><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240415192809944.png" alt="image-20240415192809944"></p><h6 id="风险识别"><a href="#风险识别" class="headerlink" title="风险识别"></a>风险识别</h6><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240415191202664.png" alt="image-20240415191202664"></p><h6 id="风险预测"><a href="#风险预测" class="headerlink" title="风险预测"></a>风险预测</h6><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240415191943137.png" alt="image-20240415191943137"></p><h6 id="风险评估"><a href="#风险评估" class="headerlink" title="风险评估"></a>风险评估</h6><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240415193454230.png" alt="image-20240415193454230"></p><h6 id="风险控制"><a href="#风险控制" class="headerlink" title="风险控制"></a>风险控制</h6><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240415193242035.png" alt="image-20240415193242035"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240415192723350.png" alt="image-20240415192723350"></p><p>例题：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240415192823459.png" alt="image-20240415192823459" style="zoom: 80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240415192908876.png" alt="image-20240415192908876" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240415192958489.png" alt="image-20240415192958489" style="zoom:80%;" /><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240415193050365.png" alt="image-20240415193050365"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240415193149884.png" alt="image-20240415193149884"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240415193249765.png" alt="image-20240415193249765"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240415193505969.png" alt="image-20240415193505969"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240415193559944.png" alt="image-20240415193559944"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240415193840248.png" alt="image-20240415193840248"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240415193909654.png" alt="image-20240415193909654"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240415194029613.png" alt="image-20240415194029613"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240415194139274.png" alt="image-20240415194139274"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240415194208381.png" alt="image-20240415194208381"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240415194337611.png" alt="image-20240415194337611"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240415194356015.png" alt="image-20240415194356015"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240415194457227.png" alt="image-20240415194457227"></p><h4 id="10-10软件质量"><a href="#10-10软件质量" class="headerlink" title="10.10软件质量"></a>10.10软件质量</h4><h5 id="10-10-1软件质量特性-考点"><a href="#10-10-1软件质量特性-考点" class="headerlink" title="10.10.1软件质量特性(考点)"></a>10.10.1软件质量特性(考点)</h5><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240415195638286.png" alt="image-20240415195638286"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240415195655040.png" alt="image-20240415195655040"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240415200429078.png" alt="image-20240415200429078"></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240415201744595.png" alt="image-20240415201744595" style="zoom: 67%;" /><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240415200932846.png" alt="image-20240415200932846"></p><p>例题：</p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240415200023595.png" alt="image-20240415200023595"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240415200108949.png" alt="image-20240415200108949"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240415200232223.png" alt="image-20240415200232223"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240415200337630.png" alt="image-20240415200337630"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240415201246142.png" alt="image-20240415201246142"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240415201302760.png" alt="image-20240415201302760"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240415201339312.png" alt="image-20240415201339312"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240415201409794.png" alt="image-20240415201409794"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240415201436358.png" alt="image-20240415201436358"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240415201449040.png" alt="image-20240415201449040"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240415201502054.png" alt="image-20240415201502054"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240415201536721.png" alt="image-20240415201536721"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240415201550863.png" alt="image-20240415201550863"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240415201646530.png" alt="image-20240415201646530"></p><h4 id="10-11系统设计"><a href="#10-11系统设计" class="headerlink" title="10.11系统设计"></a>10.11系统设计</h4><h5 id="10-11-1概要设计"><a href="#10-11-1概要设计" class="headerlink" title="10.11.1概要设计"></a>10.11.1概要设计</h5><p><strong>划分模块。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240413121821027.png" alt="image-20240413121821027"></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240413121715691.png" alt="image-20240413121715691" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240413121839030.png" alt="image-20240413121839030" style="zoom:67%;" /><p>例题：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240413122028086.png" alt="image-20240413122028086" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240413122226061.png" alt="image-20240413122226061" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240413122347239.png" alt="image-20240413122347239" style="zoom: 80%;" /><h5 id="10-11-2详细设计"><a href="#10-11-2详细设计" class="headerlink" title="10.11.2详细设计"></a>10.11.2详细设计</h5><p><strong>算法、数据结构、物理结构设计。</strong></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240413122741255.png" alt="image-20240413122741255" style="zoom:67%;" /><p>例题：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240413122837886.png" alt="image-20240413122837886" style="zoom:67%;" /><h4 id="10-12系统测试"><a href="#10-12系统测试" class="headerlink" title="10.12系统测试"></a>10.12系统测试</h4><h5 id="10-12-1系统测试与调试"><a href="#10-12-1系统测试与调试" class="headerlink" title="10.12.1系统测试与调试"></a>10.12.1系统测试与调试</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240413123806141.png" alt="image-20240413123806141" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240413124229610.png" alt="image-20240413124229610" style="zoom:67%;" /><p>例题：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240413124425635.png" alt="image-20240413124425635" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240413124657460.png" alt="image-20240413124657460" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240413124725708.png" alt="image-20240413124725708" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240413124908608.png" alt="image-20240413124908608" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240413125234045.png" alt="image-20240413125234045" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240413125342222.png" alt="image-20240413125342222" style="zoom:67%;" /><h5 id="10-12-2传统软件的测试策略"><a href="#10-12-2传统软件的测试策略" class="headerlink" title="10.12.2传统软件的测试策略"></a>10.12.2传统软件的测试策略</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240413125605885.png" alt="image-20240413125605885" style="zoom:80%;" /><h6 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h6><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240413132113266.png" alt="image-20240413132113266" style="zoom:80%;" /><p>例题：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240413130603141.png" alt="image-20240413130603141" style="zoom: 80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240413130722616.png" alt="image-20240413130722616" style="zoom: 80%;" /><h6 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h6><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240413133302247.png" alt="image-20240413133302247" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240413132014702.png" alt="image-20240413132014702" style="zoom:80%;" /><p>例题：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240413132224199.png" alt="image-20240413132224199" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240413132340232.png" alt="image-20240413132340232" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240413132405789.png" alt="image-20240413132405789" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240413133246581.png" alt="image-20240413133246581" style="zoom:67%;" /><h5 id="10-12-3测试方法-重点"><a href="#10-12-3测试方法-重点" class="headerlink" title="10.12.3测试方法(重点)"></a>10.12.3测试方法(重点)</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240413143813780.png" alt="image-20240413143813780" style="zoom: 80%;" /><h6 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h6><p><strong>不合理的测试用例：当两个输入都是不合法的。</strong></p><p><strong>合理的测试用例：合理+合理+合理或不合理+合理+合理。</strong></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240413144848559.png" alt="image-20240413144848559" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240413145305047.png" alt="image-20240413145305047" style="zoom:67%;" /><p>例题：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240413145537305.png" alt="image-20240413145537305"  /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240413145658842.png" alt="image-20240413145658842"  /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240413150338018.png" alt="image-20240413150338018"  /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240413150823093.png" alt="image-20240413150823093" style="zoom: 80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240413151128273.png" alt="image-20240413151128273" style="zoom: 80%;" /><h6 id="McCabe度量法"><a href="#McCabe度量法" class="headerlink" title="McCabe度量法"></a>McCabe度量法</h6><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240413151752503.png" alt="image-20240413151752503" style="zoom: 80%;" /><p>例题：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240413151904797.png" alt="image-20240413151904797" style="zoom: 80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240413152111144.png" alt="image-20240413152111144" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240413152249852.png" alt="image-20240413152249852" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240413152346273.png" alt="image-20240413152346273" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240413152433784.png" alt="image-20240413152433784" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240413153146334.png" alt="image-20240413153146334" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240413153532588.png" alt="image-20240413153532588" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240413153606615.png" alt="image-20240413153606615" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240413153710605.png" alt="image-20240413153710605" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240413153807545.png" alt="image-20240413153807545" style="zoom:67%;" /><h6 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h6><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240413161143154.png" alt="image-20240413161143154" style="zoom: 80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240413154311181.png" alt="image-20240413154311181" style="zoom: 80%;" /><p>例题：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240413161602576.png" alt="image-20240413161602576" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240413161651710.png" alt="image-20240413161651710" style="zoom: 80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240413162328289.png" alt="image-20240413162328289" style="zoom: 80%;" /><hr><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240413162943516.png" alt="image-20240413162943516" style="zoom: 50%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240413163756708.png" alt="image-20240413163756708" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240413164712125.png" alt="image-20240413164712125" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240413164821080.png" alt="image-20240413164821080" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240413171238426.png" alt="image-20240413171238426" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240413171706645.png" alt="image-20240413171706645" style="zoom: 67%;" /><p><strong>McCabe+白盒测试</strong></p><p>例题：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240414113958038.png" alt="image-20240414113958038" style="zoom: 80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240414114952832.png" alt="image-20240414114952832" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240414120227837.png" alt="image-20240414120227837" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240414120626635.png" alt="image-20240414120626635" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240414120852681.png" alt="image-20240414120852681" style="zoom:80%;" /><p><strong>伪代码+McCabe+白盒测试</strong></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240414123015589.png" alt="image-20240414123015589" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240414123336793.png" alt="image-20240414123336793" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240414124750870.png" alt="image-20240414124750870" style="zoom:80%;" /><h4 id="10-13运行和维护"><a href="#10-13运行和维护" class="headerlink" title="10.13运行和维护"></a>10.13运行和维护</h4><h5 id="10-13-1系统维护概述-小考点"><a href="#10-13-1系统维护概述-小考点" class="headerlink" title="10.13.1系统维护概述(小考点)"></a>10.13.1系统维护概述(小考点)</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240414124959070.png" alt="image-20240414124959070"  /><h6 id="系统可维护性概念"><a href="#系统可维护性概念" class="headerlink" title="系统可维护性概念"></a>系统可维护性概念</h6><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240414125118782.png" alt="image-20240414125118782" style="zoom:80%;" /><p>例题：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240414125341609.png" alt="image-20240414125341609" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240414125439403.png" alt="image-20240414125439403" style="zoom: 80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240414125502702.png" alt="image-20240414125502702" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240414130405295.png" alt="image-20240414130405295" style="zoom: 80%;" /><p>例题：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240414130449254.png" alt="image-20240414130449254" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240414130805330.png" alt="image-20240414130805330" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240414130757846.png" alt="image-20240414130757846" style="zoom:80%;" /><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240414130940657.png" alt="image-20240414130940657"></p><p>例题：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240414131211265.png" alt="image-20240414131211265" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240414131355722.png" alt="image-20240414131355722" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240414131428085.png" alt="image-20240414131428085" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240414131457566.png" alt="image-20240414131457566" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240414131542450.png" alt="image-20240414131542450" style="zoom:80%;" /><h5 id="10-13-2系统维护的内容和类型-考点"><a href="#10-13-2系统维护的内容和类型-考点" class="headerlink" title="10.13.2系统维护的内容和类型(考点)"></a>10.13.2系统维护的内容和类型(考点)</h5><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240414133326272.png" alt="image-20240414133326272"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240414133248570.png" alt="image-20240414133248570"></p><p>例题：</p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240414132923932.png" alt="image-20240414132923932"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240414132951258.png" alt="image-20240414132951258"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240414133102530.png" alt="image-20240414133102530"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240414133151550.png" alt="image-20240414133151550"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240414133512170.png" alt="image-20240414133512170"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240414133615277.png" alt="image-20240414133615277"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240414133744750.png" alt="image-20240414133744750"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240414133829785.png" alt="image-20240414133829785"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240414134052747.png" alt="image-20240414134052747"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240414134306222.png" alt="image-20240414134306222"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240414134420480.png" alt="image-20240414134420480"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240414134511329.png" alt="image-20240414134511329"></p><h5 id="10-13-3可靠、可用、可维护性"><a href="#10-13-3可靠、可用、可维护性" class="headerlink" title="10.13.3可靠、可用、可维护性"></a>10.13.3可靠、可用、可维护性</h5><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240414135751366.png" alt="image-20240414135751366" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240414135604270.png" alt="image-20240414135604270" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240414135550643.png" alt="image-20240414135550643" style="zoom: 67%;" /><h5 id="10-13-4沟通路径"><a href="#10-13-4沟通路径" class="headerlink" title="10.13.4沟通路径"></a>10.13.4沟通路径</h5><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240414144856331.png" alt="image-20240414144856331"></p><p>例题：</p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240414145043222.png" alt="image-20240414145043222"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240414145342929.png" alt="image-20240414145342929"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240414145515042.png" alt="image-20240414145515042"></p><h3 id="第十一章：结构化开发"><a href="#第十一章：结构化开发" class="headerlink" title="第十一章：结构化开发"></a>第十一章：结构化开发</h3><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240416172118398.png" alt="image-20240416172118398"></p><h4 id="11-1系统分析与设计概述-重点）"><a href="#11-1系统分析与设计概述-重点）" class="headerlink" title="11.1系统分析与设计概述(重点）"></a>11.1系统分析与设计概述(重点）</h4><p><strong>结构化分析的输出：数据流图，数据字典，加工逻辑，补充材料(实体联系图)。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240417182203868.png" alt="image-20240417182203868"></p><h5 id="11-1-1系统设计的基本原理"><a href="#11-1-1系统设计的基本原理" class="headerlink" title="11.1.1系统设计的基本原理"></a>11.1.1系统设计的基本原理</h5><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240416173043852.png" alt="image-20240416173043852"></p><h6 id="模块独立-重点"><a href="#模块独立-重点" class="headerlink" title="模块独立(重点)"></a>模块独立(重点)</h6><h6 id="耦合"><a href="#耦合" class="headerlink" title="耦合"></a>耦合</h6><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240416180926848.png" alt="image-20240416180926848"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240416175923314.png" alt="image-20240416175923314"></p><p>例题：</p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240416174055047.png" alt="image-20240416174055047"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240416175100443.png" alt="image-20240416175100443"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240416175256451.png" alt="image-20240416175256451"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240416175405879.png" alt="image-20240416175405879"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240416180019899.png" alt="image-20240416180019899"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240416180040517.png" alt="image-20240416180040517"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240416180122760.png" alt="image-20240416180122760"></p><h6 id="内聚"><a href="#内聚" class="headerlink" title="内聚"></a>内聚</h6><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240416180905004.png" alt="image-20240416180905004"></p><p>例题：</p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240416181304311.png" alt="image-20240416181304311"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240416181454558.png" alt="image-20240416181454558"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240416181612090.png" alt="image-20240416181612090"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240416181644324.png" alt="image-20240416181644324"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240416181936501.png" alt="image-20240416181936501"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240416182010349.png" alt="image-20240416182010349"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240416182029337.png" alt="image-20240416182029337"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240416182054434.png" alt="image-20240416182054434"></p><h4 id="11-2系统总体结构设计"><a href="#11-2系统总体结构设计" class="headerlink" title="11.2系统总体结构设计"></a>11.2系统总体结构设计</h4><h5 id="11-2-1系统设计基本原则"><a href="#11-2-1系统设计基本原则" class="headerlink" title="11.2.1系统设计基本原则"></a>11.2.1系统设计基本原则</h5><h6 id="系统结构设计原则-重点"><a href="#系统结构设计原则-重点" class="headerlink" title="系统结构设计原则(重点)"></a>系统结构设计原则(重点)</h6><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240416183403363.png" alt="image-20240416183403363" style="zoom: 67%;" /><p>例题：</p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240416183514692.png" alt="image-20240416183514692"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240416183652529.png" alt="image-20240416183652529"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240416183944871.png" alt="image-20240416183944871"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240416184523567.png" alt="image-20240416184523567"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240416184613576.png" alt="image-20240416184613576"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240416184714229.png" alt="image-20240416184714229"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240416184753021.png" alt="image-20240416184753021"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240416184834345.png" alt="image-20240416184834345"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240416184910905.png" alt="image-20240416184910905"></p><h5 id="11-2-2系统文档"><a href="#11-2-2系统文档" class="headerlink" title="11.2.2系统文档"></a>11.2.2系统文档</h5><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240416190225193.png" alt="image-20240416190225193"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240416185549182.png" alt="image-20240416185549182"></p><p>例题：</p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240416185751464.png" alt="image-20240416185751464"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240416185825698.png" alt="image-20240416185825698"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240416190251274.png" alt="image-20240416190251274"></p><h4 id="11-3数据流图"><a href="#11-3数据流图" class="headerlink" title="11.3数据流图"></a>11.3数据流图</h4><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240416203533309.png" alt="image-20240416203533309"></p><h5 id="11-3-1数据流图的基本图形"><a href="#11-3-1数据流图的基本图形" class="headerlink" title="11.3.1数据流图的基本图形"></a>11.3.1数据流图的基本图形</h5><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240416203002132.png" alt="image-20240416203002132"></p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240411120830092.png" alt="image-20240411120830092" style="zoom: 50%;" /><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240411113652621.png" alt="image-20240411113652621" style="zoom:67%;" /><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240416203815519.png" alt="image-20240416203815519"></p><h6 id="四种数据流图"><a href="#四种数据流图" class="headerlink" title="四种数据流图"></a>四种数据流图</h6><p><strong>外部实体</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240416204002193.png" alt="image-20240416204002193"></p><p><strong>数据存储</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240416204057135.png" alt="image-20240416204057135"></p><p><strong>加工</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240420192409009.png" alt="image-20240420192409009"></p><p><strong>数据流</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240416205131071.png" alt="image-20240416205131071"></p><h6 id="寻找缺失数据流"><a href="#寻找缺失数据流" class="headerlink" title="寻找缺失数据流"></a>寻找缺失数据流</h6><p><strong>父图子图平衡</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240416205707359.png" alt="image-20240416205707359"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240416205855045.png" alt="image-20240416205855045"></p><p><strong>加工既有输入数据流也有输出数据流。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240416210447701.png" alt="image-20240416210447701"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240416210634206.png" alt="image-20240416210634206"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240416210729556.png" alt="image-20240416210729556"></p><p><strong>数据守恒</strong></p><p>加工的功能描述，在子图中都有实现。</p><p>例题：</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240417171533842.png" alt="image-20240417171533842" style="zoom: 67%;" /><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240417171817844.png" alt="image-20240417171817844"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240417172943203.png" alt="image-20240417172943203"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240417173612449.png" alt="image-20240417173612449"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240417173739841.png" alt="image-20240417173739841"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240417173922535.png" alt="image-20240417173922535"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240417174143299.png" alt="image-20240417174143299"></p><h5 id="11-3-2数据字典-重点"><a href="#11-3-2数据字典-重点" class="headerlink" title="11.3.2数据字典(重点)"></a>11.3.2数据字典(重点)</h5><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240417175439328.png" alt="image-20240417174546299"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240417174612292.png" alt="image-20240417174612292"></p><h6 id="加工逻辑"><a href="#加工逻辑" class="headerlink" title="加工逻辑"></a>加工逻辑</h6><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240417175017710.png" alt="image-20240417175017710"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240417175022630.png" alt="image-20240417175022630"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240423194223481.png" alt="image-20240423194223481"></p><p>例题：</p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240417175349150.png" alt="image-20240417175349150"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240417175544428.png" alt="image-20240417175544428"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240417180014617.png" alt="image-20240417180014617"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240417180151263.png" alt="image-20240417180151263"></p><p>18d道杂题:</p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240417180557115.png" alt="image-20240417180557115"></p><hr><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240417180849187.png" alt="image-20240417180849187"></p><hr><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240417181159592.png" alt="image-20240417181159592"></p><hr><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240417181306763.png" alt="image-20240417181306763"></p><hr><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240417181453511.png" alt="image-20240417181453511"></p><hr><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240417181927855.png" alt="image-20240417181927855"></p><hr><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240417181856989.png" alt="image-20240417181856989"></p><hr><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240417182036856.png" alt="image-20240417182036856"></p><hr><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240417182349891.png" alt="image-20240417182349891"></p><hr><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240417182523448.png" alt="image-20240417182523448"></p><hr><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240417182750581.png" alt="image-20240417182750581"></p><hr><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240417183203656.png" alt="image-20240417183203656"></p><hr><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240417183659875.png" alt="image-20240417183659875"></p><hr><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240417183939371.png" alt="image-20240417183939371"></p><hr><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240417184258456.png" alt="image-20240417184258456"></p><hr><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240417184327526.png" alt="image-20240417184327526"></p><hr><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240417184844000.png" alt="image-20240417184844000"></p><h3 id="第十二章：信息安全"><a href="#第十二章：信息安全" class="headerlink" title="第十二章：信息安全"></a>第十二章：信息安全</h3><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240418180555217.png" alt="image-20240418180555217"></p><h4 id="12-1防火墙技术"><a href="#12-1防火墙技术" class="headerlink" title="12.1防火墙技术"></a>12.1防火墙技术</h4><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240418185503835.png" alt="image-20240418185503835"></p><h5 id="包过滤防火墙"><a href="#包过滤防火墙" class="headerlink" title="包过滤防火墙"></a>包过滤防火墙</h5><p><strong>网络层，对不符合的包采用直接丢弃。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240418185547964.png" alt="image-20240418185547964"></p><h5 id="应用代理网关防火墙"><a href="#应用代理网关防火墙" class="headerlink" title="应用代理网关防火墙"></a>应用代理网关防火墙</h5><p><strong>应用层，采用中间层与外网访问。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240418184547957.png" alt="image-20240418184547957"></p><h5 id="状态检测防火墙"><a href="#状态检测防火墙" class="headerlink" title="状态检测防火墙"></a>状态检测防火墙</h5><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240418182533955.png" alt="image-20240418182533955"></p><p>公用服务器DMZ</p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240428152740780.png" alt="image-20240428152740780" style="zoom: 50%;" /><p>例题：</p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240418182727860.png" alt="image-20240418182727860"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240418182816504.png" alt="image-20240418182816504"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240418183002204.png" alt="image-20240418183002204"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240418183751538.png" alt="image-20240418183751538"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240418183946189.png" alt="image-20240418183946189"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240418184109900.png" alt="image-20240418184109900"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240418184346562.png" alt="image-20240418184346562"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240418184651229.png" alt="image-20240418184651229"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240418185246752.png" alt="image-20240418185246752"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240418185814749.png" alt="image-20240418185814749"></p><h4 id="12-2病毒"><a href="#12-2病毒" class="headerlink" title="12.2病毒"></a>12.2病毒</h4><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240418185945602.png" alt="image-20240418185945602"></p><p><strong>木马病毒：</strong></p><p>木马也称木马病毒，是指通过特定的程序来控制另一台计算机。与一般的病毒不同，它不会自我繁殖，也专并不“刻意”地去感染其他文件，它通过将自身伪装吸引用户下载执行，向施种木马者提供打开被种主机的门户，使施属种者可以任意毁坏、窃取被种者的文件，甚至远程操控被种主机。</p><p><strong>蠕虫病毒：</strong></p><p>蠕虫病毒一种能够利用系统漏洞通过网络进行自我传播的恶意程序。它不需要附着在其他程序上，而是独立存在的。当形成规模、传播速度过快时会极大地消耗网络资源导致大面积网络拥塞甚至瘫痪。</p><p>例题：</p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240418190348159.png" alt="image-20240418190348159"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240418190543894.png" alt="image-20240418190543894"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240418190640648.png" alt="image-20240418190640648"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240418190701863.png" alt="image-20240418190701863"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240418190841750.png" alt="image-20240418190841750"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240418191100525.png" alt="image-20240418191100525"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240418191123089.png" alt="image-20240418191123089"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240418191242773.png" alt="image-20240418191242773"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240418191304441.png" alt="image-20240418191304441"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240418191332754.png" alt="image-20240418191332754"></p><h4 id="12-3网络攻击"><a href="#12-3网络攻击" class="headerlink" title="12.3网络攻击"></a>12.3网络攻击</h4><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240419140006551.png" alt="image-20240419140006551"></p><p>例题：</p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240419135314201.png" alt="image-20240419135314201"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240419135431980.png" alt="image-20240419135431980"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240419135657982.png" alt="image-20240419135657982"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240419135736096.png" alt="image-20240419135736096"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240419135859368.png" alt="image-20240419135859368"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240419135942707.png" alt="image-20240419135942707"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240419140301471.png" alt="image-20240419140301471"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240419140545739.png" alt="image-20240419140545739"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240419140607657.png" alt="image-20240419140607657"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240419140633586.png" alt="image-20240419140633586"></p><h4 id="12-4网络安全"><a href="#12-4网络安全" class="headerlink" title="12.4网络安全"></a>12.4网络安全</h4><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240419145033303.png" alt="image-20240419145033303"></p><p>IPSec：对数据报文进行加密。</p><p>Telnet：远程登陆协议，不安全。</p><p>TCP：传输控制协议。</p><p>RFB：远程登陆图形化用户界面协议。</p><p>IGMP：英特网主管理协议。</p><p>例题：</p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240419142034141.png" alt="image-20240419142034141"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240419142401720.png" alt="image-20240419142401720"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240419142455774.png" alt="image-20240419142455774"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240419142652977.png" alt="image-20240419142652977"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240419142945093.png" alt="image-20240419142945093"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240419143046298.png" alt="image-20240419143046298"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240419143213624.png" alt="image-20240419143213624"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240419143614203.png" alt="image-20240419143614203"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240419143813227.png" alt="image-20240419143813227"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240419144654590.png" alt="image-20240419144654590"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240419144718149.png" alt="image-20240419144718149"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240419145107500.png" alt="image-20240419145107500"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240419145150094.png" alt="image-20240419145150094"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240419145252345.png" alt="image-20240419145252345"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240419145421190.png" alt="image-20240419145421190"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240419145535472.png" alt="image-20240419145535472"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240419145558814.png" alt="image-20240419145558814"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240419145640608.png" alt="image-20240419145640608"></p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240419145918232.png" alt="image-20240419145918232"></p><p>杂题：</p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240419150702273.png" alt="image-20240419150702273"></p><hr><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240419150818690.png" alt="image-20240419150818690"></p><hr><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240419151024437.png" alt="image-20240419151024437"></p><hr><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240419151200579.png" alt="image-20240419151200579"></p><hr><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240419151357826.png" alt="image-20240419151357826"></p><hr><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240419151836307.png" alt="image-20240419151836307"></p><h4 id="12-5安全加密"><a href="#12-5安全加密" class="headerlink" title="12.5安全加密"></a>12.5安全加密</h4><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240422205846669.png" alt="image-20240422205846669" style="zoom:67%;" /><p>例题：</p><p><img src="https://cdn.jsdelivr.net/gh/Liooser/blogImage@main/img/image-20240422205906953.png" alt="image-20240422205906953"></p><h3 id="计算机英语"><a href="#计算机英语" class="headerlink" title="计算机英语"></a>计算机英语</h3>]]></content>
      
      
      
        <tags>
            
            <tag> 软考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库三级【故障管理、备份与恢复】</title>
      <link href="/post/ee7dbeea.html"/>
      <url>/post/ee7dbeea.html</url>
      
        <content type="html"><![CDATA[<h3 id="备份恢复"><a href="#备份恢复" class="headerlink" title="备份恢复"></a>备份恢复</h3><p><mark>在SQL Server 2008中，数据库镜像分为高可用操作模式、高保护操作模式和高性能操作模式</mark></p><p><mark>对于SQL Server 2008支持<strong>数据库、数据文件</strong>两个级别的数据恢复。</mark></p><p>对于SQL Server的系统数据库（不包括tempdb数据），一般是在进行了修改之后立即做备份比较合适。比如对master数据库的备份，<maRK>通常在执行了创建、修改或删除数据库的操作，或是更改了服务器或数据库的配置、建立或更改登录账户等操作后，都应对它进行备份</marK>。</p><p> 对用户数据库应该采用周期性的备份方法，至于多长时间备份一次，与数据的更改频率和用户能够允许的数据丢失多少有关。</p><p><mark><strong>但在进行了下列操作后，最好能立刻对用户数据库进行备份：</strong></mark></p><ol><li><strong>创建数据库之后，或者在数据库中批量加载了数据之后。</strong></li><li><strong>创建索引之后。</strong></li><li><strong>执行了清理事务日志的操作之后。</strong></li><li><strong>执行了大容量数据操作之后。</strong></li></ol><h3 id="检查点技术"><a href="#检查点技术" class="headerlink" title="检查点技术"></a>检查点技术</h3><p>（Checkpoint Technology）</p><ol><li><strong>定义</strong>：<mark>检查点技术是数据库管理系统中的一种机制，用于创建数据库的一致性快照，以便在数据库系统发生故障时恢复到一个已知的稳定状态。</mark></li><li><strong>作用</strong>：检查点技术可以确保数据库在执行事务期间不会丢失或损坏数据。它定期将内存中的数据库状态写入到磁盘上的持久性存储，以创建一致的数据库镜像。</li></ol><p><strong>检查点技术的优缺点：</strong></p><p>优点：</p><ol><li><strong>数据一致性</strong>：检查点技术确保数据库的一致性，因为它在稳定状态时创建快照，使得在故障恢复时可以从已知的状态开始。</li><li><strong>故障恢复</strong>：可帮助恢复数据库到故障发生前的状态，减少数据损失。</li><li><strong>操作效率</strong>：减少了频繁的写磁盘操作，提高了数据库的性能。</li></ol><p>缺点：</p><ol><li><strong>额外的I&#x2F;O开销</strong>：创建检查点需要将内存中的数据写入磁盘，可能会增加I&#x2F;O开销。</li><li><strong>需要更多的磁盘空间</strong>：存储检查点数据需要足够的磁盘空间。</li></ol><h3 id="增量转储、差量转储完全转储"><a href="#增量转储、差量转储完全转储" class="headerlink" title="增量转储、差量转储完全转储"></a>增量转储、差量转储完全转储</h3><p><strong>增量转储（Incremental Backup）</strong></p><ol><li><strong>定义</strong>：增量转储也是一种备份策略，它只备份自上一次备份以来发生的所有数据更改，包括新增数据、已更改数据和删除的数据。</li><li><strong>工作原理</strong>：与差量备份不同，增量备份记录的是自上次备份以来的所有更改，而不是只记录自上次备份以来的差异。这意味着每次增量备份都会备份更多的数据，但在恢复时，只需还原最近的完全备份和所有增量备份，无需差量备份的逐层应用。</li></ol><p><strong>差量转储（Differential Backup）</strong></p><ol><li><strong>定义</strong>：差量转储是一种备份策略，它只备份自上一次完全备份以来发生更改的数据。</li><li><strong>工作原理</strong>：差量备份在首次备份后记录自上次备份以来的更改。因此，差量备份会备份新增的数据和已更改的数据，而不是整个数据库。这可以减少备份时间和存储需求，但恢复时需要首先还原最近的完全备份，然后应用差量备份。</li></ol><p><strong>完全转储（Full Dump）</strong></p><ol><li><strong>定义</strong>：整个数据集或系统的完整副本备份到另一个存储位置或介质的过程。</li><li><strong>工作原理</strong>：捕获整个数据集的快照，将其传输和存储在安全的位置，以确保在数据丢失或系统故障时能够迅速恢复数据。</li></ol><p><strong>三者特点：</strong></p><p><strong>增量转储</strong></p><ul><li><p>增量转储比差量转储<strong>速度快</strong></p></li><li><p>增量转储比差量转储<strong>占用空间较少</strong></p></li><li><p>增量转储比完全转储的<strong>恢复时间要长</strong></p></li></ul><p><strong>差量转储</strong></p><ul><li>差量转储比增量转储<strong>恢复速度快</strong></li></ul><p><strong>完全转储</strong></p><ul><li>占用较多的时间和空间</li><li>恢复速度最快</li></ul><h3 id="事务日志备份"><a href="#事务日志备份" class="headerlink" title="事务日志备份"></a>事务日志备份</h3><p><marK>事务日志备份仅用于完整恢复模式和大容量日志恢复模式，它并不备份数据库本身，只备份日志记录</marK>，而且<marK>只备份从上次备份之后到当前备份时间发生变化的日志内容</marK>。<marK>不允许对大容量操作日志备份进行时点恢复。</marK></p><p><marK>结尾日志备份在出现故障时进行，用于防止丢失数据，可以包含纯日志记录或者大容量操作日志记录</marK>。</p><ol><li><strong>简单恢复模式（Simple Recovery Mode）</strong>：<ul><li><strong>特点</strong>：在简单恢复模式下，数据库事务日志仅用于保持事务的完整性，但<marK>不保留历史事务日志记录</marK>。</li><li><strong>备份需求</strong>：在简单恢复模式下，您只需要定期备份整个数据库。数据库备份会截断事务日志，释放日志空间。</li><li><strong>恢复过程</strong>：在故障发生时，您可以使用最近的完整备份来还原数据库，并且只能还原到备份时间点的状态，无法还原到更早的时间点。</li><li><strong>优点</strong>：简单恢复模式对于小型数据库和数据丢失风险较低的情况可能是合适的，<marK>用于测试和开发数据库，或用于主要包含只读数据的数据库（如数据仓库）</marK>，因为它减少了事务日志的管理负担。</li></ul></li><li><strong>完整恢复模式（Full Recovery Mode）</strong>：<ul><li><strong>特点</strong>：在完整恢复模式下，数据库事务日志会<marK>保留历史事务记录，用于点时间恢复和逐渐备份</marK>。</li><li><strong>备份需求</strong>：除了定期备份数据库，您还需要定期备份事务日志（差异备份或增量备份）。这些备份文件允许您将数据库恢复到特定的时间点。</li><li><strong>恢复过程</strong>：在故障发生时，您可以使用最近的完整备份和后续的事务日志备份来逐渐还原数据库到所需时间点的状态。</li><li><strong>优点</strong>：<marK>完整恢复模式适用于大型、关键性数据库</marK>，因为它允许您实现更精确的时间点恢复。</li></ul></li><li><strong>大容量日志恢复模式（Bulk-Logged Recovery Mode）</strong>：<ul><li><strong>特点</strong>：大容量日志恢复模式是介于简单恢复模式和完整恢复模式之间的一种模式。<marK>它类似于完整恢复模式，但在某些情况下可以减少日志记录量</marK>。</li><li><strong>备份需求</strong>：与完整恢复模式类似，您需要定期备份数据库和事务日志。但在大容量日志恢复模式下，某些特定操作（如大容量插入）可以生成较少的日志记录。</li><li><strong>恢复过程</strong>：恢复过程与完整恢复模式类似，但在某些情况下可能需要更多的时间。</li><li><strong>优点</strong>：<marK>大容量日志恢复模式可以在某些情况下提供更高的性能，同时仍然允许点时间恢复</marK>。</li></ul></li></ol><h3 id="静态转储和动态转储"><a href="#静态转储和动态转储" class="headerlink" title="静态转储和动态转储"></a>静态转储和动态转储</h3><p><strong>静态转储（Static Dump）</strong></p><ol><li><strong>定义</strong>：静态转储是一种在特定时间点捕获并备份数据的过程，通常是在数据处理系统停止或特定间隔内进行的。</li><li><strong>特点</strong>：<ul><li><mark>静态转储通常用于捕获整个数据集的快照，而不考虑数据的实时变化。(实时变化的数据不适用)</mark></li><li>它可以在数据库关闭或系统空闲时执行，以减少对生产系统的影响。</li><li>静态转储生成的备份文件通常包含数据库或数据存储的当前状态，但不反映后续更改。</li></ul></li><li><strong>用途</strong>：静态转储常用于定期备份数据库、文件系统或应用程序数据，以用于灾难恢复、数据分析或归档。</li></ol><p><strong>动态转储（Dynamic Dump）</strong></p><ol><li><strong>定义</strong>：动态转储是一种在数据系统持续运行时捕获并备份数据的过程，以反映实时数据变化。</li><li><strong>特点</strong>：<ul><li><mark>动态转储是一种增量备份方法，只捕获自上次备份以来发生的更改数据，而不是整个数据集。</mark></li><li>它通常是在生产系统运行时执行，以确保实时数据的连续备份。</li><li>动态转储备份文件通常较小，可以减少备份和恢复时间。</li></ul></li><li><strong>用途</strong>：动态转储常用于确保实时或近实时数据备份，以减少数据丢失的风险。它适用于需要快速数据恢复的应用和系统。</li></ol><p><strong>注意：</strong></p><ul><li><p><marK>静态转储保证了数据的有效性，却是以降低数据库的可用性为代价的。</mark></p></li><li><p><mark>动态转储虽然提高了数据库的可用性，但数据的有效性却可能得不到保证。</mark></p></li><li><p><mark>为了既能保证数据的有效性又不会降低数据库的可用性，需要引入日志文件，用它记录转储期间各事务对数据库的修改活动记录，然后使用动态转储的备份副本加上日志文件就可以将数据库恢复到某一时刻的正确状态。</marK></p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库三级【数据库运行维护和优化】</title>
      <link href="/post/61cdd72.html"/>
      <url>/post/61cdd72.html</url>
      
        <content type="html"><![CDATA[<h2 id="数据库运行维护"><a href="#数据库运行维护" class="headerlink" title="数据库运行维护"></a>数据库运行维护</h2><p><strong>数据库设计阶段，主要强调的是高效率利用存储空间，减少数据的冗余，增加数据的一致性，这个过程也就是规范化的过程。规范化关系解决了数据维护的异常，并使冗余最小化，然而，可能会出现数据处理性能下降的问题。</strong></p><p><strong>在大多数情况下，数据库系统需要考虑的第二个目标是高效率的数据处理，反规范化处理，如增加派生冗余列，增加冗余列，重新组表、分割表和新增汇总表可以有效地提高查询效率。</strong></p><p><mark>数据库应用系统投入运行标志着系统开发任务的基本完成和系统运行维护工作的开始</mark>。</p><p>数据库运行维护工作主要包括数据库的<mark> 转储和恢复</mark>；<mark>数据库的安全性和完整性控制</mark>；<mark>数据库性能的监控分析和改进</mark>；<mark>数据库的重组和重构</mark>。其中新建数据库用户属于数据库的安全性和完整性控制的一项功能。</p><h3 id="监控分析"><a href="#监控分析" class="headerlink" title="监控分析"></a>监控分析</h3><p>根据监控分析实现的方法不同，监控分析机制分为两种，一种是由数据库系统建立的<mark>自动监控机制</mark>，另一种是由<mark>管理员手动实施的监控机制</mark>。</p><p>根据监控对象的不同，监控分析可以分为两种：</p><ul><li><strong>对数据库架构体系的监控</strong><ul><li>主要监控内容：<mark>空间基本信息、空间使用率与剩余空间大小、空间是否具有自动扩展的能力、哪些表的扩展将引起空间的扩展，以及段的占用空间与区间数等</mark>。</li></ul></li><li><strong>对数据库性能的监控</strong><ul><li>主要监控内容：<mark>数据缓冲区的命中率、库缓冲、用户锁、锁与等待、回滚段、临时段使用情况、索引的使用情况、等待事件和共享池等</mark>。</li></ul></li></ul><p>数据库性能优化是对数据库管理员的严峻考验，有时候对应用程序的修改<strong>需要应用开发人员配合</strong>才能完成。</p><p><mark>监控分析的主要工作：</mark></p><ul><li><strong>数据库缓冲区的命中率</strong></li><li><strong>库缓冲</strong></li><li><strong>用户锁</strong></li><li><strong>锁与等待</strong></li><li><strong>回滚段</strong></li><li><strong>临时段使用情况</strong></li><li><strong>索引的使用情况</strong></li><li><strong>等待事件和共享池</strong></li></ul><h2 id="数据库优化"><a href="#数据库优化" class="headerlink" title="数据库优化"></a>数据库优化</h2><p><mark>集中式数据库的查询处理中，主要代价是CPU代价和I&#x2F;O代价。</mark></p><p><mark>在分布式数据库系统中，由于数据分布在多个不同的场地上，需要在各站点中传输数据，所以通信代价尤为关键。</mark></p><h3 id="存储结构和存取方法优化"><a href="#存储结构和存取方法优化" class="headerlink" title="存储结构和存取方法优化"></a>存储结构和存取方法优化</h3><h4 id="存储结构优化"><a href="#存储结构优化" class="headerlink" title="存储结构优化"></a><strong>存储结构优化</strong></h4><ol><li><strong>分区表设计：</strong> <mark>对大型表进行水平分区，将表划分为更小的逻辑单元，以减少查询范围和提高性能</mark>。分区可以根据时间、地理位置等因素进行。</li><li><strong>适当的索引：</strong> <mark>选择适当的索引类型、选择性和字段组合，确保索引与查询需求匹配，同时避免不必要的索引，以减少维护开销</mark>。</li><li><strong>表空间管理：</strong> 对于大型数据库，合理管理表空间和文件组，<mark>将数据文件和日志文件放置在不同的磁盘上，以减少磁盘 I&#x2F;O 冲突</mark>。</li><li><strong>合理的数据模型设计：</strong> 数据库的数据模型应该经过仔细设计，包括选择适当的表结构、列数据类型、主键和外键，以最大程度地减少数据冗余，并确保数据模型符合业务需求。</li><li><strong>缓存机制：</strong> 使用数据库系统提供的缓存机制，如数据缓存和执行计划缓存，以减少磁盘 I&#x2F;O 操作，提高查询性能。</li></ol><h4 id="存取方法优化"><a href="#存取方法优化" class="headerlink" title="存取方法优化"></a><strong>存取方法优化</strong></h4><ol><li><p><strong>并发控制和事务管理：</strong> <mark>使用合适的并发控制策略，管理事务隔离级别，以减少锁冲突和提高并发性能</mark>。</p></li><li><p><strong>数据分区和分片：</strong> <mark>在分布式数据库中，使用数据分区和分片来分散查询负载，以提高性能和伸缩性</mark>。</p></li><li><p><strong>存储过程和函数：</strong>  使用存储过程和函数来封装常见的业务逻辑，以减少网络传输和提高性能。</p></li><li><p><strong>查询优化：</strong> 通过分析查询执行计划，优化查询语句，使用适当的连接方法和索引，以改善查询性能。可以使用工具和分析器来帮助确定查询瓶颈。</p></li><li><p><strong>定期维护：</strong> 定期执行数据库维护任务，如索引重建、统计信息更新和数据库重新组织，以确保数据库的最佳性能。</p></li></ol><h4 id="物化视图"><a href="#物化视图" class="headerlink" title="物化视图"></a><strong>物化视图</strong></h4><p><mark>物化视图是包括一个查询结果的数据库对象。物化视图是预先计算并保存表连接或聚集等耗时较多的操作结果。</mark></p><p>这样在查询时大大提高了读取速度，特别适用于多个数据量较大的表进行连接操作及分布式数据库中需要进行分布在多站点的表进行连接操作时使用。</p><h3 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h3><ol><li><mark><strong>经常在查询中作为条件被使用的列，应为其建立索引。</strong></mark></li><li><mark><strong>频繁进行排序或分组的列，应为其建立索引。</strong></mark></li><li><strong>一个列的值域很大时，应为其建立索引。</strong></li><li><strong>如果待排序的列有多个，应在这些列上建立复合索引。</strong></li><li><strong>可以使用系统工具来检查索引的完整性，必要时进行修复。另外，当数据库表更新大量数据后，删除并重建索引也可以提高查询速度。</strong></li></ol><p>注意：</p><ul><li>索引可以提高检索速度，但需要一定的维护成本。删除记录时，会将它涉及的所有索引中的相关信息删除，所以索引越多，增、删、改的成本通常会更高。</li><li>如果作为删除条件的<strong>列</strong>没有建立过索引，将扫描整个数据表，所以为<strong>作为删除条件的列建立索引可以提高delete的效率。</strong></li></ul><h3 id="重组与重构"><a href="#重组与重构" class="headerlink" title="重组与重构"></a>重组与重构</h3><ol><li><strong>数据库重组</strong></li></ol><ul><li>指按照系统设计要求对数据库存储空间进行全面调整，如<mark>调整磁盘分区方法和存储空间、重新安排数据的存储、整理回收碎块等</mark>，以提高数据库性能。</li></ul><ol start="2"><li><strong>数据库重构</strong></li></ol><ul><li>指由于数据库应用环境的不断变化，增加了新的应用或新的实体，取消了某些应用，有的实体与实体间的联系也发生了变化等，使得原有的数据库设计不能满足新的需求，此时需要<mark>调整数据库的模式和内模式</mark>。</li></ul><p><strong>区别：</strong></p><p> <mark>数据库的重组并不修改数据库原有设计的逻辑结构和物理结构，而数据库的重构则不同，它可以部分修改数据库的模式和内模式。</mark></p><h3 id="模式调整"><a href="#模式调整" class="headerlink" title="模式调整"></a>模式调整</h3><p>数据库优化工作中的模式调整工作涉及对数据库结构（模式）进行修改和调整，以改进性能、减少数据冗余、提高查询效率或适应新的业务需求。</p><p><strong>模式调整工作：</strong></p><ol><li><strong>添加索引：</strong> 在需要的列上添加索引，以加速查询操作。优化选择合适的索引类型和列，以提高性能。</li><li><strong>表的拆分与合并：</strong> 根据数据量和查询需求，将表格拆分成更小的表或合并多个表以减少连接操作。</li><li><strong>冗余列的引入：</strong> 引入冗余列以避免频繁的计算或连接操作。这可以提高查询性能，尽管需要维护冗余数据的一致性。</li><li><strong>更改数据类型：</strong> 优化列的数据类型以减少存储空间占用或适应新的数据要求。</li><li><strong>删除不必要的列：</strong> 移除不再使用或不必要的列，以减少数据表的宽度和存储开销。</li><li><strong>引入新的关联关系：</strong> 根据新的业务需求引入新的关联关系或关联表，以支持新的查询和数据操作。</li><li><strong>更改主键和外键：</strong> 调整主键和外键以更好地满足数据库约束和关系。</li><li><strong>数据清理和规范化：</strong> 清理不必要的数据并进行数据规范化，以减少数据冗余和提高数据一致性。</li><li><strong>重命名对象：</strong> 为了更好地反映数据的含义，对表格、列、索引等对象进行重命名。</li><li><strong>引入视图和存储过程：</strong> 使用视图和存储过程来封装复杂的查询和业务逻辑，以简化数据访问。</li><li><strong>安全性调整：</strong> 根据安全需求修改表格和列的权限和访问控制。</li><li><strong>数据迁移和导入：</strong> 将数据从一个数据库迁移到另一个数据库，或从不同数据源导入数据。</li></ol><p><mark><strong>注意：</strong></mark></p><p><mark>模式调整（Schema Refactoring）并不一定要符合第三范式（3NF）要求</mark>，因为第三范式是一种关系数据库设计规范，而模式调整通常是在数据库已经存在并且需要进行改进或优化时进行的一种操作。</p><p><mark>模式调整的目的通常是优化数据库的性能、降低复杂性、提高查询效率或满足特定的业务需求</mark>。<mark>在某些情况下，为了实现这些目标，可能需要引入冗余数据、合并表或改变数据的结构，这可能违反了第三范式的原则，但却是为了更好地满足数据库的实际需求</mark>。</p><p>第三范式要求一个关系数据库中的每个非主属性都必须直接依赖于候选键（也就是说，没有传递依赖关系）。虽然第三范式是一个有益的设计原则，有助于减少数据冗余和提高数据的一致性，但在实际数据库管理中，可能会存在一些例外情况，需要进行模式调整，不一定要遵循第三范式。</p><h3 id="反规范化"><a href="#反规范化" class="headerlink" title="反规范化"></a>反规范化</h3><p>反规范化是将规范化的关系转换为非规范化的关系的过程。常用的反规范化方法有<strong>增加派生冗余列、增加冗余列、重新分组、分割表和新增汇总表</strong>等。</p><h4 id="派生冗余列"><a href="#派生冗余列" class="headerlink" title="派生冗余列"></a>派生冗余列</h4><p>派生性冗余列是数据库设计中的一种策略，它涉及在表中添加一个或多个列，这些列包含从其他列计算出来的值。这些派生列的值可以通过应用程序代码或数据库触发器等机制进行计算和维护。达到以<mark>牺牲空间来换取减少查询时间的目的</mark>。</p><p><strong>优点：</strong></p><ol><li><strong>提高查询性能：</strong> <mark>派生性冗余列可以减少复杂的计算和聚合函数操作</mark>，从而显著提高查询性能。特别是在大型数据集上进行聚合查询时，它们可以节省大量的计算时间。</li><li><strong>简化数据检索：</strong> 派生性冗余列使得某些信息可以直接从列中读取，<mark>减少执行复杂的计算或连接操作</mark>。这简化了数据检索的过程，提高了应用程序的响应速度。</li><li><strong>降低负载：</strong> 减少了实时计算的需求，这降低了数据库服务器的负载。这对于高并发环境下的应用程序尤其有利。</li><li><strong>支持离线分析：</strong> 派生性冗余列可以为离线数据分析提供便利，因为它们存储了聚合数据，可以用于生成报告和分析。</li></ol><p><strong>缺点：</strong></p><ol><li><strong>破坏规范化规则</strong>：<mark>由于增加了派生性冗余字段，破坏了规范化规则</mark>。因为规范化的目标是消除数据中的冗余并确保数据的一致性。规范化通过将数据分解成多个表，并使用外键关系来维护数据的关联性，以减少数据冗余并提高数据完整性。当引入派生性冗余字段时，部分数据冗余会重新引入到数据库中。</li><li><strong>额外的存储开销：</strong> <mark>派生性冗余列需要额外的存储空间</mark>，尤其是在大型数据库中。这可能增加存储成本，并且需要更多的磁盘空间。</li><li><strong>数据一致性：</strong> 最大的缺点之一是维护数据一致性。当原始数据发生变化时，必须确保派生性冗余列的值也相应更新。如果更新不及时或不正确，可能导致数据不一致。</li><li><strong>复杂性增加：</strong> 派生性冗余列引入了数据复杂性。数据库管理员和开发人员需要确保数据的一致性，并处理派生列的维护。</li><li><strong>性能下降的风险：</strong> 在某些情况下，派生性冗余列可能导致性能下降，特别是在数据写入频繁的情况下。因为每次写入都需要更新冗余列，可能会增加写入操作的时间。</li><li><strong>不适用于动态数据：</strong> 对于频繁变化的数据，派生性冗余列可能不适用，因为它们需要频繁更新，可能导致性能问题。</li></ol><h4 id="分割表"><a href="#分割表" class="headerlink" title="分割表"></a>分割表</h4><p>分割表（Table Partitioning）是数据库设计中一种重要的优化技术，它将一个大型数据库表分成若干个更小、更易管理的子表，每个子表通常包含相似的数据。</p><p><strong>水平分割（Horizontal Partitioning）：</strong></p><ol><li><p><strong>基本概念：</strong> 水平分割是将一个表中的数据按行划分成多个子表，每个子表包含表的一部分数据。每个子表通常包含满足特定条件的行。</p></li><li><p><strong>应用场景：</strong> 水平分割适用于将大表划分为较小的子集，以提高查询性能、减少备份和恢复时间，或根据业务需求将数据分配给不同的地理位置或应用程序。</p></li><li><p><strong>示例：</strong> 如果有一个包含全球销售数据的表，可以通过水平分割将数据划分为多个子表，每个子表包含一个地理区域（例如，北美、欧洲、亚洲）的销售数据。</p></li><li><p><strong>数据结构：</strong> 每个子表具有与原始表相同的列结构，但只包含特定条件下的行。</p></li><li><p><strong>水平分割特点：</strong></p><ul><li><mark>水平分割是根据数据行的使用特点进行分割，分割之后所得的所有表的结构都相同</mark></li><li>大部分情况是局部使用，只有很少情况才全局查询时适合使用此方法。</li><li><mark>缺点：存储的数据不同。水平分割会给应用增加复杂度，特别在查询所有数据时需要Union（并）操作</mark></li></ul></li></ol><p><strong>垂直分割（Vertical Partitioning）：</strong></p><ol><li><strong>基本概念：</strong> 垂直分割是将一个表中的列按列划分成多个子表，每个子表包含表的一部分列。每个子表通常包含与某一方面或业务功能相关的列。</li><li><strong>应用场景：</strong> 垂直分割适用于将表中的列划分成更小、更容易管理的逻辑单元，以提高查询性能、降低维护成本或根据应用程序需求将数据分配给不同的应用程序或服务。</li><li><strong>示例：</strong> 如果有一个包含员工信息的表，可以通过垂直分割将表划分为两个子表，一个包含基本信息（如姓名、员工号、雇佣日期），另一个包含薪资信息（如工资、津贴）。</li><li><strong>数据结构：</strong> 不同的子表可以包含不同的列，但它们通常具有相同的行结构（即相同的主键）。</li><li><strong>垂直分割特点：</strong> <ul><li><mark>垂直分割是根据列的特点进行分割，分割之后所得的所有表中除了都含有主码列外其余列都不同</mark></li><li><mark>查询时会减少I&#x2F;O次数</mark></li><li>缺点：查询所有数据时需要Join (连接）操作。</li></ul></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库三级【数据仓库与数据挖掘】</title>
      <link href="/post/c9b10525.html"/>
      <url>/post/c9b10525.html</url>
      
        <content type="html"><![CDATA[<h2 id="数据仓库"><a href="#数据仓库" class="headerlink" title="数据仓库"></a>数据仓库</h2><p> <strong>建立数据仓库的主要目的:</strong></p><ul><li>根据决策需求对企业的数据采取适当的手段进行集成，形成一个综合的、面相分析的数据环境，用于支持企业的信息型、决策型的分析应用。</li></ul><p><mark>数据仓库中数据特征包括面向主题性，集成性，不可更新性，时间特性。</mark></p><ol><li><strong>主题性</strong>：从实际需求出发，具有较高的抽象性，数据可用性比OLTP较为宽松。</li><li><strong>集成性</strong>：需要将数据抽取、转换、清理、装载。</li><li><strong>稳定性</strong>（不可更新性）：是面向决策支持应用主题的，数据进入数据仓库后不允许修改。</li><li><strong>动态性</strong>（时间特性）：数据需要定期更新。</li></ol><h3 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h3><p>快照是关于指定数据集合的一个完全可用拷贝，该拷贝包括相应数据在某个时间点（拷贝开始的时间点）的映像。</p><p><strong>快照的特点：</strong></p><ul><li><p>快照可以是其所表示的数据的一个副本，也可以是数据的一个复制品。<mark>它反映的是某个时间点内的数据，该数据具有不可以改变性。</mark></p></li><li><p><mark>动态数据，不适合用快照的方式获取数据。</mark></p></li></ul><h3 id="数据粒度"><a href="#数据粒度" class="headerlink" title="数据粒度"></a>数据粒度</h3><p>在数据管理和分析中，<strong>粒度表示数据的精细程度或数据的细节级别。</strong></p><p><strong>较细的数据粒度意味着数据包含更多的详细信息，而较粗的数据粒度则表示数据以较高级别的总结或聚合方式呈现。</strong>例如，对于销售数据，粗粒度数据可能是每月销售总额，而细粒度数据可能是每日或每小时的销售详细信息。</p><p><strong>提高封锁的粒度带来的好处：</strong></p><p><mark>封锁粒度越大，数据库系统能够封锁的数据单元就越少，封锁开销也就越小，并发度也就随之降低。</mark></p><h3 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h3><p>​    元数据是关于数据的数据，或者叫做描述数据的数据，它描述了数据的结构、内容、链和索引等项的内容</p><h3 id="数据集成"><a href="#数据集成" class="headerlink" title="数据集成"></a>数据集成</h3><p><mark>数据集成是将源自不同数据源的数据经过抽取、转换、清理、装载等操作载入数据仓库的过程</mark>，是实施数据仓库的重要步骤。</p><p>由于对大量的原始数据要加以提炼，要减轻分析工作给处理业务数据的服务器带来的压力，要规范各源数据，以及要处理那些难以直接使用的数据，数据集成在数据仓库设计中是必不可少的一环，ETL是实现数据集成的主要技术。</p><h3 id="数据分片"><a href="#数据分片" class="headerlink" title="数据分片"></a>数据分片</h3><ul><li><mark>水平分片是在关系中从行的角度（元组）依据一定条件划分为不同的片断，关系中的每一行必须至少属于一个片断，以便在需要时可以重构关系。</mark></li><li><mark>垂直分片是在关系中从列的角度（属性）依据一定条件分为不同的片断，各片断中应该包含关系的主码属性，以便通过连接方法恢复关系。</mark></li></ul><h3 id="维护策略"><a href="#维护策略" class="headerlink" title="维护策略"></a>维护策略</h3><p> <strong>物化视图更新维护策略分为三种：</strong></p><ol><li>实时维护：数据源发生变化时，立即更新数据仓库中的数据。</li><li>延时维护：不是在数据源的更新事务中完成，而是在数据仓库中的视图被查询时完成。</li><li>快照维护：定期对数据仓库进行维护，触发的条件是时间。</li></ol><h3 id="OLAP和OLTP"><a href="#OLAP和OLTP" class="headerlink" title="OLAP和OLTP"></a>OLAP和OLTP</h3><p>OLAP是用于<strong>复杂数据分析和决策支持的数据库处理方式</strong>，通常涉及大量历史数据和多维查询。这使得它成为适用于需要深入了解业务数据、发现趋势和模式的应用程序，例如市场分析、销售预测、业务报告等。</p><p>OLTP是联机事务处理，<strong>一般要处理大量的事务，事务简单且重复率高</strong>，例如银行出纳或民航售票。</p><h2 id="数据挖掘"><a href="#数据挖掘" class="headerlink" title="数据挖掘"></a>数据挖掘</h2><h3 id="聚类方法"><a href="#聚类方法" class="headerlink" title="聚类方法"></a>聚类方法</h3><p><mark>聚类方法包括统计方法、机器学习方法、神经网络方法和面向数据库的方法等。</mark></p><ol><li><strong>统计方法</strong>：这些方法通常依赖于统计原理和概率模型，如<strong>K均值聚类和高斯混合模型（GMM）</strong>。统计方法通常假设数据服从某种概率分布，并使用参数估计来拟合模型。</li><li><strong>机器学习方法</strong>：机器学习方法利用算法自动学习数据的模式和结构。<strong>除了K均值聚类之外，还包括谱聚类、DBSCAN、模型聚类等</strong>。这些方法通常不依赖于数据分布的先验知识。<mark>在机器学习中，聚类称作无监督（或无教师）归纳。</mark></li><li><strong>神经网络方法</strong>：神经网络方法利用深度学习技术来进行聚类，例如自组织映射（Self-Organizing Maps，SOM）和深度聚类网络。这些方法适用于大规模和高维数据。</li><li><strong>面向数据库的方法</strong>：这些方法将聚类任务与数据库技术相结合，以支持高效的数据存储和查询。例如，基于网格的聚类方法和基于索引的聚类方法。</li></ol><p><mark>聚类的核心就是将一个数据集中的数据进行分组，使得每一组内的数据尽可能的相似而不同组间的数据尽可能不同。</mark></p><p>与分类相比，分类的例子或数据对象均有类别标记，而聚类的例子则没有标记，需要由聚类算法来自动确定。</p><h3 id="分类算法"><a href="#分类算法" class="headerlink" title="分类算法"></a>分类算法</h3><ol><li><strong>决策树（Decision Trees）：</strong><ul><li>ID3、C4.5和CART等算法使用树状结构来进行分类，树的节点表示特征，分支表示特征的取值，叶节点表示类别。</li></ul></li><li>随机森林（Random Forest）：<ul><li>随机森林是一种集成学习方法，它使用多个决策树来进行分类，然后汇总它们的预测结果以提高准确性和鲁棒性。</li></ul></li><li>朴素贝叶斯（Naive Bayes）：<ul><li>基于贝叶斯定理，朴素贝叶斯算法假设特征之间是相互独立的，通过计算后验概率来进行分类。</li></ul></li><li><strong>支持向量机（Support Vector Machine，SVM）：</strong><ul><li>SVM尝试找到一个分割超平面，使得两个不同类别的样本点距离该超平面最远，从而实现分类。</li></ul></li><li><strong>K最近邻算法（K-Nearest Neighbors，K-NN）：</strong><ul><li>K-NN根据样本点周围的K个最近邻居的类别来对新样本进行分类。</li></ul></li><li>人工神经网络（Artificial Neural Networks，ANN）：<ul><li>神经网络是一种基于生物神经元模型的机器学习算法，包括多个层次的神经元，通常用于深度学习任务。</li></ul></li><li>改进的分类算法：<ul><li>还有许多改进的分类算法，如梯度提升机（Gradient Boosting Machine）、XGBoost、LightGBM等，它们在性能和效果方面取得了显著的进展。</li></ul></li><li>深度学习算法：<ul><li>深度学习模型，如卷积神经网络（Convolutional Neural Networks，CNN）和循环神经网络（Recurrent Neural Networks，RNN），在图像识别、自然语言处理等领域取得了显著的成功。</li></ul></li><li><strong>BP神经网络（Backpropagation Neural Network）</strong><ul><li>反向传播神经网络，是一种常见的神经网络算法，用于解决分类和回归等问题。它是一种前馈神经网络，通常包含输入层、隐藏层和输出层。</li></ul></li></ol><h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h2><p>机器学习的基本概念和要点：</p><ol><li><strong>学习：</strong> 机器学习强调计算机系统的学习能力，这意味着系统可以从大量数据中识别模式、规律和关联性，并从中获得知识。</li><li><strong>数据：</strong> 数据是机器学习的基础。机器学习算法使用提供的数据集（通常包括输入特征和相关输出）来进行训练和学习。</li><li><strong>模型：</strong> 机器学习算法构建数学模型或算法，用于表示从数据中学到的知识。这些模型可以是线性回归、决策树、神经网络、支持向量机等。</li><li><strong>特征工程：</strong> 特征工程是选择和预处理数据中的特征，以便模型可以更好地学习和进行预测。这包括特征选择、缺失值处理、标准化等。</li><li><strong>训练和学习：</strong> 训练是指使用历史数据来调整模型的参数或规则，以适应数据的特征和模式。这个过程涉及到优化算法，以最小化模型的误差。</li><li><strong>测试和评估：</strong> 训练后，模型需要进行测试以评估其性能。通常使用独立的测试数据集来检查模型的泛化能力，以确保它在新数据上表现良好。</li><li><strong>预测和决策：</strong> 训练好的模型可以用于从新的数据中提取知识、做出预测或执行任务。这可以包括图像分类、文本翻译、风险评估、推荐系统等各种应用。</li><li><strong>监督学习、无监督学习和强化学习：</strong> 机器学习可以分为不同的类别，包括监督学习（Supervised Learning，使用带有标签的数据进行训练）、无监督学习（Unsupervised Learning，使用无标签数据进行训练）和强化学习（Reinforcement Learning，通过与环境互动来学习决策策略）等。</li><li><strong>深度学习：</strong> 深度学习是机器学习的一个子领域，专注于使用深度神经网络（Deep Neural Networks）来处理复杂的任务，如图像识别和自然语言处理。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库三级【数据库及数据库对象】</title>
      <link href="/post/24d51f4c.html"/>
      <url>/post/24d51f4c.html</url>
      
        <content type="html"><![CDATA[<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="SQL-Server系统数据库"><a href="#SQL-Server系统数据库" class="headerlink" title="SQL Server系统数据库"></a>SQL Server系统数据库</h3><ol><li><p><strong>master数据库：</strong></p><ul><li><code>master</code> 数据库是 SQL Server 实例的主数据库，其中包含了有关整个 SQL Server 实例的元数据信息和配置设置。</li><li>它存储了登录凭据、系统级配置选项、数据库对象的元数据和其他与实例运行有关的信息。</li><li>如果 <code>master</code> 数据库损坏或无法访问，整个 SQL Server 实例可能无法正常启动或运行，因此备份和维护 <code>master</code> 数据库至关重要。</li></ul></li><li><p><strong>model数据库：</strong></p><ul><li><mark><code>model</code> 数据库用作创建新数据库的模板</mark>。当创建新数据库时，SQL Server 会以 <code>model</code> 数据库作为基础，复制其结构和配置来生成新数据库。</li><li>如果需要自定义新数据库的默认设置（如文件组、默认大小等），可以在 <code>model</code> 数据库上进行更改，以确保新数据库遵循所需的标准。</li><li><mark>当用户创建一个数据库时，系统自动将model数据库中的全部内容复制到新建数据库中。</mark></li></ul></li><li><p><strong>tempdb数据库：</strong></p><ul><li><p><code>tempdb</code> 数据库是用于存储临时对象和临时数据的数据库。</p></li><li><p>许多 SQL Server 操作需要使用 <code>tempdb</code>，包括排序、联接、临时表的创建以及大多数查询的执行。</p></li><li><p>由于 <code>tempdb</code> 经常受到高度并发的影响，因此需要定期维护和监控，以确保它的性能不成为系统瓶颈。</p></li></ul></li><li><p><strong>msdb数据库</strong> </p><ul><li><p><strong>SQL Server 代理作业：</strong> </p><ul><li><code>msdb</code> 数据库存储有关 SQL Server 代理作业的信息，包括作业定义、计划、作业历史记录以及与作业相关的警报。SQL Server 代理是一项用于自动执行任务（例如备份、维护、数据传输等）的功能，这些任务可以按计划运行。</li></ul></li><li><p><strong>备份和还原历史记录：</strong> </p><ul><li><code>msdb</code> 数据库保存了 SQL Server 中进行的备份和还原操作的历史记录。这对于跟踪数据库备份计划以及查找备份和还原操作的详细信息非常有用。</li></ul></li><li><p><strong>数据库维护计划：</strong> </p><ul><li><code>msdb</code> 存储了有关数据库维护计划的信息，这些计划用于执行数据库的定期维护任务，如索引重建、统计更新等。这有助于维护数据库的性能。</li></ul></li></ul></li></ol><h3 id="数据库分离"><a href="#数据库分离" class="headerlink" title="数据库分离"></a>数据库分离</h3><p>是一种数据库架构策略，它将一个原本包含所有数据的单一数据库分割成多个独立的数据库或数据存储单元。这个过程旨在<mark>改善系统的性能、可维护性、安全性、可扩展性和管理性等方面的因素</mark>。数据库分离通常发生在应用程序需要处理大量数据或需要更高的数据安全性和可用性时。</p><p><mark>注意</mark>：</p><ul><li><p>分离数据库是指将数据库从SQL Server实例中删除，但不删除数据库的数据文件和日志文件，实际就是让数据库的文件不受数据库管理系统的管理，使用户可以将数据库的数据文件和日志文件复制到另一台计算机上或者是同一台计算机的其他地方。</p></li><li><p><mark>数据库分离需要停用被分离的数据库，但是不需要停用SQL Server服务。</mark></p></li></ul><h3 id="数据库文件"><a href="#数据库文件" class="headerlink" title="数据库文件"></a>数据库文件</h3><p>SQL Server将数据库映射为一组操作系统文件，分为数据文件和日志文件。</p><p><strong>数据文件分类:</strong></p><ul><li><p><strong>主要数据文件（每个数据库有且只有一个）</strong></p><p> 主要数据文件不能小于3MB</p></li><li><p><strong>次要数据文件（可无可有，个数无限制）。</strong></p></li></ul><p> <mark>每个数据库必须至少有一个事务日志文件，也可以有多个事务日志文件</mark>。</p><h3 id="数据库扩容"><a href="#数据库扩容" class="headerlink" title="数据库扩容"></a>数据库扩容</h3><p>语法格式为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER DATABASE 数据库名 MODIFY FILE 文件名 (NAME = 数据文件名, SIZE = 1000MB)</span><br></pre></td></tr></table></figure><h3 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h3><p>分区表：</p><ul><li>将表中的数据按水平方式划分成不同的子集，这些数据子集存储在数据库的一个或多个文件组中。</li><li><mark>分区表是从物理上将一个大表分成几个小表，但从逻辑上来看还是一个大表</mark>。对于用户而言，所面对的仍然是一个大表，用户只要对大表进行操作就可以了，数据库管理系统会自动对小表进行操作。</li></ul><p><strong>创建分区表通过以下几个步骤实现：</strong></p><ul><li><p>创建分区函数。创建分区函数的目的是告诉数据库管理系统以什么方式对表进行分区。</p></li><li><p>创建分区方案。分区方案的作用是将分区函数生成的分区映射到文件组中。</p></li><li><p>使用分区方案创建表。</p><p>水平划分将一张基本表划分为多张具有相同属性、结构完全相同的子表。垂直划分则是将一张基本表划分为多张子表，每张子表包含的属性是原基本表的子集。</p></li></ul><p><strong>分区函数：</strong></p><pre><code>CREATE PARTITION FUNCTION PFl(int)AS RANGE RIGHT FOR VALUES (……n):</code></pre><p><mark>n用于指定分区的值的数目，所创建的分区数等于n+1</mark>。 </p><p>分区函数的<code>LEFT</code>和<code>RIGHI</code>关键字的作用是用来指定当间隔值由数据库引擎按升序从左到右排序时，<code>boundary_value </code>[,……n]属于每个边界值间隔的左侧还是右侧，如果未指定，则默认值为LEFT。</p><p><strong>分区例题：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">设在SQL Server 2008中，有如下创建分区函数的语句：</span><br><span class="line">CREATE PARTITION FUNCTION PF1(int)</span><br><span class="line">AS RANGE LEFT FOR VALUES(1,100,200)</span><br><span class="line">该语句的作用是______。</span><br></pre></td></tr></table></figure><p>SQL Server 2008中的这个创建分区函数的语句创建了一个名为PF1的分区函数，并使用了RANGE LEFT选项以整数列为基础创建分区。这个语句的作用如下：</p><ul><li>分区键：分区函数使用整数列作为分区键，这意味着你将根据整数列的值来对表进行分区。</li><li>分区类型：使用RANGE LEFT选项表示分区是左开区间。这意味着分区的边界值属于左边的分区，但不包括右边的分区。也就是说，边界值1属于第一个分区，边界值100属于第二个分区，边界值200属于第三个分区，以此类推。</li><li>分区边界值：根据提供的边界值(1, 100, 200)，将表分为多个分区。第一个分区包括所有小于等于1的值，第二个分区包括大于1且小于等于100的值，第三个分区包括大于100且小于等于200的值，最后一个分区包括大于200的值。</li></ul><p><mark>注意</mark>：</p><p>数据多了并不是创建分区表的唯一条件，哪怕数据量很大，但是这些记录都是常用的记录，那么最好也不要使用分区表。只有你的数据是分段的数据，才要考虑到是否需要使用分区表。</p><h2 id="数据库对象"><a href="#数据库对象" class="headerlink" title="数据库对象"></a>数据库对象</h2><h3 id="文件组"><a href="#文件组" class="headerlink" title="文件组"></a>文件组</h3><p>  SQL Server有两种类型的文件组：</p><ul><li><p><strong>主文件组</strong>：</p><ul><li><p><mark>PRIMARY是系统定义好的一个主文件组，每个数据库有且仅有一个PRIMARY文件组</mark>。</p></li><li><p><mark>主文件组包含主要数据文件和任何没有明确分配给其他文件组的其他数据文件</mark>。包含数据库的系统信息，也可以存放用户数据。</p></li><li><p>主要数据文件的推荐扩展名是.mdf。</p></li><li><p>SQL Server 2008不强制使用.mdf、.ndf和.ldf文件扩展名，但建议使用这些扩展名以利于标识文件的用途。</p></li></ul></li><li><p><strong>用户定义的文件组</strong>：</p><ul><li>用户可以创建自己的文件组，以将数据文件组织起来，便于管理和数据分配。</li><li>次要数据文件的推荐扩展名是.ndf。</li></ul></li></ul><p><strong>说明：</strong></p><ul><li>在数据库中，可以定义多个文件组，然后将文件放置到不同的文件组中。</li><li>日志文件不包括在文件组内。</li><li>在一个数据库中用户可以创建多个文件组，一个文件不能属于多个文件组。</li><li>如果文件组中有多个文件，则它们在所有文件被填满前不会自动增长，而填满后这些文件会循环增长。</li><li>次要数据文件可以和主要数据文件存放在相同的文件组中。</li><li><mark>日志文件可以与主要数据文件存放在相同文件夹，但不能与次要数据文件存放在相同文件夹</mark>。</li></ul><h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><p>架构（Schema，也称为模式）是数据库下的一个逻辑命名空间，可以存放表、视图等数据库对象。一个数据库可以包含一个或多个架构，架构由特定的授权用户所拥有；在同一个数据库中，架构名必须唯一；架构名可以是显示的，也可以由DBMS提供默认名。</p><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><ol><li><p><strong>聚集索引</strong>（<mark>CLUSTERED INDEX</mark>）：</p><ul><li>聚集索引确定了数据表中数据行的物理存储顺序。每个数据表只能有一个聚集索引。</li><li>聚集索引的主要作用是将数据行存储在特定的物理顺序中，这样可以加速按聚集索引键进行范围查询或排序操作。</li><li>由于每个数据表只能有一个聚集索引，因此选择适当的字段作为聚集索引非常重要，它通常是主键。</li></ul></li><li><p><strong>非聚集索引</strong>（<mark>noclustered是非聚集索引，默认为非聚集</mark>）：</p><ul><li><mark>非聚集索引是附加到数据表上的索引，它不会改变数据行的物理存储顺序（数据行的物理排序独立于索引排序）</mark>。<mark>每个数据表可以有多个非聚集索引</mark>。</li><li>非聚集索引的主要作用是加速特定字段的数据检索操作。它们包含索引键和指向实际数据行的指针或引用。</li><li>与聚集索引不同，非聚集索引的选择不受限制，可以根据查询需求创建多个非聚集索引以提高查询性能。</li></ul></li><li><p><strong>唯一索引</strong>（<mark>Unique Index</mark>）：</p><ul><li>是一种可以应用于聚集索引或非聚集索引的特殊索引类型。</li><li>其作用是<mark>确保索引键的值在整个表中是唯一的</mark>。<mark>唯一索引可以用于避免重复数据的插入，以及加速唯一值的检索</mark>。<mark>它可以用于任何字段，不仅限于主键</mark>。</li></ul></li></ol><p><strong>关系:</strong></p><ul><li><p><mark>聚集索引和非聚集索引用于不同的查询优化需求，而唯一索引用于确保索引键的唯一性</mark></p></li><li><p><mark>唯一索引和聚集索引、非聚集索引之间没有限定关系</mark>。</p></li></ul><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><ul><li><p><mark>视图不存储实际的数据，而是基于一个或多个实际表的查询结果创建的虚拟表。这意味着它们只包含从基础表中检索的数据，而不保存实际数据副本</mark>。</p></li><li><p><strong>查询结果</strong>：视图是一个查询的结果集，可以包括一个或多个表中的列。它们允许用户以更简单的方式查看、过滤和操作数据，而不必编写复杂的SQL查询。</p></li><li><p><strong>数据安全性</strong>：通过视图，数据库管理员可以限制用户访问数据的方式。可以隐藏某些列或行，以确保只有授权用户可以查看特定数据。</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库三级【安全管理】</title>
      <link href="/post/e570cd86.html"/>
      <url>/post/e570cd86.html</url>
      
        <content type="html"><![CDATA[<h2 id="数据库角色"><a href="#数据库角色" class="headerlink" title="数据库角色"></a>数据库角色</h2><ul><li>数据库角色是一组权限的逻辑集合，可以<mark>用于分组和管理数据库用户</mark>。</li><li><mark>角色可以包含一个或多个数据库用户，这些用户被视为该角色的成员。成员将继承角色所具有的权限</mark>。</li><li>角色使数据库管理员能够更轻松地管理和控制用户的权限，而无需为每个用户单独配置权限。<br> 示例：您可以创建一个 “数据分析师” 角色，并将多个数据分析用户添加为该角色的成员。然后，您可以授予 “数据分析师” 角色特定的查询权限，以便所有成员都能执行这些查询。</li></ul><p><strong>SQL Server 数据库中的一个内置数据库角色</strong></p><ul><li><p><strong><code>db_datareader</code></strong> </p><ul><li>这个角色具有一组默认<mark>查询权限</mark>，允许成员阅读（即执行 <code>SELECT</code> 操作）数据库中的所有表和视图。</li><li>这意味着在数据库中的每个表和视图上，具有 <code>db_datareader</code> 角色成员身份的用户都可以执行 <code>SELECT</code> 查询，从而查看表中的数据。</li></ul></li><li><p><strong><code>db_datawriter</code></strong></p><ul><li>db_datawriter是固定数据库角色之一，具有<mark>插入、删除和更改</mark>数据库中所有用户数据的权限。</li></ul></li></ul><h2 id="数据库用户类型"><a href="#数据库用户类型" class="headerlink" title="数据库用户类型"></a>数据库用户类型</h2><ol><li><strong>系统管理员用户：</strong> 这是数据库系统的最高权限用户，通常具有完全的系统级别权限，包括创建、删除、管理数据库和用户帐户的权限。在 SQL Server 中，这通常是 “sa” 用户。</li><li><strong>数据库管理员用户：</strong> 拥有特定数据库的管理权限，包括创建、删除、备份、还原、修改数据库结构等。这些用户通常是负责数据库管理的人员。</li><li><strong>应用程序用户：</strong> 这些用户代表应用程序或服务访问数据库。它们通常用于执行应用程序所需的数据库操作。应用程序用户的权限通常被限制在应用程序需要的最低权限级别上。</li><li><strong>数据分析用户：</strong> 用于执行复杂查询、报表生成和数据分析的用户。这些用户可能需要高级查询和分析权限。</li><li><strong>报表用户：</strong> 这些用户通常专注于访问数据库以生成报表和查询数据。他们的权限通常限制在只读或只查询操作上。</li><li><strong>临时用户：</strong> 这些用户是为了特定任务或会话而创建的，一旦任务完成或会话结束，这些用户通常会被删除。临时用户通常用于特殊的维护或数据加载任务。</li><li><strong>匿名用户（如 “guest” 用户）：</strong> 这些用户用于提供匿名访问数据库的权限，通常在公共数据库中使用。匿名用户的权限通常受到限制，以确保安全性。</li><li><strong>访客用户：</strong> 在某些数据库管理系统中，”guest” 用户可能具有特殊的访问权限，通常在一些特定情况下使用，以提供有限的访问权限。</li></ol><p><strong>sa：</strong></p><ol><li>在 SQL Server 2008 中，”sa” 是一个特殊的系统管理员（System Administrator）账户，通常称为 “系统管理员”（System Administrator）或 “sa”（System Administrator）登录。</li><li>“sa” 账户拥有数据库系统中的最高权限，允许执行各种管理任务，包括创建、删除、备份、还原数据库，以及配置和管理数据库服务器的各种设置。</li></ol><p><mark>注意：sa是SQL Server默认的系统管理员，但并不是Windows用户</mark></p><p><strong>guest：</strong></p><ol><li><mark>“guest” 用户是 SQL Server 数据库中的一个特殊数据库用户，通常用于提供匿名访问权限。</mark></li><li>默认情况下，”guest” 用户在数据库中是禁用的，需要由数据库管理员明确启用。</li><li>“guest” 用户可以为数据库中的公共数据提供访问权限，但权限必须小心配置，以确保不会导致潜在的安全风险。</li><li>数据库管理员可以使用 SQL Server Management Studio (SSMS) 或 TSQL 命令来为 “guest” 用户授予权限，以满足特定的需求。</li><li>启用或禁用 “guest” 用户是一个重要的安全措施，以确保数据库的安全性。</li></ol><h2 id="授权与收权"><a href="#授权与收权" class="headerlink" title="授权与收权"></a>授权与收权</h2><p><strong>授权格式:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GRANT &lt;可以授予的权限&gt; ON 表名 TO 用户名</span><br></pre></td></tr></table></figure><p>授权时一个语句中可以授予多个权限，也可以一次授予一个权限。</p><ul><li>授予用户在数据库中具有建表权限</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GRANT CREATE TABLE TO [用户名];</span><br></pre></td></tr></table></figure><p><strong>收权格式:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">REVOKE &lt;权限&gt;                      FROM 授予权限的主体(用户名)</span><br><span class="line"> </span><br><span class="line">REVOKE &lt;权限&gt; ON 被授予权限的对象(表) FROM 授予权限的主体(用户名)</span><br></pre></td></tr></table></figure><p><strong><code>REVOKE CREATE VIEW FROM U1</code> 和 <code>REVOKE CREATE VIEW ON DB1 FROM U1</code> 之间的主要区别在于作用范围：</strong></p><ol><li><p><strong><code>REVOKE CREATE VIEW FROM U1</code>:</strong><br> <strong>这个语句撤销了用户 “U1” 在整个数据库系统中创建视图的权限，而不仅仅是在一个特定的数据库上。</strong><br>如果 “U1” 在多个数据库上具有创建视图的权限，使用这个语句将影响到所有数据库。</p></li><li><p><strong><code>REVOKE CREATE VIEW ON DB1 FROM U1</code>:</strong><br> <strong>这个语句仅仅撤销用户 “U1” 在名为 “DB1” 的具体数据库上创建视图的权限。</strong><br> 如果 “U1” 具有在多个数据库中创建视图的权限，那么使用这个语句只会影响到 “DB1” 数据库。</p></li></ol><h2 id="Oracle安全管理"><a href="#Oracle安全管理" class="headerlink" title="Oracle安全管理"></a>Oracle安全管理</h2><ul><li><p><mark>Oracle的安全控制机制可分为数据库级的安全控制、表级、行级和列级的安全控制</mark>。</p></li><li><p><mark>数据库级的安全性通过用户身份认证</mark>和<mark>授予用户相应系统权限</mark>来保证，而<mark>表级、行级、列级的安全性是通过授予或回收对象特权保证的</mark>。</p></li><li><p><mark>Oracle数据库中的用户按其操作权限大小可分DBA用户和普通用户</mark>。</p></li></ul><h2 id="身份验证"><a href="#身份验证" class="headerlink" title="身份验证"></a>身份验证</h2><ul><li>SQL Server 2008的身份验证模式有”<mark>Windows身份验证模式</mark>“和”<mark>混合身份验证模式</mark>“两种。</li><li><strong>使用Windows身份验证模式时，用户必须首先登录到Windows操作系统中，然后再登录到SQL Server。混合身份验证模式是指允许Windows授权用户和SQL授权用户登录到SQL Server。</strong></li><li>混合身份验证模式是指SQL Server允许Windows授权用户和SQL授权用户登录到SQL Server数据库服务器。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库三级【数据库后台编程技术】</title>
      <link href="/post/6699cf8.html"/>
      <url>/post/6699cf8.html</url>
      
        <content type="html"><![CDATA[<h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><p> 使用<mark>FOR</mark>或者<mark>AFTER</mark>选项定义的触发器为<mark>后触发型触发器</mark>，即<strong>只有在引发触发器执行的语句中的操作都已成功执行，并且所有的约束检查也成功完成后，才执行该触发器</strong>。</p><p>使用<mark>INSTEAD OF</mark>选项定义的触发器为<mark>前触发型触发器</mark>，在这种模式的触发器中，<strong>指定执行触发器而不是执行引发触发器执行的SQL语句，从而替代触发的操作</strong></p><p><strong>触发器的作用：</strong></p><ul><li><mark>触发器通常用于保证业务规则和数据完整性。</mark></li></ul><p>在一个表上可以建立多个名称不同、类型各异的触发器，每个触发器可由所有三个操作来引发。<strong>对于前触发器，在一个表上针对同一个数据操作只能定义一个前触发器</strong>；<strong>对于后触发器，可以在同一种操作上建立多个触发器。</strong></p><p>  触发器是在对表中数据进行<mark>UPDATE（更新操作）</mark>、<mark>INSERT（插入操作）</mark>、<mark>DELETE（删除）</mark>操作时自动触发的。</p><p> 如果不同表中的列存在取值约束关系，则只能用触发器实现，不能用CHECK约束实现（CHECK约束只能实现一个表中列之间的取值约束）。</p><h2 id="游标数据"><a href="#游标数据" class="headerlink" title="游标数据"></a>游标数据</h2><p>在对游标数据进行提取的过程中，可以使用<mark>@@FETCH_STATUS全局变量</mark>判断数据提取的状态。由于@@FETCH_STATUS对于在一个连接上的所有游标是全局性的，不管是对哪个游标，<strong>只要执行一次FETCH语句，系统都会对@@FETCH_STATUS赋一次值，以表明该FETCH语句的执行情况</strong>。</p><p><mark>NEXT</mark>： <strong>关键字的作用是<mark>返回紧跟在当前行之后的数据行</mark>，并且当前行递增为结果行（下移一行）；。</strong></p><p><strong><mark>PRIOR</mark>： 关键字返回紧临当前行前面的数据行，并且当前行递减为结果行。</strong></p><p><strong>注意：</strong></p><ul><li>声明游标未指定<em>scroll</em>，则<em>next</em>是唯一支持的提取选项。</li></ul><h2 id="储存过程"><a href="#储存过程" class="headerlink" title="储存过程"></a>储存过程</h2><p> <strong>存储过程，实际上是存储在数据库中供所有用户程序调用的子程序。</strong></p><p><strong>存储过程的好处:</strong> </p><ul><li>允许模块化程序设计</li><li>改善性能</li><li>减少网络流量</li><li>增强应用程序的安全性</li></ul><p><mark>存储过程可以接受多个输入参数，也可以接受多个输出参数。</mark></p><p><strong>在调用存储过程时，只需要声明参数的类型，不能指明参数为输出参数。只有再执行时才能指明参数为输出参数（同时有输入参数和输出参数）。</strong></p><p><strong>在创建存储过程中可以声明一个或多个参数。</strong><mark>除非定义了参数的默认值或者将参数设置为等于另一个参数，否则用户在调用存储过程时必须为每个声明的参数提供值</mark>。一个存储过程最多可以有2100个参数。</p><p><mark>注意</mark>：</p><ul><li><p><mark>如果存储过程没有为参数指定默认值，而在执行存储过程时又使用了DEFAULT关键字，则会出现错误。</mark></p></li><li><p><strong>如果是输出参数需要在变量名后标记”output”，输入参数不需要标记。</strong></p><p>  删除存储过程的语句为：</p>  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">DROP &#123; PROC | PROCEDURE &#125; &#123; [schema_name. ] procedure&#125;[,…n]</span><br></pre></td></tr></table></figure></li></ul><h2 id="收缩数据库"><a href="#收缩数据库" class="headerlink" title="收缩数据库"></a>收缩数据库</h2><p><strong>收缩数据库就是释放数据库中未使用的空间，并将释放的空间交还给操作系统。数据文件和日志文件的空间都可以收缩。</strong></p><h2 id="数据库授权"><a href="#数据库授权" class="headerlink" title="数据库授权"></a>数据库授权</h2><p>对象级授权命令，视图权限中没有create权限。</p><p>语句级授权命令，视图权限中有create权限。</p><p>授予语句级别权限的GRANT语句的简化语法格式如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">GRANT &#123;ALL | <span class="tag">&lt;<span class="name">statement_permission</span>&gt;</span>[,…n]&#125; TO <span class="tag">&lt;<span class="name">database_principal</span>&gt;</span>[,…n]</span><br></pre></td></tr></table></figure><p><strong>角色分为服务器级角色和数据库级角色。</strong></p><p><mark>db_datawriter</mark>: 角色属于数据库级角色，具有<mark>插入</mark>、<mark>删除<mark>和</mark>更改</mark>数据库中所有用户数据的权限。</p><h2 id="标量函数"><a href="#标量函数" class="headerlink" title="标量函数"></a>标量函数</h2><p>标量函数可以返回除timestamp之外的所有数据类型。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>常用工具类库</title>
      <link href="/post/d47651.html"/>
      <url>/post/d47651.html</url>
      
        <content type="html"><![CDATA[<h1 id="java：常用工具类库"><a href="#java：常用工具类库" class="headerlink" title="java：常用工具类库"></a><a href="https://www.cnblogs.com/zhangjiale/p/17393079.html">java：常用工具类库</a></h1><p>为了减少造轮子的时间，简单总结了一下各个工具类库</p><h3 id="1、Apache-Common"><a href="#1、Apache-Common" class="headerlink" title="1、Apache Common"></a>1、<a href="https://link.juejin.cn/?target=https://www.cnblogs.com/zhuchaoli/p/10317303.html">Apache Common</a></h3><p>Apache Commons是对JDK的拓展，包含了很多开源的工具，用于解决经常会遇到的问题，减少重复工作。</p><p>在Java中，工具类定义了一组公共方法，这篇文章将介绍Java中使用最频繁及最通用的Java工具类。以下工具类、方法按使用流行度排名，参考数据来源于Github上随机选取的5万个开源项目源码。</p><h4 id="1-1-org-apache-commons-io-IOUtils"><a href="#1-1-org-apache-commons-io-IOUtils" class="headerlink" title="1.1 org.apache.commons.io.IOUtils"></a>1.1 org.apache.commons.io.IOUtils</h4><p>closeQuietly：关闭一个IO流、socket、或者selector且不抛出异常，通常放在finally块</p><p>toString：转换IO流、 Uri、 byte[]为String</p><p>copy：IO流数据复制，从输入流写到输出流中，最大支持2GB</p><p>toByteArray：从输入流、URI获取byte[]</p><p>write：把字节. 字符等写入输出流</p><p>toInputStream：把字符转换为输入流</p><p>readLines：从输入流中读取多行数据，返回List<String></p><p>copyLarge：同copy，支持2GB以上数据的复制</p><p>lineIterator：从输入流返回一个迭代器，根据参数要求读取的数据量，全部读取，如果数据不够，则失败</p><h4 id="1-2-org-apache-commons-io-FileUtils"><a href="#1-2-org-apache-commons-io-FileUtils" class="headerlink" title="1.2 org.apache.commons.io.FileUtils"></a>1.2 org.apache.commons.io.FileUtils</h4><p>deleteDirectory：删除文件夹</p><p>readFileToString：以字符形式读取文件内容</p><p>deleteQueitly：删除文件或文件夹且不会抛出异常</p><p>copyFile：复制文件</p><p>writeStringToFile：把字符写到目标文件，如果文件不存在，则创建</p><p>forceMkdir：强制创建文件夹，如果该文件夹父级目录不存在，则创建父级</p><p>write：把字符写到指定文件中</p><p>listFiles：列举某个目录下的文件(根据过滤器)</p><p>copyDirectory：复制文件夹</p><p>forceDelete：强制删除文件</p><h4 id="1-3-org-apache-commons-lang-StringUtils"><a href="#1-3-org-apache-commons-lang-StringUtils" class="headerlink" title="1.3 org.apache.commons.lang.StringUtils"></a>1.3 org.apache.commons.lang.StringUtils</h4><p>isBlank：字符串是否为空 (trim后判断)</p><p>isEmpty：字符串是否为空 (不trim并判断)</p><p>equals：字符串是否相等</p><p>join：合并数组为单一字符串，可传分隔符</p><p>split：分割字符串</p><p>EMPTY：返回空字符串</p><p>trimToNull：trim后为空字符串则转换为null</p><p>replace：替换字符串</p><h4 id="1-4-org-apache-http-util-EntityUtils"><a href="#1-4-org-apache-http-util-EntityUtils" class="headerlink" title="1.4 org.apache.http.util.EntityUtils"></a>1.4 org.apache.http.util.EntityUtils</h4><p>toString：把Entity转换为字符串</p><p>consume：确保Entity中的内容全部被消费。可以看到源码里又一次消费了Entity的内容，假如用户没有消费，那调用Entity时候将会把它消费掉</p><p>toByteArray：把Entity转换为字节流</p><p>consumeQuietly：和consume一样，但不抛异常</p><p>getContentCharset：获取内容的编码</p><h4 id="1-5-org-apache-commons-lang3-StringUtils"><a href="#1-5-org-apache-commons-lang3-StringUtils" class="headerlink" title="1.5 org.apache.commons.lang3.StringUtils"></a>1.5 org.apache.commons.lang3.StringUtils</h4><p>isBlank：字符串是否为空 (trim后判断)</p><p>isEmpty：字符串是否为空 (不trim并判断)</p><p>equals：字符串是否相等</p><p>join：合并数组为单一字符串，可传分隔符</p><p>split：分割字符串</p><p>EMPTY：返回空字符串</p><p>replace：替换字符串</p><p>capitalize：首字符大写</p><h4 id="1-6-org-apache-commons-io-FilenameUtils"><a href="#1-6-org-apache-commons-io-FilenameUtils" class="headerlink" title="1.6 org.apache.commons.io.FilenameUtils"></a>1.6 org.apache.commons.io.FilenameUtils</h4><p>getExtension：返回文件后缀名</p><p>getBaseName：返回文件名，不包含后缀名</p><p>getName：返回文件全名</p><p>concat：按命令行风格组合文件路径(详见方法注释)</p><p>removeExtension：删除后缀名</p><p>normalize：使路径正常化</p><p>wildcardMatch：匹配通配符</p><p>seperatorToUnix：路径分隔符改成unix系统格式的，即&#x2F;</p><p>getFullPath：获取文件路径，不包括文件名</p><p>isExtension：检查文件后缀名是不是传入参数(List<String>)中的一个</p><h4 id="1-7-org-springframework-util-StringUtils"><a href="#1-7-org-springframework-util-StringUtils" class="headerlink" title="1.7 org.springframework.util.StringUtils"></a>1.7 org.springframework.util.StringUtils</h4><p>hasText：检查字符串中是否包含文本</p><p>hasLength：检测字符串是否长度大于0</p><p>isEmpty：检测字符串是否为空（若传入为对象，则判断对象是否为null）</p><p>commaDelimitedStringToArray：逗号分隔的String转换为数组</p><p>collectionToDelimitedString：把集合转为CSV格式字符串</p><p>replace 替换字符串</p><p>delimitedListToStringArray：相当于split</p><p>uncapitalize：首字母小写</p><p>collectionToDelimitedCommaString：把集合转为CSV格式字符串</p><p>tokenizeToStringArray：和split基本一样，但能自动去掉空白的单词</p><h4 id="1-8-org-apache-commons-lang-ArrayUtils"><a href="#1-8-org-apache-commons-lang-ArrayUtils" class="headerlink" title="1.8 org.apache.commons.lang.ArrayUtils"></a>1.8 org.apache.commons.lang.ArrayUtils</h4><p>contains：是否包含某字符串</p><p>addAll：添加整个数组</p><p>clone：克隆一个数组</p><p>isEmpty：是否空数组</p><p>add：向数组添加元素</p><p>subarray：截取数组</p><p>indexOf：查找某个元素的下标</p><p>isEquals：比较数组是否相等</p><p>toObject：基础类型数据数组转换为对应的Object数组</p><h4 id="1-9-org-apache-commons-lang-StringEscapeUtils"><a href="#1-9-org-apache-commons-lang-StringEscapeUtils" class="headerlink" title="1.9 org.apache.commons.lang.StringEscapeUtils"></a>1.9 org.apache.commons.lang.StringEscapeUtils</h4><p>参考十五：org.apache.commons.lang3.StringEscapeUtils</p><h4 id="1-10-org-apache-http-client-utils-URLEncodedUtils"><a href="#1-10-org-apache-http-client-utils-URLEncodedUtils" class="headerlink" title="1.10 org.apache.http.client.utils.URLEncodedUtils"></a>1.10 org.apache.http.client.utils.URLEncodedUtils</h4><p>format：格式化参数，返回一个HTTP POST或者HTTP PUT可用application&#x2F;x-www-form-urlencoded字符串</p><p>parse：把String或者URI等转换为List<NameValuePair></p><h4 id="1-11-org-apache-commons-codec-digest-DigestUtils"><a href="#1-11-org-apache-commons-codec-digest-DigestUtils" class="headerlink" title="1.11 org.apache.commons.codec.digest.DigestUtils"></a>1.11 org.apache.commons.codec.digest.DigestUtils</h4><p>md5Hex：MD5加密，返回32位字符串</p><p>sha1Hex：SHA-1加密</p><p>sha256Hex：SHA-256加密</p><p>sha512Hex：SHA-512加密</p><p>md5：MD5加密，返回16位字符串</p><h4 id="1-12-org-apache-commons-collections-CollectionUtils"><a href="#1-12-org-apache-commons-collections-CollectionUtils" class="headerlink" title="1.12 org.apache.commons.collections.CollectionUtils"></a>1.12 org.apache.commons.collections.CollectionUtils</h4><p>isEmpty：是否为空</p><p>select：根据条件筛选集合元素</p><p>transform：根据指定方法处理集合元素，类似List的map()</p><p>filter：过滤元素，雷瑟List的filter()</p><p>find：基本和select一样</p><p>collect：和transform 差不多一样，但是返回新数组</p><p>forAllDo：调用每个元素的指定方法</p><p>isEqualCollection：判断两个集合是否一致</p><h4 id="1-13-org-apache-commons-lang3-ArrayUtils"><a href="#1-13-org-apache-commons-lang3-ArrayUtils" class="headerlink" title="1.13 org.apache.commons.lang3.ArrayUtils"></a>1.13 org.apache.commons.lang3.ArrayUtils</h4><p>contains：是否包含某个字符串</p><p>addAll：添加整个数组</p><p>clone：克隆一个数组</p><p>isEmpty：是否空数组</p><p>add：向数组添加元素</p><p>subarray：截取数组</p><p>indexOf：查找某个元素的下标</p><p>isEquals：比较数组是否相等</p><p>toObject：基础类型数据数组转换为对应的Object数组</p><h4 id="1-14-org-apache-commons-beanutils-PropertyUtils"><a href="#1-14-org-apache-commons-beanutils-PropertyUtils" class="headerlink" title="1.14 org.apache.commons.beanutils.PropertyUtils"></a>1.14 org.apache.commons.beanutils.PropertyUtils</h4><p>getProperty：获取对象属性值</p><p>setProperty：设置对象属性值</p><p>getPropertyDiscriptor：获取属性描述器</p><p>isReadable：检查属性是否可访问</p><p>copyProperties：复制属性值，从一个对象到另一个对象</p><p>getPropertyDiscriptors：获取所有属性描述器</p><p>isWriteable：检查属性是否可写</p><p>getPropertyType：获取对象属性类型</p><h4 id="1-15-org-apache-commons-lang3-StringEscapeUtils"><a href="#1-15-org-apache-commons-lang3-StringEscapeUtils" class="headerlink" title="1.15 org.apache.commons.lang3.StringEscapeUtils"></a>1.15 org.apache.commons.lang3.StringEscapeUtils</h4><p>unescapeHtml4：转义html</p><p>escapeHtml4：反转义html</p><p>escapeXml：转义xml</p><p>unescapeXml：反转义xml</p><p>escapeJava：转义unicode编码</p><p>escapeEcmaScript：转义EcmaScript字符</p><p>unescapeJava：反转义unicode编码</p><p>escapeJson：转义json字符</p><p>escapeXml10：转义Xml10</p><p>这个现在已经废弃了，建议使用commons-text包里面的方法。</p><h4 id="1-16-org-apache-commons-beanutils-BeanUtils"><a href="#1-16-org-apache-commons-beanutils-BeanUtils" class="headerlink" title="1.16 org.apache.commons.beanutils.BeanUtils"></a>1.16 org.apache.commons.beanutils.BeanUtils</h4><p>copyPeoperties：复制属性值，从一个对象到另一个对象</p><p>getProperty：获取对象属性值</p><p>setProperty：设置对象属性值</p><p>populate：根据Map给属性复制</p><p>copyPeoperty：复制单个值，从一个对象到另一个对象</p><p>cloneBean：克隆bean实例</p><p>原文：<a href="https://blog.csdn.net/youanyyou/article/details/79602592">https://blog.csdn.net/youanyyou/article/details/79602592</a></p><h3 id="2、Google-Guava"><a href="#2、Google-Guava" class="headerlink" title="2、Google Guava "></a>2、<a href="https://link.juejin.cn/?target=https://baijiahao.baidu.com/s?id=1663365874393123702&wfr=spider&for=pc">Google Guava </a></h3><p>Guava工程包含了若干被Google的 Java项目广泛依赖 的核心库，例如：集合 [collections] 、缓存 [caching] 、原生类型支持 [primitives support] 、并发库 [concurrency libraries] 、通用注解 [common annotations] 、字符串处理 [string processing] 、I&#x2F;O 等等。 所有这些工具每天都在被Google的工程师应用在产品服务中。在很多我们使用的框架中几乎每个框架都会用到Guava，Guava包含的工具类丰富，是每个Java程序员都必须要熟练掌握的技能。查阅Javadoc并不一定是学习这些库最有效的方式。在此，我们希望通过此文档为Guava中最流行和最强大的功能，提供更具可读性和解释性的说明。</p><h3 id="3、joda-time"><a href="#3、joda-time" class="headerlink" title="3、joda time "></a>3、<a href="https://link.juejin.cn/?target=https://www.ibm.com/developerworks/cn/java/j-jodatime.html">joda time </a></h3><p>Joda Time，一个面向 Java™ 平台的易于使用的开源时间&#x2F;日期库。正如您在本文中了解的那样，JodaTime轻松化解了处理日期和时间的痛苦和繁琐。</p><p>Joda-Time 令时间和日期值变得易于管理、操作和理解。事实上，易于使用是 Joda 的主要设计目标。其他目标包括可扩展性、完整的特性集以及对多种日历系统的支持。</p><h3 id="4、json"><a href="#4、json" class="headerlink" title="4、json"></a>4、json</h3><p>Jackson Spring 默认的Json 序列化工具。</p><p> Gson Google 出品，功能齐全。 </p><p> FastJson 阿里出品，算法良好，性能最优。</p><h3 id="5、EasyExcel"><a href="#5、EasyExcel" class="headerlink" title="5、EasyExcel"></a>5、<a href="https://link.juejin.cn/?target=https://www.cnblogs.com/liuyi13535496566/p/12634898.html">EasyExcel</a></h3><p>EasyExcel是阿里巴巴开源的一个excel处理框架，以使用简单，节省内存著称，EasyExcel能大大减少占用内存的主要原因是在解析Excel时没有将文件数据一次性全部加载到内存中，而是从磁盘上一行行读取数据，逐个解析。</p><p>EasyExcel采用一行一行的解析模式，并将一行的解析结果以观察者的模式通知处理（AnalysisEventListener）。</p><h3 id="6、JOOR"><a href="#6、JOOR" class="headerlink" title="6、JOOR "></a>6、<a href="https://link.juejin.cn/?target=https://www.jianshu.com/p/5a955285dfc5">JOOR </a></h3><p>反射工具库：<a href="https://link.juejin.cn/?target=https://github.com/jOOQ/jOOR">github.com&#x2F;jOOQ&#x2F;jOOR</a></p><h3 id="7、MyBaits-Plus"><a href="#7、MyBaits-Plus" class="headerlink" title="7、MyBaits-Plus "></a>7、<a href="https://link.juejin.cn/?target=https://www.cnblogs.com/langzhu-/p/9723616.html">MyBaits-Plus </a></h3><p><a href="https://link.juejin.cn/?target=https://link.zhihu.com/?target=https://github.com/baomidou/mybatis-plus">MyBatis-Plus</a>（简称 MP）是一个 <a href="https://link.juejin.cn/?target=https://link.zhihu.com/?target=http://www.mybatis.org/mybatis-3/">MyBatis</a> 的增强工具，在 MyBatis 的基础上<strong>只做增强不做改变</strong>，为简化开发、提高效率而生。</p><h3 id="8、Lombok"><a href="#8、Lombok" class="headerlink" title="8、Lombok: "></a>8、<a href="https://link.juejin.cn/?target=https://www.jianshu.com/p/2543c71a8e45">Lombok: </a></h3><p>Lombok项目是一个Java库，它会自动插入编辑器和构建工具中，Lombok提供了一组有用的注释，用来消除Java类中的大量样板代码。仅五个字符(@Data)就可以替换数百行代码从而产生干净，简洁且易于维护的Java类。</p><h3 id="9、Huttol：一个小而全的java工具类库"><a href="#9、Huttol：一个小而全的java工具类库" class="headerlink" title="9、Huttol：一个小而全的java工具类库"></a>9、<a href="https://link.juejin.cn/?target=https://hutool.cn/docs/%23/">Huttol</a>：一个小而全的java工具类库</h3><p>原文链接：<a href="https://www.cnblogs.com/zhangjiale/p/17393079.html">https://www.cnblogs.com/zhangjiale/p/17393079.html</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>HTML标签</title>
      <link href="/post/2b0384e8.html"/>
      <url>/post/2b0384e8.html</url>
      
        <content type="html"><![CDATA[<h2 id="基础标签"><a href="#基础标签" class="headerlink" title="基础标签"></a>基础标签</h2><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>&lt;h1&gt;  ~  &lt;h6&gt;</td><td>定义标题，h1最大，h6最小</td></tr><tr><td>&lt;font&gt;</td><td>定义文本的字体、字体尺寸、字体颜色</td></tr><tr><td>&lt;b&gt;</td><td>定义粗体文本</td></tr><tr><td>&lt;i&gt;</td><td>定义斜体文本</td></tr><tr><td>&lt;u&gt;</td><td>定义文本下划线</td></tr><tr><td>&lt;center&gt;</td><td>定义文本居中</td></tr><tr><td>&lt;p&gt;</td><td>定义段落</td></tr><tr><td>&lt;br&gt;</td><td>定义折行</td></tr><tr><td>&lt;hr&gt;</td><td>定义水平线</td></tr></tbody></table><table><thead><tr><th>HTML 原代码</th><th>显示结果</th><th>描述</th></tr></thead><tbody><tr><td>&amp;lt;</td><td>&lt;</td><td>小于号或显示标记</td></tr><tr><td>&amp;gt ;</td><td>&gt;</td><td>大于号或显示标记</td></tr><tr><td>&amp;amp;</td><td>&amp;</td><td>可用于显示其它特殊字符</td></tr><tr><td>&amp;quot;</td><td>“</td><td>引号</td></tr><tr><td>&amp;reg;</td><td>®</td><td>已注册</td></tr><tr><td>&amp;copy;</td><td>©</td><td>版权</td></tr><tr><td>&amp;trade;</td><td>™</td><td>商标</td></tr><tr><td>&amp;nbsp;</td><td></td><td>不断行的空白</td></tr></tbody></table><h2 id="图片、音频、视频标签"><a href="#图片、音频、视频标签" class="headerlink" title="图片、音频、视频标签"></a>图片、音频、视频标签</h2><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>&lt;img&gt;</td><td>定义图片</td></tr><tr><td>&lt;audio&gt;</td><td>定义音频</td></tr><tr><td>&lt;video&gt;</td><td>定义视频</td></tr></tbody></table><ul><li><p>img：定义图片</p><ul><li>src：规定显示图像的 URL</li><li>height：定义图像的高度</li><li>width：定义图像的宽度</li></ul></li><li><p>audio：定义音频。支持的音频格式：MP3、WAV、OGG </p><ul><li>src：规定音频的 URL</li><li>controls：显示播放控件</li></ul></li><li><p>video：定义视频。支持的音频格式：MP4, WebM、OGG</p><ul><li>src：规定视频的 URL</li><li>controls：显示播放控件</li></ul></li></ul><h3 id="超链接标签"><a href="#超链接标签" class="headerlink" title="超链接标签"></a>超链接标签</h3><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>&lt;a&gt;</td><td>定义超链接，用于链接到另一个资源</td></tr></tbody></table><ul><li>href：指定访问资源的URL</li><li>target：指定打开资源的方式<ul><li>_self:默认值，在当前页面打开<ul><li>_blank：在空白页面打开</li></ul></li></ul></li></ul><h3 id="列表标签"><a href="#列表标签" class="headerlink" title="列表标签"></a>列表标签</h3><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>&lt;ol&gt;</td><td>定义有序列表</td></tr><tr><td>&lt;ul&gt;</td><td>定义无序列表</td></tr><tr><td>&lt;li&gt;</td><td>定义列表项</td></tr></tbody></table><ul><li>type：设置符号的类型</li></ul><h3 id="表格标签"><a href="#表格标签" class="headerlink" title="表格标签"></a>表格标签</h3><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>&lt;table&gt;</td><td>定义表格</td></tr><tr><td>&lt;tr&gt;</td><td>定义行</td></tr><tr><td>&lt;td&gt;</td><td>定义单元格</td></tr><tr><td>&lt;th&gt;</td><td>定义表头单元格</td></tr></tbody></table><ul><li><p>table：设置符号的类型</p><pre><code>  * table：定义表格      * width：宽度      * border：边框      * cellpadding：定义内容和单元格的距离      * cellspacing：定义单元格之间的距离。如果指定为0，则单元格的线会合为一条、      * bgcolor：背景色      * align：对齐方式  * tr：定义行      * bgcolor：背景色      * align：对齐方式  * td：定义单元格      * colspan：合并列      * rowspan：合并行  * th：定义表头单元格  * &lt;caption&gt;：表格标题</code></pre></li></ul><h3 id="布局标签"><a href="#布局标签" class="headerlink" title="布局标签"></a>布局标签</h3><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>&lt;div&gt;</td><td>定义 HTML 文档中的一个区域部分，经常与 CSS 一起使用，用来布局网页</td></tr><tr><td>&lt;span&gt;</td><td>用于组合行内元素。</td></tr></tbody></table><h3 id="表单标签"><a href="#表单标签" class="headerlink" title="表单标签"></a>表单标签</h3><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>&lt;form&gt;</td><td>定义表单</td></tr><tr><td>&lt;input&gt;</td><td>定义表单项，通过type属性控制输入形式</td></tr><tr><td>&lt;label&gt;</td><td>为表单项定义标注</td></tr><tr><td>&lt;select&gt;</td><td>定义下拉列表</td></tr><tr><td>&lt;option&gt;</td><td>定义下拉列表的列表项</td></tr><tr><td>&lt;textarea&gt;</td><td>定义文本域</td></tr></tbody></table><h4 id="type取值"><a href="#type取值" class="headerlink" title="type取值"></a>type取值</h4><table><thead><tr><th>type 取值</th><th>描述</th></tr></thead><tbody><tr><td>text</td><td>默认值。定义单行的输入字段</td></tr><tr><td>password</td><td>定义密码字段</td></tr><tr><td>radio</td><td>定义单选按钮</td></tr><tr><td>checkbox</td><td>定义复选框</td></tr><tr><td>file</td><td>定义文件上传按钮</td></tr><tr><td>hidden</td><td>定义隐藏的输入字段</td></tr><tr><td>submit</td><td>定义提交按钮，提交按钮会把表单数据发送到服务器</td></tr><tr><td>reset</td><td>定义重置按钮，重置按钮会清除表单中的所有数据</td></tr><tr><td>button</td><td>定义可点击按钮</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>状态码</title>
      <link href="/post/850b4b2d.html"/>
      <url>/post/850b4b2d.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、状态码大类"><a href="#一、状态码大类" class="headerlink" title="一、状态码大类"></a>一、状态码大类</h2><table><thead><tr><th>状态码分类</th><th>说明</th></tr></thead><tbody><tr><td>1xx</td><td><strong>响应中</strong>——临时状态码，表示请求已经接受，告诉客户端应该继续请求或者如果它已经完成则忽略它</td></tr><tr><td>2xx</td><td><strong>成功</strong>——表示请求已经被成功接收，处理已完成</td></tr><tr><td>3xx</td><td><strong>重定向</strong>——重定向到其它地方：它让客户端再发起一个请求以完成整个处理。</td></tr><tr><td>4xx</td><td><strong>客户端错误</strong>——处理发生错误，责任在客户端，如：客户端的请求一个不存在的资源，客户端未被授权，禁止访问等</td></tr><tr><td>5xx</td><td><strong>服务器端错误</strong>——处理发生错误，责任在服务端，如：服务端抛出异常，路由出错，HTTP版本不支持等</td></tr></tbody></table><p>状态码大全：<a href="https://cloud.tencent.com/developer/chapter/13553">https://cloud.tencent.com/developer/chapter/13553</a> </p><h2 id="二、常见的响应状态码"><a href="#二、常见的响应状态码" class="headerlink" title="二、常见的响应状态码"></a>二、常见的响应状态码</h2><table><thead><tr><th>状态码</th><th>英文描述</th><th>解释</th></tr></thead><tbody><tr><td>200</td><td><strong><code>OK</code></strong></td><td>客户端请求成功，即<strong>处理成功</strong>，这是我们最想看到的状态码</td></tr><tr><td>302</td><td><strong><code>Found</code></strong></td><td>指示所请求的资源已移动到由<code>Location</code>响应头给定的 URL，浏览器会自动重新访问到这个页面</td></tr><tr><td>304</td><td><strong><code>Not Modified</code></strong></td><td>告诉客户端，你请求的资源至上次取得后，服务端并未更改，你直接用你本地缓存吧。隐式重定向</td></tr><tr><td>400</td><td><strong><code>Bad Request</code></strong></td><td>客户端请求有<strong>语法错误</strong>，不能被服务器所理解</td></tr><tr><td>403</td><td><strong><code>Forbidden</code></strong></td><td>服务器收到请求，但是<strong>拒绝提供服务</strong>，比如：没有权限访问相关资源</td></tr><tr><td>404</td><td><strong><code>Not Found</code></strong></td><td><strong>请求资源不存在</strong>，一般是URL输入有误，或者网站资源被删除了</td></tr><tr><td>428</td><td><strong><code>Precondition Required</code></strong></td><td><strong>服务器要求有条件的请求</strong>，告诉客户端要想访问该资源，必须携带特定的请求头</td></tr><tr><td>429</td><td><strong><code>Too Many Requests</code></strong></td><td><strong>太多请求</strong>，可以限制客户端请求某个资源的数量，配合 Retry-After(多长时间后可以请求)响应头一起使用</td></tr><tr><td>431</td><td><strong><code> Request Header Fields Too Large</code></strong></td><td><strong>请求头太大</strong>，服务器不愿意处理请求，因为它的头部字段太大。请求可以在减少请求头域的大小后重新提交。</td></tr><tr><td>405</td><td><strong><code>Method Not Allowed</code></strong></td><td>请求方式有误，比如应该用GET请求方式的资源，用了POST</td></tr><tr><td>500</td><td><strong><code>Internal Server Error</code></strong></td><td><strong>服务器发生不可预期的错误</strong>。服务器出异常了，赶紧看日志去吧</td></tr><tr><td>503</td><td><strong><code>Service Unavailable</code></strong></td><td><strong>服务器尚未准备好处理请求</strong>，服务器刚刚启动，还未初始化好</td></tr><tr><td>511</td><td><strong><code>Network Authentication Required</code></strong></td><td><strong>客户端需要进行身份验证才能获得网络访问权限</strong></td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> 状态码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Request&amp;Response</title>
      <link href="/post/7917877b.html"/>
      <url>/post/7917877b.html</url>
      
        <content type="html"><![CDATA[<p>今日目标</p><blockquote><ul><li>掌握Request对象的概念与使用</li><li>掌握Response对象的概念与使用</li><li>能够完成用户登录注册案例的实现</li><li>能够完成SqlSessionFactory工具类的抽取</li></ul></blockquote><h2 id="1-、Request和Response的概述"><a href="#1-、Request和Response的概述" class="headerlink" title="1.、Request和Response的概述"></a>1.、Request和Response的概述</h2><p>Request是请求对象，Response是响应对象。这两个对象在我们使用Servlet的时候有看到</p><p>此时，我们就需要思考一个问题request和response这两个参数的作用是什么?</p><ul><li>request : 获取请求数据<ul><li>浏览器会发送HTTP请求到后台服务器[Tomcat]</li><li>HTTP的请求中会包含很多请求数据[请求行+请求头+请求体]</li><li>后台服务器[Tomcat]会对HTTP请求中的数据进行解析并把解析结果存入到一个对象中</li><li>所存入的对象即为request对象，所以我们可以从request对象中获取请求的相关参数</li><li>获取到数据后就可以继续后续的业务，比如获取用户名和密码就可以实现登录操作的相关业务</li></ul></li><li>response : 设置响应数据<ul><li>业务处理完后，后台就需要给前端返回业务处理的结果即响应数据</li><li>把响应数据封装到response对象中</li><li>后台服务器[Tomcat]会解析response对象,按照[响应行+响应头+响应体]格式拼接结果</li><li>浏览器最终解析结果，把内容展示在浏览器给用户浏览</li></ul></li></ul><p>对于上述所讲的内容，我们通过一个案例来初步体验下request和response对象的使用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/demo3&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo3</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//使用request对象 获取请求数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;name&quot;</span>);<span class="comment">//url?name=zhangsan</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用response对象 设置响应数据</span></span><br><span class="line">        response.setHeader(<span class="string">&quot;content-type&quot;</span>,<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        response.getWriter().write(<span class="string">&quot;&lt;h1&gt;&quot;</span>+name+<span class="string">&quot;,欢迎您！&lt;/h1&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Post...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动成功后就可以通过浏览器来访问，并且根据传入参数的不同就可以在页面上展示不同的内容:</p><p><strong>小结</strong></p><p>在这节中，我们主要认识了下request对象和reponse对象:</p><ul><li>request对象是用来封装请求数据的对象</li><li>response对象是用来封装响应数据的对象</li></ul><p>目前我们只知道这两个对象是用来干什么的，那么它们具体是如何实现的，就需要我们继续深入的学习。接下来，就先从Request对象来学习,主要学习下面这些内容:</p><ul><li><p>request继承体系</p></li><li><p>request获取请求参数</p></li><li><p>request请求转发</p></li></ul><h2 id="2、Request对象"><a href="#2、Request对象" class="headerlink" title="2、Request对象"></a>2、Request对象</h2><h3 id="2-1-Request继承体系"><a href="#2-1-Request继承体系" class="headerlink" title="2.1 Request继承体系"></a>2.1 Request继承体系</h3><p>在学习这节内容之前，我们先思考一个问题，前面在介绍Request和Reponse对象的时候，比较细心的同学可能已经发现：</p><ul><li><strong>当我们的Servlet类实现的是Servlet接口的时候，service方法中的参数是ServletRequest和ServletResponse</strong></li><li><strong>当我们的Servlet类继承的是HttpServlet类的时候，doGet和doPost方法中的参数就变成HttpServletRequest和HttpServletReponse</strong></li></ul><p>那么，</p><ul><li>ServletRequest和HttpServletRequest的关系是什么?</li><li>request对象是有谁来创建的?</li><li>request提供了哪些API,这些API从哪里查?</li></ul><p><strong>ServletRequest和HttpServletRequest是继承关系，并且两个都是接口，接口是无法创建对象</strong></p><p>这个时候，我们就需要用到Request继承体系中的<code>RequestFacade</code>:</p><ul><li>该类实现了HttpServletRequest接口，也间接实现了ServletRequest接口。</li><li>Servlet类中的service方法、doGet方法或者是doPost方法最终都是由Web服务器[Tomcat]来调用的，所以Tomcat提供了方法参数接口的具体实现类，并完成了对象的创建</li><li>要想了解RequestFacade中都提供了哪些方法，我们可以直接查看JavaEE的API文档中关于ServletRequest和HttpServletRequest的接口文档，因为RequestFacade实现了其接口就需要重写接口中的方法</li></ul><p>对于上述结论，要想验证，可以编写一个Servlet，在方法中把request对象打印下，就能看到最终的对象是不是RequestFacade,代码如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/demo2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo2</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动服务器，运行访问<code>http://localhost:8080/request-demo/demo2</code>,得到运行结果:</p><p><strong>小结</strong></p><ul><li>Request的继承体系为ServletRequest–&gt;HttpServletRequest–&gt;RequestFacade</li><li>Tomcat需要解析请求数据，封装为request对象,并且创建request对象传递到service方法</li><li>使用request对象，可以查阅JavaEE API文档的HttpServletRequest接口中方法说明</li></ul><h3 id="2-2-Request获取请求数据"><a href="#2-2-Request获取请求数据" class="headerlink" title="2.2 Request获取请求数据"></a>2.2 Request获取请求数据</h3><p>HTTP请求数据总共分为三部分内容，分别是**&#x3D;&#x3D;请求行、请求头、请求体&#x3D;&#x3D;**，对于这三部分内容的数据，分别该如何获取，首先我们先来学习请求行数据如何获取?</p><h4 id="2-2-1-获取请求行数据"><a href="#2-2-1-获取请求行数据" class="headerlink" title="2.2.1 获取请求行数据"></a>2.2.1 获取请求行数据</h4><p><u>请求行包含三块内容，分别是**<code>请求方式</code>、<code>请求资源路径</code>、<code>HTTP协议及版本</code>**</u></p><p>对于这三部分内容，request对象都提供了对应的API方法来获取，具体如下:</p><ul><li>获取请求方式: <code>GET</code></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">String</span> <span class="title function_">getMethod</span>()</span><br></pre></td></tr></table></figure><ul><li>获取虚拟目录(项目访问路径): <code>/request-demo</code></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String getContextPath()</span><br></pre></td></tr></table></figure><ul><li>获取URL(统一资源定位符): <code>http://localhost:8080/request-demo/req1</code></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">StringBuffer getRequestURL()</span><br></pre></td></tr></table></figure><ul><li>获取URI(统一资源标识符): <code>/request-demo/req1</code></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String getRequestURI()</span><br></pre></td></tr></table></figure><ul><li>获取请求参数(GET方式): <code>username=zhangsan&amp;password=123</code></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String getQueryString()</span><br></pre></td></tr></table></figure><p>介绍完上述方法后，咱们通过代码把上述方法都使用下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * request 获取请求数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/req1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestDemo1</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// String getMethod()：获取请求方式： GET</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> req.getMethod();</span><br><span class="line">        System.out.println(method);<span class="comment">//GET</span></span><br><span class="line">        <span class="comment">// String getContextPath()：获取虚拟目录(项目访问路径)：/request-demo</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">contextPath</span> <span class="operator">=</span> req.getContextPath();</span><br><span class="line">        System.out.println(contextPath);</span><br><span class="line">        <span class="comment">// StringBuffer getRequestURL(): 获取URL(统一资源定位符)：http://localhost:8080/request-demo/req1</span></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">url</span> <span class="operator">=</span> req.getRequestURL();</span><br><span class="line">        System.out.println(url.toString());</span><br><span class="line">        <span class="comment">// String getRequestURI()：获取URI(统一资源标识符)： /request-demo/req1</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">uri</span> <span class="operator">=</span> req.getRequestURI();</span><br><span class="line">        System.out.println(uri);</span><br><span class="line">        <span class="comment">// String getQueryString()：获取请求参数（GET方式）： username=zhangsan</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queryString</span> <span class="operator">=</span> req.getQueryString();</span><br><span class="line">        System.out.println(queryString);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-2-获取请求头数据"><a href="#2-2-2-获取请求头数据" class="headerlink" title="2.2.2 获取请求头数据"></a>2.2.2 获取请求头数据</h4><p>根据请求头名称获取对应值的方法为:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String getHeader(String name)</span><br></pre></td></tr></table></figure><p>接下来，在代码中如果想要获取客户端浏览器的版本信息，则可以使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * request 获取请求数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/req1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestDemo1</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//获取请求头: user-agent: 浏览器的版本信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">agent</span> <span class="operator">=</span> req.getHeader(<span class="string">&quot;user-agent&quot;</span>);</span><br><span class="line">System.out.println(agent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-2-3-获取请求体数据-POST请求"><a href="#2-2-3-获取请求体数据-POST请求" class="headerlink" title="2.2.3 获取请求体数据(POST请求)"></a>2.2.3 获取请求体数据(POST请求)</h4><p>浏览器在发送GET请求的时候是没有请求体的，所以需要把请求方式变更为POST</p><p>对于请求体中的数据，Request对象提供了如下两种方式来获取其中的数据，分别是:</p><ul><li>获取字节输入流，如果前端发送的是字节数据，比如传递的是文件数据，则使用该方法</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ServletInputStream getInputStream()</span><br><span class="line">//该方法可以获取字节</span><br></pre></td></tr></table></figure><ul><li>获取字符输入流，如果前端发送的是纯文本数据，则使用该方法</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BufferedReader getReader()</span><br><span class="line">//获取字符</span><br></pre></td></tr></table></figure><p>接下来，大家需要思考，要想获取到请求体的内容该如何实现?</p><blockquote><p>具体实现的步骤如下:</p><p>1.准备一个页面，在页面中添加form表单,用来发送post请求</p><p>2.在Servlet的doPost方法中获取请求体数据</p><p>3.在doPost方法中使用request的getReader()或者getInputStream()来获取</p><p>4.访问测试</p></blockquote><ol><li>在项目的webapp目录下添加一个html页面，名称为：<code>req.html</code></li></ol><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">    action:form表单提交的请求地址</span></span><br><span class="line"><span class="comment">    method:请求方式，指定为post</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/request-demo/req1&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>在Servlet的doPost方法中获取数据</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * request 获取请求数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">@<span class="title class_">WebServlet</span>(<span class="string">&quot;/req1&quot;</span>)</span><br><span class="line">public <span class="keyword">class</span> <span class="title class_">RequestDemo1</span> <span class="keyword">extends</span> <span class="title class_ inherited__">HttpServlet</span> &#123;</span><br><span class="line">    @<span class="title class_">Override</span></span><br><span class="line">    protected <span class="keyword">void</span> <span class="title function_">doGet</span>(<span class="title class_">HttpServletRequest</span> req, <span class="title class_">HttpServletResponse</span> resp) throws <span class="title class_">ServletException</span>, <span class="title class_">IOException</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    @<span class="title class_">Override</span></span><br><span class="line">    protected <span class="keyword">void</span> <span class="title function_">doPost</span>(<span class="title class_">HttpServletRequest</span> req, <span class="title class_">HttpServletResponse</span> resp) throws <span class="title class_">ServletException</span>, <span class="title class_">IOException</span> &#123;</span><br><span class="line">        <span class="comment">//在此处获取请求体中的数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>调用getReader()或者getInputStream()方法，因为目前前端传递的是纯文本数据，所以我们采用getReader()方法来获取</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * request 获取请求数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">@<span class="title class_">WebServlet</span>(<span class="string">&quot;/req1&quot;</span>)</span><br><span class="line">public <span class="keyword">class</span> <span class="title class_">RequestDemo1</span> <span class="keyword">extends</span> <span class="title class_ inherited__">HttpServlet</span> &#123;</span><br><span class="line">    @<span class="title class_">Override</span></span><br><span class="line">    protected <span class="keyword">void</span> <span class="title function_">doGet</span>(<span class="title class_">HttpServletRequest</span> req, <span class="title class_">HttpServletResponse</span> resp) throws <span class="title class_">ServletException</span>, <span class="title class_">IOException</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    @<span class="title class_">Override</span></span><br><span class="line">    protected <span class="keyword">void</span> <span class="title function_">doPost</span>(<span class="title class_">HttpServletRequest</span> req, <span class="title class_">HttpServletResponse</span> resp) throws <span class="title class_">ServletException</span>, <span class="title class_">IOException</span> &#123;</span><br><span class="line">         <span class="comment">//获取post 请求体：请求参数</span></span><br><span class="line">        <span class="comment">//1. 获取字符输入流</span></span><br><span class="line">        <span class="title class_">BufferedReader</span> br = req.<span class="title function_">getReader</span>();</span><br><span class="line">        <span class="comment">//2. 读取数据</span></span><br><span class="line">        <span class="title class_">String</span> line = br.<span class="title function_">readLine</span>();</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(line);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><p>BufferedReader流是通过request对象来获取的，当请求完成后request对象就会被销毁，request对象被销毁后，BufferedReader流就会自动关闭，所以此处就不需要手动关闭流了。</p><ol start="4"><li>启动服务器，通过浏览器访问<code>http://localhost:8080/request-demo/req.html</code></li></ol><p>点击<code>提交</code>按钮后，就可以在控制台看到前端所发送的请求数据</p><p><strong>小结:</strong></p><p>HTTP请求数据中包含了<code>请求行</code>、<code>请求头</code>和<code>请求体</code>，针对这三部分内容，Request对象都提供了对应的API方法来获取对应的值:</p><ul><li>请求行<ul><li>getMethod()获取请求方式</li><li>getContextPath()获取项目访问路径</li><li>getRequestURL()获取请求URL</li><li>getRequestURI()获取请求URI</li><li>getQueryString()获取GET请求方式的请求参数</li></ul></li><li>请求头<ul><li>getHeader(String name)根据请求头名称获取其对应的值</li></ul></li><li>请求体<ul><li>注意: &#x3D;&#x3D;浏览器发送的POST请求才有请求体&#x3D;&#x3D;</li><li>如果是纯文本数据:getReader()</li><li>如果是字节数据如文件数据:getInputStream()</li></ul></li></ul><h4 id="2-2-4-获取请求参数的通用方式"><a href="#2-2-4-获取请求参数的通用方式" class="headerlink" title="2.2.4 获取请求参数的通用方式"></a>2.2.4 获取请求参数的通用方式</h4><p>在学习下面内容之前，我们先提出两个问题:</p><ul><li>什么是请求参数?</li><li>请求参数和请求数据的关系是什么?</li></ul><p>1.什么是请求参数?</p><p>为了能更好的回答上述两个问题，我们拿用户登录的例子来说明</p><p>1.1 想要登录网址，需要进入登录页面</p><p>1.2 在登录页面输入用户名和密码</p><p>1.3 将用户名和密码提交到后台</p><p>1.4 后台校验用户名和密码是否正确</p><p>1.5 如果正确，则正常登录，如果不正确，则提示用户名或密码错误</p><p>上述例子中，用户名和密码其实就是我们所说的请求参数。</p><p>2.什么是请求数据?</p><p>请求数据则是包含请求行、请求头和请求体的所有数据</p><p>3.请求参数和请求数据的关系是什么?</p><p>3.1 请求参数是请求数据中的部分内容</p><p>3.2 如果是GET请求，请求参数在请求行中</p><p>3.3 如果是POST请求，请求参数一般在请求体中</p><p>对于请求参数的获取,常用的有以下两种:</p><ul><li>GET方式:</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String getQueryString()</span><br></pre></td></tr></table></figure><ul><li>POST方式:</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BufferedReader getReader();</span><br></pre></td></tr></table></figure><p>有了上述的知识储备，我们来实现一个案例需求:</p><p>（1）发送一个GET请求并携带用户名，后台接收后打印到控制台</p><p>（2）发送一个POST请求并携带用户名，后台接收后打印到控制台</p><p>此处大家需要注意的是GET请求和POST请求接收参数的方式不一样，具体实现的代码如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/req1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestDemo1</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> req.getQueryString();</span><br><span class="line">        System.out.println(result);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> req.getReader();</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> br.readLine();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>对于上述的代码，会存在什么问题呢?</p><p>代码逻辑重复</p></li><li><p>如何解决上述重复代码的问题呢?</p><p>重写相同逻辑的代码，再调用</p></li></ul><p>当然，也可以在doGet中调用doPost,在doPost中完成参数的获取和打印,另外需要注意的是，doGet和doPost方法都必须存在，不能删除任意一个。（语法需要）</p><p>GET请求和POST请求获取请求参数的方式不一样，在获取请求参数这块该如何实现呢?</p><p>要想实现，我们就需要思考:</p><p>GET请求方式和POST请求方式区别主要在于获取请求参数的方式不一样</p><p>是否可以提供一种统一获取请求参数的方式，从而统一doGet和doPost方法内的代码?</p><p>解决方案一:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/req1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestDemo1</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//获取请求方式</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> req.getMethod();</span><br><span class="line">        <span class="comment">//获取请求参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">params</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;GET&quot;</span>.equals(method))&#123;</span><br><span class="line">            params = req.getQueryString();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;POST&quot;</span>.equals(method))&#123;</span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> req.getReader();</span><br><span class="line">            params = reader.readLine();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将请求参数进行打印控制台</span></span><br><span class="line">        System.out.println(params);</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用request的getMethod()来获取请求方式，根据请求方式的不同分别获取请求参数值，这样就可以解决上述问题，但是以后每个Servlet都需要这样写代码，实现起来比较麻烦，这种方案我们不采用</p><p>解决方案二:</p><p>request对象已经将上述获取请求参数的方法进行了封装，并且request提供的方法实现的功能更强大，以后只需要调用request提供的方法即可，在request的方法中都实现了哪些操作?</p><p>(1)根据不同的请求方式获取请求参数</p><p>(2)把获取到的内容进行分割</p><p>(3)把分割后端数据，存入到一个Map集合中:</p><p>&#x3D;&#x3D;<strong>注意</strong>:因为参数的值可能是一个，也可能有多个，所以Map的值的类型为String数组。&#x3D;&#x3D;</p><p>基于上述理论，request对象为我们提供了如下方法:</p><ul><li>获取所有参数Map集合</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Map&lt;String,String[]&gt; getParameterMap()</span><br></pre></td></tr></table></figure><ul><li>根据名称获取参数值（数组）</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String[] getParameterValues(String name)</span><br></pre></td></tr></table></figure><ul><li>根据名称获取参数值(单个值)</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String getParameter(String name)</span><br></pre></td></tr></table></figure><p>接下来，我们通过案例来把上述的三个方法进行实例演示:</p><p>1.修改req.html页面，添加爱好选项，爱好可以同时选多个</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/request-demo/req2&quot;</span> <span class="attr">method</span>=<span class="string">&quot;get&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span> 游泳</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>&gt;</span> 爬山 <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.在Servlet代码中获取页面传递GET请求的参数值</p><ol start="2"><li>1获取GET方式的所有请求参数</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * request 通用方式获取请求参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/req2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestDemo2</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//GET请求逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;get....&quot;</span>);</span><br><span class="line">        <span class="comment">//1. 获取所有参数的Map集合</span></span><br><span class="line">        Map&lt;String, String[]&gt; map = req.getParameterMap();</span><br><span class="line">        <span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">            <span class="comment">// username:zhangsan lisi</span></span><br><span class="line">            System.out.print(key+<span class="string">&quot;:&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取值</span></span><br><span class="line">            String[] values = map.get(key);</span><br><span class="line">            <span class="keyword">for</span> (String value : values) &#123;</span><br><span class="line">                System.out.print(value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 2.2获取GET请求参数中的爱好，结果是数组值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * request 通用方式获取请求参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/req2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestDemo2</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//GET请求逻辑</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        System.out.println(<span class="string">&quot;------------&quot;</span>);</span><br><span class="line">        String[] hobbies = req.getParameterValues(<span class="string">&quot;hobby&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String hobby : hobbies) &#123;</span><br><span class="line">            System.out.println(hobby);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 2.3获取GET请求参数中的用户名和密码，结果是单个值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * request 通用方式获取请求参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/req2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestDemo2</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//GET请求逻辑</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        System.out.println(username);</span><br><span class="line">        System.out.println(password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.在Servlet代码中获取页面传递POST请求的参数值</p><ol start="3"><li><p>1将req.html页面form表单的提交方式改成post</p></li><li><p>2将doGet方法中的业务代码，复制到doPost方法中即可</p></li></ol><p><strong>小结</strong></p><ul><li><p>req.getParameter()方法使用的频率会比较高</p></li><li><p>以后我们再写代码的时候，就只需要按照如下格式来编写:</p></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class RequestDemo1 extends HttpServlet &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">       //采用request提供的获取请求参数的通用方式来获取请求参数</span><br><span class="line">       //编写其他的业务代码...</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">        this.doGet(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-IDEA快速创建Servlet（修改模板）"><a href="#2-3-IDEA快速创建Servlet（修改模板）" class="headerlink" title="2.3 IDEA快速创建Servlet（修改模板）"></a>2.3 IDEA快速创建Servlet（修改模板）</h3><p>使用通用方式获取请求参数后，屏蔽了GET和POST的请求方式代码的不同</p><p>由于格式固定，所以我们可以使用IDEA提供的模板来制作一个Servlet的模板，这样我们后期在创建Servlet的时候就会更高效</p><p><strong>模板配置：</strong></p><p>(1)按照自己的需求，修改Servlet创建的模板内容</p><p><img src="C:\Users\廖永森\Pictures\ppt演示\req1.png" alt="req1"></p><p>（2）使用servlet模板创建Servlet类</p><h3 id="2-4-请求参数中文乱码问题"><a href="#2-4-请求参数中文乱码问题" class="headerlink" title="2.4 请求参数中文乱码问题"></a>2.4 请求参数中文乱码问题</h3><p>问题展示:</p><p>(1)将req.html页面的请求方式修改为get</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form action=&quot;/request-demo/req2&quot; method=&quot;get&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt;</span><br><span class="line">    &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt;</span><br><span class="line">    &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;1&quot;&gt; 游泳</span><br><span class="line">    &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;2&quot;&gt; 爬山 &lt;br&gt;</span><br><span class="line">    &lt;input type=&quot;submit&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>(2)在Servlet方法中获取参数，并打印</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中文乱码问题解决方案</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/req4&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestDemo4</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">       <span class="comment">//1. 获取username</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">       System.out.println(username);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）启动服务器，页面上输入中文参数</p><p>（4）查看控制台打印内容</p><p>（5）把req.html页面的请求方式改成post,再次发送请求和中文参数</p><p>（6）查看控制台打印内容，依然为乱码</p><p>通过上面的案例，会发现，不管是GET还是POST请求，在发送的请求参数中如果有中文，在后台接收的时候，都会出现中文乱码的问题。具体该如何解决呢？</p><h4 id="2-4-1-POST请求解决方案"><a href="#2-4-1-POST请求解决方案" class="headerlink" title="2.4.1 POST请求解决方案"></a>2.4.1 POST请求解决方案</h4><ul><li>分析出现中文乱码的原因：<ul><li>POST的请求参数是通过request的getReader()来获取流中的数据</li><li>&#x3D;&#x3D;TOMCAT在获取流的时候采用的编码是ISO-8859-1&#x3D;&#x3D;</li><li>ISO-8859-1编码是不支持中文的，所以会出现乱码</li></ul></li><li>解决方案：<ul><li>页面设置的编码格式为UTF-8</li><li>&#x3D;&#x3D;把TOMCAT在获取流数据之前的编码设置为UTF-8&#x3D;&#x3D;</li><li>通过request.setCharacterEncoding(“UTF-8”)设置编码,UTF-8也可以写成小写</li></ul></li></ul><p>修改后的代码为:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中文乱码问题解决方案</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/req4&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestDemo4</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//1. 解决乱码: POST getReader()</span></span><br><span class="line">        <span class="comment">//设置字符输入流的编码，设置的字符集要和页面保持一致</span></span><br><span class="line">        request.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">       <span class="comment">//2. 获取username</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">       System.out.println(username);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新发送POST请求，就会在控制台看到正常展示的中文结果。</p><p>至此POST请求中文乱码的问题就已经解决，但是这种方案不适用于GET请求，这个原因是什么呢，咱们下面再分析。</p><h4 id="2-4-2-GET请求解决方案"><a href="#2-4-2-GET请求解决方案" class="headerlink" title="2.4.2 GET请求解决方案"></a>2.4.2 GET请求解决方案</h4><p><img src="C:\Users\廖永森\AppData\Roaming\Typora\typora-user-images\image-20220311201141320.png" alt="image-20220311201141320"></p><p>刚才提到一个问题是<code>POST请求的中文乱码解决方案为什么不适用GET请求？</code></p><ul><li>GET请求获取请求参数的方式是<code>request.getQueryString()</code></li><li>POST请求获取请求参数的方式是<code>request.getReader()</code></li><li>request.setCharacterEncoding(“utf-8”)是设置request处理流的编码</li><li>getQueryString方法并没有通过流的方式获取数据</li></ul><p>所以GET请求不能用设置编码的方式来解决中文乱码问题，那问题又来了，如何解决GET请求的中文乱码呢? </p><ol><li>首先我们需要先分析下GET请求出现乱码的原因:</li></ol><p>(1)浏览器通过HTTP协议发送请求和数据给后台服务器（Tomcat)</p><p>(2)浏览器在发送HTTP的过程中会对中文数据进行URL编码</p><p>(3)&#x3D;&#x3D;在进行URL编码的时候会采用页面<code>&lt;meta&gt;</code>标签指定的UTF-8的方式进行编码&#x3D;&#x3D;，<code>张三</code>编码后的结果为<code>%E5%BC%A0%E4%B8%89</code></p><p><u><strong>(4)&#x3D;&#x3D;后台服务器(Tomcat)接收到<code>%E5%BC%A0%E4%B8%89</code>后会默认按照<code>ISO-8859-1</code>进行URL解码&#x3D;&#x3D;</strong></u></p><p>(5)由于前后**<u>编码与解码采用的格式不一样</u>**，就会导致后台获取到的数据为乱码。</p><p>思考: 如果把<code>req.html</code>页面的<code>&lt;meta&gt;</code>标签的charset属性改成<code>ISO-8859-1</code>,后台不做操作，能解决中文乱码问题么?</p><p>答案是否定的，因为<code>ISO-8859-1</code>本身是不支持中文展示的，所以改了<meta>标签的charset属性后，会导致页面上的中文内容都无法正常展示。</p><p>分析完上面的问题后，我们会发现，其中有两个我们不熟悉的内容就是URL编码和URL解码，什么是URL编码，什么又是URL解码呢?</p><p><strong>URL编码</strong></p><p>这块知识我们只需要了解下即可,具体编码过程分两步，分别是:</p><p>(1)&#x3D;&#x3D;将字符串按照编码方式转为二进制&#x3D;&#x3D;</p><p>(2)&#x3D;&#x3D;每个字节转为2个16进制数并在前边加上%&#x3D;&#x3D;</p><p><code>张三</code>按照UTF-8的方式转换成二进制的结果为:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1110 0101 1011 1100 1010 0000 1110 0100 1011 1000 1000 1001</span><br></pre></td></tr></table></figure><p>这个结果是如何计算的?</p><p>使用<code>http://www.mytju.com/classcode/tools/encode_utf8.asp</code>，输入<code>张三</code></p><p>就可以获取张和三分别对应的10进制，然后在使用计算器，选择程序员模式，计算出对应的二进制数据结果</p><p>在计算的十六进制结果中，每两位前面加一个%,就可以获取到<code>%E5%BC%A0%E4%B8%89</code>。</p><p>当然你从上面所提供的网站中就已经能看到编码16进制的结果了</p><p>但是对于上面的计算过程，如果没有工具，纯手工计算的话，相对来说还是比较复杂的，我们也不需要进行手动计算，在Java中已经为我们提供了编码和解码的API工具类可以让我们更快速的进行编码和解码:</p><p><strong>编码:</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.net.URLEncoder.encode(<span class="string">&quot;需要被编码的内容&quot;</span>,<span class="string">&quot;字符集(UTF-8)&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>解码:</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.net.URLDecoder.decode(<span class="string">&quot;需要被解码的内容&quot;</span>,<span class="string">&quot;字符集(UTF-8)&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>接下来咱们对<code>张三</code>来进行编码和解码</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">class</span> <span class="title class_">URLDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">  public <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span>(<span class="title class_">String</span>[] args) throws <span class="title class_">UnsupportedEncodingException</span> &#123;</span><br><span class="line">        <span class="title class_">String</span> username = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">        <span class="comment">//1. URL编码</span></span><br><span class="line">        <span class="title class_">String</span> encode = <span class="title class_">URLEncoder</span>.<span class="title function_">encode</span>(username, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(encode); <span class="comment">//打印:%E5%BC%A0%E4%B8%89</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//2. URL解码</span></span><br><span class="line">       <span class="comment">//String decode = URLDecoder.decode(encode, &quot;utf-8&quot;);//打印:张三</span></span><br><span class="line">       <span class="title class_">String</span> decode = <span class="title class_">URLDecoder</span>.<span class="title function_">decode</span>(encode, <span class="string">&quot;ISO-8859-1&quot;</span>);<span class="comment">//打印:`å¼ ä¸ `</span></span><br><span class="line">       <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(decode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;<strong>分析出现GET请求中文参数出现乱码的原因:</strong>&#x3D;&#x3D;</p><ul><li><u><strong>浏览器把中文参数按照<code>UTF-8</code>进行URL编码</strong></u></li><li><u><strong>Tomcat对获取到的内容进行了<code>ISO-8859-1</code>的URL解码</strong></u></li><li><u><strong>在控制台就会出现类上<code>å¼ ä¸</code>的乱码，最后一位是个空格</strong></u></li></ul><p>&#x3D;&#x3D;<strong>解决方案：</strong>&#x3D;&#x3D;</p><ul><li><p><u><strong>在进行编码和解码的时候，不管使用的是哪个字符集，他们对应的12个十六进制<code>%E5%BC%A0%E4%B8%89</code>是一致的</strong></u></p></li><li><p><u><strong>与他们相对应的二进制值也是一样的，为:</strong></u></p><ul><li><pre><code>1110 0101 1011 1100 1010 0000 1110 0100 1011 1000 1000 1001<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* &lt;u&gt;**为所以我们可以考虑把`å¼ ä¸`转换成十六进制，再将十六进制转为二进制字节，在把二进制字节转换成`张三`，在转换的过程中是它们的编码一致，就可以解决中文乱码问题。**&lt;/u&gt;</span><br><span class="line"></span><br><span class="line">**==具体的实现步骤为:**==</span><br><span class="line"></span><br><span class="line">&gt;**1. 按照ISO-8859-1编码获取乱码`å¼ ä¸`对应的字节数组**</span><br><span class="line">&gt;</span><br><span class="line">&gt;**2. 按照UTF-8编码获取字节数组对应的字符串**</span><br><span class="line"></span><br><span class="line">实现代码如下:</span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line">public class URLDemo &#123;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] args) throws UnsupportedEncodingException &#123;</span><br><span class="line">        String username = &quot;张三&quot;;</span><br><span class="line">        //1. URL编码</span><br><span class="line">        String encode = URLEncoder.encode(username, &quot;utf-8&quot;);</span><br><span class="line">        System.out.println(encode);</span><br><span class="line">        //2. URL解码</span><br><span class="line">        String decode = URLDecoder.decode(encode, &quot;ISO-8859-1&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(decode); //此处打印的是对应的乱码数据</span><br><span class="line"></span><br><span class="line">        //3. 转换为字节数据,编码</span><br><span class="line">        byte[] bytes = decode.getBytes(&quot;ISO-8859-1&quot;);</span><br><span class="line">        for (byte b : bytes) &#123;</span><br><span class="line">            System.out.print(b + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">//此处打印的是:-27 -68 -96 -28 -72 -119</span><br><span class="line">        //4. 将字节数组转为字符串，解码</span><br><span class="line">        String s = new String(bytes, &quot;utf-8&quot;);</span><br><span class="line">        System.out.println(s); //此处打印的是张三</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><p><strong>说明</strong>:在第18行中打印的数据是<code>-27 -68 -96 -28 -72 -119</code>和<code>张三</code>转换成的二进制数据<code>1110 0101 1011 1100 1010 0000 1110 0100 1011 1000 1000 1001</code>为什么不一样呢？</p><p>其实打印出来的是十进制数据，我们只需要使用计算机换算下就能得到他们的对应关系。</p><p>至此对于GET请求中文乱码的解决方案，我们就已经分析完了，最后在代码中去实现下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中文乱码问题解决方案</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/req4&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestDemo4</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//1. 解决乱码：POST，getReader()</span></span><br><span class="line">        <span class="comment">//request.setCharacterEncoding(&quot;UTF-8&quot;);//设置字符输入流的编码</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 获取username</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;解决乱码前：&quot;</span>+username);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. GET,获取参数的方式：getQueryString</span></span><br><span class="line">        <span class="comment">// 乱码原因：tomcat进行URL解码，默认的字符集ISO-8859-1</span></span><br><span class="line">       <span class="comment">/* //3.1 先对乱码数据进行编码：转为字节数组</span></span><br><span class="line"><span class="comment">        byte[] bytes = username.getBytes(StandardCharsets.ISO_8859_1);</span></span><br><span class="line"><span class="comment">        //3.2 字节数组解码</span></span><br><span class="line"><span class="comment">        username = new String(bytes, StandardCharsets.UTF_8);*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//简化为一行</span></span><br><span class="line">        username  = <span class="keyword">new</span> <span class="title class_">String</span>(username.getBytes(StandardCharsets.ISO_8859_1),StandardCharsets.UTF_8);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;解决乱码后：&quot;</span>+username);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><ul><li>把<code>request.setCharacterEncoding(&quot;UTF-8&quot;)</code>代码注释掉后，会发现GET请求参数乱码解决方案同时也可也把POST请求参数乱码的问题也解决了</li><li>只不过对于POST请求参数一般都会比较多，采用这种方式解决乱码起来比较麻烦，所以对于POST请求还是建议使用设置编码的方式进行。</li></ul><p>另外需要说明一点的是</p><p>&#x3D;&#x3D;Tomcat8.0之后，已将GET请求乱码问题解决，设置默认的解码方式为UTF-8&#x3D;&#x3D;</p><p><strong>小结</strong></p><ol><li>中文乱码解决方案</li></ol><ul><li><p>POST请求和GET请求的参数中如果有中文，后台接收数据就会出现中文乱码问题</p><p>GET请求在Tomcat8.0以后的版本就不会出现了</p></li><li><p>POST请求解决方案是:打印前设置输入流的编码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">request.setCharacterEncoding(&quot;UTF-8&quot;);</span><br><span class="line">注意:设置的字符集要和页面保持一致</span><br></pre></td></tr></table></figure></li><li><p>通用方式（GET&#x2F;POST）：需要先解码，再编码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">new String(username.getBytes(&quot;ISO-8859-1&quot;),&quot;UTF-8&quot;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-5-Request请求转发（资源跳转方式）"><a href="#2-5-Request请求转发（资源跳转方式）" class="headerlink" title="2.5 Request请求转发（资源跳转方式）"></a>2.5 Request请求转发（资源跳转方式）</h3><h5 id="2-5-1请求转发-forward"><a href="#2-5-1请求转发-forward" class="headerlink" title="2.5.1请求转发(forward)"></a>2.5.1请求转发(forward)</h5><p>一种在服务器内部的资源跳转方式。</p><p>(1)浏览器发送请求给服务器，服务器中对应的资源A接收到请求</p><p>(2)资源A处理完请求后将请求发给资源B</p><p>(3)资源B处理完后将结果响应给浏览器</p><p>(4)请求从资源A到资源B的过程就叫&#x3D;&#x3D;请求转发&#x3D;&#x3D;</p><h5 id="2-5-2请求转发的实现方式"><a href="#2-5-2请求转发的实现方式" class="headerlink" title="2.5.2请求转发的实现方式"></a>2.5.2请求转发的实现方式</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//代码写在资源A里面</span><br><span class="line">req.getRequestDispatcher(&quot;资源B路径&quot;).forward(req,resp);</span><br></pre></td></tr></table></figure><p><strong>需求：</strong></p><p>在RequestDemo5类中启动RequestDemo6类中的数据</p><p>针对上述需求，具体的实现步骤为:</p><blockquote><p>1.创建一个RequestDemo5类，接收&#x2F;req5的请求，在doGet方法中打印<code>demo5</code></p><p>2.创建一个RequestDemo6类，接收&#x2F;req6的请求，在doGet方法中打印<code>demo6</code></p><p>3.在RequestDemo5的方法中使用</p><p>​req.getRequestDispatcher(“&#x2F;req6”).forward(req,resp)进行请求转发</p><p>4.启动测试</p></blockquote><p><strong>(1)创建RequestDemo5类</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 请求转发</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/req5&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestDemo5</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;demo5...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(2)创建RequestDemo6类</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 请求转发</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/req6&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestDemo6</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;demo6...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(3)在RequestDemo5的doGet方法中进行请求转发</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 请求转发</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/req5&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestDemo5</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;demo5...&quot;</span>);</span><br><span class="line">        <span class="comment">//请求转发</span></span><br><span class="line">        request.getRequestDispatcher(<span class="string">&quot;/req6&quot;</span>).forward(request,response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(4)启动测试</strong></p><p>访问<code>http://localhost:8080/request-demo/req5</code></p><h5 id="2-5-3请求转发资源间共享数据：使用Request对象"><a href="#2-5-3请求转发资源间共享数据：使用Request对象" class="headerlink" title="2.5.3请求转发资源间共享数据：使用Request对象"></a>2.5.3请求转发资源间共享数据：使用Request对象</h5><p>此处主要解决的问题是把请求从<code>/req5</code>转发到<code>/req6</code>的时候，如何传递数据给<code>/req6</code>。</p><p>需要使用request对象提供的三个方法:</p><ul><li>存储数据到request域[范围,数据是存储在request对象]中</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void setAttribute(String name,Object o);</span><br></pre></td></tr></table></figure><ul><li>根据key获取值（与上个方法相对应）</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Object getAttribute(String name);</span><br></pre></td></tr></table></figure><ul><li>根据key删除该键值对</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void removeAttribute(String name);</span><br></pre></td></tr></table></figure><p><strong>需求：</strong></p><blockquote><p>1.在RequestDemo5的doGet方法中转发请求之前，将数据存入request域对象中</p><p>2.在RequestDemo6的doGet方法从request域对象中获取数据，并将数据打印到控制台</p><p>3.启动访问测试</p></blockquote><p><strong>(1)修改RequestDemo5中的方法</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/req5&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestDemo5</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;demo5...&quot;</span>);</span><br><span class="line">        <span class="comment">//存储数据</span></span><br><span class="line">        request.setAttribute(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="comment">//请求转发</span></span><br><span class="line">        request.getRequestDispatcher(<span class="string">&quot;/req6&quot;</span>).forward(request,response);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(2)修改RequestDemo6中的方法</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 请求转发</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/req6&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestDemo6</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;demo6...&quot;</span>);</span><br><span class="line">        <span class="comment">//获取数据</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">msg</span> <span class="operator">=</span> request.getAttribute(<span class="string">&quot;msg&quot;</span>);</span><br><span class="line">        System.out.println(msg);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问<code>http://localhost:8080/request-demo/req5</code></p><p>此时就可以实现在转发多个资源之间共享数据。</p><h5 id="2-5-4请求转发的特点"><a href="#2-5-4请求转发的特点" class="headerlink" title="2.5.4请求转发的特点"></a>2.5.4请求转发的特点</h5><ul><li><p>&#x3D;&#x3D;浏览器地址栏路径不发生变化&#x3D;&#x3D;</p><p>虽然后台从<code>/req5</code>转发到<code>/req6</code>,但是浏览器的地址一直是<code>/req5</code>,未发生变化</p></li><li><p>&#x3D;&#x3D;只能转发到当前服务器的内部资源&#x3D;&#x3D;</p><p>不能从一个服务器通过转发访问另一台服务器</p></li><li><p>&#x3D;&#x3D;一次请求，可以在转发资源间使用request共享数据&#x3D;&#x3D;</p><p>虽然后台从<code>/req5</code>转发到<code>/req6</code>，但是这个只有一次请求</p></li></ul><h2 id="3、Response对象"><a href="#3、Response对象" class="headerlink" title="3、Response对象"></a>3、Response对象</h2><ul><li>Request:使用 <em>request</em> 对象来&#x3D;&#x3D;获取请求数据&#x3D;&#x3D;</li><li>Response:使用 <em>response</em> 对象来&#x3D;&#x3D;设置响应数据&#x3D;&#x3D;</li></ul><p>Reponse的继承体系和Request的继承体系也非常相似:</p><p> 介绍完Response的相关体系结构后，接下来对于Response我们需要学习如下内容:</p><ul><li>Response设置响应数据的功能介绍</li><li>Response完成重定向</li><li>Response响应字符数据</li><li>Response响应字节数据</li></ul><h3 id="3-1-Response设置响应数据功能介绍"><a href="#3-1-Response设置响应数据功能介绍" class="headerlink" title="3.1 Response设置响应数据功能介绍"></a>3.1 Response设置响应数据功能介绍</h3><p>HTTP响应数据总共分为三部分内容，分别是&#x3D;&#x3D;响应行、响应头、响应体&#x3D;&#x3D;，对于这三部分内容的数据，respone对象都提供了哪些方法来进行设置?</p><ol><li>响应行</li></ol><p>对于响应头，比较常用的就是设置响应状态码:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void setStatus(int sc);</span><br></pre></td></tr></table></figure><ol start="2"><li>响应头</li></ol><p>设置响应头键值对：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void setHeader(String name,String value);</span><br></pre></td></tr></table></figure><ol start="3"><li>响应体</li></ol><p>对于响应体，是通过字符、字节输出流的方式往浏览器写，</p><p>获取字符输出流:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PrintWriter getWriter();</span><br></pre></td></tr></table></figure><p>获取字节输出流：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ServletOutputStream getOutputStream();</span><br></pre></td></tr></table></figure><p>介绍完这些方法后，后面我们会通过案例把这些方法都用一用，首先先来完成下重定向的功能开发。</p><h3 id="3-2-Respones请求重定向（资源跳转方式）"><a href="#3-2-Respones请求重定向（资源跳转方式）" class="headerlink" title="3.2 Respones请求重定向（资源跳转方式）"></a>3.2 Respones请求重定向（资源跳转方式）</h3><ol><li>&#x3D;&#x3D;Response重定向(redirect):一种资源跳转方式。&#x3D;&#x3D;</li></ol><p>(1)浏览器发送请求给服务器，服务器中对应的资源A接收到请求</p><p>(2)资源A现在无法处理该请求，就会给浏览器响应一个&#x3D;&#x3D;302的状态码 + location的一个访问资源B的路径&#x3D;&#x3D;</p><p>(3)浏览器接收到响应状态码为302就会重新发送请求到location对应的访问地址去访问资源B</p><p>(4)资源B接收到请求后进行处理并最终给浏览器响应结果，这整个过程就叫重定向</p><ol start="2"><li>重定向的实现方式:</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">resp.setStatus(302);</span><br><span class="line">resp.setHeader(&quot;location&quot;,&quot;资源B的访问路径&quot;);</span><br></pre></td></tr></table></figure><p>具体如何来使用，我们先来看下需求:</p><p>在ResponseDemo1类中接收&#x2F;resp1的请求，跳转&#x2F;resp2的请求</p><p>针对上述需求，具体的实现步骤为:</p><blockquote><p>1.创建一个ResponseDemo1类，接收&#x2F;resp1的请求，在doGet方法中打印<code>resp1....</code></p><p>2.创建一个ResponseDemo2类，接收&#x2F;resp2的请求，在doGet方法中打印<code>resp2....</code></p><p>3.在ResponseDemo1的方法中使用</p><p>​response.setStatus(302);</p><p>​response.setHeader(“Location”,”&#x2F;request-demo&#x2F;resp2”) 来给前端响应结果数据</p><p>4.启动测试</p></blockquote><p>(1)创建ResponseDemo1类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/resp1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResponseDemo1</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;resp1....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2)创建ResponseDemo2类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/resp2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResponseDemo2</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;resp2....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(3)在ResponseDemo1的doGet方法中给前端响应数据</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/resp1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResponseDemo1</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;resp1....&quot;</span>);</span><br><span class="line">        <span class="comment">//重定向</span></span><br><span class="line">        <span class="comment">//1.设置响应状态码 302</span></span><br><span class="line">        response.setStatus(<span class="number">302</span>);</span><br><span class="line">        <span class="comment">//2. 设置响应头 Location</span></span><br><span class="line">        response.setHeader(<span class="string">&quot;Location&quot;</span>,<span class="string">&quot;/request-demo/resp2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(4)启动测试</p><p>访问<code>http://localhost:8080/request-demo/resp1</code></p><p>说明<code>/resp1</code>和<code>/resp2</code>都被访问到了。到这重定向就已经完成了。</p><p>虽然功能已经实现，但是从设置重定向的两行代码来看，会发现除了重定向的地址不一样，其他的内容都是一模一样，所以request对象给我们提供了简化的编写方式为:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">resposne.sendRedirect(&quot;/request-demo/resp2&quot;)</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;代码简化：&#x3D;&#x3D;</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/resp1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResponseDemo1</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;resp1....&quot;</span>);</span><br><span class="line">        <span class="comment">//重定向</span></span><br><span class="line">        resposne.sendRedirect(<span class="string">&quot;/request-demo/resp2&quot;</span>)；</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>重定向的特点</li></ol><ul><li><p>&#x3D;&#x3D;浏览器地址栏路径发送变化&#x3D;&#x3D;</p><p>当进行重定向访问的时候，由于是由浏览器发送的两次请求，所以地址会发生变化</p></li><li><p>&#x3D;&#x3D;可以重定向到任何位置的资源(服务内容、外部均可)&#x3D;&#x3D;</p><p>因为第一次响应结果中包含了浏览器下次要跳转的路径，所以这个路径是可以任意位置资源。</p></li><li><p>&#x3D;&#x3D;两次请求，不能在多个资源使用request共享数据&#x3D;&#x3D;</p><p>因为浏览器发送了两次请求，是两个不同的request对象，就无法通过request对象进行共享数据</p></li></ul><p>以后到底用哪个，还是需要根据具体的业务来决定。</p><h3 id="3-3-路径问题"><a href="#3-3-路径问题" class="headerlink" title="3.3 路径问题"></a>3.3 路径问题</h3><p>问题1：转发的时候路径上没有加<code>/request-demo</code>，而重定向加了，那么到底什么时候需要加，什么时候不需要加呢?</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//资源转发:</span></span><br><span class="line">request.<span class="title function_">getRequestDispatcher</span>(<span class="string">&quot;/req6&quot;</span>).<span class="title function_">forward</span>(request,response);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//重定向:</span></span><br><span class="line">resposne.<span class="title function_">sendRedirect</span>(<span class="string">&quot;/request-demo/resp2&quot;</span>); </span><br></pre></td></tr></table></figure><p>其实判断的依据很简单，只需要记住下面的规则即可:</p><ul><li>&#x3D;&#x3D;浏览器使用:需要加虚拟目录(项目访问路径)&#x3D;&#x3D;</li><li>&#x3D;&#x3D;服务端使用:不需要加虚拟目录&#x3D;&#x3D;</li></ul><p>对于转发来说，因为是在服务端进行的，所以不需要加虚拟目录</p><p>对于重定向来说，路径最终是由浏览器来发送请求，就需要添加虚拟目录。</p><p>掌握了这个规则，接下来就通过一些练习来强化下知识的学习</p><p>练习:</p><ul><li><code>&lt;a href=&#39;路劲&#39;&gt;</code></li><li><code>&lt;form action=&#39;路径&#39;&gt;</code></li><li>req.getRequestDispatcher(“路径”)</li><li>resp.sendRedirect(“路径”)</li></ul><p>答案:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.超链接，从浏览器发送，需要加</span><br><span class="line">2.表单，从浏览器发送，需要加</span><br><span class="line">3.转发，是从服务器内部跳转，不需要加</span><br><span class="line">4.重定向，是由浏览器进行跳转，需要加。</span><br></pre></td></tr></table></figure><p>问题2：在重定向的代码中，<code>/request-demo</code>是固定编码的，如果后期通过Tomcat插件（xml）配置了项目的访问路径，那么所有需要重定向的地方都需要重新修改，该如何优化?</p><p>答案也比较简单，我们可以在代码中&#x3D;&#x3D;动态去获取项目访问的虚拟目录&#x3D;&#x3D;，具体如何获取，我们可以借助前面咱们所学习的request对象中的**<u>getContextPath()方法   +   资源路径</u>**</p><p>修改后的代码如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/resp1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResponseDemo1</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;resp1....&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//简化方式完成重定向</span></span><br><span class="line">        <span class="comment">//动态获取虚拟目录</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">contextPath</span> <span class="operator">=</span> request.getContextPath();</span><br><span class="line">        response.sendRedirect(contextPath + <span class="string">&quot;/resp2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新启动访问测试，功能依然能够实现，此时就可以动态获取项目访问的虚拟路径，从而降低代码的耦合度。</p><h3 id="3-4-Response响应字符数据"><a href="#3-4-Response响应字符数据" class="headerlink" title="3.4 Response响应字符数据"></a>3.4 Response响应字符数据</h3><p>要想将字符数据写回到浏览器，我们需要两个步骤:</p><ul><li><p>通过Response对象获取字符输出流： PrintWriter writer &#x3D; resp.getWriter();</p></li><li><p>通过字符输出流写数据: writer.write(“aaa”);</p></li></ul><p>接下来，我们实现通过些案例把响应字符数据给实际应用下:</p><ol><li>返回一个简单的字符串<code>aaa</code></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 响应字符数据：设置字符数据的响应体</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/resp3&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResponseDemo3</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">//1. 获取字符输出流</span></span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line"> writer.write(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>返回一串html的标签，并且能被浏览器解析</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">PrintWriter</span> writer = response.<span class="title function_">getWriter</span>();</span><br><span class="line"><span class="comment">//content-type，告诉浏览器返回的数据类型是HTML类型数据，这样浏览器才会解析HTML标签</span></span><br><span class="line">response.<span class="title function_">setHeader</span>(<span class="string">&quot;content-type&quot;</span>,<span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">writer.<span class="title function_">write</span>(<span class="string">&quot;&lt;h1&gt;aaa&lt;/h1&gt;&quot;</span>);</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;注意:一次请求响应结束后，response对象就会被销毁掉，所以不要手动关闭流。&#x3D;&#x3D;</p><ol start="3"><li>返回一个中文的字符串<code>你好</code>，需要注意设置响应数据的编码为<code>utf-8</code></li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//setContentType设置响应的数据格式 及 数据的编码</span></span><br><span class="line">response.<span class="title function_">setContentType</span>(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">writer.<span class="title function_">write</span>(<span class="string">&quot;你好&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="3-3-Response响应字节数据"><a href="#3-3-Response响应字节数据" class="headerlink" title="3.3 Response响应字节数据"></a>3.3 Response响应字节数据</h3><p>要想将字节数据写回到浏览器，我们需要两个步骤:</p><ul><li><p>通过Response对象获取字节输出流：ServletOutputStream outputStream &#x3D; resp.getOutputStream();</p></li><li><p>通过字节输出流写数据: outputStream.write(字节数据);</p></li></ul><p>接下来，我们实现通过些案例把响应字符数据给实际应用下:</p><ol><li>返回一个图片文件到浏览器</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 响应字节数据：设置字节数据的响应体</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/resp4&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResponseDemo4</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//1. 读取文件</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;d://a.jpg&quot;</span>);</span><br><span class="line">        <span class="comment">//2. 获取response字节输出流</span></span><br><span class="line">        <span class="type">ServletOutputStream</span> <span class="variable">os</span> <span class="operator">=</span> response.getOutputStream();</span><br><span class="line">        <span class="comment">//3. 完成流的copy</span></span><br><span class="line">        <span class="type">byte</span>[] buff = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((len = fis.read(buff))!= -<span class="number">1</span>)&#123;</span><br><span class="line">            os.write(buff,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="commons-io工具"><a href="#commons-io工具" class="headerlink" title="commons-io工具"></a>commons-io工具</h5><p>上述代码中，对于流的copy的代码还是比较复杂的</p><p>所以我们可以使用别人提供好的方法来简化代码的开发，具体的步骤是:</p><p>(1)pom.xml添加依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>(2)调用工具类方法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//fis:输入流</span><br><span class="line">//os:输出流</span><br><span class="line">IOUtils.copy(fis,os);</span><br></pre></td></tr></table></figure><p>优化后的代码:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 响应字节数据：设置字节数据的响应体</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/resp4&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResponseDemo4</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//1. guo&#x27;q文件字节输入流，读取文件</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;d://a.jpg&quot;</span>);</span><br><span class="line">        <span class="comment">//2. 获取response字节输出流</span></span><br><span class="line">        <span class="type">ServletOutputStream</span> <span class="variable">os</span> <span class="operator">=</span> response.getOutputStream();</span><br><span class="line">        <span class="comment">//3. 完成流的copy</span></span><br><span class="line">      IOUtils.copy(fis,os);</span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Request&amp;Response </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP&amp;Tomcat&amp;Servlet</title>
      <link href="/post/17af4329.html"/>
      <url>/post/17af4329.html</url>
      
        <content type="html"><![CDATA[<h2 id="HTTP-Tomcat-Servlet"><a href="#HTTP-Tomcat-Servlet" class="headerlink" title="HTTP&amp;Tomcat&amp;Servlet"></a>HTTP&amp;Tomcat&amp;Servlet</h2><p><strong>今日目标：</strong></p><blockquote><ul><li>了解JavaWeb开发的技术栈</li><li>理解HTTP协议和HTTP请求与响应数据的格式</li><li>掌握Tomcat的使用</li><li>掌握在IDEA中使用Tomcat插件</li><li>理解Servlet的执行流程和生命周期</li><li>掌握Servlet的使用和相关配置</li></ul></blockquote><h2 id="1，Web概述"><a href="#1，Web概述" class="headerlink" title="1，Web概述"></a>1，Web概述</h2><h3 id="1-1-Web和JavaWeb的概念"><a href="#1-1-Web和JavaWeb的概念" class="headerlink" title="1.1 Web和JavaWeb的概念"></a>1.1 Web和JavaWeb的概念</h3><p>&#x3D;&#x3D;Web是全球广域网，也称为万维网(www)，能够通过浏览器访问的网站。&#x3D;&#x3D;<br>在我们日常的生活中，经常会使用浏览器去访问<code>百度</code>、<code>京东</code>、<code>传智官网</code>等这些网站，这些网站统称为Web网站。<br>知道了什么是Web，那么JavaWeb又是什么呢？顾名思义&#x3D;&#x3D;JavaWeb就是用Java技术来解决相关web互联网领域的技术栈。&#x3D;&#x3D;<br>等学习完JavaWeb之后，同学们就可以使用Java语言开发我们上述所说的网站。而国内很多大型网站公司也是首选Java语言来解决web互联网相关的问题。那都有哪些公司的系统是使用Java语言的呢?<br>使用Java语言开发互联网系统是有很多技术栈需要大家了解，具体都有哪些呢?</p><h3 id="1-2-JavaWeb技术栈"><a href="#1-2-JavaWeb技术栈" class="headerlink" title="1.2 JavaWeb技术栈"></a>1.2 JavaWeb技术栈</h3><p>了解JavaWeb技术栈之前，有一个很重要的概念要介绍。</p><h4 id="1-2-1-B-S架构"><a href="#1-2-1-B-S架构" class="headerlink" title="1.2.1 B&#x2F;S架构"></a>1.2.1 B&#x2F;S架构</h4><p>什么是B&#x2F;S架构?<br>B&#x2F;S 架构：Browser&#x2F;Server，浏览器&#x2F;服务器 架构模式，它的特点是，客户端只需要浏览器，应用程序的逻辑和数据都存储在服务器端。浏览器只需要请求服务器，获取Web资源，服务器把Web资源发送给浏览器即可。大家可以通过下面这张图来回想下我们平常的上网过程:</p><ul><li>打开浏览器访问百度首页，输入要搜索的内容，点击回车或百度一下，就可以获取和搜索相关的内容</li><li>思考下搜索的内容并不在我们自己的点上，那么这些内容从何而来？答案很明显是从百度服务器返回给我们的</li><li>日常百度的小细节，逢年过节百度的logo会更换不同的图片，服务端发生变化，客户端不需做任务事情就能获取最新内容</li><li>所以说B&#x2F;S架构的好处:易于维护升级：服务器端升级后，客户端无需任何部署就可以使用到新的版本。<br>了解了什么是B&#x2F;S架构后，作为后台开发工程师的我们将来主要关注的是服务端的开发和维护工作。在服务端将来会放很多资源,都有哪些资源呢?</li></ul><h4 id="1-2-2-静态资源"><a href="#1-2-2-静态资源" class="headerlink" title="1.2.2 静态资源"></a>1.2.2 静态资源</h4><ul><li>静态资源主要包含HTML、CSS、JavaScript、图片等，主要负责页面的展示。</li><li>我们之前已经学过前端网页制作<code>三剑客</code>(HTML+CSS+JavaScript),使用这些技术我们就可以制作出效果比较丰富的网页，将来展现给用户。但是由于做出来的这些内容都是静态的，这就会导致所有的人看到的内容将是一模一样。</li><li>在日常上网的过程中，我们除了看到这些好看的页面以外，还会碰到很多动态内容，比如我们常见的百度登录效果<br><code>张三</code>登录以后在网页的右上角看到的是 <code>张三</code>，而<code>李四</code>登录以后看到的则是<code>李四</code>。所以不同的用户访问相同的资源看到的内容大多数是不一样的，要想实现这样的效果，光靠静态资源是无法实现的。</li></ul><h4 id="1-2-3-动态资源"><a href="#1-2-3-动态资源" class="headerlink" title="1.2.3 动态资源"></a>1.2.3 动态资源</h4><ul><li>动态资源主要包含Servlet、JSP等，主要用来负责逻辑处理。</li><li>动态资源处理完逻辑后会把得到的结果交给静态资源来进行展示，动态资源和静态资源要结合一起使用。</li><li>动态资源虽然可以处理逻辑，但是当用户来登录百度的时候，就需要输入<code>用户名</code>和<code>密码</code>,这个时候我们就又需要解决的一个问题是，用户在注册的时候填入的用户名和密码、以及我们经常会访问到一些数据列表的内容展示(如下图所示)，这些数据都存储在哪里?我们需要的时候又是从哪里来取呢?</li></ul><h4 id="1-2-4-数据库"><a href="#1-2-4-数据库" class="headerlink" title="1.2.4 数据库"></a>1.2.4 数据库</h4><ul><li>数据库主要负责存储数据。</li><li>整个Web的访问过程<br>(1)浏览器发送一个请求到服务端，去请求所需要的相关资源;<br>(2)资源分为动态资源和静态资源,动态资源可以是使用Java代码按照Servlet和JSP的规范编写的内容;<br>(3)在Java代码可以进行业务处理也可以从数据库中读取数据;<br>(4)拿到数据后，把数据交给HTML页面进行展示,再结合CSS和JavaScript使展示效果更好;<br>(5)服务端将静态资源响应给浏览器;<br>(6)浏览器将这些资源进行解析;<br>(7)解析后将效果展示在浏览器，用户就可以看到最终的结果。<br>在整个Web的访问过程中，会设计到很多技术，这些技术有已经学习过的，也有还未涉及到的内容，都有哪些还没有涉及到呢?</li></ul><h4 id="1-2-5-HTTP协议"><a href="#1-2-5-HTTP协议" class="headerlink" title="1.2.5 HTTP协议"></a>1.2.5 HTTP协议</h4><ul><li>HTTP协议:主要定义通信规则</li><li>浏览器发送请求给服务器，服务器响应数据给浏览器，这整个过程都需要遵守一定的规则，之前大家学习过TCP、UDP，这些都属于规则，这里我们需要使用的是HTTP协议，这也是一种规则。</li></ul><h4 id="1-2-6-Web服务器"><a href="#1-2-6-Web服务器" class="headerlink" title="1.2.6 Web服务器"></a>1.2.6 Web服务器</h4><ul><li>Web服务器:负责解析 HTTP 协议，解析请求数据，并发送响应数据</li><li>浏览器按照HTTP协议发送请求和数据，后台就需要一个Web服务器软件来根据HTTP协议解析请求和数据，然后把处理结果再按照HTTP协议发送给浏览器</li><li>Web服务器软件有很多，我们课程中将学习的是目前最为常用的&#x3D;&#x3D;Tomcat&#x3D;&#x3D;服务器</li></ul><p>到这为止，关于JavaWeb中用到的技术栈我们就介绍完了，这里面就只有HTTP协议、Servlet、JSP以及Tomcat这些知识是没有学习过的，所以整个Web核心主要就是来学习这些技术。</p><h3 id="1-3-Web核心课程安排"><a href="#1-3-Web核心课程安排" class="headerlink" title="1.3 Web核心课程安排"></a>1.3 Web核心课程安排</h3><p>整个Web核心，总共有六天的学习内容，分别是:</p><ul><li>第一天：HTTP、Tomcat、Servlet</li><li>第二天：Request(请求)、Response(响应)</li><li>第三天：JSP、会话技术(Cookie、Session)</li><li>第四天：Filter(过滤器)、Listener(监听器)</li><li>第五天：Ajax、Vue、ElementUI</li><li>第六天：综合案例</li></ul><p>(1)Request是从客户端向服务端发出的请求对象，</p><p>(2)Response是从服务端响应给客户端的结果对象，</p><p>(3)JSP是动态网页技术,</p><p>(4)会话技术是用来存储客户端和服务端交互所产生的数据，</p><p>(5)过滤器是用来拦截客户端的请求,</p><p>(6)监听器是用来监听特定事件,</p><p>(7)Ajax、Vue、ElementUI都是属于前端技术</p><p>这些技术都该如何来使用，我们后面会一个个进行详细的讲解。接下来我们来学习下HTTP、Tomcat和Servlet。 </p><h2 id="2-HTTP"><a href="#2-HTTP" class="headerlink" title="2, HTTP"></a>2, HTTP</h2><h3 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h3><p><strong>HTTP概念</strong></p><p>HyperText Transfer Protocol，超文本传输协议，规定了浏览器和服务器之间&#x3D;&#x3D;数据传输的规则&#x3D;&#x3D;。</p><ul><li>数据传输的规则指的是请求数据和响应数据需要按照指定的格式进行传输。</li><li>如果想知道具体的格式，可以打开浏览器，点击<code>F12</code>打开开发者工具，点击<code>Network</code>来查看某一次请求的请求数据和响应数据具体的格式内容，如下图所示:</li></ul><blockquote><p>注意:在浏览器中如果看不到上述内容，需要清除浏览器的浏览数据。chrome浏览器可以使用ctrl+shift+Del进行清除。</p></blockquote><p>&#x3D;&#x3D;所以学习HTTP主要就是学习请求和响应数据的具体格式内容。&#x3D;&#x3D;</p><p><strong>HTTP协议特点</strong></p><p>HTTP协议有它自己的一些特点，分别是:</p><ul><li><p>基于TCP协议: 面向连接，安全</p><p>TCP是一种面向连接的(建立连接之前是需要经过三次握手)、可靠的、基于字节流的传输层通信协议，在数据传输方面更安全。</p></li><li><p>基于请求-响应模型的:一次请求对应一次响应</p><p>请求和响应是一一对应关系</p></li><li><p>HTTP协议是无状态协议:对于事物处理没有记忆能力。每次请求-响应都是独立的</p><p>无状态指的是客户端发送HTTP请求给服务端之后，服务端根据请求响应数据，响应完后，不会记录任何信息。这种特性有优点也有缺点，</p><ul><li>缺点:多次请求间不能共享数据</li><li>优点:速度快</li></ul><p>请求之间无法共享数据会引发的问题，如:</p><ul><li>京东购物，<code>加入购物车</code>和<code>去购物车结算</code>是两次请求，</li><li>HTTP协议的无状态特性，加入购物车请求响应结束后，并未记录加入购物车是何商品</li><li>发起去购物车结算的请求后，因为无法获取哪些商品加入了购物车，会导致此次请求无法正确展示数据</li></ul><p>具体使用的时候，我们发现京东是可以正常展示数据的，原因是Java早已考虑到这个问题，并提出了使用<code>会话技术(Cookie、Session)</code>来解决这个问题。具体如何来做，我们后面会详细讲到。刚才提到HTTP协议是规定了请求和响应数据的格式，那具体的格式是什么呢?</p></li></ul><h3 id="2-2-请求数据格式"><a href="#2-2-请求数据格式" class="headerlink" title="2.2 请求数据格式"></a>2.2 请求数据格式</h3><h4 id="2-2-1-格式介绍"><a href="#2-2-1-格式介绍" class="headerlink" title="2.2.1 格式介绍"></a>2.2.1 格式介绍</h4><p>请求数据总共分为三部分内容，分别是&#x3D;&#x3D;请求行&#x3D;&#x3D;、&#x3D;&#x3D;请求头&#x3D;&#x3D;、&#x3D;&#x3D;请求体&#x3D;&#x3D;</p><ul><li><p>请求行: HTTP请求中的第一行数据，请求行包含三块内容，分别是 GET[请求方式] &#x2F;[请求URL路径] HTTP&#x2F;1.1[HTTP协议及版本]</p><p> 请求方式有七种,最常用的是GET和POST</p></li><li><p>请求头: 第二行开始，格式为key: value形式</p><p>请求头中会包含若干个属性，常见的HTTP请求头有:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host: 表示请求的主机名</span><br><span class="line">User-Agent: 浏览器版本,例如Chrome浏览器的标识类似Mozilla/5.0 ...Chrome/79，IE浏览器的标识类似Mozilla/5.0 (Windows NT ...)like Gecko；</span><br><span class="line">Accept：表示浏览器能接收的资源类型，如text/*，image/*或者*/*表示所有；</span><br><span class="line">Accept-Language：表示浏览器偏好的语言，服务器可以据此返回不同语言的网页；</span><br><span class="line">Accept-Encoding：表示浏览器可以支持的压缩类型，例如gzip, deflate等。</span><br></pre></td></tr></table></figure><p> &#x3D;&#x3D;这些数据有什么用处?&#x3D;&#x3D;</p><p>举例说明:服务端可以根据请求头中的内容来获取客户端的相关信息，有了这些信息服务端就可以处理不同的业务需求，比如:</p><ul><li>不同浏览器解析HTML和CSS标签的结果会有不一致，所以就会导致相同的代码在不同的浏览器会出现不同的效果</li><li>服务端根据客户端请求头中的数据获取到客户端的浏览器类型，就可以根据不同的浏览器设置不同的代码来达到一致的效果</li><li>这就是我们常说的浏览器兼容问题</li></ul></li><li><p>请求体: POST请求的最后一部分，存储请求参数</p><p> 如上图红线框的内容就是请求体的内容，请求体和请求头之间是有一个空行隔开。此时浏览器发送的是POST请求，为什么不能使用GET呢?这时就需要回顾GET和POST两个请求之间的区别了:</p><ul><li>GET请求请求参数在请求行中，没有请求体，POST请求请求参数在请求体中</li></ul></li><li><p>GET请求请求参数大小有限制，POST没有</p></li></ul><p><strong>小结</strong>:</p><ol><li><p>请求数据中包含三部分内容，分别是请求行、请求头和请求体</p></li><li><p>POST请求数据在请求体中，GET请求数据在请求行上</p></li></ol><h3 id="2-3-响应数据格式"><a href="#2-3-响应数据格式" class="headerlink" title="2.3 响应数据格式"></a>2.3 响应数据格式</h3><h4 id="2-3-1-格式介绍"><a href="#2-3-1-格式介绍" class="headerlink" title="2.3.1 格式介绍"></a>2.3.1 格式介绍</h4><p>响应数据总共分为三部分内容，分别是&#x3D;&#x3D;响应行&#x3D;&#x3D;、&#x3D;&#x3D;响应头&#x3D;&#x3D;、&#x3D;&#x3D;响应体&#x3D;&#x3D;</p><ul><li><p>响应行：响应数据的第一行,响应行包含三块内容，分别是 HTTP&#x2F;1.1[HTTP协议及版本] 200[响应状态码] ok[状态码的描述]</p></li><li><p>响应头：第二行开始，格式为key：value形式</p><p>响应头中会包含若干个属性，常见的HTTP响应头有:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Content-Type：表示该响应内容的类型，例如text/html，image/jpeg；</span><br><span class="line">Content-Length：表示该响应内容的长度（字节数）；</span><br><span class="line">Content-Encoding：表示该响应压缩算法，例如gzip；</span><br><span class="line">Cache-Control：指示客户端应如何缓存，例如max-age=300表示可以最多缓存300秒</span><br></pre></td></tr></table></figure></li><li><p>响应体： 最后一部分。存放响应数据</p><p>上图中<html>…</html>这部分内容就是响应体，它和响应头之间有一个空行隔开。</p></li></ul><h4 id="2-3-2-响应状态码"><a href="#2-3-2-响应状态码" class="headerlink" title="2.3.2 响应状态码"></a>2.3.2 响应状态码</h4><p>参考: 资料&#x2F;1.HTTP&#x2F;《响应状态码.md》</p><p>关于响应状态码，我们先主要认识三个状态码，其余的等后期用到了再去掌握:</p><ul><li>200  ok 客户端请求成功</li><li>404  Not Found 请求资源不存在</li><li>500 Internal Server Error 服务端发生不可预期的错误</li></ul><h4 id="2-3-3-自定义服务器"><a href="#2-3-3-自定义服务器" class="headerlink" title="2.3.3 自定义服务器"></a>2.3.3 自定义服务器</h4><p>在前面我们导入到IDEA中的http项目中，有一个Server.java类，这里面就是自定义的一个服务器代码，主要使用到的是<code>ServerSocket</code>和<code>Socket</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sun.misc.IOUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Files;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    自定义服务器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8080</span>); <span class="comment">// 监听指定端口</span></span><br><span class="line">        System.out.println(<span class="string">&quot;server is running...&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">sock</span> <span class="operator">=</span> ss.accept();</span><br><span class="line">            System.out.println(<span class="string">&quot;connected from &quot;</span> + sock.getRemoteSocketAddress());</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Handler</span>(sock);</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Handler</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    Socket sock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Handler</span><span class="params">(Socket sock)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sock = sock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="built_in">this</span>.sock.getInputStream()) &#123;</span><br><span class="line">            <span class="keyword">try</span> (<span class="type">OutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="built_in">this</span>.sock.getOutputStream()) &#123;</span><br><span class="line">                handle(input, output);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.sock.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;client disconnected.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(InputStream input, OutputStream output)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(input, StandardCharsets.UTF_8));</span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(output, StandardCharsets.UTF_8));</span><br><span class="line">        <span class="comment">// 读取HTTP请求:</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">requestOk</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">first</span> <span class="operator">=</span> reader.readLine();</span><br><span class="line">        <span class="keyword">if</span> (first.startsWith(<span class="string">&quot;GET / HTTP/1.&quot;</span>)) &#123;</span><br><span class="line">            requestOk = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">header</span> <span class="operator">=</span> reader.readLine();</span><br><span class="line">            <span class="keyword">if</span> (header.isEmpty()) &#123; <span class="comment">// 读取到空行时, HTTP Header读取完毕</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(header);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(requestOk ? <span class="string">&quot;Response OK&quot;</span> : <span class="string">&quot;Response Error&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!requestOk) &#123;</span><br><span class="line">            <span class="comment">// 发送错误响应:</span></span><br><span class="line">            writer.write(<span class="string">&quot;HTTP/1.0 404 Not Found\r\n&quot;</span>);</span><br><span class="line">            writer.write(<span class="string">&quot;Content-Length: 0\r\n&quot;</span>);</span><br><span class="line">            writer.write(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">            writer.flush();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 发送成功响应:</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//读取html文件，转换为字符串</span></span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;http/html/a.html&quot;</span>));</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">                data.append(line);</span><br><span class="line">            &#125;</span><br><span class="line">            br.close();</span><br><span class="line">            <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> data.toString().getBytes(StandardCharsets.UTF_8).length;</span><br><span class="line"></span><br><span class="line">            writer.write(<span class="string">&quot;HTTP/1.1 200 OK\r\n&quot;</span>);</span><br><span class="line">            writer.write(<span class="string">&quot;Connection: keep-alive\r\n&quot;</span>);</span><br><span class="line">            writer.write(<span class="string">&quot;Content-Type: text/html\r\n&quot;</span>);</span><br><span class="line">            writer.write(<span class="string">&quot;Content-Length: &quot;</span> + length + <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">            writer.write(<span class="string">&quot;\r\n&quot;</span>); <span class="comment">// 空行标识Header和Body的分隔</span></span><br><span class="line">            writer.write(data.toString());</span><br><span class="line">            writer.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码，大家不需要自己写，主要通过上述代码，只需要大家了解到服务器可以使用java完成编写，是可以接受页面发送的请求和响应数据给前端浏览器的，真正用到的Web服务器，我们不会自己写，都是使用目前比较流行的web服务器，比如&#x3D;&#x3D;Tomcat&#x3D;&#x3D;</p><p><strong>小结</strong></p><ol><li><p>响应数据中包含三部分内容，分别是响应行、响应头和响应体</p></li><li><p>掌握200，404，500这三个响应状态码所代表含义，分布是成功、所访问资源不存在和服务的错误</p></li></ol><h2 id="3-Tomcat"><a href="#3-Tomcat" class="headerlink" title="3, Tomcat"></a>3, Tomcat</h2><h3 id="3-1-简介"><a href="#3-1-简介" class="headerlink" title="3.1 简介"></a>3.1 简介</h3><h4 id="3-1-1-什么是Web服务器"><a href="#3-1-1-什么是Web服务器" class="headerlink" title="3.1.1 什么是Web服务器"></a>3.1.1 什么是Web服务器</h4><p>Web服务器是一个应用程序（&#x3D;&#x3D;软件&#x3D;&#x3D;），对HTTP协议的操作进行封装，使得程序员不必直接对协议进行操作，让Web开发更加便捷。主要功能是”提供网上信息浏览服务”。</p><p> Web服务器是安装在服务器端的一款软件，将来我们把自己写的Web项目部署到Web Tomcat服务器软件中，当Web服务器软件启动后，部署在Web服务器软件中的页面就可以直接通过浏览器来访问了。</p><p><strong>Web服务器软件使用步骤</strong></p><ul><li>准备静态资源</li><li>下载安装Web服务器软件</li><li>将静态资源部署到Web服务器上</li><li>启动Web服务器使用浏览器访问对应的资源</li></ul><p>上述内容在演示的时候，使用的是Apache下的Tomcat软件，至于Tomcat软件如何使用，后面会详细的讲到。而对于Web服务器来说，实现的方案有很多，Tomcat只是其中的一种，而除了Tomcat以外，还有很多优秀的Web服务器</p><p>Tomcat就是一款软件，我们主要是以学习如何去使用为主。具体我们会从以下这些方向去学习:</p><ol><li><p>简介: 初步认识下Tomcat</p></li><li><p>基本使用: 安装、卸载、启动、关闭、配置和项目部署，这些都是对Tomcat的基本操作</p></li><li><p>IDEA中如何创建Maven Web项目</p></li><li><p>IDEA中如何使用Tomcat,后面这两个都是我们以后开发经常会用到的方式</p></li></ol><p>首选我们来认识下Tomcat。</p><p><strong>Tomcat</strong></p><p>Tomcat的相关概念:</p><ul><li><p>Tomcat是Apache软件基金会一个核心项目，是一个开源免费的轻量级Web服务器，支持Servlet&#x2F;JSP少量JavaEE规范。</p></li><li><p>概念中提到了JavaEE规范，那什么又是JavaEE规范呢?</p><p>JavaEE: Java Enterprise Edition,Java企业版。指Java企业级开发的技术规范总和。包含13项技术规范:JDBC、JNDI、EJB、RMI、JSP、Servlet、XML、JMS、Java IDL、JTS、JTA、JavaMail、JAF。</p></li><li><p>因为Tomcat支持Servlet&#x2F;JSP规范，所以Tomcat也被称为Web容器、Servlet容器。Servlet需要依赖Tomcat才能运行。</p></li><li><p>Tomcat的官网: <a href="https://tomcat.apache.org/">https://tomcat.apache.org/</a> 从官网上可以下载对应的版本进行使用。</p></li></ul><p><strong>Tomcat的LOGO</strong></p><p><strong>小结</strong></p><p>通过这一节的学习，我们需要掌握以下内容:</p><ol><li>Web服务器的作用</li></ol><blockquote><p>封装HTTP协议操作，简化开发</p><p>可以将Web项目部署到服务器中，对外提供网上浏览服务</p></blockquote><ol start="2"><li>Tomcat是一个轻量级的Web服务器，支持Servlet&#x2F;JSP少量JavaEE规范，也称为Web容器，Servlet容器。</li></ol><h3 id="3-2-基本使用"><a href="#3-2-基本使用" class="headerlink" title="3.2 基本使用"></a>3.2 基本使用</h3><p>Tomcat总共分两部分学习，先来学习Tomcat的基本使用，包括Tomcat的&#x3D;&#x3D;下载、安装、卸载、启动和关闭&#x3D;&#x3D;。</p><h4 id="3-2-1-下载"><a href="#3-2-1-下载" class="headerlink" title="3.2.1 下载"></a>3.2.1 下载</h4><p>直接从官网下载</p><h4 id="3-2-2-安装"><a href="#3-2-2-安装" class="headerlink" title="3.2.2 安装"></a>3.2.2 安装</h4><p>Tomcat是绿色版,直接解压即可</p><ul><li><p>在D盘的software目录下，将<code>apache-tomcat-8.5.68-windows-x64.zip</code>进行解压缩，会得到一个<code>apache-tomcat-8.5.68</code>的目录，Tomcat就已经安装成功。</p><p>&#x3D;&#x3D;注意&#x3D;&#x3D;，Tomcat在解压缩的时候，解压所在的目录可以任意，但最好解压到一个不包含中文和空格的目录，因为后期在部署项目的时候，如果路径有中文或者空格可能会导致程序部署失败。</p><p>bin:目录下有两类文件，一种是以<code>.bat</code>结尾的，是Windows系统的可执行文件，一种是以<code>.sh</code>结尾的，是Linux系统的可执行文件。</p><p>webapps:就是以后项目部署的目录</p><p>到此，Tomcat的安装就已经完成。</p></li></ul><h4 id="3-2-3-卸载"><a href="#3-2-3-卸载" class="headerlink" title="3.2.3 卸载"></a>3.2.3 卸载</h4><p>卸载比较简单，可以直接删除目录即可</p><h4 id="3-2-4-启动"><a href="#3-2-4-启动" class="headerlink" title="3.2.4 启动"></a>3.2.4 启动</h4><p>双击: bin\startup.bat</p><p>启动后，通过浏览器访问 <code>http://localhost:8080</code>能看到Apache Tomcat的内容就说明Tomcat已经启动成功。</p><p>&#x3D;&#x3D;注意&#x3D;&#x3D;: 启动的过程中，控制台有中文乱码，需要修改conf&#x2F;logging.prooperties</p><h4 id="3-2-5-关闭"><a href="#3-2-5-关闭" class="headerlink" title="3.2.5 关闭"></a>3.2.5 关闭</h4><p>关闭有三种方式 </p><ul><li>直接x掉运行窗口:强制关闭[不建议]</li><li>bin\shutdown.bat：正常关闭</li><li>ctrl+c： 正常关闭</li></ul><h4 id="3-2-6-配置"><a href="#3-2-6-配置" class="headerlink" title="3.2.6 配置"></a>3.2.6 配置</h4><p><strong>修改端口</strong></p><ul><li>Tomcat默认的端口是8080，要想修改Tomcat启动的端口号，需要修改 conf&#x2F;server.xml</li></ul><blockquote><p>注: HTTP协议默认端口号为80，如果将Tomcat端口号改为80，则将来访问Tomcat时，将不用输入端口号。</p></blockquote><p><strong>启动时可能出现的错误</strong></p><ul><li><p>Tomcat的端口号取值范围是0-65535之间任意未被占用的端口，如果设置的端口号被占用，启动的时候就会报错误</p></li><li><p>Tomcat启动的时候，启动窗口一闪而过: 需要检查JAVA_HOME环境变量是否正确配置</p></li></ul><h4 id="3-2-7-部署"><a href="#3-2-7-部署" class="headerlink" title="3.2.7 部署"></a>3.2.7 部署</h4><ul><li><p>Tomcat部署项目： 将项目放置到webapps目录下，即部署完成。</p><ul><li><p>将 <code>资料/2. Tomcat/hello</code> 目录拷贝到Tomcat的webapps目录下</p></li><li><p>通过浏览器访问<code>http://localhost/hello/a.html</code>，能看到内容就说明项目已经部署成功。</p><p>但是呢随着项目的增大，项目中的资源也会越来越多，项目在拷贝的过程中也会越来越费时间，该如何解决呢?</p></li></ul></li><li><p>一般JavaWeb项目会被打包称&#x3D;&#x3D;war&#x3D;&#x3D;包，然后将war包放到Webapps目录下，Tomcat会自动解压缩war文件</p><ul><li><p>将 目录拷贝到Tomcat的webapps目录下</p></li><li><p>Tomcat检测到war包后会自动完成解压缩，在webapps目录下就会多一个haha目录</p></li><li><p>通过浏览器访问<code>http://localhost/haha/a.html</code>，能看到下面的内容就说明项目已经部署成功。</p></li></ul></li></ul><p>至此，Tomcat的部署就已经完成了，至于如何获得项目对应的war包，后期会借助于IDEA工具来生成。</p><h3 id="3-3-Maven创建Web项目"><a href="#3-3-Maven创建Web项目" class="headerlink" title="3.3 Maven创建Web项目"></a>3.3 Maven创建Web项目</h3><p>介绍完Tomcat的基本使用后，学习在IDEA中如何创建Maven Web项目，学习这种方式的原因是以后Tomcat中运行的绝大多数都是Web项目，而使用Maven工具能更加简单快捷的把Web项目给创建出来，所以Maven的Web项目具体如何来构建呢?</p><p>在真正创建Maven Web项目之前，我们先要知道Web项目长什么样子，具体的结构是什么?</p><h4 id="3-3-1-Web项目结构"><a href="#3-3-1-Web项目结构" class="headerlink" title="3.3.1 Web项目结构"></a>3.3.1 Web项目结构</h4><p>Web项目的结构分为:开发中的项目和开发完可以部署的Web项目,这两种项目的结构是不一样的</p><ul><li><p>Maven Web项目结构: 开发中的项目</p></li><li><p>开发完成部署的Web项目</p><ul><li>开发项目通过执行Maven打包命令&#x3D;&#x3D;package&#x3D;&#x3D;,可以获取到部署的Web项目目录</li><li>编译后的Java字节码文件和resources的资源文件，会被放到WEB-INF下的classes目录下</li><li>pom.xml中依赖坐标对应的jar包，会被放入WEB-INF下的lib目录下</li></ul></li></ul><h4 id="3-3-2-创建Maven-Web项目"><a href="#3-3-2-创建Maven-Web项目" class="headerlink" title="3.3.2 创建Maven Web项目"></a>3.3.2 创建Maven Web项目</h4><p>介绍完Maven Web的项目结构后，接下来使用Maven来创建Web项目，创建方式有两种:使用骨架和不使用骨架</p><p><strong>使用骨架</strong></p><blockquote><p>具体的步骤包含:</p><p>1.创建Maven项目</p><p>2.选择使用Web项目骨架</p><p>3.输入Maven项目坐标创建项目</p><p>4.确认Maven相关的配置信息后，完成项目创建</p><p>5.删除pom.xml中多余内容</p><p>6.补齐Maven Web项目缺失的目录结构</p></blockquote><ol><li><p>创建Maven项目</p></li><li><p>选择使用Web项目骨架</p></li><li><p>输入Maven项目坐标创建项目</p></li><li><p>确认Maven相关的配置信息后，完成项目创建</p></li><li><p>删除pom.xml中多余内容，只留下面的这些内容，注意打包方式 jar和war的区别</p></li><li><p>补齐Maven Web项目缺失的目录结构，默认没有java和resources目录，需要手动完成创建补齐，最终的目录结果如下</p></li></ol><p><strong>不使用骨架</strong></p><blockquote><p>具体的步骤包含:</p><p>1.创建Maven项目</p><p>2.选择不使用Web项目骨架</p><p>3.输入Maven项目坐标创建项目</p><p>4.在pom.xml设置打包方式为war</p><p>5.补齐Maven Web项目缺失webapp的目录结构</p><p>6.补齐Maven Web项目缺失WEB-INF&#x2F;web.xml的目录结构</p></blockquote><ol><li><p>创建Maven项目</p></li><li><p>选择不使用Web项目骨架</p></li><li><p>输入Maven项目坐标创建项目</p></li><li><p>在pom.xml设置打包方式为war,默认是不写代表打包方式为jar</p></li><li><p>补齐Maven Web项目缺失webapp的目录结构</p></li><li><p>补齐Maven Web项目缺失WEB-INF&#x2F;web.xml的目录结构</p></li><li><p>补充完后，最终的项目结构如下:</p></li></ol><p>上述两种方式，创建的web项目，都不是很全，需要手动补充内容，至于最终采用哪种方式来创建Maven Web项目，都是可以的，根据各自的喜好来选择使用即可。</p><p><strong>小结</strong></p><p>1.掌握Maven Web项目的目录结构</p><p>2.掌握使用骨架的方式创建Maven Web项目</p><blockquote><p>3.掌握不使用骨架的方式创建Maven Web项目</p></blockquote><h3 id="3-4-IDEA使用Tomcat"><a href="#3-4-IDEA使用Tomcat" class="headerlink" title="3.4 IDEA使用Tomcat"></a>3.4 IDEA使用Tomcat</h3><ul><li>Maven Web项目创建成功后，通过Maven的package命令可以将项目打包成war包，将war文件拷贝到Tomcat的webapps目录下，启动Tomcat就可以将项目部署成功，然后通过浏览器进行访问即可。</li><li>然而我们在开发的过程中，项目中的内容会经常发生变化，如果按照上面这种方式来部署测试，是非常不方便的</li><li>如何在IDEA中能快速使用Tomcat呢?</li></ul><p>在IDEA中集成使用Tomcat有两种方式，分别是&#x3D;&#x3D;集成本地Tomcat&#x3D;&#x3D;和&#x3D;&#x3D;Tomcat Maven插件&#x3D;&#x3D;</p><h4 id="3-4-1-方法一：集成本地Tomcat"><a href="#3-4-1-方法一：集成本地Tomcat" class="headerlink" title="3.4.1 方法一：集成本地Tomcat"></a>3.4.1 方法一：集成本地Tomcat</h4><p>目标: 将刚才本地安装好的Tomcat8集成到IDEA中，完成项目部署，具体的实现步骤</p><p><strong>打开Run下的Edit Configurations</strong></p><ol><li><p>打开添加本地Tomcat的面板</p></li><li><p>指定本地Tomcat的具体路径</p></li><li><p>修改Tomcat的名称，此步骤可以不改，只是让名字看起来更有意义，HTTP port中的端口也可以进行修改，比如把8080改成80</p></li><li><p>将开发项目部署项目到Tomcat中</p><p>扩展内容： xxx.war和 xxx.war exploded这两种部署项目模式的区别?</p><ul><li><p>war模式是将WEB工程打成war包，把war包发布到Tomcat服务器上</p></li><li><p>war exploded模式是将WEB工程以当前文件夹的位置关系发布到Tomcat服务器上</p></li><li><p>war模式部署成功后，Tomcat的webapps目录下会有部署的项目内容</p></li><li><p>war exploded模式部署成功后，Tomcat的webapps目录下没有，而使用的是项目的target目录下的内容进行部署</p></li><li><p>建议大家都选war模式进行部署，更符合项目部署的实际情况</p></li></ul></li><li><p>部署成功后，就可以启动项目，为了能更好的看到启动的效果，可以在webapp目录下添加a.html页面</p></li><li><p>启动成功后，可以通过浏览器进行访问测试</p></li><li><p>最终的注意事项</p></li></ol><p>至此，IDEA中集成本地Tomcat进行项目部署的内容我们就介绍完了，整体步骤如下，大家需要按照流程进行部署操作练习。</p><h4 id="3-4-2-方法二：Tomcat-Maven插件"><a href="#3-4-2-方法二：Tomcat-Maven插件" class="headerlink" title="3.4.2 方法二：Tomcat Maven插件"></a>3.4.2 方法二：Tomcat Maven插件</h4><p>在IDEA中使用本地Tomcat进行项目部署，相对来说步骤比较繁琐，所以我们需要一种更简便的方式来替换它，那就是直接使用Maven中的Tomcat插件来部署项目，具体的实现步骤，只需要两步，分别是:</p><ol><li><p>在pom.xml中添加Tomcat插件</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--Tomcat插件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用Maven Helper插件快速启动项目，选中项目，右键–&gt;Run Maven –&gt; tomcat7:run</p></li></ol><p>&#x3D;&#x3D;注意:&#x3D;&#x3D;</p><ul><li><p>如果选中项目并右键点击后，看不到Run Maven和Debug Maven，这个时候就需要在IDEA中下载Maven Helper插件，具体的操作方式为: File –&gt; Settings –&gt; Plugins –&gt; Maven Helper —&gt; Install,安装完后按照提示重启IDEA，就可以看到了。</p></li><li><p><strong>Maven Tomcat插件目前只有Tomcat7版本，没有更高的版本可以使用</strong></p></li><li><p>使用Maven Tomcat插件，要想修改Tomcat的端口和访问路径，可以直接修改pom.xml</p></li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--Tomcat插件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">port</span>&gt;</span>80<span class="tag">&lt;/<span class="name">port</span>&gt;</span><span class="comment">&lt;!--访问端口号 --&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--项目访问路径</span></span><br><span class="line"><span class="comment">未配置访问路径: http://localhost:80/tomcat-demo2/a.html</span></span><br><span class="line"><span class="comment">配置/后访问路径: http://localhost:80/a.html</span></span><br><span class="line"><span class="comment">如果配置成 /hello,访问路径会变成什么?</span></span><br><span class="line"><span class="comment">答案: http://localhost:80/hello/a.html</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">path</span>&gt;</span>/<span class="tag">&lt;/<span class="name">path</span>&gt;</span> <span class="comment">&lt;!-- / 的作用是本模块下的a.html --&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>小结</strong></p><p>通过这一节的学习，大家要掌握在IDEA中使用Tomcat的两种方式，集成本地Tomcat和使用Maven的Tomcat插件。后者更简单，推荐大家使用，但是如果对于Tomcat的版本有比较高的要求，要在Tomcat7以上，这个时候就只能用前者了。</p><h2 id="4，-Servlet-javaEE的规范接口"><a href="#4，-Servlet-javaEE的规范接口" class="headerlink" title="4， Servlet(javaEE的规范接口)"></a>4， Servlet(javaEE的规范接口)</h2><h3 id="4-1-简介"><a href="#4-1-简介" class="headerlink" title="4.1 简介"></a>4.1 简介</h3><ul><li><p>Servlet是JavaWeb最为核心的内容，它是Java提供的一门&#x3D;&#x3D;动态&#x3D;&#x3D;web资源开发技术。</p></li><li><p>使用Servlet就可以实现，根据不同的登录用户在页面上动态显示不同内容。</p></li><li><p>Servlet是JavaEE规范之一，其实就是一个接口，将来我们需要定义Servlet类实现Servlet接口，并由web服务器运行Servlet</p></li></ul><p>介绍完Servlet是什么以后，接下来我们就按照<code>快速入门</code>-&gt;<code>执行流程</code>-&gt;<code>生命周期</code>-&gt;<code>体系结构</code>-&gt;<code>urlPattern配置</code>-&gt;<code>XML配置</code>的学习步骤，一步步完成对Servlet的知识学习，首选我们来通过一个入门案例来快速把Servlet用起来。</p><h3 id="4-2-快速入门"><a href="#4-2-快速入门" class="headerlink" title="4.2 快速入门"></a>4.2 快速入门</h3><p>&#x3D;&#x3D;需求分析: 编写一个Servlet类，并使用IDEA中Tomcat插件进行部署，最终通过浏览器访问所编写的Servlet程序。&#x3D;&#x3D;</p><p>具体的实现步骤为:</p><h5 id="1-创建Web项目web-demo"><a href="#1-创建Web项目web-demo" class="headerlink" title="(1). 创建Web项目web-demo"></a>(1). <strong>创建Web项目<code>web-demo</code></strong></h5><p><strong>在pol.xml中导入 <em>Servlet</em> 的依赖坐标</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">      注意：此处为什么需要添加该标签?</span></span><br><span class="line"><span class="comment">      provided指的是在 编译 和 测试 过程中有效,最后生成的war包时不会加入</span></span><br><span class="line"><span class="comment">       因为Tomcat的lib目录中已经有servlet-api这个jar包，如果在生成war包的时候生效就会和Tomcat中的jar包冲突，导致报错</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="2-创建-定义一个类-实现Servlet接口"><a href="#2-创建-定义一个类-实现Servlet接口" class="headerlink" title="(2). 创建:定义一个类,实现Servlet接口"></a>(2). <strong>创建:定义一个类</strong>,实现Servlet接口</h5><p><strong>并重写接口中所有方法</strong>，并在service方法中输入一句话(标识连接成功)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo1</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;servlet hello world~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig servletConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ServletConfig <span class="title function_">getServletConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getServletInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-配置-在类上使用-WebServlet注解"><a href="#3-配置-在类上使用-WebServlet注解" class="headerlink" title="(3). 配置:在类上使用@WebServlet注解"></a>(3). <strong>配置:在类上使用@WebServlet注解</strong></h5><p><strong>配置该Servlet的访问路径</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/demo1&quot;)</span></span><br></pre></td></tr></table></figure><h5 id="4-访问"><a href="#4-访问" class="headerlink" title="(4). 访问"></a>(4). 访问</h5><p><strong>启动Tomcat,浏览器中输入URL地址访问该Servlet</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://localhost:8080/web-demo/demo1</span><br></pre></td></tr></table></figure><p>器访问后，在控制台会打印<code>servlet hello world~</code> 说明servlet程序已经成功运行。</p><p>至此，Servlet的入门案例就已经完成，大家可以按照上面的步骤进行练习了。</p><h3 id="4-3-执行流程"><a href="#4-3-执行流程" class="headerlink" title="4.3 执行流程"></a>4.3 执行流程</h3><p>Servlet程序已经能正常运行，但是我们需要思考个问题: 我们并没有创建ServletDemo1类的对象，也没有调用对象中的service方法，为什么在控制台就打印了<code>servlet hello world~</code>这句话呢?</p><p>要想回答上述问题，我们就需要对Servlet的执行流程进行一个学习。</p><ul><li>浏览器发出<code>http://localhost:8080/web-demo/demo1</code>请求，从请求中可以解析出三部分内容，分别是<code>localhost:8080</code>、<code>web-demo</code>、<code>demo1</code><ul><li>根据<code>localhost:8080</code>可以找到要访问的Tomcat Web服务器</li><li>根据<code>web-demo</code>可以找到部署在Tomcat服务器上的web-demo项目</li><li>根据<code>demo1</code>可以找到要访问的是项目中的哪个Servlet类，根据@WebServlet后面的值进行匹配</li></ul></li><li>找到ServletDemo1这个类后，Tomcat Web服务器就会为ServletDemo1这个类创建一个对象，然后调用对象中的service方法<ul><li>ServletDemo1实现了Servlet接口，所以类中必然会重写service方法供Tomcat Web服务器进行调用</li><li>service方法中有ServletRequest和ServletResponse两个参数，ServletRequest封装的是请求数据，ServletResponse封装的是响应数据，后期我们可以通过这两个参数实现前后端的数据交互</li></ul></li></ul><p><strong>小结</strong></p><p>介绍完Servlet的执行流程，需要大家掌握两个问题：</p><ol><li>Servlet由谁创建?Servlet方法由谁调用?</li></ol><blockquote><p>Servlet由web服务器创建，Servlet方法由web服务器调用</p></blockquote><ol start="2"><li>服务器怎么知道Servlet中一定有service方法?</li></ol><blockquote><p>因为我们自定义的Servlet,必须实现Servlet接口并复写其方法，而Servlet接口中有service方法</p></blockquote><h3 id="4-4-生命周期"><a href="#4-4-生命周期" class="headerlink" title="4.4 生命周期"></a>4.4 生命周期</h3><p>介绍完Servlet的执行流程后，我们知道Servlet是由Tomcat Web服务器帮我们创建的。</p><p>接下来咱们再来思考一个问题:&#x3D;&#x3D;Tomcat什么时候创建的Servlet对象?&#x3D;&#x3D;</p><p>要想回答上述问题，我们就需要对Servlet的生命周期进行一个学习。</p><ul><li><p>生命周期: 对象的生命周期指一个对象从被创建到被销毁的整个过程。</p></li><li><p>Servlet运行在Servlet容器(web服务器)中，其生命周期由容器来管理，分为4个阶段：</p><ol><li>加载和实例化：默认情况下，当Servlet第一次被访问时，由容器创建Servlet对象</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">默认情况，Servlet会在第一次访问被容器创建，但是如果创建Servlet比较耗时的话，那么第一个访问的人等待的时间就比较长，用户的体验就比较差，那么我们能不能把Servlet的创建放到服务器启动的时候来创建，具体如何来配置?</span><br><span class="line"></span><br><span class="line">@WebServlet(urlPatterns = &quot;/demo1&quot;,loadOnStartup = 1)</span><br><span class="line">loadOnstartup的取值有两类情况</span><br><span class="line">（1）负整数:第一次访问时创建Servlet对象</span><br><span class="line">（2）0或正整数:服务器启动时创建Servlet对象，数字越小优先级越高</span><br></pre></td></tr></table></figure><ol start="2"><li>初始化 init()：在Servlet实例化之后，容器将调用Servlet的 <em><strong>init()</strong></em> 方法初始化这个对象，完成一些如加载配置文件、创建连接等初始化的工作。该方法只会调用一次</li><li>请求处理：每次请求Servlet时，Servlet容器都会调用Servlet的  <em><strong>service()</strong></em>  方法对请求进行处理</li><li>服务终止：当需要释放内存或者容器关闭时，容器就会调用Servlet实例的  <em><strong>destroy()</strong></em>  方法完成资源的释放。在**<em>destroy()</em> **  方法调用之后，容器会释放这个Servlet实例，该实例随后会被Java的垃圾收集器所回收</li></ol></li><li><p>通过案例演示下上述的生命周期</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Servlet生命周期方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/demo2&quot;,loadOnStartup = 1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo2</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  初始化方法</span></span><br><span class="line"><span class="comment">     *  1.调用时机：默认情况下，Servlet被第一次访问时，调用</span></span><br><span class="line"><span class="comment">     *    loadOnStartup: 默认为-1，修改为0或者正整数，则会在服务器启动的时候，调用</span></span><br><span class="line"><span class="comment">     *  2.调用次数: 1次</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> config</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ServletException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供服务</span></span><br><span class="line"><span class="comment">     * 1.调用时机:每一次Servlet被访问时，调用</span></span><br><span class="line"><span class="comment">     * 2.调用次数: 多次</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> req</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> res</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ServletException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest req, ServletResponse res)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;servlet hello world~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 销毁方法</span></span><br><span class="line"><span class="comment">     * 1.调用时机：内存释放或者服务器关闭的时候，Servlet对象会被销毁，调用</span></span><br><span class="line"><span class="comment">     * 2.调用次数: 1次</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;destroy...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> ServletConfig <span class="title function_">getServletConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getServletInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;注意:如何才能让Servlet中的destroy方法被执行？&#x3D;&#x3D;</p></li></ul><p>在Terminal命令行中，先使用<code>mvn tomcat7:run</code>启动，然后再使用<code>ctrl+c</code>关闭tomcat</p><p><strong>小结</strong></p><p>这节中需要掌握的内容是:</p><ol><li>Servlet对象在什么时候被创建的?</li></ol><blockquote><p>默认是第一次访问的时候被创建，可以使用@WebServlet(urlPatterns &#x3D; “&#x2F;demo2”,loadOnStartup &#x3D; 1)的loadOnStartup 修改成在服务器启动的时候创建。</p></blockquote><ol start="2"><li>Servlet生命周期中涉及到的三个方法，这三个方法是什么?什么时候被调用?调用几次?</li></ol><blockquote><p>涉及到三个方法，分别是 init()、service()、destroy()</p><p>init方法在Servlet对象被创建的时候执行，只执行1次</p><p>service方法在Servlet被访问的时候调用，每访问1次就调用1次</p><p>destroy方法在Servlet对象被销毁的时候调用，只执行1次</p></blockquote><h3 id="4-5-五种方法介绍"><a href="#4-5-五种方法介绍" class="headerlink" title="4.5 五种方法介绍"></a>4.5 五种方法介绍</h3><p>Servlet中总共有5个方法，我们已经介绍过其中的三个，剩下的两个方法作用分别是什么？</p><p>我们先来回顾下前面讲的三个方法，分别是:</p><ul><li>初始化方法，在Servlet被创建时执行，只执行一次</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig config)</span> </span><br></pre></td></tr></table></figure><ul><li>提供服务方法， 每次Servlet被访问，都会调用该方法</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest req, ServletResponse res)</span></span><br></pre></td></tr></table></figure><ul><li>销毁方法，当Servlet被销毁时，调用该方法。在内存释放或服务器关闭时销毁Servlet</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> </span><br></pre></td></tr></table></figure><p>剩下的两个方法是:</p><ul><li>获取Servlet信息</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String <span class="title function_">getServletInfo</span><span class="params">()</span> </span><br><span class="line"><span class="comment">//该方法用来返回Servlet的相关信息，没有什么太大的用处，一般我们返回一个空字符串即可</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getServletInfo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>获取ServletConfig对象</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ServletConfig <span class="title function_">getServletConfig</span><span class="params">()</span></span><br></pre></td></tr></table></figure><p>ServletConfig对象，在init方法的参数中有，而Tomcat Web服务器在创建Servlet对象的时候会调用init方法，必定会传入一个ServletConfig对象，我们只需要将服务器传过来的ServletConfig进行返回即可。具体如何操作?</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Servlet方法介绍</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/demo3&quot;,loadOnStartup = 1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo3</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServletConfig servletConfig;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  初始化方法</span></span><br><span class="line"><span class="comment">     *  1.调用时机：默认情况下，Servlet被第一次访问时，调用</span></span><br><span class="line"><span class="comment">     *      * loadOnStartup: 默认为-1，修改为0或者正整数，则会在服务器启动的时候，调用</span></span><br><span class="line"><span class="comment">     *  2.调用次数: 1次</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> config</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ServletException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        <span class="built_in">this</span>.servletConfig = config;</span><br><span class="line">        System.out.println(<span class="string">&quot;init...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> ServletConfig <span class="title function_">getServletConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> servletConfig;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供服务</span></span><br><span class="line"><span class="comment">     * 1.调用时机:每一次Servlet被访问时，调用</span></span><br><span class="line"><span class="comment">     * 2.调用次数: 多次</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> req</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> res</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ServletException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest req, ServletResponse res)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;servlet hello world~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 销毁方法</span></span><br><span class="line"><span class="comment">     * 1.调用时机：内存释放或者服务器关闭的时候，Servlet对象会被销毁，调用</span></span><br><span class="line"><span class="comment">     * 2.调用次数: 1次</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;destroy...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getServletInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getServletInfo()和getServletConfig()这两个方法使用的不是很多，大家了解下。</p><h3 id="4-6-书写规范：Servlet体系结构-简化作用"><a href="#4-6-书写规范：Servlet体系结构-简化作用" class="headerlink" title="4.6 书写规范：Servlet体系结构(简化作用)"></a>4.6 书写规范：Servlet体系结构(简化作用)</h3><p><strong><u>作用：继承 HttpServlet ，判断七种请求方式  （HttpServlet实现类  内部已将请求方式处理逻辑完成）</u></strong></p><p>通过上面的学习，我们知道要想编写一个Servlet就必须要实现Servlet接口，重写接口中的5个方法，虽然已经能完成要求，但是编写起来还是比较麻烦的，因为我们更关注的其实只有service方法，那有没有更简单方式来创建Servlet呢?</p><p>要想解决上面的问题，我们需要先对Servlet的体系结构进行下了解:</p><p><strong>Servlet的体系结构</strong></p><p>因为将来开发B&#x2F;S架构的web项目，都是针对HTTP协议，所以自定义Servlet,会通过继承  HttpServlet  。</p><p><strong>具体的编写格式如下:</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/demo4&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo4</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//TODO GET 请求方式处理逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;get...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//TODO Post 请求方式处理逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;post...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>要想发送一个GET请求，请求该Servlet，只需要通过浏览器发送<code>http://localhost:8080/web-demo/demo4</code>,就能看到doGet方法被执行了</li><li>要想发送一个POST请求，请求该Servlet，单单通过浏览器是无法实现的，这个时候就需要编写一个form表单来发送请求，在webapp下创建一个<code>a.html</code>页面，内容如下:</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/web-demo/demo4&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>/&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>启动测试，即可看到doPost方法被执行了。</p><p><strong>Servlet的简化编写就介绍完了，接着需要思考两个问题:</strong></p><ol><li>HttpServlet中为什么要根据请求方式的不同，调用不同的方法?</li><li>如何调用?</li></ol><p>针对问题一，我们需要回顾之前的知识点&#x3D;&#x3D;前端发送GET和POST请求的时候，参数的位置不一致，GET请求参数在请求行中，POST请求参数在请求体中&#x3D;&#x3D;，为了能处理不同的请求方式，我们得在service方法中进行判断，然后写不同的业务处理，这样能实现，但是每个Servlet类中都将有相似的代码，针对这个问题，有什么可以优化的策略么?</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(&quot;/demo5&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo5</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ServletConfig <span class="title function_">getServletConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest req, ServletResponse res)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//如何调用?</span></span><br><span class="line">        <span class="comment">//获取请求方式，根据不同的请求方式进行不同的业务处理</span></span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> (HttpServletRequest)req;</span><br><span class="line">       <span class="comment">//1. 获取请求方式</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> request.getMethod();</span><br><span class="line">        <span class="comment">//2. 判断</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;GET&quot;</span>.equals(method))&#123;</span><br><span class="line">            <span class="comment">// get方式的处理逻辑</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;POST&quot;</span>.equals(method))&#123;</span><br><span class="line">            <span class="comment">// post方式的处理逻辑</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getServletInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>要解决上述问题，我们可以对Servlet接口进行继承封装，来简化代码开发。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyHttpServlet</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ServletConfig <span class="title function_">getServletConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest req, ServletResponse res)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> (HttpServletRequest)req;</span><br><span class="line">        <span class="comment">//1. 获取请求方式</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> request.getMethod();</span><br><span class="line">        <span class="comment">//2. 判断</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;GET&quot;</span>.equals(method))&#123;</span><br><span class="line">            <span class="comment">// get方式的处理逻辑</span></span><br><span class="line">            doGet(req,res);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;POST&quot;</span>.equals(method))&#123;</span><br><span class="line">            <span class="comment">// post方式的处理逻辑</span></span><br><span class="line">            doPost(req,res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(ServletRequest req, ServletResponse res)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(ServletRequest req, ServletResponse res)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getServletInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>有了MyHttpServlet这个类，以后我们再编写Servlet类的时候，只需要继承MyHttpServlet，重写父类中的doGet和doPost方法，就可以用来处理GET和POST请求的业务逻辑。接下来，可以把ServletDemo5代码进行改造</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/demo5&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo5</span> <span class="keyword">extends</span> <span class="title class_">MyHttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(ServletRequest req, ServletResponse res)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;get...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(ServletRequest req, ServletResponse res)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;post...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>将来页面发送的是GET请求，则会进入到doGet方法中进行执行，如果是POST请求，则进入到doPost方法。这样代码在编写的时候就相对来说更加简单快捷。</p><p>类似MyHttpServlet这样的类Servlet中已经为我们提供好了，就是HttpServlet,翻开源码，大家可以搜索<code>service()</code>方法，你会发现HttpServlet做的事更多，不仅可以处理GET和POST还可以处理其他五种请求方式。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span><br><span class="line">        <span class="keyword">throws</span> ServletException, IOException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> req.getMethod();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (method.equals(METHOD_GET)) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">lastModified</span> <span class="operator">=</span> getLastModified(req);</span><br><span class="line">            <span class="keyword">if</span> (lastModified == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// servlet doesn&#x27;t support if-modified-since, no reason</span></span><br><span class="line">                <span class="comment">// to go through further expensive logic</span></span><br><span class="line">                doGet(req, resp);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">ifModifiedSince</span> <span class="operator">=</span> req.getDateHeader(HEADER_IFMODSINCE);</span><br><span class="line">                <span class="keyword">if</span> (ifModifiedSince &lt; lastModified) &#123;</span><br><span class="line">                    <span class="comment">// If the servlet mod time is later, call doGet()</span></span><br><span class="line">                    <span class="comment">// Round down to the nearest second for a proper compare</span></span><br><span class="line">                    <span class="comment">// A ifModifiedSince of -1 will always be less</span></span><br><span class="line">                    maybeSetLastModified(resp, lastModified);</span><br><span class="line">                    doGet(req, resp);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_HEAD)) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">lastModified</span> <span class="operator">=</span> getLastModified(req);</span><br><span class="line">            maybeSetLastModified(resp, lastModified);</span><br><span class="line">            doHead(req, resp);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_POST)) &#123;</span><br><span class="line">            doPost(req, resp);</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_PUT)) &#123;</span><br><span class="line">            doPut(req, resp);</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_DELETE)) &#123;</span><br><span class="line">            doDelete(req, resp);</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_OPTIONS)) &#123;</span><br><span class="line">            doOptions(req,resp);</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_TRACE)) &#123;</span><br><span class="line">            doTrace(req,resp);</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// Note that this means NO servlet supports whatever</span></span><br><span class="line">            <span class="comment">// method was requested, anywhere on this server.</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">errMsg</span> <span class="operator">=</span> lStrings.getString(<span class="string">&quot;http.method_not_implemented&quot;</span>);</span><br><span class="line">            Object[] errArgs = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">1</span>];</span><br><span class="line">            errArgs[<span class="number">0</span>] = method;</span><br><span class="line">            errMsg = MessageFormat.format(errMsg, errArgs);</span><br><span class="line">            </span><br><span class="line">            resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>小结</strong></p><p>通过这一节的学习，要掌握:</p><ol><li>HttpServlet的使用步骤</li></ol><blockquote><p><u>继承HttpServlet</u></p><p><u>重写doGet和doPost方法</u></p></blockquote><ol start="2"><li>HttpServlet原理</li></ol><blockquote><p><u>官方定义获取请求方式，并根据不同的请求方式，调用不同的doXxx方法</u></p></blockquote><h3 id="4-7-urlPattern配置"><a href="#4-7-urlPattern配置" class="headerlink" title="4.7 urlPattern配置"></a>4.7 urlPattern配置</h3><p>Servlet类编写好后，要想被访问到，就需要配置其访问路径（&#x3D;&#x3D;urlPattern&#x3D;&#x3D;）</p><ul><li><p>一个Servlet,可以配置多个urlPattern</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.web;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">import</span> javax.servlet.ServletRequest;</span><br><span class="line">  <span class="keyword">import</span> javax.servlet.ServletResponse;</span><br><span class="line">  <span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * urlPattern: 一个Servlet可以配置多个访问路径</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="meta">@WebServlet(urlPatterns = &#123;&quot;/demo7&quot;,&quot;/demo8&quot;&#125;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo7</span> <span class="keyword">extends</span> <span class="title class_">MyHttpServlet</span> &#123;</span><br><span class="line">  </span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(ServletRequest req, ServletResponse res)</span> &#123;</span><br><span class="line">          </span><br><span class="line">          System.out.println(<span class="string">&quot;demo7 get...&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(ServletRequest req, ServletResponse res)</span> &#123;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>在浏览器上输入<code>http://localhost:8080/web-demo/demo7</code>,<code>http://localhost:8080/web-demo/demo8</code>这两个地址都能访问到ServletDemo7的doGet方法。</p></li><li><p>&#x3D;&#x3D;urlPattern配置规则&#x3D;&#x3D;</p><ul><li><p>精确匹配</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * UrlPattern:</span></span><br><span class="line"><span class="comment">   * * 精确匹配</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@WebServlet(urlPatterns = &quot;/user/select&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo8</span> <span class="keyword">extends</span> <span class="title class_">MyHttpServlet</span> &#123;</span><br><span class="line">  </span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(ServletRequest req, ServletResponse res)</span> &#123;</span><br><span class="line">  </span><br><span class="line">          System.out.println(<span class="string">&quot;demo8 get...&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(ServletRequest req, ServletResponse res)</span> &#123;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>访问路径<code>http://localhost:8080/web-demo/user/select</code></p></li><li><p>目录匹配</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.web;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">import</span> javax.servlet.ServletRequest;</span><br><span class="line">  <span class="keyword">import</span> javax.servlet.ServletResponse;</span><br><span class="line">  <span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * UrlPattern:</span></span><br><span class="line"><span class="comment">   * * 目录匹配: /user/*</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@WebServlet(urlPatterns = &quot;/user/*&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo9</span> <span class="keyword">extends</span> <span class="title class_">MyHttpServlet</span> &#123;</span><br><span class="line">  </span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(ServletRequest req, ServletResponse res)</span> &#123;</span><br><span class="line">  </span><br><span class="line">          System.out.println(<span class="string">&quot;demo9 get...&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(ServletRequest req, ServletResponse res)</span> &#123;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>访问路径<code>http://localhost:8080/web-demo/user/任意</code></p><p>&#x3D;&#x3D;思考:&#x3D;&#x3D;</p><ol><li>访问路径<code>http://localhost:8080/web-demo/user</code>是否能访问到demo9的doGet方法?</li></ol></li></ul><ol start="2"><li>访问路径<code>http://localhost:8080/web-demo/user/a/b</code>是否能访问到demo9的doGet方法?</li><li>访问路径<code>http://localhost:8080/web-demo/user/select</code>是否能访问到demo9还是demo8的doGet方法?</li></ol><p>  答案是: 能、能、demo8，进而我们可以得到的结论是<code>/user/*</code>中的<code>/*</code>代表的是零或多个层级访问目录同时精确匹配优先级要高于目录匹配。</p><ul><li><p>扩展名匹配</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.web;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">import</span> javax.servlet.ServletRequest;</span><br><span class="line">  <span class="keyword">import</span> javax.servlet.ServletResponse;</span><br><span class="line">  <span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * UrlPattern:</span></span><br><span class="line"><span class="comment">   * * 扩展名匹配: *.do</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@WebServlet(urlPatterns = &quot;*.do&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo10</span> <span class="keyword">extends</span> <span class="title class_">MyHttpServlet</span> &#123;</span><br><span class="line">  </span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(ServletRequest req, ServletResponse res)</span> &#123;</span><br><span class="line">  </span><br><span class="line">          System.out.println(<span class="string">&quot;demo10 get...&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(ServletRequest req, ServletResponse res)</span> &#123;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>访问路径<code>http://localhost:8080/web-demo/任意.do</code></p><p>&#x3D;&#x3D;注意&#x3D;&#x3D;:</p><ol><li><p>如果路径配置的不是扩展名，那么在路径的前面就必须要加<code>/</code>否则会报错</p></li><li><p>如果路径配置的是<code>*.do</code>,那么在*.do的前面不能加<code>/</code>,否则会报错</p></li></ol></li><li><p>任意匹配</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * UrlPattern:</span></span><br><span class="line"><span class="comment"> * * 任意匹配： /</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo11</span> <span class="keyword">extends</span> <span class="title class_">MyHttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(ServletRequest req, ServletResponse res)</span> &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;demo11 get...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(ServletRequest req, ServletResponse res)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问路径<code>http://localhost:8080/demo-web/任意</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * UrlPattern:</span></span><br><span class="line"><span class="comment"> * * 任意匹配： /*</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/*&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo12</span> <span class="keyword">extends</span> <span class="title class_">MyHttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(ServletRequest req, ServletResponse res)</span> &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;demo12 get...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(ServletRequest req, ServletResponse res)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>访问路径&#96;<a href="http://localhost:8080/demo-web/%E4%BB%BB%E6%84%8F">http://localhost:8080/demo-web/任意</a></p><p>&#x3D;&#x3D;注意:&#x3D;&#x3D;<code>/</code>和<code>/*</code>的区别?</p><ol><li><p>当我们的项目中的Servlet配置了 “&#x2F;“,会覆盖掉tomcat中的DefaultServlet,当其他的url-pattern都匹配不上时都会走这个Servlet</p></li><li><p>当我们的项目中配置了”&#x2F;*”,意味着匹配任意访问路径</p></li><li><p>DefaultServlet是用来处理静态资源，如果配置了”&#x2F;“会把默认的覆盖掉，就会引发请求静态资源的时候没有走默认的而是走了自定义的Servlet类，最终导致静态资源不能被访问</p></li></ol></li></ul></li></ul><p><strong>小结</strong></p><ol><li><p>urlPattern总共有四种配置方式，分别是精确匹配、目录匹配、扩展名匹配、任意匹配</p></li><li><p>五种配置的优先级为 精确匹配 &gt; 目录匹配&gt; 扩展名匹配 &gt; &#x2F;* &gt; &#x2F; ,无需记，以最终运行结果为准。</p></li></ol><h3 id="4-8-XML配置"><a href="#4-8-XML配置" class="headerlink" title="4.8 XML配置"></a>4.8 XML配置</h3><p>前面对应Servlet的配置，我们都使用的是@WebServlet,这个是Servlet从3.0版本后开始支持注解配置，3.0版本前只支持XML配置文件的配置方法。</p><p>对于XML的配置步骤有两步:</p><ul><li>编写Servlet类</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo13</span> <span class="keyword">extends</span> <span class="title class_">MyHttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(ServletRequest req, ServletResponse res)</span> &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;demo13 get...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(ServletRequest req, ServletResponse res)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在web.xml中配置该Servlet</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">        Servlet 全类名</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- servlet的名称，名字任意--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>demo13<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--servlet的类全名--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.itheima.web.ServletDemo13<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">        Servlet 访问路径</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- servlet的名称，要和上面的名称一致--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>demo13<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- servlet的访问路径--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/demo13<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这种配置方式和注解比起来，确认麻烦很多，所以建议大家使用注解来开发。但是大家要认识上面这种配置方式，因为并不是所有的项目都是基于注解开发的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> HTTP,Tomcat,Servlet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript</title>
      <link href="/post/cc1b9611.html"/>
      <url>/post/cc1b9611.html</url>
      
        <content type="html"><![CDATA[<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><p><strong>今日目标</strong></p><blockquote><ul><li>掌握 JavaScript 的基础语法</li><li>掌握 JavaScript 的常用对象（Array、String）</li><li>能根据需求灵活运用定时器及通过 js 代码进行页面跳转</li><li>能通过DOM 对象对标签进行常规操作</li><li>掌握常用的事件</li><li>能独立完成表单校验案例</li></ul></blockquote><h2 id="1，JavaScript简介"><a href="#1，JavaScript简介" class="headerlink" title="1，JavaScript简介"></a>1，JavaScript简介</h2><p>&#x3D;&#x3D;JavaScript 是一门跨平台、面向对象的脚本语言&#x3D;&#x3D;，而Java语言也是跨平台的、面向对象的语言，只不过Java是编译语言，是需要编译成字节码文件才能运行的；JavaScript是脚本语言，不需要编译，由浏览器直接解析并执行。</p><p>JavaScript 是用来控制网页行为的，它能使网页可交互；那么它可以做什么呢？如改变页面内容、修改指定元素的属性值、对表单进行校验等，下面是这些功能的效果展示：</p><ul><li><p><strong>改变页面内容</strong></p></li><li><p><strong>修改指定元素的属性值</strong></p></li><li><p><strong>对表单进行校验</strong></p></li></ul><p>JavaScript 和 Java 是完全不同的语言，不论是概念还是设计，只是名字比较像而已。但是&#x3D;&#x3D;基础语法类似&#x3D;&#x3D;，所以我们有java的学习经验，再学习JavaScript 语言就相对比较容易些。</p><p>JavaScript（简称：JS） 在 1995 年由 Brendan Eich 发明，并于 1997 年成为一部 ECMA 标准。ECMA 规定了一套标准 就叫 <code>ECMAScript</code> ，所有的客户端校验语言必须遵守这个标准，当然 JavaScript 也遵守了这个标准。ECMAScript 6 (简称ES6) 是最新的 JavaScript 版本（发布于 2015 年)，我们的课程就是基于最新的 <code>ES6</code> 进行讲解。</p><h2 id="2，JavaScript引入方式"><a href="#2，JavaScript引入方式" class="headerlink" title="2，JavaScript引入方式"></a>2，JavaScript引入方式</h2><p>JavaScript 引入方式就是 HTML 和 JavaScript 的结合方式。JavaScript引入方式有两种：</p><ul><li>内部脚本：将 JS代码定义在HTML页面中</li><li>外部脚本：将 JS代码定义在外部 JS文件中，然后引入到 HTML页面中</li></ul><h3 id="2-1-内部脚本"><a href="#2-1-内部脚本" class="headerlink" title="2.1  内部脚本"></a>2.1  内部脚本</h3><p>在 HTML 中，JavaScript 代码必须位于 <code>&lt;script&gt;</code> 与 <code>&lt;/script&gt;</code> 标签之间</p><p><strong>代码如下：</strong></p><p><code>alert(数据)</code> 是 JavaScript 的一个方法，作用是将参数数据以浏览器弹框的形式输出出来。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(<span class="string">&quot;hello js1&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>&#x3D;&#x3D;提示：&#x3D;&#x3D;</p><ul><li><p>在 HTML 文档中可以在任意地方，放置任意数量的<script>标签。如下图</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(<span class="string">&quot;hello js1&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(<span class="string">&quot;hello js1&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(<span class="string">&quot;hello js1&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>一般把脚本置于 <body> 元素的底部，可改善显示速度</p><p>因为浏览器在加载页面的时候会从上往下进行加载并解析。 我们应该让用户看到页面内容，然后再展示动态的效果。</p></li></ul></blockquote><h3 id="2-2-外部脚本"><a href="#2-2-外部脚本" class="headerlink" title="2.2  外部脚本"></a>2.2  外部脚本</h3><p><strong>第一步：定义外部 js 文件。如定义名为 demo.js的文件</strong></p><p>demo.js 文件内容如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">alert</span>(<span class="string">&quot;hello js&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>第二步：在页面中引入外部的js文件</strong></p><p>在页面使用 <code>script</code> 标签中使用 <code>src</code> 属性指定 js 文件的 URL 路径。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/demo.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>==注意：==</p><ul><li><p>外部脚本不能包含 <code>&lt;script&gt;</code> 标签</p><p>在js文件中直接写 js 代码即可，不要在 js文件 中写 <code>script</code> 标签</p></li><li><p><code>&lt;script&gt;</code> 标签不能自闭合</p><p>在页面中引入外部js文件时，不能写成 <code>&lt;script src=&quot;../js/demo.js&quot; /&gt;</code>。</p></li></ul></blockquote><h2 id="3，JavaScript基础语法"><a href="#3，JavaScript基础语法" class="headerlink" title="3，JavaScript基础语法"></a>3，JavaScript基础语法</h2><h3 id="3-1-书写语法"><a href="#3-1-书写语法" class="headerlink" title="3.1  书写语法"></a>3.1  书写语法</h3><ul><li><p>区分大小写：与 Java 一样，变量名、函数名以及其他一切东西都是区分大小写的</p></li><li><p>每行结尾的分号可有可无</p><p>如果一行上写多个语句时，必须加分号用来区分多个语句。</p></li><li><p>注释</p><ul><li>单行注释：// 注释内容</li><li>多行注释：/* 注释内容 */</li></ul><blockquote><p>注意：JavaScript 没有文档注释</p></blockquote></li><li><p>大括号表示代码块</p><p>下面语句大家肯定能看懂，和 java 一样 大括号表示代码块。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (count == <span class="number">3</span>) &#123; </span><br><span class="line">   <span class="title function_">alert</span>(count); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li></ul><h3 id="3-2-输出语句"><a href="#3-2-输出语句" class="headerlink" title="3.2  输出语句"></a>3.2  输出语句</h3><p>js 可以通过以下方式进行内容的输出，只不过不同的语句输出到的位置不同</p><ul><li><p><strong>使用 window.alert() 写入警告框</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="title function_">alert</span>(<span class="string">&quot;hello js&quot;</span>);<span class="comment">//写入警告框</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>使用 document.write() 写入 HTML 输出</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;hello js 2~&quot;</span>);<span class="comment">//写入html页面</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>使用 console.log() 写入浏览器控制台</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello js 3&quot;</span>);<span class="comment">//写入浏览器的控制台</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面代码通过浏览器打开，我们可以在不能页面上看到  <code>console.log(内容)</code> 输出的内容，它是输出在控制台了，而怎么在控制台查看输出的内容呢？在浏览器界面按 <code>F12</code> 就可以看到下图的控制台</p></li></ul><h3 id="3-3-变量"><a href="#3-3-变量" class="headerlink" title="3.3  变量"></a>3.3  变量</h3><p>JavaScript 中用 <code>var </code>关键字（variable 的缩写）来声明变量。格式 <code>var 变量名 = 数据值;</code>。而在JavaScript 是一门弱类型语言，变量==可以存放不同类型的值==；如下在定义变量时赋值为数字数据，还可以将变量的值改为字符串类型的数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="number">20</span>;</span><br><span class="line">test = <span class="string">&quot;张三&quot;</span>;</span><br></pre></td></tr></table></figure><p>js 中的变量名命名也有如下规则，和java语言基本都相同</p><ul><li>组成字符可以是任何字母、数字、下划线（_）或美元符号（$）</li><li>数字不能开头</li><li>建议使用驼峰命名</li></ul><p>JavaScript 中 <code>var</code> 关键字有点特殊，有以下地方和其他语言不一样</p><ul><li><p>作用域：全局变量</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">alert</span>(age);  <span class="comment">// 在代码块中定义的age 变量，在代码块外边还可以使用</span></span><br></pre></td></tr></table></figure></li><li><p>变量可以重复定义</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">30</span>;<span class="comment">//JavaScript 会用 30 将之前 age 变量的 20 替换掉</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">alert</span>(age); <span class="comment">//打印的结果是 30</span></span><br></pre></td></tr></table></figure></li></ul><p>针对如上的问题，==ECMAScript 6 新增了 <code>let </code>关键字来定义变量。==它的用法类似于 <code>var</code>，但是==所声明的变量，只在 <code>let</code> 关键字所在的代码块内有效，且不允许重复声明==。</p><p>例如：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> age = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">alert</span>(age); </span><br></pre></td></tr></table></figure><p>运行上面代码，浏览器并没有弹框输出结果，说明这段代码是有问题的。通过 <code>F12</code> 打开开发者模式可以看到错误信息。</p><p>而如果在代码块中定义两个同名的变量，IDEA 开发工具就直接报错了</p><p>==ECMAScript 6 新增了 <code>const</code>关键字，用来声明一个只读的常量。一旦声明，常量的值就不能改变。== </p><p>给这个常量重新赋值时会报错。</p><h3 id="3-4-数据类型"><a href="#3-4-数据类型" class="headerlink" title="3.4  数据类型"></a>3.4  数据类型</h3><p>JavaScript 中提供了两类数据类型：原始类型 和 引用类型。</p><blockquote><p>使用 typeof 运算符可以获取数据类型</p><p><code>alert(typeof age);</code> 以弹框的形式将 age 变量的数据类型输出</p></blockquote><p>原始数据类型：</p><ul><li><p><strong>number</strong>：数字（整数、小数、NaN(Not a Number)）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> price = <span class="number">99.8</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(<span class="keyword">typeof</span> age); <span class="comment">// 结果是 ： number</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="keyword">typeof</span> price);<span class="comment">// 结果是 ： number</span></span><br></pre></td></tr></table></figure><blockquote><p>==注意：== NaN是一个特殊的number类型的值，后面用到再说</p></blockquote></li><li><p><strong>string</strong>：字符、字符串，单双引皆可</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ch = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;张三&#x27;</span>; </span><br><span class="line"><span class="keyword">var</span> addr = <span class="string">&quot;北京&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(<span class="keyword">typeof</span> ch); <span class="comment">//结果是  string</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="keyword">typeof</span> name); <span class="comment">//结果是  string</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="keyword">typeof</span> addr); <span class="comment">//结果是  string</span></span><br></pre></td></tr></table></figure><blockquote><p>==注意：==在 js 中 双引号和单引号都表示字符串类型的数据</p></blockquote></li><li><p><strong>boolean</strong>：布尔。true，false</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> flag2 = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(<span class="keyword">typeof</span> flag); <span class="comment">//结果是 boolean</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="keyword">typeof</span> flag2); <span class="comment">//结果是 boolean</span></span><br></pre></td></tr></table></figure></li><li><p><strong>null</strong>：对象为空</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(<span class="keyword">typeof</span> obj);<span class="comment">//结果是 object</span></span><br></pre></td></tr></table></figure><p>为什么打印上面的 obj 变量的数据类型，结果是object；这个官方给出了解释，</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">历史上，JavaScript 中的 null 被错误地标识为一个对象（object），但实际上它是一个特殊的原始值，表示一个空对象指针。这个问题在 JavaScript 的早期版本中就存在，并为了保持向后兼容性，不能修复。</span><br></pre></td></tr></table></figure></li><li><p><strong>undefined</strong>：当声明的变量未初始化时，该变量的默认值是 undefined</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a ;</span><br><span class="line"><span class="title function_">alert</span>(<span class="keyword">typeof</span> a); <span class="comment">//结果是 undefined</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="3-5-运算符"><a href="#3-5-运算符" class="headerlink" title="3.5  运算符"></a>3.5  运算符</h3><p>JavaScript 提供了如下的运算符。大部分和 Java语言 都是一样的，不同的是 JS 关系运算符中的 <code>==</code> 和 <code>===</code>，一会我们只演示这两个的区别，其他运算符将不做演示</p><ul><li><p>一元运算符：++，--</p></li><li><p>算术运算符：+，-，*，/，%</p></li><li><p>赋值运算符：=，+=，-=…</p></li><li><p>关系运算符：>，<，>=，<=，!=，==，===…</p></li><li><p>逻辑运算符：&&，||，!</p></li><li><p>三元运算符：条件表达式 ? true_value : false_value</p></li></ul><h4 id="3-5-1-和-区别"><a href="#3-5-1-和-区别" class="headerlink" title="3.5.1  == 和 === 区别"></a>3.5.1  == 和 === 区别</h4><p><strong>概述:</strong></p><ul><li><p>==：</p><ol><li><p>判断类型是否一样，如果不一样，则进行类型转换</p></li><li><p>再去比较其值</p></li></ol></li><li><p>===：js 中的全等于</p><ol><li>判断类型是否一样，如果不一样，直接返回false</li><li>再去比较其值</li></ol></li></ul><p><strong>代码：</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> age1 = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> age2 = <span class="string">&quot;20&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(age1 == age2);<span class="comment">// true</span></span><br><span class="line"><span class="title function_">alert</span>(age1 === age2);<span class="comment">// false</span></span><br></pre></td></tr></table></figure><h4 id="3-5-2-类型转换"><a href="#3-5-2-类型转换" class="headerlink" title="3.5.2  类型转换"></a>3.5.2  类型转换</h4><p>上述讲解 <code>==</code> 运算符时，发现会进行类型转换，所以接下来我们来详细的讲解一下 JavaScript 中的类型转换。</p><ul><li><p>其他类型转为number</p><ul><li><p>string 转换为 number 类型：按照字符串的字面值，转为数字。如果字面值不是数字，则转为NaN</p><p>将 string 转换为 number 有两种方式：</p><ul><li><p>使用 <code>+</code> 正号运算符：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = +<span class="string">&quot;20&quot;</span>;</span><br><span class="line"><span class="title function_">alert</span>(str + <span class="number">1</span>) <span class="comment">//21</span></span><br></pre></td></tr></table></figure></li><li><p>使用 <code>parseInt()</code> 函数(方法)：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;20&quot;</span>;</span><br><span class="line"><span class="title function_">alert</span>(<span class="built_in">parseInt</span>(str) + <span class="number">1</span>);</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>==建议使用 <code>parseInt()</code> 函数进行转换。==</p></blockquote></li><li><p>boolean 转换为 number 类型：true 转为1，false转为0</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> flag = +<span class="literal">false</span>;</span><br><span class="line"><span class="title function_">alert</span>(flag); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>其他类型转为boolean</strong></p><ul><li>number 类型转换为 boolean 类型：0和NaN转为false，其他的数字转为true</li><li>string 类型转换为 boolean 类型：空字符串转为false，其他的字符串转为true</li><li>null类型转换为 boolean 类型是 false</li><li>undefined 转换为 boolean 类型是 false</li></ul><p><strong>代码如下：</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// var flag = 3;</span></span><br><span class="line"><span class="comment">// var flag = &quot;&quot;;</span></span><br><span class="line"><span class="keyword">var</span> flag = <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(flag)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;转为true&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;转为false&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>使用场景：</strong></p><p>在 Java 中使用字符串前，一般都会先判断字符串不是null，并且不是空字符才会做其他的一些操作，JavaScript也有类型的操作，代码如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//健壮性判断</span></span><br><span class="line"><span class="keyword">if</span>(str != <span class="literal">null</span> &amp;&amp; str.<span class="property">length</span> &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;转为true&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;转为false&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是由于 JavaScript 会自动进行类型转换，所以上述的判断可以进行简化，代码如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//健壮性判断</span></span><br><span class="line"><span class="keyword">if</span>(str)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;转为true&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;转为false&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-6-流程控制语句"><a href="#3-6-流程控制语句" class="headerlink" title="3.6  流程控制语句"></a>3.6  流程控制语句</h3><p>JavaScript 中提供了和 Java 一样的流程控制语句，如下</p><ul><li>if </li><li>switch</li><li>for</li><li>while</li><li>dowhile</li></ul><h4 id="3-6-1-if-语句"><a href="#3-6-1-if-语句" class="headerlink" title="3.6.1  if 语句"></a>3.6.1  if 语句</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">if</span> (count == <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-6-2-switch-语句"><a href="#3-6-2-switch-语句" class="headerlink" title="3.6.2  switch 语句"></a>3.6.2  switch 语句</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">switch</span> (num) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;星期一&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;星期二&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;星期三&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;星期四&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;星期五&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;星期六&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;星期日&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;输入的星期有误&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-6-3-for-循环语句"><a href="#3-6-3-for-循环语句" class="headerlink" title="3.6.3  for 循环语句"></a>3.6.3  for 循环语句</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123; <span class="comment">//建议for循环小括号中定义的变量使用let</span></span><br><span class="line">    sum += i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">alert</span>(sum);</span><br></pre></td></tr></table></figure><h4 id="3-6-4-while-循环语句"><a href="#3-6-4-while-循环语句" class="headerlink" title="3.6.4  while 循环语句"></a>3.6.4  while 循环语句</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">    sum += i;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">alert</span>(sum);</span><br></pre></td></tr></table></figure><h4 id="3-6-5-dowhile-循环语句"><a href="#3-6-5-dowhile-循环语句" class="headerlink" title="3.6.5  dowhile 循环语句"></a>3.6.5  dowhile 循环语句</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    sum += i;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= <span class="number">100</span>);</span><br><span class="line"><span class="title function_">alert</span>(sum);</span><br></pre></td></tr></table></figure><h3 id="3-7-函数"><a href="#3-7-函数" class="headerlink" title="3.7  函数"></a>3.7  函数</h3><p>函数（就是Java中的方法）是被设计为执行特定任务的代码块；JavaScript 函数通过 function 关键词进行定义。</p><h4 id="3-7-1-定义格式"><a href="#3-7-1-定义格式" class="headerlink" title="3.7.1  定义格式"></a>3.7.1  定义格式</h4><p>函数定义格式有两种：</p><ul><li><p>方式1</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> 函数名(参数<span class="number">1</span>,参数<span class="number">2.</span>.)&#123;</span><br><span class="line">    要执行的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方式2</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 函数名 = <span class="keyword">function</span> (<span class="params">参数列表</span>)&#123;</span><br><span class="line">    要执行的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>==注意：==</p><ul><li><p>形式参数不需要类型。因为JavaScript是弱类型语言</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述函数的参数 a 和 b 不需要定义数据类型，因为在每个参数前加上 var 也没有任何意义。</p></li><li><p>返回值也不需要定义类型，可以在函数内部直接使用return返回即可</p></li></ul></blockquote><h4 id="3-7-2-函数调用"><a href="#3-7-2-函数调用" class="headerlink" title="3.7.2  函数调用"></a>3.7.2  函数调用</h4><p>函数调用函数：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">函数名称(实际参数列表);</span><br></pre></td></tr></table></figure><p>eg：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="title function_">add</span>(<span class="number">10</span>,<span class="number">20</span>);</span><br></pre></td></tr></table></figure><blockquote><p>==注意：==</p><ul><li><p>JS中，函数调用可以传递任意个数参数</p></li><li><p>例如  <code>let result = add(1,2,3);</code> </p><p>它是将数据 1 传递给了变量a，将数据 2 传递给了变量 b，而数据 3 没有变量接收。</p></li></ul></blockquote><h2 id="4，JavaScript常用对象"><a href="#4，JavaScript常用对象" class="headerlink" title="4，JavaScript常用对象"></a>4，JavaScript常用对象</h2><p>JavaScript 提供了很多对象供使用者来使用。这些对象总共分类三类</p><ul><li><p>基本对象</p></li><li><p>BOM 对象</p></li><li><p>DOM对象</p><p>DOM 中的对象就比较多了</p></li></ul><p>这小节先学习基本对象，而我们先学习 <code>Array</code> 数组对象和 <code>String</code> 字符串对象。</p><h3 id="4-1-Array对象"><a href="#4-1-Array对象" class="headerlink" title="4.1  Array对象"></a>4.1  Array对象</h3><p>JavaScript Array对象用于定义数组</p><h4 id="4-1-1-定义格式"><a href="#4-1-1-定义格式" class="headerlink" title="4.1.1  定义格式"></a>4.1.1  定义格式</h4><p>数组的定义格式有两种：</p><ul><li><p>方式1</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 = <span class="keyword">new</span> <span class="title class_">Array</span>(元素列表); </span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>); <span class="comment">//1,2,3 是存储在数组中的数据（元素）</span></span><br></pre></td></tr></table></figure></li><li><p>方式2</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 = [元素列表];</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]; <span class="comment">//1,2,3 是存储在数组中的数据（元素）</span></span><br></pre></td></tr></table></figure><p>==注意：Java中的数组静态初始化使用的是{}定义，而 JavaScript 中使用的是 [] 定义==</p></li></ul><h4 id="4-1-2-元素访问"><a href="#4-1-2-元素访问" class="headerlink" title="4.1.2  元素访问"></a>4.1.2  元素访问</h4><p>访问数组中的元素和 Java 语言的一样，格式如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr[索引] = 值;</span><br></pre></td></tr></table></figure><p><strong>代码演示：</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 方式一</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="comment">// alert(arr);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二</span></span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="comment">//alert(arr2);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问</span></span><br><span class="line">arr2[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line"><span class="title function_">alert</span>(arr2)</span><br></pre></td></tr></table></figure><h4 id="4-1-3-特点"><a href="#4-1-3-特点" class="headerlink" title="4.1.3  特点"></a>4.1.3  特点</h4><p>JavaScript 中的数组相当于 Java 中集合。数组的长度是可以变化的，而 JavaScript 是弱类型，所以可以存储任意的类型的数据。</p><p>例如如下代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 变长</span></span><br><span class="line"><span class="keyword">var</span> arr3 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">arr3[<span class="number">10</span>] = <span class="number">10</span>;</span><br><span class="line"><span class="title function_">alert</span>(arr3[<span class="number">10</span>]); <span class="comment">// 10</span></span><br><span class="line"><span class="title function_">alert</span>(arr3[<span class="number">9</span>]);  <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure><p>上面代码在定义数组中给了三个元素，又给索引是 10 的位置添加了数据 10，那么 <code>索引3</code> 到 <code>索引9</code> 位置的元素是什么呢？我们之前就介绍了，在 JavaScript 中没有赋值的话，默认就是 <code>undefined</code>。</p><p>如果给 <code>arr3</code> 数组添加字符串的数据，也是可以添加成功的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr3[<span class="number">5</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="title function_">alert</span>(arr3[<span class="number">5</span>]); <span class="comment">// hello</span></span><br></pre></td></tr></table></figure><h4 id="4-1-4-属性"><a href="#4-1-4-属性" class="headerlink" title="4.1.4  属性"></a>4.1.4  属性</h4><p>Array 对象提供了很多属性, 只讲解 <code>length</code> 属性，该数组可以动态的获取数组的长度。而有这个属性，我们就可以遍历数组了</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-1-5-方法"><a href="#4-1-5-方法" class="headerlink" title="4.1.5  方法"></a>4.1.5  方法</h4><p>Array 对象同样也提供了很多方法，中只演示 <code>push</code> 函数和 <code>splice</code> 函数。</p><ul><li><p>push 函数：给数组添加元素，也就是在数组的末尾添加元素</p><p>参数表示要添加的元素</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// push:添加方法</span></span><br><span class="line"><span class="keyword">var</span> arr5 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">arr5.<span class="title function_">push</span>(<span class="number">10</span>);</span><br><span class="line"><span class="title function_">alert</span>(arr5);  <span class="comment">//数组的元素是 &#123;1,2,3,10&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>splice 函数：删除元素</p><p>参数1：索引。表示从哪个索引位置删除</p><p>参数2：个数。表示删除几个元素</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// splice:删除元素</span></span><br><span class="line"><span class="keyword">var</span> arr5 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">arr5.<span class="title function_">splice</span>(<span class="number">0</span>,<span class="number">1</span>); <span class="comment">//从 0 索引位置开始删除，删除一个元素 </span></span><br><span class="line"><span class="title function_">alert</span>(arr5); <span class="comment">// &#123;2,3&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="4-2-String对象"><a href="#4-2-String对象" class="headerlink" title="4.2  String对象"></a>4.2  String对象</h3><p>String对象的创建方式有两种</p><ul><li><p>方式1：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 = <span class="keyword">new</span> <span class="title class_">String</span>(s); </span><br></pre></td></tr></table></figure></li><li><p>方式2：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 = <span class="string">&quot;数组&quot;</span>; </span><br></pre></td></tr></table></figure></li></ul><p><strong>函数：</strong></p><p>String对象还有一个函数 <code>trim()</code> ，该方法在文档中没有体现，但是所有的浏览器都支持；它是用来去掉字符串两端的空格。</p><p>代码演示：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str4 = <span class="string">&#x27;  abc   &#x27;</span>;</span><br><span class="line"><span class="title function_">alert</span>(<span class="number">1</span> + str4 + <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>上面代码会输出内容 <code>1  abc  1</code>，很明显可以看到 abc 字符串左右两边是有空格的。接下来使用 <code>trim()</code> 函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str4 = <span class="string">&#x27;  abc   &#x27;</span>;</span><br><span class="line"><span class="title function_">alert</span>(<span class="number">1</span> + str4.<span class="title function_">trim</span>() + <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>输出的内容是 <code>1abc1</code> 。这就是 <code>trim()</code> 函数的作用。</p><p><code>trim()</code> 函数在以后开发中还是比较常用的</p><p>用户在输入用户名和密码时，可能会习惯的输入一些空格，这样在我们后端程序中判断用户名和密码是否正确，结果肯定是失败。所以我们一般都会对用户输入的字符串数据进行去除前后空格的操作。</p><h3 id="4-3-自定义对象"><a href="#4-3-自定义对象" class="headerlink" title="4.3  自定义对象"></a>4.3  自定义对象</h3><p>在 JavaScript 中自定义对象特别简单，下面就是自定义对象的格式：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 对象名称 = &#123;</span><br><span class="line">    属性名称<span class="number">1</span>:属性值<span class="number">1</span>,</span><br><span class="line">    属性名称<span class="number">2</span>:属性值<span class="number">2</span>,</span><br><span class="line">    ...,</span><br><span class="line">    函数名称:<span class="keyword">function</span> (<span class="params">形参列表</span>)&#123;&#125;,</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>调用属性的格式：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">对象名.属性名</span><br></pre></td></tr></table></figure><p>调用函数的格式：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">对象名.函数名()</span><br></pre></td></tr></table></figure><p>接下来通过代码演示一下，让大家体验一下 JavaScript 中自定义对象</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">        name : <span class="string">&quot;zhangsan&quot;</span>,</span><br><span class="line">        age : <span class="number">23</span>,</span><br><span class="line">        <span class="attr">eat</span>: <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">            <span class="title function_">alert</span>(<span class="string">&quot;干饭~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(person.<span class="property">name</span>);  <span class="comment">//zhangsan</span></span><br><span class="line"><span class="title function_">alert</span>(person.<span class="property">age</span>); <span class="comment">//23</span></span><br><span class="line"></span><br><span class="line">person.<span class="title function_">eat</span>();  <span class="comment">//干饭~</span></span><br></pre></td></tr></table></figure><h2 id="5，BOM-浏览器对象模型"><a href="#5，BOM-浏览器对象模型" class="headerlink" title="5，BOM 浏览器对象模型"></a>5，BOM 浏览器对象模型</h2><p>BOM：Browser Object Model 浏览器对象模型。也就是 JavaScript 将浏览器的各个组成部分封装为对象。</p><p>我们要操作浏览器的各个组成部分就可以通过操作 BOM 中的对象来实现。比如：我现在想将浏览器地址栏的地址改为 <code>https://www.itheima.com</code> 就可以通过使用 BOM 中定义的 <code>Location</code> 对象的 <code>href</code> 属性，代码： <code>location.href = &quot;https://itheima.com&quot;;</code> </p><p> BOM 中包含了如下对象：</p><ul><li><strong>Window</strong>：浏览器窗口对象</li><li>Navigator：浏览器对象</li><li>Screen：屏幕对象</li><li><strong>History</strong>：历史记录对象</li><li><strong>Location</strong>：地址栏对象</li></ul><p>BOM 中的 <code>Navigator</code> 对象和 <code>Screen</code> 对象基本不会使用，所以只对 <code>Window</code>、<code>History</code>、<code>Location</code> 对象进行讲解。</p><h3 id="5-1-Window对象"><a href="#5-1-Window对象" class="headerlink" title="5.1  Window对象"></a>5.1  Window对象</h3><p>window 对象是 JavaScript 对浏览器的窗口进行封装的对象。</p><h4 id="5-1-1-获取window对象"><a href="#5-1-1-获取window对象" class="headerlink" title="5.1.1  获取window对象"></a>5.1.1  获取window对象</h4><p>该对象不需要创建直接使用 <code>window</code>，其中 <code>window. </code> 可以省略。比如我们之前使用的 <code>alert()</code> 函数，其实就是 <code>window</code> 对象的函数，在调用是可以写成如下两种</p><ul><li><p>显式使用 <code>window</code> 对象调用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">alert</span>(<span class="string">&quot;abc&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>隐式调用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alert(&quot;abc&quot;)</span><br></pre></td></tr></table></figure></li></ul><h4 id="5-1-2-window对象属性"><a href="#5-1-2-window对象属性" class="headerlink" title="5.1.2  window对象属性"></a>5.1.2  window对象属性</h4><p><code>window</code> 对象提供了用于获取其他 BOM 组成对象的属性</p><p>也就是说，我们想使用 <code>Location</code> 对象的话，就可以使用 <code>window</code> 对象获取；写成 <code>window.location</code>，而 <code>window.</code> 可以省略，简化写成 <code>location</code> 来获取 <code>Location</code> 对象。</p><h4 id="5-1-3-window对象函数"><a href="#5-1-3-window对象函数" class="headerlink" title="5.1.3  window对象函数"></a>5.1.3  window对象函数</h4><p><code>window</code> 对象提供了很多函数供我们使用，而很多都不常用</p><h5 id="5-1-3-1confirm："><a href="#5-1-3-1confirm：" class="headerlink" title="5.1.3.1confirm："></a>5.1.3.1<strong>confirm：</strong></h5><p><u>当我们点击 <code>确定</code> 按钮，<code>flag</code> 变量值记录的就是 <code>true</code> ；当我们点击 <code>取消</code> 按钮，<code>flag</code> 变量值记录的就是 <code>false</code>。</u></p><p>而以后我们在页面删除数据时候如下图每一条数据后都有 <code>删除</code> 按钮，有可能是用户的一些误操作，所以对于删除操作需要用户进行再次确认，此时就需要用到 <code>confirm()</code> 函数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// confirm()，点击确定按钮，返回true，点击取消按钮，返回false</span></span><br><span class="line"><span class="keyword">var</span> flag = <span class="title function_">confirm</span>(<span class="string">&quot;确认删除？&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(flag);</span><br></pre></td></tr></table></figure><h5 id="5-1-3-1定时器："><a href="#5-1-3-1定时器：" class="headerlink" title="5.1.3.1定时器："></a>5.1.3.1<strong>定时器：</strong></h5><p><u><code>setTimeout(function,毫秒值)</code> : 在一定的时间间隔后执行一个function，只执行一次</u><br><u><code>setInterval(function,毫秒值)</code> :在一定的时间间隔后执行一个function，循环执行（用于广告弹窗da）</u></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;hehe&quot;</span>); <span class="comment">//当我们打开浏览器，3秒后才会弹框输出 `hehe`，并且只会弹出一次。</span></span><br><span class="line">&#125;,<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setInterval</span>(<span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;hehe&quot;</span>); <span class="comment">//当我们打开浏览器，每隔2秒都会弹框输出 `hehe`。</span></span><br><span class="line">&#125;,<span class="number">2000</span>);</span><br></pre></td></tr></table></figure><h4 id="5-1-4-案例"><a href="#5-1-4-案例" class="headerlink" title="5.1.4  案例"></a>5.1.4  案例</h4><p><strong>需求：每隔1秒，灯泡切换一次状态</strong></p><p>需求说明：</p><p>实现定时进行开灯、关灯功能</p><p>初始页面环境</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>JavaScript演示<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;on()&quot;</span> <span class="attr">value</span>=<span class="string">&quot;开灯&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">&quot;myImage&quot;</span> <span class="attr">border</span>=<span class="string">&quot;0&quot;</span> <span class="attr">src</span>=<span class="string">&quot;../imgs/off.gif&quot;</span> <span class="attr">style</span>=<span class="string">&quot;text-align:center;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;off()&quot;</span> <span class="attr">value</span>=<span class="string">&quot;关灯&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">on</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myImage&#x27;</span>).<span class="property">src</span>=<span class="string">&#x27;../imgs/on.gif&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">off</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myImage&#x27;</span>).<span class="property">src</span>=<span class="string">&#x27;../imgs/off.gif&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>代码实现：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>JavaScript演示<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;on()&quot;</span> <span class="attr">value</span>=<span class="string">&quot;开灯&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">&quot;myImage&quot;</span> <span class="attr">border</span>=<span class="string">&quot;0&quot;</span> <span class="attr">src</span>=<span class="string">&quot;../imgs/off.gif&quot;</span> <span class="attr">style</span>=<span class="string">&quot;text-align:center;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;off()&quot;</span> <span class="attr">value</span>=<span class="string">&quot;关灯&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">on</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myImage&#x27;</span>).<span class="property">src</span>=<span class="string">&#x27;../imgs/on.gif&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">off</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myImage&#x27;</span>).<span class="property">src</span>=<span class="string">&#x27;../imgs/off.gif&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    </span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//定义一个变量，用来记录灯的状态，偶数是开灯状态，奇数是关灯状态</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> x = <span class="number">0</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//使用循环定时器</span></span></span><br><span class="line"><span class="language-javascript">    <span class="built_in">setInterval</span>(<span class="keyword">function</span> (<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span>(x % <span class="number">2</span> == <span class="number">0</span>)&#123;<span class="comment">//表示是偶数，开灯状态，调用 on() 函数</span></span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">on</span>();</span></span><br><span class="line"><span class="language-javascript">        &#125;<span class="keyword">else</span> &#123;  <span class="comment">//表示是奇数，关灯状态，调用 off() 函数</span></span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">off</span>();</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        x ++;<span class="comment">//改变变量的值</span></span></span><br><span class="line"><span class="language-javascript">    &#125;,<span class="number">1000</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="5-2-History对象"><a href="#5-2-History对象" class="headerlink" title="5.2  History对象"></a>5.2  History对象</h3><p>History 对象是 JavaScript 对历史记录进行封装的对象。</p><ul><li><p>History 对象的获取</p><p>使用 window.history获取，其中window. 可以省略</p></li><li><p>History 对象的函数</p><p>这两个函数我们平时在访问其他的一些网站时经常使用</p></li></ul><h3 id="5-3-Location对象"><a href="#5-3-Location对象" class="headerlink" title="5.3  Location对象"></a>5.3  Location对象</h3><p>Location 对象是 JavaScript 对地址栏封装的对象。可以通过操作该对象，跳转到任意页面。</p><h4 id="5-3-1-获取Location对象"><a href="#5-3-1-获取Location对象" class="headerlink" title="5.3.1  获取Location对象"></a>5.3.1  获取Location对象</h4><p>使用 window.location获取，其中window. 可以省略</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">location</span>.方法();</span><br><span class="line">location.方法();</span><br></pre></td></tr></table></figure><h4 id="5-3-2-Location对象属性"><a href="#5-3-2-Location对象属性" class="headerlink" title="5.3.2  Location对象属性"></a>5.3.2  Location对象属性</h4><p>Location对象提供了很对属性。以后常用的只有一个属性 <code>href</code></p><p><u><em>注意：href 后是等号</em></u></p><p><strong>代码演示：</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">alert</span>(<span class="string">&quot;要跳转了&quot;</span>);</span><br><span class="line">location.<span class="property">href</span> = <span class="string">&quot;https://www.baidu.com&quot;</span>;</span><br></pre></td></tr></table></figure><p>在浏览器首先会弹框显示 <code>要跳转了</code>，当我们点击了 <code>确定</code> 就会跳转到 百度 的首页。</p><h4 id="5-3-3-案例"><a href="#5-3-3-案例" class="headerlink" title="5.3.3  案例"></a>5.3.3  案例</h4><p><strong>需求：3秒跳转到百度首页</strong></p><p><strong>分析：</strong></p><ol><li>3秒跳转，由此可以确定需要使用到定时器，而只跳转一次，所以使用 <code>setTimeOut()</code></li><li>要进行页面跳转，所以需要用到 <code>location</code> 对象的 <code>href</code> 属性实现</li></ol><p><strong>代码实现：</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;3秒跳转到首页...&quot;</span>); </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">    location.<span class="property">href</span> = <span class="string">&quot;https://www.baidu.com&quot;</span></span><br><span class="line">&#125;,<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><h2 id="6，DOM-文档对象模型"><a href="#6，DOM-文档对象模型" class="headerlink" title="6，DOM 文档对象模型"></a>6，DOM 文档对象模型</h2><h3 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1  概述"></a>6.1  概述</h3><p>DOM：Document Object Model 文档对象模型。也就是 JavaScript 将 HTML 文档的各个组成部分封装为对象。</p><p>DOM 其实我们并不陌生，之前在学习 XML 就接触过，只不过 XML 文档中的标签需要我们写代码解析，而 HTML 文档是浏览器解析。封装的对象分为</p><ul><li>Document：整个文档对象</li><li>Element：元素对象</li><li>Attribute：属性对象</li><li>Text：文本对象</li><li>Comment：注释对象</li></ul><p><strong>作用：</strong></p><p>JavaScript 通过 DOM， 就能够对 HTML进行操作了</p><ul><li>改变 HTML 元素的内容</li><li>改变 HTML 元素的样式（CSS）</li><li>对 HTML DOM 事件作出反应</li><li>添加和删除 HTML 元素</li></ul><p><strong>DOM相关概念：</strong></p><p>DOM 是 W3C（万维网联盟）定义了访问 HTML 和 XML 文档的标准。该标准被分为 3 个不同的部分：</p><ol><li><p>核心 DOM：针对任何结构化文档的标准模型。 XML 和 HTML 通用的标准</p><ul><li><p>Document：整个文档对象</p></li><li><p>Element：元素对象</p></li><li><p>Attribute：属性对象</p></li><li><p>Text：文本对象</p></li><li><p>Comment：注释对象</p></li></ul></li><li><p>XML DOM： 针对 XML 文档的标准模型</p></li><li><p>HTML DOM： 针对 HTML 文档的标准模型</p><p>该标准是在核心 DOM 基础上，对 HTML 中的每个标签都封装成了不同的对象</p><ul><li>例如：<code>&lt;img&gt;</code> 标签在浏览器加载到内存中时会被封装成 <code>Image</code> 对象，同时该对象也是 <code>Element</code> 对象。</li><li>例如：<code>&lt;input type=&#39;button&#39;&gt;</code> 标签在浏览器加载到内存中时会被封装成 <code>Button</code> 对象，同时该对象也是 <code>Element</code> 对象。</li></ul></li></ol><h3 id="6-2-获取-Element对象"><a href="#6-2-获取-Element对象" class="headerlink" title="6.2  获取 Element对象"></a>6.2  获取 Element对象</h3><p>HTML 中的 Element 对象可以通过 <code>Document</code> 对象获取，而 <code>Document</code> 对象是通过 <code>window</code> 对象获取。</p><p><code>Document</code> 对象中提供了以下获取 <code>Element</code> 元素对象的函数</p><ul><li><code>getElementById()</code>：根据id属性值获取，返回单个Element对象</li><li><code>getElementsByTagName()</code>：根据标签名称获取，返回Element对象数组</li><li><code>getElementsByName()</code>：根据name属性值获取，返回Element对象数组</li><li><code>getElementsByClassName()</code>：根据class属性值获取，返回Element对象数组</li></ul><p><strong>代码演示：</strong></p><p>下面有提前准备好的页面：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">&quot;light&quot;</span> <span class="attr">src</span>=<span class="string">&quot;../imgs/off.gif&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cls&quot;</span>&gt;</span>传智教育<span class="tag">&lt;/<span class="name">div</span>&gt;</span>   <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cls&quot;</span>&gt;</span>黑马程序员<span class="tag">&lt;/<span class="name">div</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span>&gt;</span> 电影</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span>&gt;</span> 旅游</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span>&gt;</span> 游戏</span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">//在此处书写js代码</span></span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li><p>根据 <code>id</code> 属性值获取上面的 <code>img</code> 元素对象，返回单个对象</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;light&quot;</span>);</span><br><span class="line"><span class="title function_">alert</span>(img);</span><br></pre></td></tr></table></figure></li><li><p>根据标签名称获取所有的 <code>div</code> 元素对象</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> divs = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;div&quot;</span>);<span class="comment">// 返回一个数组，数组中存储的是 div 元素对象</span></span><br><span class="line"><span class="comment">// alert(divs.length);  //输出 数组的长度</span></span><br><span class="line"><span class="comment">//遍历数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; divs.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(divs[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取所有的满足 <code>name = &#39;hobby&#39;</code> 条件的元素对象</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//3. getElementsByName：根据name属性值获取，返回Element对象数组</span></span><br><span class="line"><span class="keyword">var</span> hobbys = <span class="variable language_">document</span>.<span class="title function_">getElementsByName</span>(<span class="string">&quot;hobby&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; hobbys.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(hobbys[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取所有的满足 <code>class=&#39;cls&#39;</code> 条件的元素对象</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//4. getElementsByClassName：根据class属性值获取，返回Element对象数组</span></span><br><span class="line"><span class="keyword">var</span> clss = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; clss.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(clss[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="6-3-HTML-Element对象使用"><a href="#6-3-HTML-Element对象使用" class="headerlink" title="6.3  HTML Element对象使用"></a>6.3  HTML Element对象使用</h3><p>HTML 中的 <code>Element</code> 元素对象有很多，不可能全部记住，以后是根据具体的需求查阅文档使用。</p><p>下面我们通过具体的案例给大家演示文档的查询和对象的使用；下面提前给大家准备好的页面</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">&quot;light&quot;</span> <span class="attr">src</span>=<span class="string">&quot;../imgs/off.gif&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cls&quot;</span>&gt;</span>传智教育<span class="tag">&lt;/<span class="name">div</span>&gt;</span>   <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cls&quot;</span>&gt;</span>黑马程序员<span class="tag">&lt;/<span class="name">div</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span>&gt;</span> 电影</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span>&gt;</span> 旅游</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span>&gt;</span> 游戏</span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//在此处写js低吗</span></span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>需求：</strong></p><ol><li><p>点亮灯泡</p><p>此案例由于需要改变 <code>img</code> 标签 的图片</p><p>代码实现：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1，根据 id=&#x27;light&#x27; 获取 img 元素对象</span></span><br><span class="line"><span class="keyword">var</span> img = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;light&quot;</span>);</span><br><span class="line"><span class="comment">//2，修改 img 对象的 src 属性来改变图片</span></span><br><span class="line">img.<span class="property">src</span> = <span class="string">&quot;../imgs/on.gif&quot;</span>;</span><br></pre></td></tr></table></figure></li><li><p>将所有的 <code>div</code> 标签的标签体内容替换为 <code>呵呵</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1，获取所有的 div 元素对象</span></span><br><span class="line"><span class="keyword">var</span> divs = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;div&quot;</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        style:设置元素css样式</span></span><br><span class="line"><span class="comment">        innerHTML：设置元素内容</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">//2，遍历数组，获取到每一个 div 元素对象，并修改元素内容</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; divs.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="comment">//divs[i].style.color = &#x27;red&#x27;;</span></span><br><span class="line">    divs[i].<span class="property">innerHTML</span> = <span class="string">&quot;呵呵&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使所有的复选框呈现被选中的状态</p><p>此案例我们需要看 复选框 元素对象有什么属性或者函数是来操作 复选框的选中状态。</p><p>代码实现：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1，获取所有的 复选框 元素对象</span></span><br><span class="line"><span class="keyword">var</span> hobbys = <span class="variable language_">document</span>.<span class="title function_">getElementsByName</span>(<span class="string">&quot;hobby&quot;</span>);</span><br><span class="line"><span class="comment">//2，遍历数组，通过将 复选框 元素对象的 checked 属性值设置为 true 来改变复选框的选中状态</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; hobbys.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    hobbys[i].<span class="property">checked</span> = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="7，事件监听"><a href="#7，事件监听" class="headerlink" title="7，事件监听"></a>7，事件监听</h2><p>要想知道什么是事件监听，首先先聊聊什么是事件？</p><p>HTML 事件是发生在 HTML 元素上的“事情”。比如：页面上的 <code>按钮被点击</code>、<code>鼠标移动到元素之上</code>、<code>按下键盘按键</code> 等都是事件。</p><p>事件监听是JavaScript 可以在事件被侦测到时==执行一段逻辑代码。==例如下图当点击 <code>开灯</code> 按钮，就需要通过 js 代码实现替换图片</p><p>再比如输入框，当输入了用户名 <code>光标离开</code> 输入框，就需要通过 js 代码对输入的内容进行校验，没通过校验就在输入框后提示 <code>用户名格式有误!</code></p><h3 id="7-1-事件绑定"><a href="#7-1-事件绑定" class="headerlink" title="7.1  事件绑定"></a>7.1  事件绑定</h3><p>JavaScript 提供了两种事件绑定方式：</p><ul><li><p>方式一：通过 HTML标签中的事件属性进行绑定</p><p>如下面代码，有一个按钮元素，我们是在该标签上定义 <code>事件属性</code>，在事件属性中绑定函数。<code>onclick</code> 就是 <code>单击事件</code> 的事件属性。<code>onclick=&#39;on（）&#39;</code> 表示该点击事件绑定了一个名为 <code>on()</code> 的函数</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onclick</span>=<span class="string">&#x27;on()’&gt;</span></span></span><br></pre></td></tr></table></figure><p>下面是点击事件绑定的 <code>on()</code> 函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">on</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&quot;我被点了&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方式二：通过 DOM 元素属性绑定</p><p>如下面代码是按钮标签，在该标签上我们并没有使用 <code>事件属性</code>，绑定事件的操作需要在 js 代码中实现</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>下面 js 代码是获取了 <code>id=&#39;btn&#39;</code> 的元素对象，然后将 <code>onclick</code> 作为该对象的属性，并且绑定匿名函数。该函数是在事件触发后自动执行</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;btn&quot;</span>).<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;我被点了&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>代码演示：</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--方式1：在下面input标签上添加 onclick 属性，并绑定 on() 函数--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;点我&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;on()&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;再点我&quot;</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">on</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>(<span class="string">&quot;我被点了&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">//方式2：获取 id=&quot;btn&quot; 元素对象，通过调用 onclick 属性 绑定点击事件</span></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;btn&quot;</span>).<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>(<span class="string">&quot;我被点了&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="7-2-常见事件"><a href="#7-2-常见事件" class="headerlink" title="7.2  常见事件"></a>7.2  常见事件</h3><p>上面案例中使用到了 <code>onclick</code> 事件属性，那都有哪些事件属性供我们使用呢？下面就给大家列举一些比较常用的事件属性</p><table><thead><tr><th>事件属性名</th><th>说明</th></tr></thead><tbody><tr><td>onclick</td><td>鼠标单击事件</td></tr><tr><td>onblur</td><td>元素失去焦点</td></tr><tr><td>onfocus</td><td>元素获得焦点</td></tr><tr><td>onload</td><td>某个页面或图像被完成加载</td></tr><tr><td>onsubmit</td><td>当表单提交时触发该事件</td></tr><tr><td>onmouseover</td><td>鼠标被移到某元素之上</td></tr><tr><td>onmouseout</td><td>鼠标从某元素移开</td></tr></tbody></table><ul><li><p><code>onfocus</code> 获得焦点事件。</p><p>当点击了输入框后，输入框就获得了焦点。而下图示例是当获取焦点后会更改输入框的背景颜色。</p></li><li><p><code>onblur  </code> 失去焦点事件。</p><p>当点击了输入框后，输入框就获得了焦点；再点击页面其他位置，那输入框就失去焦点了。下图示例是将输入的文本转换为大写。</p></li><li><p><code>onmouseout  </code> 鼠标移出事件。</p></li><li><p><code>onmouseover  </code>  鼠标移入事件。</p><p>当鼠标移入到 苹果 图片上时，苹果图片变大；当鼠标移出 苹果图片时，苹果图片变小。</p></li><li><p><code>onsubmit  </code> 表单提交事件</p><p>如下是带有表单的页面</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;register&quot;</span> <span class="attr">action</span>=<span class="string">&quot;#&quot;</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如上代码的表单，当我们点击 <code>提交</code> 按钮后，表单就会提交，此处默认使用的是 <code>GET</code> 提交方式，会将提交的数据拼接到 URL 后。现需要通过 js 代码实现阻止表单提交的功能，js 代码实现如下：</p><ol><li>获取 <code>form</code> 表单元素对象。</li><li>给 <code>form</code> 表单元素对象绑定 <code>onsubmit</code> 事件，并绑定匿名函数。</li><li>该匿名函数如果返回的是true，提交表单；如果返回的是false，阻止表单提交。</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;register&quot;</span>).<span class="property">onsubmit</span> = <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//onsubmit 返回true，则表单会被提交，返回false，则表单不提交</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="8，表单验证案例"><a href="#8，表单验证案例" class="headerlink" title="8，表单验证案例"></a>8，表单验证案例</h2><h3 id="8-1-需求"><a href="#8-1-需求" class="headerlink" title="8.1  需求"></a>8.1  需求</h3><p>有如下注册页面，对表单进行校验，如果输入的用户名、密码、手机号符合规则，则允许提交；如果不符合规则，则不允许提交。</p><p>完成以下需求：</p><ol><li><p>当输入框失去焦点时，验证输入内容是否符合要求</p></li><li><p>当点击注册按钮时，判断所有输入框的内容是否都符合要求，如果不合符则阻止表单提交</p></li></ol><h3 id="8-2-环境准备"><a href="#8-2-环境准备" class="headerlink" title="8.2  环境准备"></a>8.2  环境准备</h3><p>下面是初始页面</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>欢迎注册<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;../css/register.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-div&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;reg-content&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>欢迎注册<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span>&gt;</span>已有帐号？<span class="tag">&lt;/<span class="name">span</span>&gt;</span> <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;reg-form&quot;</span> <span class="attr">action</span>=<span class="string">&quot;#&quot;</span> <span class="attr">method</span>=<span class="string">&quot;get&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>用户名<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">&quot;inputs&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;username_err&quot;</span> <span class="attr">class</span>=<span class="string">&quot;err_msg&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display: none&quot;</span>&gt;</span>用户名不太受欢迎<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>密码<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">&quot;inputs&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">id</span>=<span class="string">&quot;password&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;password_err&quot;</span> <span class="attr">class</span>=<span class="string">&quot;err_msg&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display: none&quot;</span>&gt;</span>密码格式有误<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>手机号<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">&quot;inputs&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;tel&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;tel&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;tel_err&quot;</span> <span class="attr">class</span>=<span class="string">&quot;err_msg&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display: none&quot;</span>&gt;</span>手机号格式有误<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;buttons&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&quot;注 册&quot;</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">id</span>=<span class="string">&quot;reg_btn&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">br</span> <span class="attr">class</span>=<span class="string">&quot;clear&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="8-3-验证输入框"><a href="#8-3-验证输入框" class="headerlink" title="8.3  验证输入框"></a>8.3  验证输入框</h3><p>此小节完成如下功能：</p><ul><li>校验用户名。当用户名输入框失去焦点时，判断输入的内容是否符合 <code>长度是 6-12 位</code> 规则，不符合使 <code>id=&#39;username_err&#39;</code> 的span标签显示出来，给出用户提示。</li><li>校验密码。当密码输入框失去焦点时，判断输入的内容是否符合 <code>长度是 6-12 位</code> 规则，不符合使 <code>id=&#39;password_err&#39;</code> 的span标签显示出来，给出用户提示。</li><li>校验手机号。当手机号输入框失去焦点时，判断输入的内容是否符合 <code>长度是 11 位</code> 规则，不符合使 <code>id=&#39;tel_err&#39;</code> 的span标签显示出来，给出用户提示。</li></ul><p>代码如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 验证用户名是否符合规则</span></span><br><span class="line"><span class="comment">//1.1 获取用户名的输入框</span></span><br><span class="line"><span class="keyword">var</span> usernameInput = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;username&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.2 绑定onblur事件 失去焦点</span></span><br><span class="line">usernameInput.<span class="property">onblur</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//1.3 获取用户输入的用户名</span></span><br><span class="line">    <span class="keyword">var</span> username = usernameInput.<span class="property">value</span>.<span class="title function_">trim</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.4 判断用户名是否符合规则：长度 6~12</span></span><br><span class="line">    <span class="keyword">if</span> (username.<span class="property">length</span> &gt;= <span class="number">6</span> &amp;&amp; username.<span class="property">length</span> &lt;= <span class="number">12</span>) &#123;</span><br><span class="line">        <span class="comment">//符合规则</span></span><br><span class="line">        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;username_err&quot;</span>).<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//不合符规则</span></span><br><span class="line">        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;username_err&quot;</span>).<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 验证密码是否符合规则</span></span><br><span class="line"><span class="comment">//1.1 获取密码的输入框</span></span><br><span class="line"><span class="keyword">var</span> passwordInput = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;password&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.2 绑定onblur事件 失去焦点</span></span><br><span class="line">passwordInput.<span class="property">onblur</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//1.3 获取用户输入的密码</span></span><br><span class="line">    <span class="keyword">var</span> password = passwordInput.<span class="property">value</span>.<span class="title function_">trim</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.4 判断密码是否符合规则：长度 6~12</span></span><br><span class="line">    <span class="keyword">if</span> (password.<span class="property">length</span> &gt;= <span class="number">6</span> &amp;&amp; password.<span class="property">length</span> &lt;= <span class="number">12</span>) &#123;</span><br><span class="line">        <span class="comment">//符合规则</span></span><br><span class="line">        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;password_err&quot;</span>).<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//不合符规则</span></span><br><span class="line">        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;password_err&quot;</span>).<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 验证手机号是否符合规则</span></span><br><span class="line"><span class="comment">//1.1 获取手机号的输入框</span></span><br><span class="line"><span class="keyword">var</span> telInput = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;tel&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.2 绑定onblur事件 失去焦点</span></span><br><span class="line">telInput.<span class="property">onblur</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//1.3 获取用户输入的手机号</span></span><br><span class="line">    <span class="keyword">var</span> tel = telInput.<span class="property">value</span>.<span class="title function_">trim</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.4 判断手机号是否符合规则：长度 11</span></span><br><span class="line">    <span class="keyword">if</span> (tel.<span class="property">length</span> == <span class="number">11</span>) &#123;</span><br><span class="line">        <span class="comment">//符合规则</span></span><br><span class="line">        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;tel_err&quot;</span>).<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//不合符规则</span></span><br><span class="line">        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;tel_err&quot;</span>).<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-3-验证表单"><a href="#8-3-验证表单" class="headerlink" title="8.3  验证表单"></a>8.3  验证表单</h3><p>当用户点击 <code>注册</code> 按钮时，需要同时对输入的 <code>用户名</code>、<code>密码</code>、<code>手机号</code> ，如果都符合规则，则提交表单；如果有一个不符合规则，则不允许提交表单。实现该功能需要获取表单元素对象，并绑定 <code>onsubmit</code> 事件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 获取表单对象</span></span><br><span class="line"><span class="keyword">var</span> regForm = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;reg-form&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 绑定onsubmit 事件</span></span><br><span class="line">regForm.<span class="property">onsubmit</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>onsubmit</code> 事件绑定的函数需要对输入的 <code>用户名</code>、<code>密码</code>、<code>手机号</code> 进行校验，这些校验我们之前都已经实现过了，这里我们还需要再校验一次吗？不需要，只需要对之前校验的代码进行改造，把每个校验的代码专门抽象到有名字的函数中，方便调用；并且每个函数都要返回结果来去决定是提交表单还是阻止表单提交，代码如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 验证用户名是否符合规则</span></span><br><span class="line"><span class="comment">//1.1 获取用户名的输入框</span></span><br><span class="line"><span class="keyword">var</span> usernameInput = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;username&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.2 绑定onblur事件 失去焦点</span></span><br><span class="line">usernameInput.<span class="property">onblur</span> = checkUsername;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">checkUsername</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//1.3 获取用户输入的用户名</span></span><br><span class="line">    <span class="keyword">var</span> username = usernameInput.<span class="property">value</span>.<span class="title function_">trim</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.4 判断用户名是否符合规则：长度 6~12</span></span><br><span class="line">    <span class="keyword">var</span> flag = username.<span class="property">length</span> &gt;= <span class="number">6</span> &amp;&amp; username.<span class="property">length</span> &lt;= <span class="number">12</span>;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        <span class="comment">//符合规则</span></span><br><span class="line">        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;username_err&quot;</span>).<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//不合符规则</span></span><br><span class="line">        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;username_err&quot;</span>).<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 验证密码是否符合规则</span></span><br><span class="line"><span class="comment">//1.1 获取密码的输入框</span></span><br><span class="line"><span class="keyword">var</span> passwordInput = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;password&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.2 绑定onblur事件 失去焦点</span></span><br><span class="line">passwordInput.<span class="property">onblur</span> = checkPassword;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">checkPassword</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//1.3 获取用户输入的密码</span></span><br><span class="line">    <span class="keyword">var</span> password = passwordInput.<span class="property">value</span>.<span class="title function_">trim</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.4 判断密码是否符合规则：长度 6~12</span></span><br><span class="line">    <span class="keyword">var</span> flag = password.<span class="property">length</span> &gt;= <span class="number">6</span> &amp;&amp; password.<span class="property">length</span> &lt;= <span class="number">12</span>;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        <span class="comment">//符合规则</span></span><br><span class="line">        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;password_err&quot;</span>).<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//不合符规则</span></span><br><span class="line">        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;password_err&quot;</span>).<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 验证手机号是否符合规则</span></span><br><span class="line"><span class="comment">//1.1 获取手机号的输入框</span></span><br><span class="line"><span class="keyword">var</span> telInput = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;tel&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.2 绑定onblur事件 失去焦点</span></span><br><span class="line">telInput.<span class="property">onblur</span> = checkTel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">checkTel</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//1.3 获取用户输入的手机号</span></span><br><span class="line">    <span class="keyword">var</span> tel = telInput.<span class="property">value</span>.<span class="title function_">trim</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.4 判断手机号是否符合规则：长度 11</span></span><br><span class="line">    <span class="keyword">var</span> flag = tel.<span class="property">length</span> == <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        <span class="comment">//符合规则</span></span><br><span class="line">        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;tel_err&quot;</span>).<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//不合符规则</span></span><br><span class="line">        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;tel_err&quot;</span>).<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 <code>onsubmit</code> 绑定的函数需要调用 <code>checkUsername()</code> 函数、<code>checkPassword()</code> 函数、<code>checkTel()</code> 函数。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 获取表单对象</span></span><br><span class="line"><span class="keyword">var</span> regForm = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;reg-form&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 绑定onsubmit 事件</span></span><br><span class="line">regForm.<span class="property">onsubmit</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//挨个判断每一个表单项是否都符合要求，如果有一个不合符，则返回false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> flag = <span class="title function_">checkUsername</span>() &amp;&amp; <span class="title function_">checkPassword</span>() &amp;&amp; <span class="title function_">checkTel</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9，RegExp对象"><a href="#9，RegExp对象" class="headerlink" title="9，RegExp对象"></a>9，RegExp对象</h2><p>RegExp 是正则对象。正则对象是判断指定字符串是否符合规则。</p><p>可以通过爬虫技术去爬取该页面源代码，然后获取页面中所有的邮箱，后期我们可以给这些邮箱地址发送推广的邮件。那么问题来了，如何才能知道页面内容中哪些事邮箱地址呢？这里就可以使用正则表达式来匹配邮箱。</p><p>在 js 中对正则表达式封装的对象就是正则对象。</p><h3 id="9-1-正则对象使用"><a href="#9-1-正则对象使用" class="headerlink" title="9.1  正则对象使用"></a>9.1  正则对象使用</h3><h4 id="9-1-1-创建对象"><a href="#9-1-1-创建对象" class="headerlink" title="9.1.1  创建对象"></a>9.1.1  创建对象</h4><p>正则对象有两种创建方式：</p><ul><li><p>直接量方式：注意不要加引号</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/正则表达式/</span>;</span><br></pre></td></tr></table></figure></li><li><p>创建 RegExp 对象</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&quot;正则表达式&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul><h4 id="9-1-2-函数"><a href="#9-1-2-函数" class="headerlink" title="9.1.2  函数"></a>9.1.2  函数</h4><p><code>test(str)</code> ：判断指定字符串是否符合规则，返回 true或 false</p><h3 id="9-2-正则表达式"><a href="#9-2-正则表达式" class="headerlink" title="9.2  正则表达式"></a>9.2  正则表达式</h3><p>从上面创建正则对象的格式中可以看出不管哪种方式都需要正则表达式，那么什么是正则表达式呢？</p><p>正则表达式定义了字符串组成的规则。也就是判断指定的字符串是否符合指定的规则，如果符合返回true，如果不符合返回false。</p><p>正则表达式是和语言无关的。很多语言都支持正则表达式，Java语言也支持，只不过正则表达式在不同的语言中的使用方式不同，js 中需要使用正则对象来使用正则表达式。</p><p>正则表达式常用的规则如下：</p><ul><li><p>^：表示开始</p></li><li><p>$：表示结束</p></li><li><p>[ ]：代表某个范围内的单个字符，比如： [0-9] 单个数字字符</p></li><li><p>.：代表任意单个字符，除了换行和行结束符</p></li><li><p>\w：代表单词字符：字母、数字、下划线(<em>)，相当于 [A-Za-z0-9</em>]</p></li><li><p>\d：代表数字字符： 相当于 [0-9]</p></li></ul><p>量词：</p><ul><li><p>+：至少一个</p></li><li><p>*：零个或多个</p></li><li><p>？：零个或一个</p></li><li><p>{x}：x个</p></li><li><p>{m,}：至少m个</p></li><li><p>{m,n}：至少m个，最多n个</p></li></ul><p><strong>代码演示：</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 规则：单词字符，6~12</span></span><br><span class="line"><span class="comment">//1,创建正则对象，对正则表达式进行封装</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/^\w&#123;6,12&#125;$/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;abcccc&quot;</span>;</span><br><span class="line"><span class="comment">//2,判断 str 字符串是否符合 reg 封装的正则表达式的规则</span></span><br><span class="line"><span class="keyword">var</span> flag = reg.<span class="title function_">test</span>(str);</span><br><span class="line"><span class="title function_">alert</span>(flag);</span><br></pre></td></tr></table></figure><h3 id="9-3-改进表单校验案例"><a href="#9-3-改进表单校验案例" class="headerlink" title="9.3  改进表单校验案例"></a>9.3  改进表单校验案例</h3><p>表单校验案例中的规则是我们进行一系列的判断来实现的，现在学习了正则对象后，就可以使用正则对象来改进这个案例。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>欢迎注册<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;../css/register.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-div&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;reg-content&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>欢迎注册<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>已有帐号？<span class="tag">&lt;/<span class="name">span</span>&gt;</span> <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;reg-form&quot;</span> <span class="attr">action</span>=<span class="string">&quot;#&quot;</span> <span class="attr">method</span>=<span class="string">&quot;get&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>用户名<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">&quot;inputs&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;username_err&quot;</span> <span class="attr">class</span>=<span class="string">&quot;err_msg&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display: none&quot;</span>&gt;</span>用户名不太受欢迎<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>密码<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">&quot;inputs&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">id</span>=<span class="string">&quot;password&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;password_err&quot;</span> <span class="attr">class</span>=<span class="string">&quot;err_msg&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display: none&quot;</span>&gt;</span>密码格式有误<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>手机号<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">&quot;inputs&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;tel&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;tel&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;tel_err&quot;</span> <span class="attr">class</span>=<span class="string">&quot;err_msg&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display: none&quot;</span>&gt;</span>手机号格式有误<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;buttons&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&quot;注 册&quot;</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">id</span>=<span class="string">&quot;reg_btn&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span> <span class="attr">class</span>=<span class="string">&quot;clear&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//1. 验证用户名是否符合规则</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//1.1 获取用户名的输入框</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> usernameInput = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;username&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//1.2 绑定onblur事件 失去焦点</span></span></span><br><span class="line"><span class="language-javascript">    usernameInput.<span class="property">onblur</span> = checkUsername;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">checkUsername</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//1.3 获取用户输入的用户名</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> username = usernameInput.<span class="property">value</span>.<span class="title function_">trim</span>();</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//1.4 判断用户名是否符合规则：长度 6~12,单词字符组成</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> reg = <span class="regexp">/^\w&#123;6,12&#125;$/</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> flag = reg.<span class="title function_">test</span>(username);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//var flag = username.length &gt;= 6 &amp;&amp; username.length &lt;= 12;</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span> (flag) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//符合规则</span></span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;username_err&quot;</span>).<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;none&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//不合符规则</span></span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;username_err&quot;</span>).<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">return</span> flag;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//1. 验证密码是否符合规则</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//1.1 获取密码的输入框</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> passwordInput = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;password&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//1.2 绑定onblur事件 失去焦点</span></span></span><br><span class="line"><span class="language-javascript">    passwordInput.<span class="property">onblur</span> = checkPassword;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">checkPassword</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//1.3 获取用户输入的密码</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> password = passwordInput.<span class="property">value</span>.<span class="title function_">trim</span>();</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//1.4 判断密码是否符合规则：长度 6~12</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> reg = <span class="regexp">/^\w&#123;6,12&#125;$/</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> flag = reg.<span class="title function_">test</span>(password);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//var flag = password.length &gt;= 6 &amp;&amp; password.length &lt;= 12;</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span> (flag) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//符合规则</span></span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;password_err&quot;</span>).<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;none&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//不合符规则</span></span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;password_err&quot;</span>).<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">return</span> flag;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//1. 验证手机号是否符合规则</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//1.1 获取手机号的输入框</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> telInput = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;tel&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//1.2 绑定onblur事件 失去焦点</span></span></span><br><span class="line"><span class="language-javascript">    telInput.<span class="property">onblur</span> = checkTel;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">checkTel</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//1.3 获取用户输入的手机号</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> tel = telInput.<span class="property">value</span>.<span class="title function_">trim</span>();</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//1.4 判断手机号是否符合规则：长度 11，数字组成，第一位是1</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//var flag = tel.length == 11;</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> reg = <span class="regexp">/^[1]\d&#123;10&#125;$/</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> flag = reg.<span class="title function_">test</span>(tel);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span> (flag) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//符合规则</span></span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;tel_err&quot;</span>).<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;none&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//不合符规则</span></span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;tel_err&quot;</span>).<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">        </span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">return</span> flag;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//1. 获取表单对象</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> regForm = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;reg-form&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//2. 绑定onsubmit 事件</span></span></span><br><span class="line"><span class="language-javascript">    regForm.<span class="property">onsubmit</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//挨个判断每一个表单项是否都符合要求，如果有一个不合符，则返回false</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> flag = <span class="title function_">checkUsername</span>() &amp;&amp; <span class="title function_">checkPassword</span>() &amp;&amp; <span class="title function_">checkTel</span>();</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">return</span> flag;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML&amp;CSS</title>
      <link href="/post/f274aacd.html"/>
      <url>/post/f274aacd.html</url>
      
        <content type="html"><![CDATA[<h2 id="HTML-CSS"><a href="#HTML-CSS" class="headerlink" title="HTML&amp;CSS"></a>HTML&amp;CSS</h2><p><strong>今日目标：</strong></p><blockquote><ul><li>能够掌握课程中讲解的标签的使用</li><li>了解css的使用</li></ul></blockquote><h2 id="1，HTML"><a href="#1，HTML" class="headerlink" title="1，HTML"></a>1，HTML</h2><h3 id="1-1-介绍"><a href="#1-1-介绍" class="headerlink" title="1.1  介绍"></a>1.1  介绍</h3><p>HTML 是一门语言，所有的网页都是用HTML 这门语言编写出来的，也就是HTML是用来写网页的，像京东，12306等网站有很多网页。</p><p>&#x3D;&#x3D;HTML(HyperText Markup Language)：超文本标记语言：&#x3D;&#x3D;</p><ul><li><p>超文本：超越了文本的限制，比普通文本更强大。除了文字信息，还可以定义图片、音频、视频等内容</p></li><li><p>标记语言：由标签构成的语言</p></li></ul><p>这些标签不像XML那样可以自定义，&#x3D;&#x3D;HTML中的标签都是预定义好的，运行在浏览器上并由浏览器解析，&#x3D;&#x3D;然后展示出对应的效果。例如我们想在浏览器上展示出图片就需要使用预定义的 <code>img</code> 标签；想展示可以点击的链接的效果就可以使用预定义的 <code>a</code> 标签等。</p><p>HTML 预定义了很多标签，由于我们是Java工程师、是做后端开发，所以不会每个都学习，页面开发是有专门的前端工程来开发。那为什么我们还要学习呢？在公司中或多或少大家也会涉及到前端开发。</p><p>简单的给大家聊一下开发流程：</p><p>以后我们是通过Java程序从数据库中查询出来数据，然后交给页面进行展示，这样用户就能通过在浏览器通过页面看到数据。</p><p>&#x3D;&#x3D;W3C标准：&#x3D;&#x3D;</p><p>W3C是万维网联盟，这个组成是用来定义标准的。他们规定了一个网页是由三部分组成，分别是：</p><ul><li>结构：对应的是 HTML 语言</li><li>表现：对应的是 CSS 语言</li><li>行为：对应的是 JavaScript 语言</li></ul><p>HTML定义页面的整体结构；CSS是用来美化页面，让页面看起来更加美观；JavaScript可以使网页动起来，比如轮播图也就是多张图片自动的进行切换等效果。</p><h3 id="1-2-快速入门"><a href="#1-2-快速入门" class="headerlink" title="1.2  快速入门"></a>1.2  快速入门</h3><p>要实现这个页面，我们需要从以下三步进行实现</p><ul><li><p>新建文本文件，后缀名改为 .html</p><p>页面文件的后缀名是 .html，所以需要该后缀名</p></li><li><p>编写 HTML 结构标签</p><p>HTML 是由一个一个的标签组成的，但是它也用于表示结构的标签</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span> <span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>html标签是根标签，下面有 <code>head</code> 标签和 <code>body</code> 标签这两个子标签。而 <code>head</code> 标签的 <code>title</code> 子标签是用来定义页面标题名称的，它定义的内容会展示在浏览器的标题位置</p></li><li><p>在<body>中定义文字</p></li></ul><p>代码如下：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>html 快速入门<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        乾坤未定，你我皆是黑马~</span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>同学们在访问其他网站页面时会看到字体颜色是五颜六色的，我们可以该字体颜色吗？当然可以了</p><p><code>font</code> 标签就可以使用，该标签有一个 <code>color</code> 属性可以设置字体颜色，如： <font color='red'></font> 就是将文字设置成了红颜色。那么我们只需要将需要变成红色的文字放在标签体部分就可以了，如下：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>html 快速入门<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">&#x27;red&#x27;</span>&gt;</span>乾坤未定，你我皆是黑马~<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;总结：&#x3D;&#x3D;</p><ul><li><p>HTML 文件以.htm或.html为扩展名</p></li><li><p>HTML 标签不区分大小写</p><p>如上案例中的 <code>font</code> 写成 <code>Font</code> 也是一样可以展示出对应的效果的。</p></li><li><p>HTML 标签属性值 单双引皆可</p><p>如上案例中的color属性值使用双引号也是可以的。<font color="red"></font> </p></li><li><p>HTML 语法松散</p><p>比如 font 标签不加结束标签也是可以展示出效果的。但是建议同学们在写的时候还是不要这样做，严格按照要求去写。</p></li></ul><h3 id="1-3-基础标签"><a href="#1-3-基础标签" class="headerlink" title="1.3  基础标签"></a>1.3  基础标签</h3><h4 id="1-3-1-标题标签"><a href="#1-3-1-标题标签" class="headerlink" title="1.3.1  标题标签"></a>1.3.1  标题标签</h4><ul><li><p>创建页面文件</p><p>选中 <code>html</code> 文件夹右键创建页面文件（01-基础标签.html）</p><p>创建好后 idea 会自动加上结构标签</p><p>我们只需要在 <code>body</code> 标签中书写标签。</p></li><li><p>书写标题标签</p><p>标题标签中 h1最大，h6最小。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>我是标题 h1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是标题 h2<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>我是标题 h3<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span>我是标题 h4<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h5</span>&gt;</span>我是标题 h5<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h6</span>&gt;</span>我是标题 h6<span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="1-3-2-hr标签"><a href="#1-3-2-hr标签" class="headerlink" title="1.3.2  hr标签"></a>1.3.2  hr标签</h4><p><code>hr</code> 标签在浏览器中呈现出 横线 的效果。</p><p>在页面文件中书写 hr 标签</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;hr&gt;</span><br></pre></td></tr></table></figure><h4 id="1-3-3-字体标签"><a href="#1-3-3-字体标签" class="headerlink" title="1.3.3  字体标签"></a>1.3.3  字体标签</h4><p>font：字体标签</p><ul><li><p>face 属性：用来设置字体。如 “楷体”、”宋体”等</p></li><li><p>color 属性：设置文字颜色。颜色有三种表示方式</p><ul><li><p><strong>英文单词</strong>：red,pink,blue…</p><p>这种方式表示的颜色特别有限，所以一般不用。</p></li><li><p>**rgb(值1,值2,值3)**：值的取值范围：0~255  </p><p>此种方式也就是三原色（红绿蓝）设置方式。 例如： rgb(255,0,0)。</p><p>这种书写起来比较麻烦，一般不用。</p></li><li><p><strong>#值1值2值3</strong>：值的范围：00~FF</p><p>这种方式是rgb方式的简化写法，以后基本都用此方式。</p><p>值1表示红色的范围，值2表示绿色的范围，值3表示蓝色范围。例如： #ff0000</p></li></ul></li><li><p>size 属性：设置文字大小</p></li></ul><p>代码演示：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">&quot;楷体&quot;</span> <span class="attr">size</span>=<span class="string">&quot;5&quot;</span> <span class="attr">color</span>=<span class="string">&quot;#ff0000&quot;</span>&gt;</span>传智教育<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>&#x3D;&#x3D;注意：&#x3D;&#x3D;</p><p>font 标签已经不建议使用了，以后如果要改变文字字体，大小，颜色可以使用 CSS 进行设置。</p></blockquote><h4 id="1-3-4-换行标签"><a href="#1-3-4-换行标签" class="headerlink" title="1.3.4  换行标签"></a>1.3.4  换行标签</h4><p>在页面文件中书写如下内容</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">刚察草原绿草如茵，沙柳河水流淌入湖。藏族牧民索南才让家中，茶几上摆着馓子、麻花和水果，炉子上刚煮开的奶茶香气四溢……</span><br><span class="line"></span><br><span class="line">6月8日下午，习近平总书记来到青海省海北藏族自治州刚察县沙柳河镇果洛藏贡麻村，走进牧民索南才让家中，看望慰问藏族群众。</span><br></pre></td></tr></table></figure><p>如果要实现换行效果，需要使用 换行标签（br标签）。</p><p>修改页面文件内容如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">刚察草原绿草如茵，沙柳河水流淌入湖。藏族牧民索南才让家中，茶几上摆着馓子、麻花和水果，炉子上刚煮开的奶茶香气四溢……&lt;br&gt;</span><br><span class="line"></span><br><span class="line">6月8日下午，习近平总书记来到青海省海北藏族自治州刚察县沙柳河镇果洛藏贡麻村，走进牧民索南才让家中，看望慰问藏族群众。</span><br></pre></td></tr></table></figure><h4 id="1-3-5-段落标签"><a href="#1-3-5-段落标签" class="headerlink" title="1.3.5  段落标签"></a>1.3.5  段落标签</h4><p>上面文字展示的效果还是不太好，我们想让每一段上下都加空行。此时就需要使用段落标签（p标签）</p><p>在页面文件中书写如下内容：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">刚察草原绿草如茵，沙柳河水流淌入湖。藏族牧民索南才让家中，茶几上摆着馓子、麻花和水果，炉子上刚煮开的奶茶香气四溢……</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">6月8日下午，习近平总书记来到青海省海北藏族自治州刚察县沙柳河镇果洛藏贡麻村，走进牧民索南才让家中，看望慰问藏族群众。</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这种效果就会比之前的效果好一些，呈现出段落的效果。</p><h4 id="1-3-6-加粗、斜体、下划线标签"><a href="#1-3-6-加粗、斜体、下划线标签" class="headerlink" title="1.3.6  加粗、斜体、下划线标签"></a>1.3.6  加粗、斜体、下划线标签</h4><ul><li>b：加粗标签</li><li>i：斜体标签</li><li>u：下划线标签，在文字的下方有一条横线</li></ul><p>代码如下：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>沙柳河水流淌<span class="tag">&lt;/<span class="name">b</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">i</span>&gt;</span>沙柳河水流淌<span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">u</span>&gt;</span>沙柳河水流淌<span class="tag">&lt;/<span class="name">u</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="1-3-7-居中标签"><a href="#1-3-7-居中标签" class="headerlink" title="1.3.7  居中标签"></a>1.3.7  居中标签</h4><p>center ：文本居中</p><p>代码如下：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">b</span>&gt;</span>沙柳河水流淌<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-4-图片、音频、视频标签img-audio-video"><a href="#1-4-图片、音频、视频标签img-audio-video" class="headerlink" title="1.4  图片、音频、视频标签img audio video"></a>1.4  图片、音频、视频标签<code>img</code> <code>audio</code> <code>video</code></h3><ul><li><p>img：定义图片</p><ul><li><p>src：规定显示图像的 URL（统一资源定位符）</p></li><li><p>height：定义图像的高度</p></li><li><p>width：定义图像的宽度</p></li></ul></li><li><p>audio：定义音频。支持的音频格式：MP3、WAV、OGG </p><ul><li><p>src：规定音频的 URL</p></li><li><p>controls：显示播放控件</p></li></ul></li><li><p>video：定义视频。支持的音频格式：MP4, WebM、OGG</p><ul><li>src：规定视频的 URL</li><li>controls：显示播放控件</li></ul></li></ul><p><strong>尺寸单位：</strong></p><p>height属性和width属性有两种设置方式：</p><ul><li>像素：单位是px</li><li>百分比。占父标签的百分比。例如宽度设置为 50%，意思就是占它的父标签宽度的一般（50%）</li></ul><p><strong>资源路径：</strong></p><p>图片，音频，视频标签都有src属性，而src是用来指定对应的图片，音频，视频文件的路径。此处的图片，音频，视频就称为资源。资源路径有如下两种设置方式：</p><ul><li><p>绝对路径：完整路径</p><p>这里的绝对路径是网络中的绝对路径。 格式为： 协议:&#x2F;&#x2F;ip地址:端口号&#x2F;资源名称。</p><p>如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;img src=&quot;https://th.bing.com/th/id/R33674725d9ae34f86e3835ae30b20afe?rik=Pb3C9e5%2b%2b3a9Vw&amp;riu=http%3a%2f%2fwww.desktx.com%2fd%2ffile%2fwallpaper%2fscenery%2f20180626%2f4c8157d07c14a30fd76f9bc110b1314e.jpg&amp;ehk=9tpmnrrRNi0eBGq3CnhwvuU8PPmKuy1Yma0zL%2ba14T0%3d&amp;risl=&amp;pid=ImgRaw&quot; width=&quot;300&quot; height=&quot;400&quot;&gt;</span><br></pre></td></tr></table></figure><p>这里src属性的值就是网络中的绝对路径。</p></li><li><p>相对路径：相对位置关系</p><p>找页面和其他资源的相对路径。</p><blockquote><p>.&#x2F;    表示当前路径</p><p>..&#x2F;   表示上一级路径</p><p>..&#x2F;..&#x2F;   表示上两级路径</p></blockquote><p>在 <code>01-基础标签.html</code> 里的标签中找不同的图片，路径写法不同</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--在该页面找a.jpg，就需要先回到上一级目录，该级目录有img目录，进入该目录就可以找到 a.jpg图片--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;../img/a.jpg&quot;</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;400&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--该页面和aa.jpg 是在同一级下，所以可以直接写 图片的名称，也可以写成  ./aa.jpg--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;aa.jpg&quot;</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;400&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>使用这些标签的代码如下：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;../img/a.jpg&quot;</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;400&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">&quot;b.mp3&quot;</span> <span class="attr">controls</span>&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">&quot;c.mp4&quot;</span> <span class="attr">controls</span> <span class="attr">width</span>=<span class="string">&quot;500&quot;</span> <span class="attr">height</span>=<span class="string">&quot;300&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-5-超链接标签"><a href="#1-5-超链接标签" class="headerlink" title="1.5  超链接标签 &lt;a&gt;"></a>1.5  超链接标签 <code>&lt;a&gt;</code></h3><p>点击超链接时会跳转到其他的页面或者资源。而超链接使用的是 <code>a</code> 标签。</p><p><code>a</code> 标签属性：</p><ul><li><p>href：指定访问资源的URL </p></li><li><p>target：指定打开资源的方式</p><ul><li>_self：默认值，在当前页面打开</li><li>_blank：在空白页面打开</li></ul></li></ul><p><strong>代码演示：</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.itcast.cn&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_self&quot;</span>&gt;</span>点我有惊喜<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-6-列表标签ol-ul-li"><a href="#1-6-列表标签ol-ul-li" class="headerlink" title="1.6  列表标签ol ul li"></a>1.6  列表标签<code>ol</code> <code>ul</code> <code>li</code></h3><p>HTML 中列表分为</p><ul><li><p>有序列表</p><p>页面效果中是有标号对每一项进行标记的。</p></li><li><p>无序列表</p><p>页面效果中没有标号对每一项进行标记，而是使用 点 进行标记。</p></li></ul><p><strong>标签说明：</strong></p><p>有序列表中的 <code>type</code> 属性用来指定标记的标号的类型（数字、字母、罗马数字等）</p><p>无序列表中的 <code>type</code> 属性用来指定标记的形状</p><p><strong>代码演示：</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ol</span> <span class="attr">type</span>=<span class="string">&quot;A&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>咖啡<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>茶<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>牛奶<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">type</span>=<span class="string">&quot;circle&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>咖啡<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>茶<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>牛奶<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-7-表格标签table-tr-td-th"><a href="#1-7-表格标签table-tr-td-th" class="headerlink" title="1.7  表格标签table tr td th"></a>1.7  表格标签<code>table</code> <code>tr</code> <code>td</code> <code>th</code></h3><p>表格可以使用如下标签定义</p><ul><li><p>table ：定义表格</p><ul><li><p>border：规定表格边框的宽度</p></li><li><p>width ：规定表格整体的宽度</p></li><li><p>cellspacing：规定单元格之间的空白</p></li></ul></li><li><p>tr ：定义行</p><ul><li>align：定义表格行的内容对齐方式（center为居中对齐）</li></ul></li><li><p>td ：定义单元格</p><ul><li><p>rowspan:规定单元格可横跨的行数</p></li><li><p>colspan:规定单元格可横跨的列数</p></li></ul></li><li><p>th：定义表头单元格</p></li></ul><p><strong>代码演示：</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span> <span class="attr">cellspacing</span>=<span class="string">&quot;0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;500&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>序号<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>品牌logo<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>品牌名称<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>企业名称<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>010<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;../img/三只松鼠.png&quot;</span> <span class="attr">width</span>=<span class="string">&quot;60&quot;</span> <span class="attr">height</span>=<span class="string">&quot;50&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>三只松鼠<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>三只松鼠<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>009<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;../img/优衣库.png&quot;</span> <span class="attr">width</span>=<span class="string">&quot;60&quot;</span> <span class="attr">height</span>=<span class="string">&quot;50&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>优衣库<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>优衣库<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>008<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;../img/小米.png&quot;</span> <span class="attr">width</span>=<span class="string">&quot;60&quot;</span> <span class="attr">height</span>=<span class="string">&quot;50&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>小米<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>小米科技有限公司<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-8-布局标签div-span"><a href="#1-8-布局标签div-span" class="headerlink" title="1.8  布局标签div span"></a>1.8  布局标签<code>div</code> <code>span</code></h3><p>这两个标签，一般都是和css结合到一块使用来实现页面的布局。</p><p><code>div</code>标签 在浏览器上会有换行的效果，而 <code>span</code> 标签在浏览器上没有换行效果。</p><p><strong>代码演示：</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>我是div<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>我是div<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>我是span<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>我是span<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-9-表单标签from"><a href="#1-9-表单标签from" class="headerlink" title="1.9  表单标签from"></a>1.9  表单标签<code>from</code></h3><p>表单标签效果大家其实都不陌生，像登陆页面、注册页面等都是表单。</p><p>像这样的表单就是用来采集用户输入的数据，然后将数据发送到服务端，服务端会对数据库进行操作，比如注册就是将数据保存到数据库中，而登陆就是根据用户名和密码进行数据库的查询操作。</p><p>表单是很重要的标签，需要大家重点来学习。</p><h4 id="1-9-1-概述"><a href="#1-9-1-概述" class="headerlink" title="1.9.1  概述"></a>1.9.1  概述</h4><blockquote><p>表单：在网页中主要负责数据采集功能，使用<form>标签定义表单</p><p>表单项(元素)：不同类型的 input 元素、下拉列表、文本域等</p></blockquote><p><code>form</code> 是表单标签，它在页面上没有任何展示的效果。<strong>需要借助于表单项标签来展示不同的效果</strong>。如下图就是不同的表单项标签展示出来的效果。</p><h4 id="1-9-2-form标签属性"><a href="#1-9-2-form标签属性" class="headerlink" title="1.9.2  form标签属性"></a>1.9.2  form标签属性</h4><ul><li><p><strong>action：规定当提交表单时向何处发送表单数据，该属性值就是URL（地址）</strong></p><p>以后会将数据提交到服务端，该属性需要书写服务端的URL。而今天我们可以书写 <code>#</code> ，表示提交到当前页面来看效果。</p></li><li><p><strong>method ：规定用于发送表单数据的方式</strong></p><p>method取值有如下两种：</p><ul><li><strong>get：默认值。</strong>如果不设置method属性则默认就是该值<ul><li><strong>请求参数会拼接在URL后边</strong></li><li><strong>url的长度有限制 4KB</strong></li></ul></li><li><strong>post</strong>：<ul><li><strong>浏览器会将数据放到http请求消息体中</strong></li><li><strong>请求参数无限制的</strong></li></ul></li></ul></li></ul><p><strong>代码演示：</strong></p><p>由于表单标签在页面上没有任何展示的效果，所以在演示的过程是会先使用 <code>input</code> 这个表单项标签展示输入框效果。</p><p>代码如下：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>从效果可以看到页面有一个输入框，用户可以在数据框中输入自己想输入的内容，点击提交按钮以后会将数据发送到服务端，当然现在肯定不能实现。</p><!--要想提交数据需要设置`form 标签 action 的URL属性值 和 input 输入框的 name 属性--><p>代码如下：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;#&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-10-表单项标签"><a href="#1-10-表单项标签" class="headerlink" title="1.10  表单项标签"></a>1.10  表单项标签</h3><p>表单项标签有很多，不同的表单项标签有不同的展示效果。表单项标签可以分为以下三个：</p><h5 id="1-10-1-控制type属性"><a href="#1-10-1-控制type属性" class="headerlink" title="1.10.1&lt;input&gt; 控制type属性"></a>1.10.1<strong>&lt;input&gt; 控制type属性</strong></h5><p><strong>表单项，通过type属性控制输入形式</strong></p><p><code>input</code> 标签有个 <code>type</code> 属性。 <code>type</code> 属性的取值不同，展示的效果也不一样</p><h5 id="1-10-2下拉列表"><a href="#1-10-2下拉列表" class="headerlink" title="1.10.2&lt;select&gt;下拉列表"></a>1.10.2<strong>&lt;select&gt;下拉列表</strong></h5><p>定义下拉列表，<strong>&lt;option&gt;</strong> 定义列表项 </p><p>如下图就是下拉列表的效果：</p><h5 id="1-10-3-文本域标签"><a href="#1-10-3-文本域标签" class="headerlink" title="1.10.3**&lt;textarea&gt;**文本域标签"></a>1.10.3**&lt;textarea&gt;**文本域标签</h5><p>它可以输入多行文本，而 <code>input</code> 数据框只能输入一行文本。</p><p>使用cols(每行字符数)  rows(行数)修改文本框大小</p><p><code>&lt;textarea cols=&quot;20&quot; rows=&quot;5&quot; name=&quot;text&quot;&gt;&lt;/textarea&gt;</code> </p><blockquote><p><strong>注意：</strong></p><ul><li><strong>以上标签项的内容要想提交，必须得定义 <code>name</code> 属性。</strong></li><li><strong>每一个标签都有id属性，id属性值是唯一的标识。</strong></li><li><strong>单选框、复选框、下拉列表需要使用 <code>value</code> 属性指定提交的值。</strong></li></ul></blockquote><p><strong>小知识点：</strong></p><ul><li>使用<label>标签可以增加文本框的点击范围</li></ul><p><code>&lt;label for=&quot;username&quot;&gt;用户名&lt;/label&gt;</code></p><p><code>&lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;username&quot;&gt;</code></p><p>注意：<label>标签for值必须与<input>标签的id值一致</p><ul><li>在单选、多选、下拉列表中 <em>value 是后台数据提交显示的值</em>（用于区分选择的内容）没有<em>value</em>，后台数据显示为 on 或者文本内容</li><li>在多选中必须需要定义相同的 <em>name</em>值</li><li>二选一（男和女），必须定义不同的 <em>for</em> 值</li></ul><p><strong>代码演示：</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;#&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;username&quot;</span>&gt;</span>用户名：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;password&quot;</span>&gt;</span>密码：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">id</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        性别：</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> <span class="attr">id</span>=<span class="string">&quot;male&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;male&quot;</span>&gt;</span>男<span class="tag">&lt;/<span class="name">label</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span> <span class="attr">id</span>=<span class="string">&quot;female&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;female&quot;</span>&gt;</span>女<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        爱好：</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span> 旅游</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>&gt;</span> 电影</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;3&quot;</span>&gt;</span> 游戏</span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        头像：</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        城市:</span><br><span class="line">        <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;city&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;shanghai&quot;</span>&gt;</span>上海<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>广州<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        个人描述：</span><br><span class="line">        <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">cols</span>=<span class="string">&quot;20&quot;</span> <span class="attr">rows</span>=<span class="string">&quot;5&quot;</span> <span class="attr">name</span>=<span class="string">&quot;desc&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;免费注册&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span> <span class="attr">value</span>=<span class="string">&quot;重置&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;一个按钮&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2，CSS"><a href="#2，CSS" class="headerlink" title="2，CSS"></a>2，CSS</h2><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1  概述"></a>2.1  概述</h3><p>&#x3D;&#x3D;CSS 是一门语言，用于控制网页表现。&#x3D;&#x3D;我们之前介绍过W3C标准。W3C标准规定了网页是由以下组成：</p><ul><li>结构：HTML</li><li>表现：CSS</li><li>行为：JavaScript</li></ul><p>CSS也有一个专业的名字：&#x3D;&#x3D;Cascading Style Sheet（层叠样式表）。&#x3D;&#x3D;</p><p>如下面的代码， <code>style</code> 标签中定义的就是css代码。该代码描述了将 div 标签的内容的字体颜色设置为 红色。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">div</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello CSS~<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-2-css-导入方式"><a href="#2-2-css-导入方式" class="headerlink" title="2.2  css 导入方式"></a>2.2  css 导入方式</h3><p>css 导入方式其实就是 css 代码和 html 代码的结合方式。CSS 导入 HTML有三种方式：</p><ul><li><p>内联样式：在标签内部使用style属性，属性值是css属性键值对</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;color: red&quot;</span>&gt;</span>Hello CSS~<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>给方式只能作用在这一个标签上，如果其他的标签也想使用同样的样式，那就需要在其他标签上写上相同的样式。复用性太差。</p></blockquote></li><li><p>内部样式：定义<style>标签，在标签内部定义css样式</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-tag">div</span>&#123;</span></span><br><span class="line"><span class="language-css"><span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>这种方式可以做到在该页面中复用。</p></blockquote></li><li><p>外部样式：定义link标签，引入外部的css文件</p><p>编写一个css文件。名为：demo.css，内容如下:</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line"><span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在html中引入 css 文件。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span>  <span class="attr">href</span>=<span class="string">&quot;demo.css&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>这种方式可以在多个页面进行复用。其他的页面想使用同样的样式，只需要使用 <code>link</code> 标签引入该css文件。</p></blockquote></li></ul><p>编写页面 <code>02-导入方式.html</code>，内容如下：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">span</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;../css/demo.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;color: red&quot;</span>&gt;</span>hello css<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>hello css <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>hello css<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-3-css-选择器"><a href="#2-3-css-选择器" class="headerlink" title="2.3  css 选择器"></a>2.3  css 选择器</h3><p>css 选择器就是选取需设置样式的元素（标签），比如如下css代码：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line"><span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码中的 <code>div</code> 就是 css 中的选择器。我们只讲下面三种选择器：</p><ul><li><p>元素选择器</p><p>格式：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">元素名称&#123;<span class="attribute">color</span>: red;&#125;</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">div &#123;color:red&#125;  /*该代码表示将页面中所有的div标签的内容的颜色设置为红色*/</span><br></pre></td></tr></table></figure></li><li><p>id选择器</p><p>格式：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#id</span>属性值&#123;<span class="attribute">color</span>: red;&#125;</span><br></pre></td></tr></table></figure><p>例子：</p><p>html代码如下：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;name&quot;</span>&gt;</span>hello css2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>css代码如下：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#name</span>&#123;<span class="attribute">color</span>: red;&#125;<span class="comment">/*该代码表示将页面中所有的id属性值是 name 的标签的内容的颜色设置为红色*/</span></span><br></pre></td></tr></table></figure></li><li><p>类选择器</p><p>格式：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.class</span>属性值&#123;<span class="attribute">color</span>: red;&#125;</span><br></pre></td></tr></table></figure><p>例子：</p><p>html代码如下：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cls&quot;</span>&gt;</span>hello css3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>css代码如下：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.cls</span>&#123;<span class="attribute">color</span>: red;&#125; <span class="comment">/*该代码表示将页面中所有的class属性值是 cls 的标签的内容的颜色设置为红色*/</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>代码演示：</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">div</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-id">#name</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: blue;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.cls</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: pink;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>div1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;name&quot;</span>&gt;</span>div2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cls&quot;</span>&gt;</span>div3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;cls&quot;</span>&gt;</span>span<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-4-css-属性"><a href="#2-4-css-属性" class="headerlink" title="2.4  css 属性"></a>2.4  css 属性</h3><p>css有很多css属性，你要想把它们都学会，需要花费很长的时间。而作为java程序员，不需要重点掌握这部分内容。对于网页三剑客中css是对我们要求最低的。给大家简单介绍一下文档怎么查看即可。</p>]]></content>
      
      
      
        <tags>
            
            <tag> HTML,CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis</title>
      <link href="/post/da3e1361.html"/>
      <url>/post/da3e1361.html</url>
      
        <content type="html"><![CDATA[<h2 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h2><h3 id="1-Mybatis概述"><a href="#1-Mybatis概述" class="headerlink" title="1. Mybatis概述"></a>1. Mybatis概述</h3><h4 id="1-1-Mybatis概念"><a href="#1-1-Mybatis概念" class="headerlink" title="1.1  Mybatis概念"></a>1.1  Mybatis概念</h4><blockquote><ul><li><p><strong><u><em>MyBatis 是一款优秀的&#x3D;&#x3D;持久层框架&#x3D;&#x3D;，用于简化 JDBC 开发</em></u></strong></p></li><li><p>MyBatis 本是 Apache 的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。2013年11月迁移到Github</p></li><li><p>官网：<a href="https://mybatis.org/mybatis-3/zh/index.html">https://mybatis.org/mybatis-3/zh/index.html</a></p></li></ul></blockquote><p><strong>持久层：</strong></p><ul><li><p>负责将数据到保存到数据库的那一层代码。</p><p>我们会将操作数据库的Java代码作为持久层。而Mybatis就是对jdbc代码进行了封装。</p></li><li><p>JavaEE三层架构：表现层、业务层、持久层</p></li></ul><p><strong>框架：</strong></p><ul><li><p>框架就是一个半成品软件，是一套可重用的、通用的、软件基础代码模型</p></li><li><p>在框架的基础之上构建软件编写更加高效、规范、通用、可扩展</p></li></ul><p>了解了什么是Mybatis后，接下来说说以前 <code>JDBC代码</code> 的缺点以及Mybatis又是如何解决的。</p><h4 id="1-2-JDBC-缺点"><a href="#1-2-JDBC-缺点" class="headerlink" title="1.2  JDBC 缺点"></a>1.2  JDBC 缺点</h4><ul><li><p><strong>硬编码</strong></p><ul><li><p>注册驱动、获取连接</p><p>连接数据库的四个基本信息，以后如果要将Mysql数据库换成其他的关系型数据库的话，这四个地方都需要修改，如果放在此处就意味着要修改我们的源代码。</p></li><li><p>SQL语句</p><p>如果表结构发生变化，SQL语句就要进行更改。这也不方便后期的维护。</p></li></ul></li><li><p><strong>操作繁琐</strong></p><ul><li><p>手动设置参数</p></li><li><p>手动封装结果集</p><p>对查询到的数据进行封装，而这部分代码是没有什么技术含量，而且特别耗费时间的。</p></li></ul></li></ul><h4 id="1-3-Mybatis-优化"><a href="#1-3-Mybatis-优化" class="headerlink" title="1.3  Mybatis 优化"></a>1.3  Mybatis 优化</h4><ul><li>硬编码可以配置到&#x3D;&#x3D;配置文件&#x3D;&#x3D;</li><li>操作繁琐的地方mybatis都&#x3D;&#x3D;自动完成&#x3D;&#x3D;</li></ul><h3 id="2-Mybatis快速入门"><a href="#2-Mybatis快速入门" class="headerlink" title="2. Mybatis快速入门"></a>2. Mybatis快速入门</h3><p><strong>需求：查询user表中所有的数据</strong></p><ul><li><p>创建user表，添加数据</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> database mybatis;</span><br><span class="line">use mybatis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> tb_user;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tb_user(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">username <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">password <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">gender <span class="type">char</span>(<span class="number">1</span>),</span><br><span class="line">addr <span class="type">varchar</span>(<span class="number">30</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_user <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;zhangsan&#x27;</span>, <span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;北京&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_user <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">&#x27;李四&#x27;</span>, <span class="string">&#x27;234&#x27;</span>, <span class="string">&#x27;女&#x27;</span>, <span class="string">&#x27;天津&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_user <span class="keyword">VALUES</span> (<span class="number">3</span>, <span class="string">&#x27;王五&#x27;</span>, <span class="string">&#x27;11&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;西安&#x27;</span>);</span><br></pre></td></tr></table></figure></li><li><p>创建模块，导入坐标</p><p>在创建好的模块中的 pom.xml 配置文件中添加依赖的坐标</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--mybatis 依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--mysql 驱动--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.46<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--junit 单元测试--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 添加slf4j日志api --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.20<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 添加logback-classic依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 添加logback-core依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意：需要在项目的 resources 目录下创建logback的配置文件</strong></p></li><li><p>编写 MyBatis 核心配置文件 – &gt; 替换连接信息 解决硬编码问题</p><p>在模块下的 resources 目录下创建mybatis的配置文件 <code>mybatis-config.xml</code>，内容如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    //直接加载pojo下的全部的类，解决代码繁琐</span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.itheima.pojo&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    environments：配置数据库连接环境信息。可以配置多个environment，通过default属性切换不同的environment</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--数据库连接信息--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql:///mybatis?useSSL=false&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1234&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--数据库连接信息--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql:///mybatis?useSSL=false&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1234&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--加载sql映射文件--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写 SQL 映射文件 –&gt; 统一管理sql语句，解决硬编码问题</p><p>在模块的 <code>resources</code> 目录下创建映射配置文件 <code>UserMapper.xml</code>，内容如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.itheima.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        select * from tb_user;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编码</p><ul><li><p>在 <code>com.itheima.pojo</code> 包下创建 User类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">    <span class="keyword">private</span> String addr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//省略了 setter 和 getter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在 <code>com.itheima</code> 包下编写 MybatisDemo 测试类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1. 加载mybatis的核心配置文件，获取 SqlSessionFactory</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 获取SqlSession对象，用它来执行sql</span></span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">        <span class="comment">//3. 执行sql</span></span><br><span class="line">        List&lt;User&gt; users = sqlSession.selectList(<span class="string">&quot;test.selectAll&quot;</span>); <span class="comment">//参数是一个字符串，该字符串必须是映射配置文件的namespace.id</span></span><br><span class="line">        System.out.println(users);</span><br><span class="line">        <span class="comment">//4. 释放资源</span></span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p><strong>解决SQL映射文件的警告提示：</strong></p><p>在入门案例映射配置文件中存在报红的情况。</p><ul><li>产生的原因：Idea和数据库没有建立连接，不识别表信息。一定要记住，它并不影响程序的执行。</li><li>解决方式：在Idea中配置MySQL数据库连接。</li></ul><p>IDEA中配置MySQL数据库连接</p><ul><li><p>点击IDEA右边框的 <code>Database</code> ，在展开的界面点击 <code>+</code> 选择 <code>Data Source</code> ，再选择 <code>MySQL</code></p></li><li><p>在弹出的界面进行基本信息的填写</p></li><li><p>点击完成后就能看到如下界面</p><p>而此界面就和 <code>navicat</code> 工具一样可以进行数据库的操作。也可以编写SQL语句</p></li></ul><h3 id="3-Mapper代理开发"><a href="#3-Mapper代理开发" class="headerlink" title="3.  Mapper代理开发"></a>3.  Mapper代理开发</h3><h4 id="3-1-Mapper代理开发概述"><a href="#3-1-Mapper代理开发概述" class="headerlink" title="3.1  Mapper代理开发概述"></a>3.1  Mapper代理开发概述</h4><p>之前我们写的代码是基本使用方式，它也存在硬编码的问题。</p><p>Mapper 代理方式的目的：</p><ul><li>解决原生方式中的硬编码</li><li>简化后期执行SQL</li></ul><p>Mybatis 官网也是推荐使用 Mapper 代理的方式。</p><h4 id="3-2-使用Mapper代理要求"><a href="#3-2-使用Mapper代理要求" class="headerlink" title="3.2  使用Mapper代理要求"></a>3.2  使用Mapper代理要求</h4><p>使用Mapper代理方式，必须满足以下要求：</p><ul><li><p>&#x3D;&#x3D;定义与SQL映射文件同名的Mapper接口，并且将Mapper接口和SQL映射文件放置在同一目录下。&#x3D;&#x3D; </p></li><li><p>&#x3D;&#x3D;设置SQL映射文件的namespace属性为Mapper接口全限定名&#x3D;&#x3D; </p></li><li><p>&#x3D;&#x3D;在 Mapper 接口中定义方法，方法名就是SQL映射文件中sql语句的id，并保持参数类型和返回值类型一致&#x3D;&#x3D;</p></li></ul><h4 id="3-3-案例代码实现"><a href="#3-3-案例代码实现" class="headerlink" title="3.3  案例代码实现"></a>3.3  案例代码实现</h4><ul><li><p>在 <code>com.itheima.mapper</code> 包下创建 UserMapper接口，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    List&lt;User&gt; <span class="title function_">selectAll</span><span class="params">()</span>;</span><br><span class="line">    User <span class="title function_">selectById</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在 <code>resources</code> 下创建 <code>com/itheima/mapper</code> 目录，并在该目录下创建 UserMapper.xml 映射配置文件</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    namespace:名称空间。必须是对应接口的全限定名</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.itheima.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.itheima.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        select *</span><br><span class="line">        from tb_user;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在 <code>com.itheima</code> 包下创建 MybatisDemo2 测试类，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Mybatis 代理开发</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisDemo2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 加载mybatis的核心配置文件，获取 SqlSessionFactory</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 获取SqlSession对象，用它来执行sql</span></span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">        <span class="comment">//3. 执行sql</span></span><br><span class="line">        <span class="comment">//3.1 获取UserMapper接口的代理对象</span></span><br><span class="line">        <span class="type">UserMapper</span> <span class="variable">userMapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line">        List&lt;User&gt; users = userMapper.selectAll();</span><br><span class="line"></span><br><span class="line">        System.out.println(users);</span><br><span class="line">        <span class="comment">//4. 释放资源</span></span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>&#x3D;&#x3D;注意：&#x3D;&#x3D;</p><p>如果Mapper接口名称和SQL映射文件名称相同，并在同一目录下，则可以使用包扫描的方式简化SQL映射文件的加载。也就是将核心配置文件的加载映射配置文件的配置修改为</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--加载sql映射文件--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;mapper resource=&quot;com/itheima/mapper/UserMapper.xml&quot;/&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--Mapper代理方式--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.itheima.mapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="4-核心配置文件"><a href="#4-核心配置文件" class="headerlink" title="4.  核心配置文件"></a>4.  核心配置文件</h3><p>核心配置文件中还可以配置很多内容。我们可以通过查询官网看可以配置的内容。</p><h4 id="4-1-数据库连接环境"><a href="#4-1-数据库连接环境" class="headerlink" title="4.1  数据库连接环境"></a>4.1  数据库连接环境</h4><!--environments：配置数据库连接环境信息--><p>在核心配置文件的 <code>environments</code> 标签中其实是可以配置多个 <code>environment</code> ，使用 <code>id</code> 给每段环境起名，在 <code>environments</code> 中使用 <code>default=&#39;环境id&#39;</code> 来指定使用哪儿段配置。我们一般就配置一个 <code>environment</code> 即可。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--environments：配置数据库连接环境信息，可以配置多个environment，通过 default属性切换不同的environment--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--development为一个数据库连接环境信息--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--数据库连接信息--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql:///mybatis?useSSL=false&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1234&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--数据库连接信息--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql:///mybatis?useSSL=false&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1234&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br></pre></td></tr></table></figure><!--加载sql映射文件--><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--1.路径扫描繁琐  &lt;mapper resource=&quot;com/itheima/mapper/UserMapper.xml&quot;/--&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!--2.包扫描:遵守三个规则就能使用--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.itheima.mapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>配置文件详解</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line">        <span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">                <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">                <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--environments：配置数据库连接环境信息，可以配置多个environment，通过 default属性切换不同的environment--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--development为一个数据库连接环境信息--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--事务管理信息，此配置不做修改--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--数据库连接池，mybatis默认连接池pooled,此配置不做修改--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--连接信息--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/mybatis?useSSL=false&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1234&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--加载sql映射文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--1.&lt;mapper resource=&quot;com/itheima/mapper/UserMapper.xml&quot;/&gt;--&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!--2.包扫描:遵守三个规则就能使用--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.itheima.mapper&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="4-2-类型别名"><a href="#4-2-类型别名" class="headerlink" title="4.2  类型别名"></a>4.2  类型别名</h4><p>在映射配置文件中的 <code>resultType</code> 属性需要配置数据封装的类型（类的全限定名）。而每次这样写是特别麻烦的，Mybatis 提供了 <code>类型别名</code>(typeAliases) 可以简化这部分的书写。</p><p>首先需要现在核心配置文件中配置类型别名，也就意味着给pojo包下所有的类起了别名（别名就是类名），不区分大小写。内容如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;typeAliases&gt;</span><br><span class="line">    &lt;!--name属性的值是实体类所在包--&gt;</span><br><span class="line">    &lt;package name=&quot;com.itheima.pojo&quot;/&gt; </span><br><span class="line">&lt;/typeAliases&gt;</span><br></pre></td></tr></table></figure><p>通过上述的配置，我们就可以简化映射配置文件中 <code>resultType</code> 属性值的编写</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.itheima.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">        select * from tb_user;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Mybatis练习"><a href="#Mybatis练习" class="headerlink" title="Mybatis练习"></a>Mybatis练习</h2><p><strong>目标</strong></p><blockquote><ul><li>能够使用映射配置文件实现CRUD操作</li><li>能够使用注解实现CRUD操作</li></ul></blockquote><h2 id="1-配置文件实现CRUD"><a href="#1-配置文件实现CRUD" class="headerlink" title="1.配置文件实现CRUD"></a>1.配置文件实现CRUD</h2><p>如上图所示产品原型，里面包含了品牌数据的 <code>查询</code> 、<code>按条件查询</code>、<code>添加</code>、<code>删除</code>、<code>批量删除</code>、<code>修改</code> 等功能，而这些功能其实就是对数据库表中的数据进行CRUD操作。接下来我们就使用Mybatis完成品牌数据的增删改查操作。以下是我们要完成功能列表：</p><blockquote><ul><li>查询<ul><li>查询所有数据</li><li>查询详情</li><li>条件查询</li></ul></li><li>添加</li><li>修改<ul><li>修改全部字段</li><li>修改动态字段</li></ul></li><li>删除<ul><li>删除一个</li><li>批量删除</li></ul></li></ul></blockquote><p>我们先将必要的环境准备一下。</p><h3 id="1-1-环境准备"><a href="#1-1-环境准备" class="headerlink" title="1.1  环境准备"></a>1.1  环境准备</h3><ul><li><p>数据库表（tb_brand）及数据准备</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 删除tb_brand表</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> tb_brand;</span><br><span class="line"><span class="comment">-- 创建tb_brand表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tb_brand</span><br><span class="line">(</span><br><span class="line">    <span class="comment">-- id 主键</span></span><br><span class="line">    id           <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">    <span class="comment">-- 品牌名称</span></span><br><span class="line">    brand_name   <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    <span class="comment">-- 企业名称</span></span><br><span class="line">    company_name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    <span class="comment">-- 排序字段</span></span><br><span class="line">    ordered      <span class="type">int</span>,</span><br><span class="line">    <span class="comment">-- 描述信息</span></span><br><span class="line">    description  <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">    <span class="comment">-- 状态：0：禁用  1：启用</span></span><br><span class="line">    status       <span class="type">int</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 添加数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_brand (brand_name, company_name, ordered, description, status)</span><br><span class="line"><span class="keyword">values</span> (<span class="string">&#x27;三只松鼠&#x27;</span>, <span class="string">&#x27;三只松鼠股份有限公司&#x27;</span>, <span class="number">5</span>, <span class="string">&#x27;好吃不上火&#x27;</span>, <span class="number">0</span>),</span><br><span class="line">       (<span class="string">&#x27;华为&#x27;</span>, <span class="string">&#x27;华为技术有限公司&#x27;</span>, <span class="number">100</span>, <span class="string">&#x27;华为致力于把数字世界带入每个人、每个家庭、每个组织，构建万物互联的智能世界&#x27;</span>, <span class="number">1</span>),</span><br><span class="line">       (<span class="string">&#x27;小米&#x27;</span>, <span class="string">&#x27;小米科技有限公司&#x27;</span>, <span class="number">50</span>, <span class="string">&#x27;are you ok&#x27;</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure></li><li><p>实体类 Brand</p><p>在 <code>com.itheima.pojo</code> 包下创建 Brand 实体类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Brand</span> &#123;</span><br><span class="line">    <span class="comment">// id 主键</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="comment">// 品牌名称</span></span><br><span class="line">    <span class="keyword">private</span> String brandName;</span><br><span class="line">    <span class="comment">// 企业名称</span></span><br><span class="line">    <span class="keyword">private</span> String companyName;</span><br><span class="line">    <span class="comment">// 排序字段</span></span><br><span class="line">    <span class="keyword">private</span> Integer ordered;</span><br><span class="line">    <span class="comment">// 描述信息</span></span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">    <span class="comment">// 状态：0：禁用  1：启用</span></span><br><span class="line">    <span class="keyword">private</span> Integer status;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//省略 setter and getter。自己写时要补全这部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写测试用例</p><p>测试代码需要在 <code>test/java</code> 目录下创建包及测试用例。</p></li><li><p>安装 MyBatisX 插件</p><ul><li><p>MybatisX 是一款基于 IDEA 的快速开发插件，为效率而生。</p></li><li><p>主要功能</p><ul><li>XML映射配置文件 和 接口方法间相互跳转</li><li>根据接口方法生成 statement</li></ul></li><li><p>安装方式</p><p>点击 <code>file</code> ，选择 <code>settings</code> ，就能看到如下图所示界面</p><blockquote><p>注意：安装完毕后需要重启IDEA</p></blockquote></li><li><p>插件效果</p><p>红色头绳的表示映射配置文件，蓝色头绳的表示mapper接口。在mapper接口点击红色头绳的小鸟图标会自动跳转到对应的映射配置文件，在映射配置文件中点击蓝色头绳的小鸟图标会自动跳转到对应的mapper接口。也可以在mapper接口中定义方法，自动生成映射配置文件中的 <code>statement</code> 。</p></li></ul></li></ul><h3 id="1-2-查询所有数据"><a href="#1-2-查询所有数据" class="headerlink" title="1.2  查询所有数据"></a>1.2  查询所有数据</h3><p>查询所有数据功能，而实现该功能我们分以下步骤进行实现：</p><ul><li><p>编写接口方法：Mapper接口</p><ul><li><p>参数：无</p><p>查询所有数据功能是不需要根据任何条件进行查询的，所以此方法不需要参数。</p></li><li><p>结果：List<Brand></p><p>我们会将查询出来的每一条数据封装成一个 <code>Brand</code> 对象，而多条数据封装多个 <code>Brand</code> 对象，需要将这些对象封装到List集合中返回。</p></li><li><p>执行方法、测试</p></li></ul></li></ul><h4 id="1-2-1-编写接口方法"><a href="#1-2-1-编写接口方法" class="headerlink" title="1.2.1  编写接口方法"></a>1.2.1  编写接口方法</h4><p>在 <code>com.itheima.mapper</code> 包写创建名为 <code>BrandMapper</code> 的接口。并在该接口中定义 <code>List&lt;Brand&gt; selectAll()</code> 方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BrandMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询所有</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;Brand&gt; <span class="title function_">selectAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-2-编写SQL语句"><a href="#1-2-2-编写SQL语句" class="headerlink" title="1.2.2  编写SQL语句"></a>1.2.2  编写SQL语句</h4><p>在 <code>reources</code> 下创建 <code>com/itheima/mapper</code> 目录结构，并在该目录下创建名为 <code>BrandMapper.xml</code> 的映射配置文件</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.itheima.mapper.BrandMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;brand&quot;</span>&gt;</span></span><br><span class="line">        select *</span><br><span class="line">        from tb_brand;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="1-2-3-编写测试方法"><a href="#1-2-3-编写测试方法" class="headerlink" title="1.2.3  编写测试方法"></a>1.2.3  编写测试方法</h4><p>在 <code>MybatisTest</code> 类中编写测试查询所有的方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectAll</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//1. 获取SqlSessionFactory</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line">    <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 获取SqlSession对象</span></span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 获取Mapper接口的代理对象</span></span><br><span class="line">    <span class="type">BrandMapper</span> <span class="variable">brandMapper</span> <span class="operator">=</span> sqlSession.getMapper(BrandMapper.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. 执行方法</span></span><br><span class="line">    List&lt;Brand&gt; brands = brandMapper.selectAll();</span><br><span class="line">    System.out.println(brands);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5. 释放资源</span></span><br><span class="line">    sqlSession.close();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：现在我们感觉测试这部分代码写起来特别麻烦，我们可以先忍忍。以后我们只会写上面的第3步的代码，其他的都不需要我们来完成。</p></blockquote><p>从上面结果我们看到了问题，有些数据封装成功了，而有些数据并没有封装成功。为什么这样呢？</p><p>这个问题可以通过两种方式进行解决：</p><ul><li>给字段起别名</li><li>使用resultMap定义字段和属性的映射关系</li></ul><h4 id="注意：数据库部分数据封装为null的问题"><a href="#注意：数据库部分数据封装为null的问题" class="headerlink" title="注意：数据库部分数据封装为null的问题"></a>注意：数据库部分数据封装为null的问题</h4><p><em><strong>数据库表的字段名称 和 实体类属性名称 不一致，则不能自动封装数据</strong></em></p><p>从上面结果可以看到 <code>brandName</code> 和 <code>companyName</code> 这两个属性的数据没有封装成功，查询 实体类 和 表中的字段 发现，在实体类中属性名是 <code>brandName</code> 和 <code>companyName</code> ，而表中的字段名为 <code>brand_name</code> 和 <code>company_name</code>。</p><h5 id="1-起别名：（繁琐）"><a href="#1-起别名：（繁琐）" class="headerlink" title="1.起别名：（繁琐）"></a>1.起别名：（繁琐）</h5><p>那么我们只需要保持这两部分的名称一致这个问题就迎刃而解。</p><p><strong>我们可以在写sql语句时给这两个字段起别名，将别名定义成和属性名一致即可。</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;brand&quot;</span>&gt;</span></span><br><span class="line">    select</span><br><span class="line">    id, brand_name as brandName, company_name as companyName, ordered, description, status</span><br><span class="line">    from tb_brand;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>而上面的SQL语句中的字段列表书写麻烦，如果表中还有更多的字段，同时其他的功能也需要查询这些字段时就显得我们的代码不够精炼。Mybatis提供了<code>sql</code> 片段可以提高sql的复用性。</p><h5 id="2-SQL片段：（不灵活）"><a href="#2-SQL片段：（不灵活）" class="headerlink" title="2.SQL片段：（不灵活）"></a><strong>2.SQL片段：（不灵活）</strong></h5><ul><li><p>将需要复用的SQL片段抽取到 <code>sql</code> 标签中</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;brand_column&quot;</span>&gt;</span></span><br><span class="line">id, brand_name as brandName, company_name as companyName, ordered, description, status</span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br></pre></td></tr></table></figure><p>id属性值是唯一标识，引用时也是通过该值进行引用。</p></li><li><p>在原sql语句中进行引用</p><p>使用 <code>include</code> 标签引用上述的 SQL 片段，而 <code>refid</code> 指定上述 SQL 片段的id值。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;brand&quot;</span>&gt;</span></span><br><span class="line">    select</span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;brand_column&quot;</span> /&gt;</span></span><br><span class="line">    from tb_brand;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="3-使用resultMap解决上述问题"><a href="#3-使用resultMap解决上述问题" class="headerlink" title="3.使用resultMap解决上述问题"></a>3.使用resultMap解决上述问题</h5><p>起别名 + sql片段的方式可以解决上述问题，但是它也存在问题。如果还有功能只需要查询部分字段，而不是查询所有字段，那么我们就需要再定义一个 SQL 片段，这就显得不是那么灵活。</p><p>那么我们也可以使用resultMap来定义字段和属性的映射关系的方式解决上述问题。</p><ul><li><p>在映射配置文件中使用resultMap定义 字段 和 属性 的映射关系</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--id：完成主键字段的映射（随便取名）  type：属性名（类名）--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;brandResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;brand&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--result：完成一般字段的映射</span></span><br><span class="line"><span class="comment">        column：表的列名</span></span><br><span class="line"><span class="comment">property：实体类的属性名</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;brand_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;brandName&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;company_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;companyName&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：在上面只需要定义 字段名 和 属性名 不一样的映射，而一样的则不需要专门定义出来。</p></blockquote></li><li><p>SQL语句编写</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--id：对应接口的方法名（定义接口自动生成）   resultMap：对应上面主键字段的映射名--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;brandResultMap&quot;</span>&gt;</span></span><br><span class="line">    select *</span><br><span class="line">    from tb_brand;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="1-2-4-小结"><a href="#1-2-4-小结" class="headerlink" title="1.2.4  小结"></a>1.2.4  小结</h4><p>实体类属性名 和 数据库表列名 不一致，不能自动封装数据</p><ul><li>&#x3D;&#x3D;起别名：&#x3D;&#x3D;在SQL语句中，对不一样的列名起别名，别名和实体类属性名一样<ul><li>可以定义 <sql>片段，提升复用性</li></ul></li><li>&#x3D;&#x3D;resultMap：&#x3D;&#x3D;定义<resultMap> 完成不一致的属性名和列名的映射</li></ul><p>而我们最终选择使用 resultMap的方式。查询映射配置文件中查询所有的 statement 书写如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;brandResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;brand&quot;</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            id：完成主键字段的映射</span></span><br><span class="line"><span class="comment">                column：表的列名</span></span><br><span class="line"><span class="comment">                property：实体类的属性名</span></span><br><span class="line"><span class="comment">            result：完成一般字段的映射</span></span><br><span class="line"><span class="comment">                column：表的列名</span></span><br><span class="line"><span class="comment">                property：实体类的属性名</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;brand_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;brandName&quot;</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;company_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;companyName&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;brandResultMap&quot;</span>&gt;</span></span><br><span class="line">    select *</span><br><span class="line">    from tb_brand;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-3-查询详情"><a href="#1-3-查询详情" class="headerlink" title="1.3  查询详情"></a>1.3  查询详情</h3><p>有些数据的属性比较多，在页面表格中无法全部实现，而只会显示部分，而其他属性数据的查询可以通过 <code>查看详情</code> 来进行查询。</p><p>查看详情功能实现步骤：</p><ul><li><p><strong>编写接口方法：Mapper接口</strong></p><ul><li><p>参数：id</p><p>查看详情就是查询某一行数据，所以需要根据id进行查询。而id以后是由页面传递过来。</p></li><li><p>结果：Brand</p><p>根据id查询出来的数据只要一条，而将一条数据封装成一个Brand对象即可</p></li></ul></li><li><p><strong>编写SQL语句：SQL映射文件</strong></p></li><li><p>执行方法、进行测试</p></li></ul><h4 id="1-3-1-编写接口方法"><a href="#1-3-1-编写接口方法" class="headerlink" title="1.3.1  编写接口方法"></a>1.3.1  编写接口方法</h4><p>在 <code>BrandMapper</code> 接口中定义根据id查询数据的方法 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 查看详情：根据Id查询</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">Brand <span class="title function_">selectById</span><span class="params">(<span class="type">int</span> id)</span>;</span><br></pre></td></tr></table></figure><h4 id="1-3-2-编写SQL语句"><a href="#1-3-2-编写SQL语句" class="headerlink" title="1.3.2  编写SQL语句"></a>1.3.2  编写SQL语句</h4><p>在 <code>BrandMapper.xml</code> 映射配置文件中编写 <code>statement</code>，使用 <code>resultMap</code> 而不是使用 <code>resultType</code></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectById&quot;</span>  <span class="attr">resultMap</span>=<span class="string">&quot;brandResultMap&quot;</span>&gt;</span></span><br><span class="line">    select *</span><br><span class="line">    from tb_brand where id = #&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：上述SQL中的 #{id}先这样写，一会我们再详细讲解</p></blockquote><h4 id="1-3-3-编写测试方法"><a href="#1-3-3-编写测试方法" class="headerlink" title="1.3.3  编写测试方法"></a>1.3.3  编写测试方法</h4><p>在 <code>test/java</code> 下的 <code>com.itheima.mapper</code>  包下的 <code>MybatisTest类中</code> 定义测试方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectById</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//接收参数，该id以后需要传递过来</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 获取SqlSessionFactory</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line">    <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 获取SqlSession对象</span></span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 获取Mapper接口的代理对象</span></span><br><span class="line">    <span class="type">BrandMapper</span> <span class="variable">brandMapper</span> <span class="operator">=</span> sqlSession.getMapper(BrandMapper.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. 执行方法</span></span><br><span class="line">    <span class="type">Brand</span> <span class="variable">brand</span> <span class="operator">=</span> brandMapper.selectById(id);</span><br><span class="line">    System.out.println(brand);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5. 释放资源</span></span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-4-参数占位符（重点）"><a href="#1-3-4-参数占位符（重点）" class="headerlink" title="1.3.4  参数占位符（重点）"></a>1.3.4  参数占位符（重点）</h4><p>查询到的结果很好理解就是id为1的这行数据。而这里我们需要看控制台显示的SQL语句，能看到使用？进行占位。说明我们在映射配置文件中的写的 <code>#&#123;id&#125;</code> 最终会被？进行占位。接下来我们就聊聊映射配置文件中的参数占位符。</p><p>mybatis提供了两种参数占位符：</p><ul><li><p>#{} ：执行SQL时，会将 #{} 占位符替换为？，将来自动设置参数值。从上述例子可以看出使用#{} 底层使用的是 <code>PreparedStatement</code></p></li><li><p>${} ：拼接SQL。底层使用的是 <code>Statement</code>，会存在SQL注入问题。如下图将 映射配置文件中的 #{} 替换成 ${} 来看效果</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectById&quot;</span>  <span class="attr">resultMap</span>=<span class="string">&quot;brandResultMap&quot;</span>&gt;</span></span><br><span class="line">    select *</span><br><span class="line">    from tb_brand where id = $&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>&#x3D;&#x3D;注意：&#x3D;&#x3D;从上面两个例子可以看出，以后开发我们使用 #{} 参数占位符。</p></blockquote><h4 id="1-3-5-parameterType使用（可以省略）"><a href="#1-3-5-parameterType使用（可以省略）" class="headerlink" title="1.3.5  parameterType使用（可以省略）"></a>1.3.5  parameterType使用（可以省略）</h4><p>对于有参数的mapper接口方法，我们在映射配置文件中应该配置 <code>ParameterType</code> 来指定参数类型。只不过该属性都可以省略。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;brandResultMap&quot;</span>&gt;</span></span><br><span class="line">    select *</span><br><span class="line">    from tb_brand where id = $&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="1-3-6-SQL语句中特殊字段处理（重点）"><a href="#1-3-6-SQL语句中特殊字段处理（重点）" class="headerlink" title="1.3.6  SQL语句中特殊字段处理（重点）"></a>1.3.6  SQL语句中特殊字段处理（重点）</h4><p>以后肯定会在SQL语句中写一下特殊字符，比如某一个字段大于某个值。</p><p>可以看出报错了，因为映射配置文件是xml类型的问题，而 &gt; &lt; 等这些字符在xml中有特殊含义，所以此时我们需要将这些符号进行转义，可以使用以下两种方式进行转义</p><ul><li><p>转义字符</p><p>下图的 <code>&amp;lt;</code> 就是 <code>&lt;</code> 的转义字符。</p></li><li><p>CDATA区</p><![CDATA[内容]]></li></ul><h3 id="1-4-多条件查询（动态SQL之-if-条件判断）"><a href="#1-4-多条件查询（动态SQL之-if-条件判断）" class="headerlink" title="1.4  多条件查询（动态SQL之 if 条件判断）"></a>1.4  多条件查询（动态SQL之 if 条件判断）</h3><p>我们经常会遇到如上图所示的多条件查询，将多条件查询的结果展示在下方的数据列表中。而我们做这个功能需要分析最终的SQL语句应该是什么样，思考两个问题</p><ul><li>条件表达式</li><li>如何连接</li></ul><p>简单的分析后，我们来看功能实现的步骤：</p><ul><li><p>编写接口方法</p><ul><li>参数：所有查询条件</li><li>结果：List<Brand></li></ul></li><li><p>在映射配置文件中编写SQL语句</p></li><li><p>编写测试方法并执行</p></li></ul><h4 id="1-4-1-编写接口方法"><a href="#1-4-1-编写接口方法" class="headerlink" title="1.4.1  编写接口方法"></a>1.4.1  编写接口方法</h4><p>在 <code>BrandMapper</code> 接口中定义多条件查询的方法。</p><p>而该功能有三个参数，我们就需要考虑定义接口时，参数应该如何定义。Mybatis针对多参数有多种实现</p><ul><li><p>使用 <code>@Param(&quot;参数名称&quot;)</code> 标记每一个参数，在映射配置文件中就需要使用 <code>#&#123;参数名称&#125;</code> 进行占位</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Brand&gt; <span class="title function_">selectByCondition</span><span class="params">(<span class="meta">@Param(&quot;status&quot;)</span> <span class="type">int</span> status, <span class="meta">@Param(&quot;companyName&quot;)</span> String companyName,<span class="meta">@Param(&quot;brandName&quot;)</span> String brandName)</span>;</span><br></pre></td></tr></table></figure></li><li><p>将多个参数封装成一个 实体对象 ，将该实体对象作为接口的方法参数。该方式要求在映射配置文件的SQL中使用 <code>#&#123;内容&#125;</code> 时，里面的内容必须和实体类属性名保持一致。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Brand&gt; <span class="title function_">selectByCondition</span><span class="params">(Brand brand)</span>;</span><br></pre></td></tr></table></figure></li><li><p>将多个参数封装到map集合中，将map集合作为接口的方法参数。该方式要求在映射配置文件的SQL中使用 <code>#&#123;内容&#125;</code> 时，里面的内容必须和map集合中键的名称一致。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;Brand&gt; selectByCondition(Map map);</span><br></pre></td></tr></table></figure></li></ul><h4 id="1-4-2-编写SQL语句"><a href="#1-4-2-编写SQL语句" class="headerlink" title="1.4.2  编写SQL语句"></a>1.4.2  编写SQL语句</h4><p>在 <code>BrandMapper.xml</code> 映射配置文件中编写 <code>statement</code>，使用 <code>resultMap</code> 而不是使用 <code>resultType</code></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByCondition&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;brandResultMap&quot;</span>&gt;</span></span><br><span class="line">    select *</span><br><span class="line">    from tb_brand</span><br><span class="line">    where status = #&#123;status&#125;</span><br><span class="line">    and company_name like #&#123;companyName&#125;</span><br><span class="line">    and brand_name like #&#123;brandName&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="1-4-3-编写测试方法"><a href="#1-4-3-编写测试方法" class="headerlink" title="1.4.3  编写测试方法"></a>1.4.3  编写测试方法</h4><p>在 <code>test/java</code> 下的 <code>com.itheima.mapper</code>  包下的 <code>MybatisTest类中</code> 定义测试方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectByCondition</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//接收参数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">status</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">companyName</span> <span class="operator">=</span> <span class="string">&quot;华为&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">brandName</span> <span class="operator">=</span> <span class="string">&quot;华为&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理参数</span></span><br><span class="line">    companyName = <span class="string">&quot;%&quot;</span> + companyName + <span class="string">&quot;%&quot;</span>;</span><br><span class="line">    brandName = <span class="string">&quot;%&quot;</span> + brandName + <span class="string">&quot;%&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 获取SqlSessionFactory</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line">    <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line">    <span class="comment">//2. 获取SqlSession对象</span></span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">    <span class="comment">//3. 获取Mapper接口的代理对象</span></span><br><span class="line">    <span class="type">BrandMapper</span> <span class="variable">brandMapper</span> <span class="operator">=</span> sqlSession.getMapper(BrandMapper.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. 执行方法</span></span><br><span class="line"><span class="comment">//方式一 ：接口方法参数使用 @Param 方式调用的方法</span></span><br><span class="line">    <span class="comment">//List&lt;Brand&gt; brands = brandMapper.selectByCondition(status, companyName, brandName);</span></span><br><span class="line">    <span class="comment">//方式二 ：接口方法参数是 实体类对象 方式调用的方法</span></span><br><span class="line">     <span class="comment">//封装对象</span></span><br><span class="line">    <span class="comment">/* Brand brand = new Brand();</span></span><br><span class="line"><span class="comment">        brand.setStatus(status);</span></span><br><span class="line"><span class="comment">        brand.setCompanyName(companyName);</span></span><br><span class="line"><span class="comment">        brand.setBrandName(brandName);*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//List&lt;Brand&gt; brands = brandMapper.selectByCondition(brand);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方式三 ：接口方法参数是 map集合对象 方式调用的方法</span></span><br><span class="line">    <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">    map.put(<span class="string">&quot;status&quot;</span> , status);</span><br><span class="line">    map.put(<span class="string">&quot;companyName&quot;</span>, companyName);</span><br><span class="line">    map.put(<span class="string">&quot;brandName&quot;</span> , brandName);</span><br><span class="line">    List&lt;Brand&gt; brands = brandMapper.selectByCondition(map);</span><br><span class="line">    System.out.println(brands);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5. 释放资源</span></span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-4-4-动态SQL（重点）"><a href="#1-4-4-动态SQL（重点）" class="headerlink" title="1.4.4  动态SQL（重点）"></a>1.4.4  动态SQL（重点）</h4><p>上述功能实现存在很大的问题。用户在输入条件时，肯定不会所有的条件都填写，这个时候我们的SQL语句就不能那样写的</p><p>例如用户只输入 当前状态 时，SQL语句就是</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_brand <span class="keyword">where</span> status <span class="operator">=</span> #&#123;status&#125;</span><br></pre></td></tr></table></figure><p>而用户如果只输入企业名称时，SQL语句就是</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_brand <span class="keyword">where</span> company_name <span class="keyword">like</span> #&#123;companName&#125;</span><br></pre></td></tr></table></figure><p>而用户如果输入了 <code>当前状态</code> 和 <code>企业名称 </code> 时，SQL语句又不一样</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_brand <span class="keyword">where</span> status <span class="operator">=</span> #&#123;status&#125; <span class="keyword">and</span> company_name <span class="keyword">like</span> #&#123;companName&#125;</span><br></pre></td></tr></table></figure><p>针对上述的需要，Mybatis对动态SQL有很强大的支撑：</p><blockquote><ul><li><p>if</p></li><li><p>choose (when, otherwise)</p></li><li><p>trim (where, set)</p></li><li><p>foreach</p></li></ul></blockquote><p>我们先学习 if 标签和 where 标签：</p><h5 id="1-if-标签：条件判断"><a href="#1-if-标签：条件判断" class="headerlink" title="1.if 标签：条件判断"></a>1.<strong>if 标签：条件判断</strong></h5><ul><li><strong>test 属性：逻辑表达式</strong></li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByCondition&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;brandResultMap&quot;</span>&gt;</span></span><br><span class="line">    select *</span><br><span class="line">    from tb_brand</span><br><span class="line">    where</span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;status != null&quot;</span>&gt;</span></span><br><span class="line">            and status = #&#123;status&#125; <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;companyName != null and companyName != &#x27;&#x27; &quot;</span>&gt;</span></span><br><span class="line">            and company_name like #&#123;companyName&#125; <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;brandName != null and brandName != &#x27;&#x27; &quot;</span>&gt;</span></span><br><span class="line">            and brand_name like #&#123;brandName&#125; <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如上的这种SQL语句就会根据传递的参数值进行动态的拼接。如果此时status和companyName有值那么就会值拼接这两个条件。</p><p>但是它也存在问题，如果此时给的参数值是</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="comment">// map.put(&quot;status&quot; , status);</span></span><br><span class="line">map.put(<span class="string">&quot;companyName&quot;</span>, companyName);</span><br><span class="line">map.put(<span class="string">&quot;brandName&quot;</span> , brandName);</span><br></pre></td></tr></table></figure><p>拼接的SQL语句就变成了</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_brand <span class="keyword">where</span> <span class="keyword">and</span> company_name <span class="keyword">like</span> ? <span class="keyword">and</span> brand_name <span class="keyword">like</span> ?</span><br></pre></td></tr></table></figure><p>而上面的语句中 where 关键后直接跟 and 关键字，这就是一条错误的SQL语句。</p><p>两种解决方法：</p><ol><li><p>恒等式</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_brand <span class="keyword">where</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> company_name <span class="keyword">like</span> ? <span class="keyword">and</span> brand_name <span class="keyword">like</span> ?</span><br></pre></td></tr></table></figure></li><li><p>where 标签解决</p></li></ol><h5 id="2-where标签-包裹if条件"><a href="#2-where标签-包裹if条件" class="headerlink" title="2.where标签 包裹if条件"></a>2.where标签 包裹if条件</h5><ul><li>作用：<ul><li>替换where关键字</li><li>会动态的去掉第一个条件前的 and </li><li>如果所有的参数没有值则不加where关键字</li></ul></li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByCondition&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;brandResultMap&quot;</span>&gt;</span></span><br><span class="line">    select *</span><br><span class="line">    from tb_brand</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;status != null&quot;</span>&gt;</span></span><br><span class="line">            and status = #&#123;status&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;companyName != null and companyName != &#x27;&#x27; &quot;</span>&gt;</span></span><br><span class="line">            and company_name like #&#123;companyName&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;brandName != null and brandName != &#x27;&#x27; &quot;</span>&gt;</span></span><br><span class="line">            and brand_name like #&#123;brandName&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：需要给每个条件前都加上 and 关键字。</p></blockquote><h3 id="1-5-单个条件（动态SQL）"><a href="#1-5-单个条件（动态SQL）" class="headerlink" title="1.5 单个条件（动态SQL）"></a>1.5 单个条件（动态SQL）</h3><p>在查询时只能选择 <code>品牌名称</code>、<code>当前状态</code>、<code>企业名称</code> 这三个条件中的一个，但是用户到底选择哪儿一个，我们并不能确定。这种就属于单个条件的动态SQL语句。 </p><p>这种需求需要使用到  <code>choose（when，otherwise）标签</code>  实现，而标签类似于Java 中的语句。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">choose相当于switch</span><br><span class="line">when相当于case</span><br><span class="line">otherwise   相当于default</span><br></pre></td></tr></table></figure><p>通过一个案例来使用这些标签</p><h4 id="1-5-1-编写接口方法"><a href="#1-5-1-编写接口方法" class="headerlink" title="1.5.1  编写接口方法"></a>1.5.1  编写接口方法</h4><p>在 <code>BrandMapper</code> 接口中定义单条件查询的方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 单条件动态查询</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> brand</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">List&lt;Brand&gt; <span class="title function_">selectByConditionSingle</span><span class="params">(Brand brand)</span>;</span><br></pre></td></tr></table></figure><h4 id="1-5-2-编写SQL语句"><a href="#1-5-2-编写SQL语句" class="headerlink" title="1.5.2  编写SQL语句"></a>1.5.2  编写SQL语句</h4><p>在 <code>BrandMapper.xml</code> 映射配置文件中编写 <code>statement</code>，使用 <code>resultMap</code> 而不是使用 <code>resultType</code></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByConditionSingle&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;brandResultMap&quot;</span>&gt;</span></span><br><span class="line">    select *</span><br><span class="line">    from tb_brand</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">choose</span>&gt;</span><span class="comment">&lt;!--相当于switch--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;status != null&quot;</span>&gt;</span><span class="comment">&lt;!--相当于case--&gt;</span></span><br><span class="line">                status = #&#123;status&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;companyName != null and companyName != &#x27;&#x27; &quot;</span>&gt;</span><span class="comment">&lt;!--相当于case--&gt;</span></span><br><span class="line">                company_name like #&#123;companyName&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;brandName != null and brandName != &#x27;&#x27;&quot;</span>&gt;</span><span class="comment">&lt;!--相当于case--&gt;</span></span><br><span class="line">                brand_name like #&#123;brandName&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="1-5-3-编写测试方法"><a href="#1-5-3-编写测试方法" class="headerlink" title="1.5.3  编写测试方法"></a>1.5.3  编写测试方法</h4><p>在 <code>test/java</code> 下的 <code>com.itheima.mapper</code>  包下的 <code>MybatisTest类中</code> 定义测试方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectByConditionSingle</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//接收参数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">status</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">companyName</span> <span class="operator">=</span> <span class="string">&quot;华为&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">brandName</span> <span class="operator">=</span> <span class="string">&quot;华为&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理参数</span></span><br><span class="line">    companyName = <span class="string">&quot;%&quot;</span> + companyName + <span class="string">&quot;%&quot;</span>;</span><br><span class="line">    brandName = <span class="string">&quot;%&quot;</span> + brandName + <span class="string">&quot;%&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//封装对象</span></span><br><span class="line">    <span class="type">Brand</span> <span class="variable">brand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Brand</span>();</span><br><span class="line">    <span class="comment">//brand.setStatus(status);</span></span><br><span class="line">    brand.setCompanyName(companyName);</span><br><span class="line">    <span class="comment">//brand.setBrandName(brandName);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 获取SqlSessionFactory</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line">    <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line">    <span class="comment">//2. 获取SqlSession对象</span></span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">    <span class="comment">//3. 获取Mapper接口的代理对象</span></span><br><span class="line">    <span class="type">BrandMapper</span> <span class="variable">brandMapper</span> <span class="operator">=</span> sqlSession.getMapper(BrandMapper.class);</span><br><span class="line">    <span class="comment">//4. 执行方法</span></span><br><span class="line">    List&lt;Brand&gt; brands = brandMapper.selectByConditionSingle(brand);</span><br><span class="line">    System.out.println(brands);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5. 释放资源</span></span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-6-添加数据"><a href="#1-6-添加数据" class="headerlink" title="1.6  添加数据"></a>1.6  添加数据</h3><p>我们在该页面输入想要的数据后添加 <code>提交</code> 按钮，就会将这些数据添加到数据库中。</p><ul><li><p>编写接口方法</p><p>参数：除了id之外的所有的数据。id对应的是表中主键值，而主键我们是 &#x3D;&#x3D;自动增长&#x3D;&#x3D; 生成的。</p></li><li><p>编写SQL语句</p></li><li><p>编写测试方法并执行</p></li></ul><h4 id="1-6-1-编写接口方法"><a href="#1-6-1-编写接口方法" class="headerlink" title="1.6.1  编写接口方法"></a>1.6.1  编写接口方法</h4><p>在 <code>BrandMapper</code> 接口中定义添加方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 添加</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Brand brand)</span>;</span><br></pre></td></tr></table></figure><h4 id="1-6-2-编写SQL语句"><a href="#1-6-2-编写SQL语句" class="headerlink" title="1.6.2  编写SQL语句"></a>1.6.2  编写SQL语句</h4><p>在 <code>BrandMapper.xml</code> 映射配置文件中编写添加数据的 <code>statement</code></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;add&quot;</span>&gt;</span></span><br><span class="line">    insert into tb_brand (brand_name, company_name, ordered, description, status)</span><br><span class="line">    values (#&#123;brandName&#125;, #&#123;companyName&#125;, #&#123;ordered&#125;, #&#123;description&#125;, #&#123;status&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="1-6-3-编写测试方法（提交事务）"><a href="#1-6-3-编写测试方法（提交事务）" class="headerlink" title="1.6.3  编写测试方法（提交事务）"></a>1.6.3  编写测试方法（提交事务）</h4><!--openSession()-->       默认手动提交事务commit()<!--openSession(true)--> 设置自动提交事务<p>在 <code>test/java</code> 下的 <code>com.itheima.mapper</code>  包下的 <code>MybatisTest类中</code> 定义测试方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAdd</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//接收参数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">status</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">companyName</span> <span class="operator">=</span> <span class="string">&quot;波导手机&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">brandName</span> <span class="operator">=</span> <span class="string">&quot;波导&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">description</span> <span class="operator">=</span> <span class="string">&quot;手机中的战斗机&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ordered</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//封装对象</span></span><br><span class="line">    <span class="type">Brand</span> <span class="variable">brand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Brand</span>();</span><br><span class="line">    brand.setStatus(status);</span><br><span class="line">    brand.setCompanyName(companyName);</span><br><span class="line">    brand.setBrandName(brandName);</span><br><span class="line">    brand.setDescription(description);</span><br><span class="line">    brand.setOrdered(ordered);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 获取SqlSessionFactory</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line">    <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line">    <span class="comment">//2. 获取SqlSession对象</span></span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession(); <span class="comment">// 默认手动提交事务</span></span><br><span class="line">    <span class="comment">//SqlSession sqlSession = sqlSessionFactory.openSession(true); //设置自动提交事务，这种情况不需要手动提交事务了</span></span><br><span class="line">    <span class="comment">//3. 获取Mapper接口的代理对象</span></span><br><span class="line">    <span class="type">BrandMapper</span> <span class="variable">brandMapper</span> <span class="operator">=</span> sqlSession.getMapper(BrandMapper.class);</span><br><span class="line">    <span class="comment">//4. 执行方法</span></span><br><span class="line">    brandMapper.add(brand);</span><br><span class="line">    <span class="comment">//提交事务</span></span><br><span class="line">    sqlSession.commit(); <span class="comment">// 手动提交事务</span></span><br><span class="line">    <span class="comment">//5. 释放资源</span></span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-6-4-添加-主键返回"><a href="#1-6-4-添加-主键返回" class="headerlink" title="1.6.4  添加-主键返回"></a>1.6.4  添加-主键返回</h4><p>在 insert 标签上添加如下属性：</p><ul><li><strong>useGeneratedKeys：是够获取自动增长的主键值。默认为fales，true表示获取</strong></li><li><strong>keyProperty  ：指定将获取到的主键值封装到哪个属性里</strong></li></ul><p>在数据添加成功后，有时候需要获取插入数据库数据的主键（主键是自增长）。</p><p>比如：添加订单和订单项，如下图就是京东上的订单</p><p>订单数据存储在订单表中，订单项存储在订单项表中。</p><ul><li><p>添加订单数据</p></li><li><p>添加订单项数据，订单项中需要设置所属订单的id</p></li></ul><p>明白了什么时候 <code>主键返回</code> 。接下来我们简单模拟一下，在添加完数据后打印id属性值，能打印出来说明已经获取到了。</p><p>我们将上面添加品牌数据的案例中映射配置文件里 <code>statement</code> 进行修改，如下</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;add&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">    insert into tb_brand (brand_name, company_name, ordered, description, status)</span><br><span class="line">    values (#&#123;brandName&#125;, #&#123;companyName&#125;, #&#123;ordered&#125;, #&#123;description&#125;, #&#123;status&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-7-修改"><a href="#1-7-修改" class="headerlink" title="1.7  修改"></a>1.7  修改</h3><p>如图所示是修改页面，用户在该页面书写需要修改的数据，点击 <code>提交</code> 按钮，就会将数据库中对应的数据进行修改。注意一点，如果哪儿个输入框没有输入内容，我们是将表中数据对应字段值替换为空白还是保留字段之前的值？答案肯定是保留之前的数据。</p><p>接下来我们就具体来实现</p><h4 id="1-7-1-编写接口方法"><a href="#1-7-1-编写接口方法" class="headerlink" title="1.7.1  编写接口方法"></a>1.7.1  编写接口方法</h4><p>在 <code>BrandMapper</code> 接口中定义修改方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 修改</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Brand brand)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>上述方法参数 Brand 就是封装了需要修改的数据，而id肯定是有数据的，这也是和添加方法的区别。</p></blockquote><h4 id="1-7-2-编写SQL语句"><a href="#1-7-2-编写SQL语句" class="headerlink" title="1.7.2  编写SQL语句"></a>1.7.2  编写SQL语句</h4><p>在 <code>BrandMapper.xml</code> 映射配置文件中编写修改数据的 <code>statement</code>。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;update&quot;</span>&gt;</span></span><br><span class="line">    update tb_brand</span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;brandName != null and brandName != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            brand_name = #&#123;brandName&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;companyName != null and companyName != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            company_name = #&#123;companyName&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;ordered != null&quot;</span>&gt;</span></span><br><span class="line">            ordered = #&#123;ordered&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;description != null and description != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            description = #&#123;description&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;status != null&quot;</span>&gt;</span></span><br><span class="line">            status = #&#123;status&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    where id = #&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><em>set</em> 标签可以用于动态包含需要更新的列，忽略其它不更新的列。</p></blockquote><h4 id="1-7-3-编写测试方法"><a href="#1-7-3-编写测试方法" class="headerlink" title="1.7.3  编写测试方法"></a>1.7.3  编写测试方法</h4><p>在 <code>test/java</code> 下的 <code>com.itheima.mapper</code>  包下的 <code>MybatisTest类中</code> 定义测试方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUpdate</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//接收参数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">status</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">companyName</span> <span class="operator">=</span> <span class="string">&quot;波导手机&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">brandName</span> <span class="operator">=</span> <span class="string">&quot;波导&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">description</span> <span class="operator">=</span> <span class="string">&quot;波导手机,手机中的战斗机&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ordered</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//封装对象</span></span><br><span class="line">    <span class="type">Brand</span> <span class="variable">brand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Brand</span>();</span><br><span class="line">    brand.setStatus(status);</span><br><span class="line">    <span class="comment">//        brand.setCompanyName(companyName);</span></span><br><span class="line">    <span class="comment">//        brand.setBrandName(brandName);</span></span><br><span class="line">    <span class="comment">//        brand.setDescription(description);</span></span><br><span class="line">    <span class="comment">//        brand.setOrdered(ordered);</span></span><br><span class="line">    brand.setId(id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 获取SqlSessionFactory</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line">    <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line">    <span class="comment">//2. 获取SqlSession对象</span></span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">    <span class="comment">//SqlSession sqlSession = sqlSessionFactory.openSession(true);</span></span><br><span class="line">    <span class="comment">//3. 获取Mapper接口的代理对象</span></span><br><span class="line">    <span class="type">BrandMapper</span> <span class="variable">brandMapper</span> <span class="operator">=</span> sqlSession.getMapper(BrandMapper.class);</span><br><span class="line">    <span class="comment">//4. 执行方法</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> brandMapper.update(brand);</span><br><span class="line">    System.out.println(count);</span><br><span class="line">    <span class="comment">//提交事务</span></span><br><span class="line">    sqlSession.commit();</span><br><span class="line">    <span class="comment">//5. 释放资源</span></span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从结果中SQL语句可以看出，只修改了 <code>status</code>  字段值，因为我们给的数据中只给Brand实体对象的 <code>status</code> 属性设置值了。这就是 <code>set</code> 标签的作用。</p><h3 id="1-8-删除一行数据"><a href="#1-8-删除一行数据" class="headerlink" title="1.8  删除一行数据"></a>1.8  删除一行数据</h3><p>当用户点击了该按钮，就会将改行数据删除掉。那我们就需要思考，这种删除是根据什么进行删除呢？是通过主键id删除，因为id是表中数据的唯一标识。</p><p>接下来就来实现该功能。</p><h4 id="1-8-1-编写接口方法"><a href="#1-8-1-编写接口方法" class="headerlink" title="1.8.1  编写接口方法"></a>1.8.1  编写接口方法</h4><p>在 <code>BrandMapper</code> 接口中定义根据id删除方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 根据id删除</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">deleteById</span><span class="params">(<span class="type">int</span> id)</span>;</span><br></pre></td></tr></table></figure><h4 id="1-8-2-编写SQL语句"><a href="#1-8-2-编写SQL语句" class="headerlink" title="1.8.2  编写SQL语句"></a>1.8.2  编写SQL语句</h4><p>在 <code>BrandMapper.xml</code> 映射配置文件中编写删除一行数据的 <code>statement</code></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteById&quot;</span>&gt;</span></span><br><span class="line">    delete from tb_brand where id = #&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="1-8-3-编写测试方法"><a href="#1-8-3-编写测试方法" class="headerlink" title="1.8.3  编写测试方法"></a>1.8.3  编写测试方法</h4><p>在 <code>test/java</code> 下的 <code>com.itheima.mapper</code>  包下的 <code>MybatisTest类中</code> 定义测试方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDeleteById</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//接收参数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 获取SqlSessionFactory</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line">    <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line">    <span class="comment">//2. 获取SqlSession对象</span></span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">    <span class="comment">//SqlSession sqlSession = sqlSessionFactory.openSession(true);</span></span><br><span class="line">    <span class="comment">//3. 获取Mapper接口的代理对象</span></span><br><span class="line">    <span class="type">BrandMapper</span> <span class="variable">brandMapper</span> <span class="operator">=</span> sqlSession.getMapper(BrandMapper.class);</span><br><span class="line">    <span class="comment">//4. 执行方法</span></span><br><span class="line">    brandMapper.deleteById(id);</span><br><span class="line">    <span class="comment">//提交事务</span></span><br><span class="line">    sqlSession.commit();</span><br><span class="line">    <span class="comment">//5. 释放资源</span></span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行过程只要没报错，直接到数据库查询数据是否还存在。</p><h3 id="1-9-批量删除"><a href="#1-9-批量删除" class="headerlink" title="1.9  批量删除"></a>1.9  批量删除</h3><p>用户可以选择多条数据，然后点击 <code>删除</code> 按钮，就会删除数据库中对应的多行数据。</p><h4 id="1-9-1-编写接口方法"><a href="#1-9-1-编写接口方法" class="headerlink" title="1.9.1  编写接口方法"></a>1.9.1  编写接口方法</h4><p>在 <code>BrandMapper</code> 接口中定义删除多行数据的方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 批量删除</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">deleteByIds</span><span class="params">(<span class="type">int</span>[] ids)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>参数是一个数组，数组中存储的是多条数据的id</p></blockquote><h4 id="1-9-2-编写SQL语句"><a href="#1-9-2-编写SQL语句" class="headerlink" title="1.9.2  编写SQL语句"></a>1.9.2  编写SQL语句</h4><p>在 <code>BrandMapper.xml</code> 映射配置文件中编写删除多条数据的 <code>statement</code>。</p><p>编写SQL时需要遍历数组来拼接SQL语句。Mybatis 提供了 <code>foreach</code> 标签供我们使用</p><p><strong>foreach 标签</strong></p><p>用来迭代任何可迭代的对象（如数组，集合）。</p><ul><li>collection 属性：<ul><li>mybatis会将数组参数，封装为一个Map集合。<ul><li>默认：array &#x3D; 数组</li><li>使用@Param注解改变map集合的默认key的名称</li></ul></li></ul></li><li>item 属性：本次迭代获取到的元素。</li><li>separator 属性：集合项迭代之间的分隔符。<code>foreach</code> 标签不会错误地添加多余的分隔符。也就是最后一次迭代不会加分隔符。</li><li>open 属性：该属性值是在拼接SQL语句之前拼接的语句，只会拼接一次</li><li>close 属性：该属性值是在拼接SQL语句拼接后拼接的语句，只会拼接一次</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteByIds&quot;</span>&gt;</span></span><br><span class="line">    delete from tb_brand where id</span><br><span class="line">    in</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;array&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">        #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    ;</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>假如数组中的id数据是{1,2,3}，那么拼接后的sql语句就是：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> tb_brand <span class="keyword">where</span> id <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure></blockquote><h4 id="1-9-3-编写测试方法"><a href="#1-9-3-编写测试方法" class="headerlink" title="1.9.3  编写测试方法"></a>1.9.3  编写测试方法</h4><p>在 <code>test/java</code> 下的 <code>com.itheima.mapper</code>  包下的 <code>MybatisTest类中</code> 定义测试方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDeleteByIds</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//接收参数</span></span><br><span class="line">    <span class="type">int</span>[] ids = &#123;<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 获取SqlSessionFactory</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line">    <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line">    <span class="comment">//2. 获取SqlSession对象</span></span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">    <span class="comment">//SqlSession sqlSession = sqlSessionFactory.openSession(true);</span></span><br><span class="line">    <span class="comment">//3. 获取Mapper接口的代理对象</span></span><br><span class="line">    <span class="type">BrandMapper</span> <span class="variable">brandMapper</span> <span class="operator">=</span> sqlSession.getMapper(BrandMapper.class);</span><br><span class="line">    <span class="comment">//4. 执行方法</span></span><br><span class="line">    brandMapper.deleteByIds(ids);</span><br><span class="line">    <span class="comment">//提交事务</span></span><br><span class="line">    sqlSession.commit();</span><br><span class="line">    <span class="comment">//5. 释放资源</span></span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-10-Mybatis参数传递"><a href="#1-10-Mybatis参数传递" class="headerlink" title="1.10  Mybatis参数传递"></a>1.10  Mybatis参数传递</h3><p>Mybatis 接口方法中可以接收各种各样的参数，如下：</p><ul><li>多个参数</li><li>单个参数：单个参数又可以是如下类型<ul><li>POJO 类型</li><li>Map 集合类型</li><li>Collection 集合类型</li><li>List 集合类型</li><li>Array 类型</li><li>其他类型</li></ul></li></ul><h4 id="1-10-1-多个参数"><a href="#1-10-1-多个参数" class="headerlink" title="1.10.1  多个参数"></a>1.10.1  多个参数</h4><p><em><!--结论：以后接口参数是多个时，在每个参数上都使用 @Param 注解。这样代码的可读性更高。--></em></p><p>如下面的代码，就是接收两个参数，而接收多个参数需要使用 <code>@Param</code> 注解，那么为什么要加该注解呢？这个问题要弄明白就必须来研究Mybatis 底层对于这些参数是如何处理的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User <span class="title function_">select</span><span class="params">(<span class="meta">@Param(&quot;username&quot;)</span> String username,<span class="meta">@Param(&quot;password&quot;)</span> String password)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;select&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">select *</span><br><span class="line">    from tb_user</span><br><span class="line">    where </span><br><span class="line">    username=#&#123;username&#125;</span><br><span class="line">    and password=#&#123;password&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们在接口方法中定义多个参数，Mybatis 会将这些参数封装成 Map 集合对象，值就是参数值，而键在没有使用 <code>@Param</code> 注解时有以下命名规则：</p><ul><li><p>以 arg 开头  ：第一个参数就叫 arg0，第二个参数就叫 arg1，以此类推。如：</p><blockquote><p>map.put(“arg0”，参数值1);</p><p>map.put(“arg1”，参数值2);</p></blockquote></li><li><p>以 param 开头 ： 第一个参数就叫 param1，第二个参数就叫 param2，依次类推。如：</p><blockquote><p>map.put(“param1”，参数值1);</p><p>map.put(“param2”，参数值2);</p></blockquote></li></ul><p><strong>代码验证：</strong></p><ul><li><p>在 <code>UserMapper</code> 接口中定义如下方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User <span class="title function_">select</span><span class="params">(String username,String password)</span>;</span><br></pre></td></tr></table></figure></li><li><p>在 <code>UserMapper.xml</code> 映射配置文件中定义SQL</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;select&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">select *</span><br><span class="line">    from tb_user</span><br><span class="line">    where </span><br><span class="line">    username=#&#123;arg0&#125;</span><br><span class="line">    and password=#&#123;arg1&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;select&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">select *</span><br><span class="line">    from tb_user</span><br><span class="line">    where </span><br><span class="line">    username=#&#123;param1&#125;</span><br><span class="line">    and password=#&#123;param2&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在映射配合文件的SQL语句中使用用 <code>arg</code> 开头的和 <code>param</code> 书写，代码的可读性会变的特别差，此时可以使用 <code>@Param</code> 注解。</p></li></ul><p>在接口方法参数上使用 <code>@Param</code> 注解，Mybatis 会将 <code>arg</code> 开头的键名替换为对应注解的属性值。</p><p><strong>代码验证：</strong></p><ul><li><p>在 <code>UserMapper</code> 接口中定义如下方法，在 <code>username</code> 参数前加上 <code>@Param</code> 注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User <span class="title function_">select</span><span class="params">(<span class="meta">@Param(&quot;username&quot;)</span> String username, String password)</span>;</span><br></pre></td></tr></table></figure><p>Mybatis 在封装 Map 集合时，键名就会变成如下：</p><blockquote><p>map.put(“username”，参数值1);</p><p>map.put(“arg1”，参数值2);</p><p>map.put(“param1”，参数值1);</p><p>map.put(“param2”，参数值2);</p></blockquote></li><li><p>在 <code>UserMapper.xml</code> 映射配置文件中定义SQL</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;select&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">select *</span><br><span class="line">    from tb_user</span><br><span class="line">    where </span><br><span class="line">    username=#&#123;username&#125;</span><br><span class="line">    and password=#&#123;param2&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>运行程序结果没有报错。而如果将 <code>#&#123;&#125;</code> 中的 <code>username</code> 还是写成  <code>arg0</code> </p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;select&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">select *</span><br><span class="line">    from tb_user</span><br><span class="line">    where </span><br><span class="line">    username=#&#123;arg0&#125;</span><br><span class="line">    and password=#&#123;param2&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="1-10-2-单个参数"><a href="#1-10-2-单个参数" class="headerlink" title="1.10.2  单个参数"></a>1.10.2  单个参数</h4><p><em><!--结论：接口是参数是Collection 类型，List 类型，Array 类型，在每个参数传递上都使用 @Param 注解。--></em></p><ul><li><p>POJO 类型：直接使用，要求 <code>属性名</code> 和 <code>参数占位符名称</code> 一致</p></li><li><p>Map 类型：直接使用，要求 <code>map集合的键名</code> 和 <code>参数占位符名称</code> 一致</p></li><li><p><strong>Collection 类型</strong> ：Mybatis 会将集合封装到 map 集合中，如下：</p><blockquote><p>map.put(“arg0”，collection集合);</p></blockquote></li></ul><blockquote><p>map.put(“collection”，collection集合;</p></blockquote>  <!--可以使用 @Param 注解替换map集合中默认的 arg 键名。--><ul><li><p><strong>List 类型</strong>：Mybatis 会将集合封装到 map 集合中，如下：</p><blockquote><p>map.put(“arg0”，list集合);</p></blockquote></li></ul><blockquote><p>map.put(“collection”，list集合);</p><p>map.put(“list”，list集合);</p></blockquote>  <!--可以使用 `@Param` 注解替换map集合中默认的 arg 键名。--><ul><li><p><strong>Array 类型</strong>：Mybatis 会将集合封装到 map 集合中，如下：</p><blockquote><p>map.put(“arg0”，数组);</p></blockquote></li></ul><blockquote><p>map.put(“array”，数组);</p></blockquote>  <!--可以使用 `@Param` 注解替换map集合中默认的 arg 键名。--><ul><li><p>其他类型</p><p>比如int类型，<code>参数占位符名称</code> 叫什么都可以。尽量做到见名知意。</p></li></ul><h2 id="2，注解实现CRUD"><a href="#2，注解实现CRUD" class="headerlink" title="2，注解实现CRUD"></a>2，注解实现CRUD</h2><p>使用注解开发会比配置文件开发更加方便。如下就是使用注解进行开发</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Select(value = &quot;select * from tb_user where id = #&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">select</span><span class="params">(<span class="type">int</span> id)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>&#x3D;&#x3D;注意：&#x3D;&#x3D;</p><ul><li>注解是用来替换映射配置文件方式配置的，所以使用了注解，就不需要再映射配置文件中书写对应的 <code>statement</code></li></ul></blockquote><p>Mybatis 针对 CURD 操作都提供了对应的注解，已经做到见名知意。如下：</p><ul><li>查询 ：@Select</li><li>添加 ：@Insert</li><li>修改 ：@Update</li><li>删除 ：@Delete</li></ul><p>接下来我们做一个案例来使用 Mybatis 的注解开发</p><p><strong>代码实现：</strong></p><ul><li><p>将之前案例中 <code>UserMapper.xml</code> 中的 根据id查询数据 的 <code>statement</code> 注释掉</p></li><li><p>在 <code>UserMapper</code> 接口的 <code>selectById</code> 方法上添加注解</p></li><li><p>运行测试程序也能正常查询到数据</p></li></ul><p>&#x3D;&#x3D;注意：&#x3D;&#x3D;&#x3D;&#x3D;注解完成简单功能，配置文件完成复杂功能。&#x3D;&#x3D;</p>]]></content>
      
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven</title>
      <link href="/post/7273cdc.html"/>
      <url>/post/7273cdc.html</url>
      
        <content type="html"><![CDATA[<h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h2><p><strong>目标</strong></p><blockquote><ul><li>能够使用Maven进行项目的管理</li><li>能够完成Mybatis代理方式查询数据</li><li>能够理解Mybatis核心配置文件的配置</li></ul></blockquote><h2 id="1，Maven"><a href="#1，Maven" class="headerlink" title="1，Maven"></a>1，Maven</h2><p>Maven是专门用于管理和构建Java项目的工具，它的主要功能有：</p><ul><li><p>提供了一套标准化的项目结构</p></li><li><p>提供了一套标准化的构建流程（编译，测试，打包，发布……）</p></li><li><p>提供了一套依赖管理机制</p></li></ul><p><strong>标准化的项目结构：</strong></p><p>项目结构我们都知道，每一个开发工具（IDE）都有自己不同的项目结构，它们互相之间不通用。我再eclipse中创建的目录，无法在idea中进行使用，这就造成了很大的不方便，如下图:前两个是以后开发经常使用的开发工具</p><p>而Maven提供了一套标准化的项目结构，所有的IDE使用Maven构建的项目完全一样，所以IDE创建的Maven项目可以通用。</p><p><strong>标准化的构建流程：</strong></p><p>开发了一套系统，代码需要进行编译、测试、打包、发布，这些操作如果需要反复进行就显得特别麻烦，而Maven提供了一套简单的命令来完成项目构建。</p><p><strong>依赖管理：</strong></p><p>依赖管理其实就是管理你项目所依赖的第三方资源（jar包、插件）。如之前我们项目中需要使用JDBC和Druid的话，就需要去网上下载对应的依赖包，复制到项目中，还要将jar包加入工作环境这一系列的操作。如下图所示</p><p>而Maven使用标准的 &#x3D;&#x3D;坐标&#x3D;&#x3D; 配置来管理各种依赖，只需要简单的配置就可以完成依赖管理。</p><p>市面上有很多构建工具，而Maven依旧还是主流构建工具，如下图是常用构建工具的使用占比</p><h3 id="1-1-Maven简介"><a href="#1-1-Maven简介" class="headerlink" title="1.1  Maven简介"></a>1.1  Maven简介</h3><blockquote><p>&#x3D;&#x3D;Apache Maven&#x3D;&#x3D; 是一个项目管理和构建&#x3D;&#x3D;工具&#x3D;&#x3D;，它基于项目对象模型(POM)的概念，通过一小段描述信息来管理项目的构建、报告和文档。</p><p>官网 ：<a href="http://maven.apache.org/">http://maven.apache.org/</a> </p></blockquote><p>通过上面的描述大家只需要知道Maven是一个工具即可。Apache 是一个开源组织，将来我们会学习很多Apache提供的项目。</p><h4 id="1-1-1-Maven模型"><a href="#1-1-1-Maven模型" class="headerlink" title="1.1.1  Maven模型"></a>1.1.1  Maven模型</h4><ul><li>项目对象模型 (Project Object Model)</li><li>依赖管理模型(Dependency)</li><li>插件(Plugin)</li></ul><h4 id="1-1-2-仓库"><a href="#1-1-2-仓库" class="headerlink" title="1.1.2  仓库"></a>1.1.2  仓库</h4><p>我们创建Maven项目，在项目中使用坐标来指定项目的依赖，那么依赖的jar包到底存储在什么地方呢？其实依赖jar包是存储在我们的本地仓库中。而项目运行时从本地仓库中拿需要的依赖jar包。</p><p><strong>仓库分类：</strong></p><ul><li><p>本地仓库：自己计算机上的一个目录</p></li><li><p>中央仓库：由Maven团队维护的全球唯一的仓库</p><ul><li>地址： <a href="https://repo1.maven.org/maven2/">https://repo1.maven.org/maven2/</a></li></ul></li><li><p>远程仓库(私服)：一般由公司团队搭建的私有仓库</p><p>今天我们只学习远程仓库的使用，并不会搭建。</p></li></ul><p>当项目中使用坐标引入对应依赖jar包后，首先会查找本地仓库中是否有对应的jar包：</p><ul><li><p>如果有，则在项目直接引用;</p></li><li><p>如果没有，则去中央仓库中下载对应的jar包到本地仓库。</p></li></ul><p>如果还可以搭建远程仓库，将来jar包的查找顺序则变为：</p><blockquote><p>本地仓库 –&gt; 远程仓库–&gt; 中央仓库</p></blockquote><h3 id="1-2-Maven安装配置"><a href="#1-2-Maven安装配置" class="headerlink" title="1.2  Maven安装配置"></a>1.2  Maven安装配置</h3><ul><li><p>解压 apache-maven-3.6.1.rar 既安装完成</p><blockquote><p>建议解压缩到没有中文、特殊字符的路径下。</p></blockquote><ul><li>bin目录 ： 存放的是可执行命令。mvn 命令重点关注。</li></ul></li><li><p>conf目录 ：存放Maven的配置文件。<code>settings.xml</code> 配置文件后期需要修改。</p><ul><li>lib目录 ：存放Maven依赖的jar包。Maven也是使用java开发的，所以它也依赖其他的jar包。</li></ul></li><li><p>配置环境变量 MAVEN_HOME 为安装路径的bin目录</p><p><code>此电脑</code> 右键  –&gt;  <code>高级系统设置</code>  –&gt;  <code>高级</code>  –&gt;  <code>环境变量</code></p><p>在系统变量处新建一个变量 <code>MAVEN_HOME</code></p><p>在 <code>Path</code> 中进行配置</p><p>打开命令提示符进行验证，出现如图所示表示安装成功</p></li><li><p>配置本地仓库</p><p>修改 conf&#x2F;settings.xml 中的 <localRepository> 为一个指定目录作为本地仓库，用来存储jar包。</p></li><li><p>配置阿里云私服</p><p>中央仓库在国外，所以下载jar包速度可能比较慢，而阿里公司提供了一个远程仓库，里面基本也都有开源项目的jar包。</p><p>修改 conf&#x2F;settings.xml 中的 <mirrors>标签，为其添加如下子标签：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span>          </span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="1-3-Maven基本使用"><a href="#1-3-Maven基本使用" class="headerlink" title="1.3  Maven基本使用"></a>1.3  Maven基本使用</h3><h4 id="1-3-1-Maven-常用命令"><a href="#1-3-1-Maven-常用命令" class="headerlink" title="1.3.1  Maven 常用命令"></a>1.3.1  Maven 常用命令</h4><blockquote><ul><li><p><strong>compile ：编译</strong></p></li><li><p><strong>clean：清理</strong></p></li><li><p><strong>test：测试</strong></p></li><li><p><strong>package：打包</strong></p></li><li><p><strong>install：安装</strong></p></li></ul></blockquote><p><strong>编译命令演示：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">compile ：编译</span><br></pre></td></tr></table></figure><p>执行上述命令可以看到：</p><ul><li>从阿里云下载编译需要的插件的jar包，在本地仓库也能看到下载好的插件</li><li>在项目下会生成一个 <code>target</code> 目录</li></ul><p>同时在项目下会出现一个 <code>target</code> 目录，编译后的字节码文件就放在该目录下</p><p><strong>清理命令演示：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn clean</span><br></pre></td></tr></table></figure><p>执行上述命令可以看到</p><ul><li>从阿里云下载清理需要的插件jar包</li><li>删除项目下的 <code>target</code> 目录</li></ul><p><strong>打包命令演示：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn package</span><br></pre></td></tr></table></figure><p>执行上述命令可以看到：</p><ul><li>从阿里云下载打包需要的插件jar包</li><li>在项目的 <code>terget</code> 目录下有一个jar包（将当前项目打成的jar包）</li></ul><p><strong>测试命令演示：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn test  </span><br></pre></td></tr></table></figure><p>该命令会执行所有的测试代码。执行上述命令效果如下</p><p><strong>安装命令演示：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn install</span><br></pre></td></tr></table></figure><p>该命令会将当前项目打成jar包，并安装到本地仓库。执行完上述命令后到本地仓库查看结果如下：</p><h4 id="1-3-2-Maven-生命周期"><a href="#1-3-2-Maven-生命周期" class="headerlink" title="1.3.2  Maven 生命周期"></a>1.3.2  Maven 生命周期</h4><p>Maven 构建项目生命周期描述的是一次构建过程经历经历了多少个事件</p><p>Maven 对项目构建的生命周期划分为3套：</p><ul><li>clean ：清理工作。</li><li>default ：核心工作，例如编译，测试，打包，安装等。</li><li>site ： 产生报告，发布站点等。这套声明周期一般不会使用。</li></ul><p>同一套生命周期内，执行后边的命令，前面的所有命令会自动执行。例如默认（default）生命周期</p><p>当我们执行 <code>install</code>（安装）命令时，它会先执行 <code>compile</code>命令，再执行 <code>test </code> 命令，再执行 <code>package</code> 命令，最后执行 <code>install</code> 命令。</p><p>当我们执行 <code>package</code> （打包）命令时，它会先执行 <code>compile</code> 命令，再执行 <code>test</code> 命令，最后执行 <code>package</code> 命令。</p><p>默认的生命周期也有对应的很多命令，其他的一般都不会使用，我们只关注常用。</p><h3 id="1-4-IDEA使用Maven"><a href="#1-4-IDEA使用Maven" class="headerlink" title="1.4  IDEA使用Maven"></a>1.4  IDEA使用Maven</h3><p>以后开发中我们肯定会在高级开发工具中使用Maven管理项目，而我们常用的高级开发工具是IDEA，所以接下来我们会讲解Maven在IDEA中的使用。</p><h4 id="1-4-1-IDEA配置Maven环境"><a href="#1-4-1-IDEA配置Maven环境" class="headerlink" title="1.4.1  IDEA配置Maven环境"></a>1.4.1  IDEA配置Maven环境</h4><p>我们需要先在IDEA中配置Maven环境：</p><ul><li><p>选择 IDEA中 File –&gt; Settings</p></li><li><p>搜索 maven </p></li><li><p>设置 IDEA 使用本地安装的 Maven，并修改配置文件路径</p></li></ul><h4 id="1-4-2-Maven-坐标详解"><a href="#1-4-2-Maven-坐标详解" class="headerlink" title="1.4.2  Maven 坐标详解"></a>1.4.2  Maven 坐标详解</h4><p><strong>什么是坐标？</strong></p><ul><li>Maven 中的坐标是&#x3D;&#x3D;资源的唯一标识&#x3D;&#x3D;</li><li>使用坐标来定义项目或引入项目中需要的依赖</li></ul><p><strong>Maven 坐标主要组成</strong></p><ul><li>groupId：定义当前Maven项目隶属组织名称（通常是域名反写，例如：com.itheima）</li><li>artifactId：定义当前Maven项目名称（通常是模块名称，例如 order-service、goods-service）</li><li>version：定义当前项目版本号</li></ul><blockquote><p>&#x3D;&#x3D;注意：&#x3D;&#x3D;</p><ul><li>上面所说的资源可以是插件、依赖、当前项目。</li><li>我们的项目如果被其他的项目依赖时，也是需要坐标来引入的。</li></ul></blockquote><h4 id="1-4-3-IDEA-创建-Maven项目"><a href="#1-4-3-IDEA-创建-Maven项目" class="headerlink" title="1.4.3  IDEA 创建 Maven项目"></a>1.4.3  IDEA 创建 Maven项目</h4><ul><li><p>创建模块，选择Maven，点击Next</p></li><li><p>填写模块名称，坐标信息，点击finish，创建完成</p></li><li><p>编写 HelloWorld，并运行</p></li></ul><h4 id="1-4-4-IDEA-导入-Maven项目"><a href="#1-4-4-IDEA-导入-Maven项目" class="headerlink" title="1.4.4  IDEA 导入 Maven项目"></a>1.4.4  IDEA 导入 Maven项目</h4><p>我们可以通过以下步骤进行项目的导入：</p><ul><li><p>选择右侧Maven面板，点击 + 号</p></li><li><p>选中对应项目的pom.xml文件，双击即可</p></li><li><p>如果没有Maven面板，选择</p><p>View –&gt; Appearance –&gt; Tool Window Bars</p></li></ul><p><strong>配置 Maven-Helper 插件</strong> </p><ul><li><p>选择 IDEA中 File –&gt; Settings</p></li><li><p>选择 Plugins</p></li><li><p>搜索 Maven，选择第一个 Maven Helper，点击Install安装，弹出面板中点击Accept</p></li><li><p>重启 IDEA</p></li></ul><p>安装完该插件后可以通过 选中项目右键进行相关命令操作，如下图所示：</p><h3 id="1-5-依赖管理"><a href="#1-5-依赖管理" class="headerlink" title="1.5  依赖管理"></a>1.5  依赖管理</h3><h4 id="1-5-1-使用坐标引入jar包"><a href="#1-5-1-使用坐标引入jar包" class="headerlink" title="1.5.1  使用坐标引入jar包"></a>1.5.1  使用坐标引入jar包</h4><p><strong>使用坐标引入jar包的步骤：</strong></p><ul><li><p>在项目的 pom.xml 中编写 <dependencies> 标签</p></li><li><p>在 <dependencies> 标签中 使用 <dependency> 引入坐标</p></li><li><p>定义坐标的 groupId（标识符），artifactId（jar包名），version（版本号）</p></li><li><p>点击刷新按钮，使坐标生效</p></li></ul><blockquote><p> 注意：</p><ul><li>具体的坐标我们可以到如下网站进行搜索</li><li><a href="https://mvnrepository.com/">https://mvnrepository.com/</a></li></ul></blockquote><p><strong>导入本地jar包的坐标（快捷方式）：</strong></p><p>每次需要引入jar包，都去对应的网站进行搜索是比较麻烦的，接下来给大家介绍一种快捷引入坐标的方式</p><ul><li><p>在 pom.xml 中 按 alt + insert，选择 Dependency</p></li><li><p>在弹出的面板中搜索对应坐标，然后双击选中对应坐标</p></li><li><p>点击刷新按钮，使坐标生效</p></li></ul><p><strong>导入立即生效设置（免刷新）：</strong></p><p>上面每次操作都需要点击刷新按钮，让引入的坐标生效。当然我们也可以通过设置让其自动完成</p><ul><li><p>选择 IDEA中 File –&gt; Settings</p></li><li><p>在弹出的面板中找到 Build Tools</p></li><li><p>选择 Any changes，点击 ok 即可生效</p></li></ul><p><strong>三种常用坐标导入方式</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--导入mysql 驱动jar包--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.48<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">&lt;!--数据库连接池--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">&lt;!--Test单元测试--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="1-5-2-依赖范围"><a href="#1-5-2-依赖范围" class="headerlink" title="1.5.2  依赖范围"></a>1.5.2  依赖范围</h4><p>通过设置坐标的依赖范围(scope)，可以设置 对应jar包的作用范围：编译环境、测试环境、运行环境。</p><table><thead><tr><th><strong>依赖范围</strong></th><th>编译classpath</th><th>测试classpath</th><th>运行classpath</th><th>例子</th></tr></thead><tbody><tr><td><strong>compile</strong></td><td>Y</td><td>Y</td><td>Y</td><td>logback</td></tr><tr><td><strong>test</strong></td><td>-</td><td>Y</td><td>-</td><td>Junit</td></tr><tr><td><strong>provided</strong></td><td>Y</td><td>Y</td><td>-</td><td>servlet-api</td></tr><tr><td><strong>runtime</strong></td><td>-</td><td>Y</td><td>Y</td><td>jdbc驱动</td></tr><tr><td><strong>system</strong></td><td>Y</td><td>Y</td><td>-</td><td>存储在本地的jar包</td></tr></tbody></table><ul><li>&#x3D;&#x3D;compile ：作用于编译环境、测试环境、运行环境。&#x3D;&#x3D;</li><li>&#x3D;&#x3D;test ： 作用于测试环境。典型的就是Junit坐标，以后使用Junit时，都会将scope指定为该值&#x3D;&#x3D;</li><li>&#x3D;&#x3D;provided ：作用于编译环境、测试环境。我们后面会学习 <code>servlet-api</code> ，在使用它时，必须将 <code>scope</code> 设置为该值，不然运行时就会报错&#x3D;&#x3D;</li><li>&#x3D;&#x3D;runtime  ： 作用于测试环境、运行环境。jdbc驱动一般将 <code>scope</code> 设置为该值，当然不设置也没有任何问题&#x3D;&#x3D;</li></ul><blockquote><p>注意：</p><ul><li><strong>如果引入坐标不指定 <code>scope</code> 标签时，默认就是 compile  值。以后大部分jar包都是使用默认值。</strong></li></ul></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC</title>
      <link href="/post/8fe47ff4.html"/>
      <url>/post/8fe47ff4.html</url>
      
        <content type="html"><![CDATA[<h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><p><strong>今日目标</strong></p><blockquote><ul><li>掌握JDBC的的CRUD</li><li>理解JDBC中各个对象的作用</li><li>掌握Druid的使用</li></ul></blockquote><h2 id="1，JDBC概述"><a href="#1，JDBC概述" class="headerlink" title="1，JDBC概述"></a>1，JDBC概述</h2><p>在开发中我们使用的是java语言，那么势必要通过java语言操作数据库中的数据。这就是接下来要学习的JDBC。</p><h3 id="1-1-JDBC概念"><a href="#1-1-JDBC概念" class="headerlink" title="1.1  JDBC概念"></a>1.1  JDBC概念</h3><blockquote><p><strong>JDBC   就是使用Java语言操作关系型数据库的一套API</strong></p><p>全称：( Java DataBase Connectivity ) Java 数据库连接</p></blockquote><p>我们开发的同一套Java代码是无法操作不同的关系型数据库，因为每一个关系型数据库的底层实现细节都不一样。如果这样，问题就很大了，在公司中可以在开发阶段使用的是MySQL数据库，而上线时公司最终选用oracle数据库，我们就需要对代码进行大批量修改，这显然并不是我们想看到的。我们要做到的是同一套Java代码操作不同的关系型数据库，而此时sun公司就指定了一套标准接口（JDBC），JDBC中定义了所有操作关系型数据库的规则。众所周知接口是无法直接使用的，我们需要使用接口的实现类，而这套实现类（称之为：驱动）就由各自的数据库厂商给出。</p><h3 id="1-2-JDBC本质"><a href="#1-2-JDBC本质" class="headerlink" title="1.2  JDBC本质"></a>1.2  JDBC本质</h3><ul><li>官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口</li><li>各个数据库厂商去实现这套接口，提供数据库驱动jar包</li><li>我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类</li></ul><h3 id="1-3-JDBC好处"><a href="#1-3-JDBC好处" class="headerlink" title="1.3  JDBC好处"></a>1.3  JDBC好处</h3><ul><li>各数据库厂商使用相同的接口，Java代码不需要针对不同数据库分别开发</li><li>可随时替换底层数据库，访问数据库的Java代码基本不变</li></ul><p>以后编写操作数据库的代码只需要面向JDBC（接口），操作哪儿个关系型数据库就需要导入该数据库的驱动包，如需要操作MySQL数据库，就需要再项目中导入MySQL数据库的驱动包。</p><h2 id="2，JDBC快速入门"><a href="#2，JDBC快速入门" class="headerlink" title="2，JDBC快速入门"></a>2，JDBC快速入门</h2><p><strong>通过Java操作数据库的流程:</strong></p><p>第一步：编写Java代码</p><p>第二步：Java代码将SQL发送到MySQL服务端</p><p>第三步：MySQL服务端接收到SQL语句并执行该SQL语句</p><p>第四步：将SQL语句执行的结果返回给Java代码</p><h3 id="2-1-编写代码步骤"><a href="#2-1-编写代码步骤" class="headerlink" title="2.1  编写代码步骤"></a>2.1  编写代码步骤</h3><ul><li><p>创建工程，导入驱动jar包</p></li><li><p>注册驱动</p></li></ul>  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br></pre></td></tr></table></figure><ul><li><p>获取连接</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">Connection conn <span class="operator">=</span> DriverManager.getConnection(url, username, password);</span><br></pre></td></tr></table></figure><p>Java代码需要发送SQL给MySQL服务端，就需要先建立连接</p></li><li><p>定义SQL语句</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">String <span class="keyword">sql</span> <span class="operator">=</span>  “<span class="keyword">update</span>…” ;</span><br></pre></td></tr></table></figure></li><li><p>获取执行SQL对象</p><p>执行SQL语句需要SQL执行对象，而这个执行对象就是Statement对象</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">Statement stmt <span class="operator">=</span> conn.createStatement();</span><br></pre></td></tr></table></figure></li><li><p>执行SQL</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">stmt.executeUpdate(<span class="keyword">sql</span>);  </span><br></pre></td></tr></table></figure></li><li><p>处理返回结果</p></li><li><p>释放资源</p></li></ul><h3 id="2-2-具体操作"><a href="#2-2-具体操作" class="headerlink" title="2.2  具体操作"></a>2.2  具体操作</h3><ul><li><p>导入驱动包</p><p>将mysql的驱动包放在模块下的lib目录（随意命名）下，并将该jar包添加为库文件</p></li><li><p>在添加为库文件的时候，有如下三个选项</p><ul><li>Global Library  ： 全局有效</li><li>Project Library :   项目有效</li><li>Module Library ： 模块有效</li></ul></li><li><p>在src下创建类</p></li><li><p>编写代码如下</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JDBC快速入门</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1. 注册驱动</span></span><br><span class="line">        <span class="comment">//Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span></span><br><span class="line">        <span class="comment">//2. 获取连接</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://127.0.0.1:3306/db1&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;1234&quot;</span>;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, username, password);</span><br><span class="line">        <span class="comment">//3. 定义sql</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update account set money = 2000 where id = 1&quot;</span>;</span><br><span class="line">        <span class="comment">//4. 获取执行sql的对象 Statement</span></span><br><span class="line">        <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line">        <span class="comment">//5. 执行sql</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> stmt.executeUpdate(sql);<span class="comment">//受影响的行数</span></span><br><span class="line">        <span class="comment">//6. 处理结果</span></span><br><span class="line">        System.out.println(count);</span><br><span class="line">        <span class="comment">//7. 释放资源</span></span><br><span class="line">        stmt.close();</span><br><span class="line">        conn.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3，JDBC-API详解"><a href="#3，JDBC-API详解" class="headerlink" title="3，JDBC API详解"></a>3，JDBC API详解</h2><h3 id="3-1-DriverManager"><a href="#3-1-DriverManager" class="headerlink" title="3.1  DriverManager"></a>3.1  DriverManager</h3><p>DriverManager（驱动管理类）作用：</p><ul><li><p>注册驱动</p><p>registerDriver方法是用于注册驱动的，但是我们之前做的入门案例并不是这样写的。而是如下实现</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br></pre></td></tr></table></figure><p>在该类中的静态代码块中已经执行了 <code>DriverManager</code> 对象的 <code>registerDriver()</code> 方法进行驱动的注册了，那么我们只需要加载 <code>Driver</code> 类，该静态代码块就会执行。而 <code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</code> 就可以加载 <code>Driver</code> 类。</p><blockquote><p>&#x3D;&#x3D;提示：&#x3D;&#x3D;</p><ul><li>MySQL 5之后的驱动包，可以省略注册驱动的步骤</li><li>自动加载jar包中META-INF&#x2F;services&#x2F;java.sql.Driver文件中的驱动类</li></ul></blockquote></li><li><p>获取数据库连接</p><p>参数说明：</p><ul><li><p>url ： 连接路径</p><blockquote><p>语法：jdbc:mysql:&#x2F;&#x2F;ip地址(域名):端口号&#x2F;数据库名称?参数键值对1&amp;参数键值对2…</p></blockquote></li></ul><blockquote><p>示例：jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;db1</p><p>&#x3D;&#x3D;细节：&#x3D;&#x3D;</p><ul><li><p>如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则url可以简写为：jdbc:mysql:&#x2F;&#x2F;&#x2F;数据库名称?参数键值对</p></li><li><p>配置 useSSL&#x3D;false 参数，禁用安全连接方式，解决警告提示</p></li></ul></blockquote><ul><li>user ：用户名</li></ul></li><li><p>poassword ：密码</p></li></ul><h3 id="3-2-Connection"><a href="#3-2-Connection" class="headerlink" title="3.2  Connection"></a>3.2  Connection</h3><p>Connection（数据库连接对象）作用：</p><ul><li>获取执行 SQL 的对象</li><li>管理事务</li></ul><h4 id="3-2-1-获取执行对象"><a href="#3-2-1-获取执行对象" class="headerlink" title="3.2.1  获取执行对象"></a>3.2.1  获取执行对象</h4><ul><li><p>普通执行SQL对象</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">Statement createStatement()</span><br></pre></td></tr></table></figure><p>入门案例中就是通过该方法获取的执行对象。</p></li><li><p>预编译SQL的执行SQL对象：防止SQL注入</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">PreparedStatement  prepareStatement(<span class="keyword">sql</span>)</span><br></pre></td></tr></table></figure><p>通过这种方式获取的 <code>PreparedStatement</code> SQL语句执行对象是我们一会重点要进行讲解的，它可以防止SQL注入。</p></li><li><p>执行存储过程的对象</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">CallableStatement prepareCall(<span class="keyword">sql</span>)</span><br></pre></td></tr></table></figure><p>通过这种方式获取的 <code>CallableStatement</code> 执行对象是用来执行存储过程的，而存储过程在MySQL中不常用，所以这个我们将不进行讲解。</p></li></ul><h4 id="3-2-2-事务管理"><a href="#3-2-2-事务管理" class="headerlink" title="3.2.2  事务管理"></a>3.2.2  事务管理</h4><p>先回顾一下MySQL事务管理的操作：</p><ul><li>开启事务 ： BEGIN; 或者 START TRANSACTION;</li><li>提交事务 ： COMMIT;</li><li>回滚事务 ： ROLLBACK;</li></ul><blockquote><p>MySQL默认是自动提交事务</p></blockquote><p>接下来学习JDBC事务管理的方法。</p><p>Connection几口中定义了3个对应的方法：</p><ul><li><p>开启事务</p><p>参与autoCommit 表示是否自动提交事务，true表示自动提交事务，false表示手动提交事务。而开启事务需要将该参数设为为false。</p></li><li><p>提交事务</p></li><li><p>回滚事务</p></li></ul><p>具体代码实现如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JDBC API 详解：Connection</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public class JDBCDemo3_Connection &#123;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">static</span> void main(String[] args) throws Exception &#123;</span><br><span class="line">        <span class="operator">/</span><span class="operator">/</span><span class="number">1.</span> 注册驱动</span><br><span class="line">        <span class="operator">/</span><span class="operator">/</span>Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">        <span class="operator">/</span><span class="operator">/</span><span class="number">2.</span> 获取连接：如果连接的是本机mysql并且端口是默认的 <span class="number">3306</span> 可以简化书写</span><br><span class="line">        String url <span class="operator">=</span> &quot;jdbc:mysql:///db1?useSSL=false&quot;;</span><br><span class="line">        String username <span class="operator">=</span> &quot;root&quot;;</span><br><span class="line">        String password <span class="operator">=</span> &quot;1234&quot;;</span><br><span class="line">        Connection conn <span class="operator">=</span> DriverManager.getConnection(url, username, password);</span><br><span class="line">        <span class="operator">/</span><span class="operator">/</span><span class="number">3.</span> 定义<span class="keyword">sql</span></span><br><span class="line">        String sql1 <span class="operator">=</span> &quot;update account set money = 3000 where id = 1&quot;;</span><br><span class="line">        String sql2 <span class="operator">=</span> &quot;update account set money = 3000 where id = 2&quot;;</span><br><span class="line">        <span class="operator">/</span><span class="operator">/</span><span class="number">4.</span> 获取执行<span class="keyword">sql</span>的对象 Statement</span><br><span class="line">        Statement stmt <span class="operator">=</span> conn.createStatement();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            <span class="operator">/</span><span class="operator">/</span> <span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span>开启事务<span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span></span><br><span class="line">            conn.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">            <span class="operator">/</span><span class="operator">/</span><span class="number">5.</span> 执行<span class="keyword">sql</span></span><br><span class="line">            <span class="type">int</span> count1 <span class="operator">=</span> stmt.executeUpdate(sql1);<span class="operator">/</span><span class="operator">/</span>受影响的行数</span><br><span class="line">            <span class="operator">/</span><span class="operator">/</span><span class="number">6.</span> 处理结果</span><br><span class="line">            System.out.println(count1);</span><br><span class="line">            <span class="type">int</span> i <span class="operator">=</span> <span class="number">3</span><span class="operator">/</span><span class="number">0</span>;</span><br><span class="line">            <span class="operator">/</span><span class="operator">/</span><span class="number">5.</span> 执行<span class="keyword">sql</span></span><br><span class="line">            <span class="type">int</span> count2 <span class="operator">=</span> stmt.executeUpdate(sql2);<span class="operator">/</span><span class="operator">/</span>受影响的行数</span><br><span class="line">            <span class="operator">/</span><span class="operator">/</span><span class="number">6.</span> 处理结果</span><br><span class="line">            System.out.println(count2);</span><br><span class="line"></span><br><span class="line">            <span class="operator">/</span><span class="operator">/</span> <span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span>提交事务<span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span></span><br><span class="line">            <span class="operator">/</span><span class="operator">/</span>程序运行到此处，说明没有出现任何问题，则需求提交事务</span><br><span class="line">            conn.commit();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            <span class="operator">/</span><span class="operator">/</span> <span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span>回滚事务<span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span></span><br><span class="line">            <span class="operator">/</span><span class="operator">/</span>程序在出现异常时会执行到这个地方，此时就需要回滚事务</span><br><span class="line">            conn.rollback();</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="operator">/</span><span class="operator">/</span><span class="number">7.</span> 释放资源</span><br><span class="line">        stmt.close();</span><br><span class="line">        conn.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-Statement"><a href="#3-3-Statement" class="headerlink" title="3.3  Statement"></a>3.3  Statement</h3><h4 id="3-3-1-概述"><a href="#3-3-1-概述" class="headerlink" title="3.3.1  概述"></a>3.3.1  概述</h4><p>Statement对象的作用就是用来执行SQL语句。而针对不同类型的SQL语句使用的方法也不一样。</p><ul><li><p>执行DDL、DML语句</p></li><li><p>执行DQL语句</p></li></ul><h4 id="3-3-2-代码实现"><a href="#3-3-2-代码实现" class="headerlink" title="3.3.2  代码实现"></a>3.3.2  代码实现</h4><ul><li><p>执行DML语句</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 执行DML语句</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDML</span><span class="params">()</span> <span class="keyword">throws</span>  Exception &#123;</span><br><span class="line">    <span class="comment">//1. 注册驱动</span></span><br><span class="line">    <span class="comment">//Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span></span><br><span class="line">    <span class="comment">//2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql:///db1?useSSL=false&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;1234&quot;</span>;</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, username, password);</span><br><span class="line">    <span class="comment">//3. 定义sql</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update account set money = 3000 where id = 1&quot;</span>;</span><br><span class="line">    <span class="comment">//4. 获取执行sql的对象 Statement</span></span><br><span class="line">    <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line">    <span class="comment">//5. 执行sql</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> stmt.executeUpdate(sql);<span class="comment">//执行完DML语句，受影响的行数</span></span><br><span class="line">    <span class="comment">//6. 处理结果</span></span><br><span class="line">    <span class="comment">//System.out.println(count);</span></span><br><span class="line">    <span class="keyword">if</span>(count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;修改成功~&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;修改失败~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//7. 释放资源</span></span><br><span class="line">    stmt.close();</span><br><span class="line">    conn.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>执行DDL语句</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 执行DDL语句</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDDL</span><span class="params">()</span> <span class="keyword">throws</span>  Exception &#123;</span><br><span class="line">    <span class="comment">//1. 注册驱动</span></span><br><span class="line">    <span class="comment">//Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span></span><br><span class="line">    <span class="comment">//2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql:///db1?useSSL=false&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;1234&quot;</span>;</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, username, password);</span><br><span class="line">    <span class="comment">//3. 定义sql</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;drop database db2&quot;</span>;</span><br><span class="line">    <span class="comment">//4. 获取执行sql的对象 Statement</span></span><br><span class="line">    <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line">    <span class="comment">//5. 执行sql</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> stmt.executeUpdate(sql);<span class="comment">//执行完DDL语句，可能是0</span></span><br><span class="line">    <span class="comment">//6. 处理结果</span></span><br><span class="line">    System.out.println(count);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7. 释放资源</span></span><br><span class="line">    stmt.close();</span><br><span class="line">    conn.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><ul><li>以后开发很少使用java代码操作DDL语句</li></ul></blockquote></li></ul><h3 id="3-4-ResultSet"><a href="#3-4-ResultSet" class="headerlink" title="3.4  ResultSet"></a>3.4  ResultSet</h3><h4 id="3-4-1-概述"><a href="#3-4-1-概述" class="headerlink" title="3.4.1  概述"></a>3.4.1  概述</h4><p>ResultSet（结果集对象）作用：</p><ul><li>&#x3D;&#x3D;封装了SQL查询语句的结果。&#x3D;&#x3D;</li></ul><p>而执行了DQL语句后就会返回该对象，对应执行DQL语句的方法如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">ResultSet  executeQuery(<span class="keyword">sql</span>)：执行DQL 语句，返回 ResultSet 对象</span><br></pre></td></tr></table></figure><p>那么我们就需要从 <code>ResultSet</code> 对象中获取我们想要的数据。<code>ResultSet</code> 对象提供了操作查询结果数据的方法，如下：</p><blockquote><p>boolean  next()</p><ul><li>将光标从当前位置向前移动一行 </li><li>判断当前行是否为有效行</li></ul><p>方法返回值说明：</p><ul><li>true  ： 有效航，当前行有数据</li><li>false ： 无效行，当前行没有数据</li></ul></blockquote><blockquote><p>xxx  getXxx(参数)：获取数据</p><ul><li>xxx : 数据类型；如： int getInt(参数) ；String getString(参数)</li><li>参数<ul><li>int类型的参数：列的编号，从1开始</li><li>String类型的参数： 列的名称</li></ul></li></ul></blockquote><p>一开始光标指定于第一行前，如图所示红色箭头指向于表头行。当我们调用了 <code>next()</code> 方法后，光标就下移到第一行数据，并且方法返回true，此时就可以通过 <code>getInt(&quot;id&quot;)</code> 获取当前行id字段的值，也可以通过 <code>getString(&quot;name&quot;)</code> 获取当前行name字段的值。如果想获取下一行的数据，继续调用 <code>next()</code>  方法，以此类推。</p><h4 id="3-4-2-代码实现"><a href="#3-4-2-代码实现" class="headerlink" title="3.4.2  代码实现"></a>3.4.2  代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 执行DQL</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testResultSet</span><span class="params">()</span> <span class="keyword">throws</span>  Exception &#123;</span><br><span class="line">    <span class="comment">//1. 注册驱动</span></span><br><span class="line">    <span class="comment">//Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span></span><br><span class="line">    <span class="comment">//2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql:///db1?useSSL=false&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;1234&quot;</span>;</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, username, password);</span><br><span class="line">    <span class="comment">//3. 定义sql</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from account&quot;</span>;</span><br><span class="line">    <span class="comment">//4. 获取statement对象</span></span><br><span class="line">    <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line">    <span class="comment">//5. 执行sql</span></span><br><span class="line">    <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery(sql);</span><br><span class="line">    <span class="comment">//6. 处理结果， 遍历rs中的所有数据</span></span><br><span class="line">    <span class="comment">/* // 6.1 光标向下移动一行，并且判断当前行是否有数据</span></span><br><span class="line"><span class="comment">        while (rs.next())&#123;</span></span><br><span class="line"><span class="comment">            //6.2 获取数据  getXxx()</span></span><br><span class="line"><span class="comment">            int id = rs.getInt(1);</span></span><br><span class="line"><span class="comment">            String name = rs.getString(2);</span></span><br><span class="line"><span class="comment">            double money = rs.getDouble(3);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            System.out.println(id);</span></span><br><span class="line"><span class="comment">            System.out.println(name);</span></span><br><span class="line"><span class="comment">            System.out.println(money);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            System.out.println(&quot;--------------&quot;);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">    <span class="comment">// 6.1 光标向下移动一行，并且判断当前行是否有数据</span></span><br><span class="line">    <span class="keyword">while</span> (rs.next())&#123;</span><br><span class="line">        <span class="comment">//6.2 获取数据  getXxx()</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="type">double</span> <span class="variable">money</span> <span class="operator">=</span> rs.getDouble(<span class="string">&quot;money&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(id);</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        System.out.println(money);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;--------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7. 释放资源</span></span><br><span class="line">    rs.close();</span><br><span class="line">    stmt.close();</span><br><span class="line">    conn.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-案例"><a href="#3-5-案例" class="headerlink" title="3.5  案例"></a>3.5  案例</h3><ul><li><p>需求：查询account账户表数据，封装为Account对象中，并且存储到ArrayList集合中</p></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 查询account账户表数据，封装为Account对象中，并且存储到ArrayList集合中</span></span><br><span class="line"><span class="comment">  * 1. 定义实体类Account</span></span><br><span class="line"><span class="comment">  * 2. 查询数据，封装到Account对象中</span></span><br><span class="line"><span class="comment">  * 3. 将Account对象存入ArrayList集合中</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testResultSet2</span><span class="params">()</span> <span class="keyword">throws</span>  Exception &#123;</span><br><span class="line">    <span class="comment">//1. 注册驱动</span></span><br><span class="line">    <span class="comment">//Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span></span><br><span class="line">    <span class="comment">//2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql:///db1?useSSL=false&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;1234&quot;</span>;</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, username, password);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 定义sql</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from account&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. 获取statement对象</span></span><br><span class="line">    <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5. 执行sql</span></span><br><span class="line">    <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery(sql);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建集合</span></span><br><span class="line">    List&lt;Account&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 6.1 光标向下移动一行，并且判断当前行是否有数据</span></span><br><span class="line">    <span class="keyword">while</span> (rs.next())&#123;</span><br><span class="line">        <span class="type">Account</span> <span class="variable">account</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.2 获取数据  getXxx()</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="type">double</span> <span class="variable">money</span> <span class="operator">=</span> rs.getDouble(<span class="string">&quot;money&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//赋值</span></span><br><span class="line">        account.setId(id);</span><br><span class="line">        account.setName(name);</span><br><span class="line">        account.setMoney(money);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存入集合</span></span><br><span class="line">        list.add(account);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(list);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7. 释放资源</span></span><br><span class="line">    rs.close();</span><br><span class="line">    stmt.close();</span><br><span class="line">    conn.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-6-PreparedStatement"><a href="#3-6-PreparedStatement" class="headerlink" title="3.6  PreparedStatement"></a>3.6  PreparedStatement</h3><blockquote><p>PreparedStatement作用：</p><ul><li>预编译SQL语句并执行：预防SQL注入问题</li></ul></blockquote><p>对上面的作用中SQL注入问题大家肯定不理解。那我们先对SQL注入进行说明.</p><h4 id="3-6-1-SQL注入"><a href="#3-6-1-SQL注入" class="headerlink" title="3.6.1  SQL注入"></a>3.6.1  SQL注入</h4><blockquote><p>SQL注入是通过操作输入来修改事先定义好的SQL语句，用以达到执行代码对服务器进行攻击的方法。</p></blockquote><p>但是我可以通过输入一些特殊的字符登陆到首页。</p><p>用户名随意写，密码写成 <code>&#39; or &#39;1&#39; =&#39;1</code></p><p>这就是SQL注入漏洞，也是很危险的。当然现在市面上的系统都不会存在这种问题了，。</p><p>那么该如何解决呢？这里就可以将SQL执行对象 <code>Statement</code> 换成 <code>PreparedStatement</code> 对象。</p><h4 id="3-6-2-代码模拟SQL注入问题"><a href="#3-6-2-代码模拟SQL注入问题" class="headerlink" title="3.6.2  代码模拟SQL注入问题"></a>3.6.2  代码模拟SQL注入问题</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLogin</span><span class="params">()</span> <span class="keyword">throws</span>  Exception &#123;</span><br><span class="line">    <span class="comment">//2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql:///db1?useSSL=false&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;1234&quot;</span>;</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, username, password);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收用户输入 用户名和密码</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;sjdljfld&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">pwd</span> <span class="operator">=</span> <span class="string">&quot;&#x27; or &#x27;1&#x27; = &#x27;1&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from tb_user where username = &#x27;&quot;</span>+name+<span class="string">&quot;&#x27; and password = &#x27;&quot;</span>+pwd+<span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">    <span class="comment">// 获取stmt对象</span></span><br><span class="line">    <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line">    <span class="comment">// 执行sql</span></span><br><span class="line">    <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery(sql);</span><br><span class="line">    <span class="comment">// 判断登录是否成功</span></span><br><span class="line">    <span class="keyword">if</span>(rs.next())&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;登录成功~&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;登录失败~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7. 释放资源</span></span><br><span class="line">    rs.close();</span><br><span class="line">    stmt.close();</span><br><span class="line">    conn.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码是将用户名和密码拼接到sql语句中，拼接后的sql语句如下</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> username <span class="operator">=</span> <span class="string">&#x27;sjdljfld&#x27;</span> <span class="keyword">and</span> password <span class="operator">=</span> <span class="string">&#x27;&#x27;</span><span class="keyword">or</span> <span class="string">&#x27;1&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span></span><br></pre></td></tr></table></figure><p>从上面语句可以看出条件 <code>username = &#39;sjdljfld&#39; and password = &#39;&#39;</code> 不管是否满足，而 <code>or</code> 后面的 <code>&#39;1&#39; = &#39;1&#39;</code> 是始终满足的，最终条件是成立的，就可以正常的进行登陆了。</p><p>接下来我们来学习PreparedStatement对象.</p><h4 id="3-6-3-PreparedStatement概述"><a href="#3-6-3-PreparedStatement概述" class="headerlink" title="3.6.3  PreparedStatement概述"></a>3.6.3  PreparedStatement概述</h4><blockquote><p>PreparedStatement作用：</p><ul><li>预编译SQL语句并执行：预防SQL注入问题</li></ul></blockquote><ul><li><p>获取 PreparedStatement 对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SQL语句中的参数值，使用？占位符替代</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from user where username = ? and password = ?&quot;</span>;</span><br><span class="line"><span class="comment">// 通过Connection对象获取，并传入对应的sql语句</span></span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br></pre></td></tr></table></figure></li><li><p>设置参数值</p><p>上面的sql语句中参数使用 ? 进行占位，在之前之前肯定要设置这些 ?  的值。</p><blockquote><p>PreparedStatement对象：setXxx(参数1，参数2)：给 ? 赋值</p><ul><li><p>Xxx：数据类型 ； 如 setInt (参数1，参数2)</p></li><li><p>参数：</p><ul><li><p>参数1： ？的位置编号，从1 开始</p></li><li><p>参数2： ？的值</p></li></ul></li></ul></blockquote></li><li><p>执行SQL语句</p><blockquote><p>executeUpdate();  执行DDL语句和DML语句</p><p>executeQuery();  执行DQL语句</p><p>&#x3D;&#x3D;注意：&#x3D;&#x3D;</p><ul><li>调用这两个方法时不需要传递SQL语句，因为获取SQL语句执行对象时已经对SQL语句进行预编译了。</li></ul></blockquote></li></ul><h4 id="3-6-4-使用PreparedStatement改进"><a href="#3-6-4-使用PreparedStatement改进" class="headerlink" title="3.6.4  使用PreparedStatement改进"></a>3.6.4  使用PreparedStatement改进</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPreparedStatement</span><span class="params">()</span> <span class="keyword">throws</span>  Exception &#123;</span><br><span class="line">    <span class="comment">//2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql:///db1?useSSL=false&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;1234&quot;</span>;</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, username, password);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收用户输入 用户名和密码</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;zhangsan&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">pwd</span> <span class="operator">=</span> <span class="string">&quot;&#x27; or &#x27;1&#x27; = &#x27;1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义sql</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from tb_user where username = ? and password = ?&quot;</span>;</span><br><span class="line">    <span class="comment">// 获取pstmt对象</span></span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line">    <span class="comment">// 设置？的值</span></span><br><span class="line">    pstmt.setString(<span class="number">1</span>,name);</span><br><span class="line">    pstmt.setString(<span class="number">2</span>,pwd);</span><br><span class="line">    <span class="comment">// 执行sql</span></span><br><span class="line">    <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> pstmt.executeQuery();</span><br><span class="line">    <span class="comment">// 判断登录是否成功</span></span><br><span class="line">    <span class="keyword">if</span>(rs.next())&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;登录成功~&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;登录失败~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//7. 释放资源</span></span><br><span class="line">    rs.close();</span><br><span class="line">    pstmt.close();</span><br><span class="line">    conn.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上面语句就可以发现不会出现SQL注入漏洞问题了。那么PreparedStatement又是如何解决的呢？它是将特殊字符进行了转义，转义的SQL如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> username <span class="operator">=</span> <span class="string">&#x27;sjdljfld&#x27;</span> <span class="keyword">and</span> password <span class="operator">=</span> <span class="string">&#x27;\&#x27;</span><span class="keyword">or</span> \<span class="string">&#x27;1\&#x27;</span> <span class="operator">=</span> \<span class="string">&#x27;1&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="3-6-5-PreparedStatement原理"><a href="#3-6-5-PreparedStatement原理" class="headerlink" title="3.6.5  PreparedStatement原理"></a>3.6.5  PreparedStatement原理</h4><blockquote><p>PreparedStatement 好处：</p><ul><li>预编译SQL，性能更高</li><li>防止SQL注入：&#x3D;&#x3D;将敏感字符进行转义&#x3D;&#x3D;</li></ul></blockquote><p>Java代码操作数据库流程如图所示：</p><ul><li><p>将sql语句发送到MySQL服务器端</p></li><li><p>MySQL服务端会对sql语句进行如下操作</p><ul><li><p>检查SQL语句</p><p>检查SQL语句的语法是否正确。</p></li><li><p>编译SQL语句。将SQL语句编译成可执行的函数。</p><p>检查SQL和编译SQL花费的时间比执行SQL的时间还要长。如果我们只是重新设置参数，那么检查SQL语句和编译SQL语句将不需要重复执行。这样就提高了性能。</p></li><li><p>执行SQL语句</p></li></ul></li></ul><p>接下来我们通过查询日志来看一下原理。</p><ul><li><p>开启预编译功能</p><p>在代码中编写url时需要加上以下参数。而我们之前根本就没有开启预编译功能，只是解决了SQL注入漏洞。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">useServerPrepStmts<span class="operator">=</span><span class="literal">true</span></span><br></pre></td></tr></table></figure></li><li><p>配置MySQL执行日志（重启mysql服务后生效）</p><p>在mysql配置文件（my.ini）中添加如下配置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">log-output=FILE</span><br><span class="line">general-log=1</span><br><span class="line">general_log_file=&quot;D:\mysql.log&quot;</span><br><span class="line">slow-query-log=1</span><br><span class="line">slow_query_log_file=&quot;D:\mysql_slow.log&quot;</span><br><span class="line">long_query_time=2</span><br></pre></td></tr></table></figure></li><li><p>java测试代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * PreparedStatement原理</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPreparedStatement2</span><span class="params">()</span> <span class="keyword">throws</span>  Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写</span></span><br><span class="line">    <span class="comment">// useServerPrepStmts=true 参数开启预编译功能</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql:///db1?useSSL=false&amp;useServerPrepStmts=true&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;1234&quot;</span>;</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, username, password);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收用户输入 用户名和密码</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;zhangsan&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">pwd</span> <span class="operator">=</span> <span class="string">&quot;&#x27; or &#x27;1&#x27; = &#x27;1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义sql</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from tb_user where username = ? and password = ?&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取pstmt对象</span></span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">    <span class="comment">// 设置？的值</span></span><br><span class="line">    pstmt.setString(<span class="number">1</span>,name);</span><br><span class="line">    pstmt.setString(<span class="number">2</span>,pwd);</span><br><span class="line">    <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 执行sql</span></span><br><span class="line">    rs = pstmt.executeQuery();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置？的值</span></span><br><span class="line">    pstmt.setString(<span class="number">1</span>,<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">    pstmt.setString(<span class="number">2</span>,<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">    <span class="comment">// 执行sql</span></span><br><span class="line">    rs = pstmt.executeQuery();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断登录是否成功</span></span><br><span class="line">    <span class="keyword">if</span>(rs.next())&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;登录成功~&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;登录失败~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7. 释放资源</span></span><br><span class="line">    rs.close();</span><br><span class="line">    pstmt.close();</span><br><span class="line">    conn.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>&#x3D;&#x3D;小结：&#x3D;&#x3D;</p><ul><li>在获取PreparedStatement对象时，将sql语句发送给mysql服务器进行检查，编译（这些步骤很耗时）</li><li>执行时就不用再进行这些步骤了，速度更快</li><li>如果sql模板一样，则只需要进行一次检查、编译</li></ul></blockquote><h2 id="4，数据库连接池"><a href="#4，数据库连接池" class="headerlink" title="4，数据库连接池"></a>4，数据库连接池</h2><h3 id="4-1-数据库连接池简介"><a href="#4-1-数据库连接池简介" class="headerlink" title="4.1  数据库连接池简介"></a>4.1  数据库连接池简介</h3><blockquote><ul><li><p>数据库连接池是个容器，负责分配、管理数据库连接(Connection)</p></li><li><p>它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；</p></li><li><p>释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏</p></li><li><p>好处</p><ul><li>资源重用</li><li>提升系统响应速度</li><li>避免数据库连接遗漏</li></ul></li></ul></blockquote><p>之前我们代码中使用连接是没有使用都创建一个Connection对象，使用完毕就会将其销毁。这样重复创建销毁的过程是特别耗费计算机的性能的及消耗时间的。</p><p>而数据库使用了数据库连接池后，就能达到Connection对象的复用.</p><p>连接池是在一开始就创建好了一些连接（Connection）对象存储起来。用户需要连接数据库时，不需要自己创建连接，而只需要从连接池中获取一个连接进行使用，使用完毕后再将连接对象归还给连接池；这样就可以起到资源重用，也节省了频繁创建连接销毁连接所花费的时间，从而提升了系统响应的速度。</p><h3 id="4-2-数据库连接池实现"><a href="#4-2-数据库连接池实现" class="headerlink" title="4.2  数据库连接池实现"></a>4.2  数据库连接池实现</h3><ul><li><p>标准接口：&#x3D;&#x3D;DataSource&#x3D;&#x3D;</p><p>官方(SUN) 提供的数据库连接池标准接口，由第三方组织实现此接口。该接口提供了获取连接的功能：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Connection <span class="title function_">getConnection</span><span class="params">()</span></span><br></pre></td></tr></table></figure><p>那么以后就不需要通过 <code>DriverManager</code> 对象获取 <code>Connection</code> 对象，而是通过连接池（DataSource）获取 <code>Connection</code> 对象。</p></li><li><p>常见的数据库连接池</p><ul><li>DBCP</li><li>C3P0</li><li>Druid</li></ul><p>我们现在使用更多的是Druid，它的性能比其他两个会好一些。</p></li><li><p>Druid（德鲁伊）</p><ul><li><p>Druid连接池是阿里巴巴开源的数据库连接池项目 </p></li><li><p>功能强大，性能优秀，是Java语言最好的数据库连接池之一</p></li></ul></li></ul><h3 id="4-3-Driud使用"><a href="#4-3-Driud使用" class="headerlink" title="4.3  Driud使用"></a>4.3  Driud使用</h3><blockquote><ul><li>导入jar包 druid-1.1.12.jar</li><li>定义配置文件</li><li>加载配置文件</li><li>获取数据库连接池对象</li><li>获取连接</li></ul></blockquote><p>现在通过代码实现，首先需要先将druid的jar包放到项目下的lib下并添加为库文件</p><p>编写配置文件如下：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">driverClassName</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql:///db1?useSSL=false&amp;useServerPrepStmts=true</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">1234</span></span><br><span class="line"><span class="comment"># 初始化连接数量</span></span><br><span class="line"><span class="attr">initialSize</span>=<span class="string">5</span></span><br><span class="line"><span class="comment"># 最大连接数</span></span><br><span class="line"><span class="attr">maxActive</span>=<span class="string">10</span></span><br><span class="line"><span class="comment"># 最大等待时间</span></span><br><span class="line"><span class="attr">maxWait</span>=<span class="string">3000</span></span><br></pre></td></tr></table></figure><p>使用druid的代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Druid数据库连接池演示</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DruidDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1.导入jar包</span></span><br><span class="line">        <span class="comment">//2.定义配置文件</span></span><br><span class="line">        <span class="comment">//3. 加载配置文件</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">prop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        prop.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;jdbc-demo/src/druid.properties&quot;</span>));</span><br><span class="line">        <span class="comment">//4. 获取连接池对象</span></span><br><span class="line">        <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> DruidDataSourceFactory.createDataSource(prop);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5. 获取数据库连接 Connection</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> dataSource.getConnection();</span><br><span class="line">        System.out.println(connection); <span class="comment">//获取到了连接后就可以继续做其他操作了</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//System.out.println(System.getProperty(&quot;user.dir&quot;));</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5，JDBC练习"><a href="#5，JDBC练习" class="headerlink" title="5，JDBC练习"></a>5，JDBC练习</h2><h3 id="5-1-需求"><a href="#5-1-需求" class="headerlink" title="5.1  需求"></a>5.1  需求</h3><p>完成商品品牌数据的增删改查操作</p><ul><li>查询：查询所有数据</li><li>添加：添加品牌</li><li>修改：根据id修改</li><li>删除：根据id删除</li></ul><h3 id="5-2-案例实现"><a href="#5-2-案例实现" class="headerlink" title="5.2  案例实现"></a>5.2  案例实现</h3><h4 id="5-2-1-环境准备"><a href="#5-2-1-环境准备" class="headerlink" title="5.2.1  环境准备"></a>5.2.1  环境准备</h4><ul><li><p>数据库表 <code>tb_brand</code></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 删除tb_brand表</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> tb_brand;</span><br><span class="line"><span class="comment">-- 创建tb_brand表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tb_brand (</span><br><span class="line">    <span class="comment">-- id 主键</span></span><br><span class="line">    id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">    <span class="comment">-- 品牌名称</span></span><br><span class="line">    brand_name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    <span class="comment">-- 企业名称</span></span><br><span class="line">    company_name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    <span class="comment">-- 排序字段</span></span><br><span class="line">    ordered <span class="type">int</span>,</span><br><span class="line">    <span class="comment">-- 描述信息</span></span><br><span class="line">    description <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">    <span class="comment">-- 状态：0：禁用  1：启用</span></span><br><span class="line">    status <span class="type">int</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 添加数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_brand (brand_name, company_name, ordered, description, status)</span><br><span class="line"><span class="keyword">values</span> (<span class="string">&#x27;三只松鼠&#x27;</span>, <span class="string">&#x27;三只松鼠股份有限公司&#x27;</span>, <span class="number">5</span>, <span class="string">&#x27;好吃不上火&#x27;</span>, <span class="number">0</span>),</span><br><span class="line">       (<span class="string">&#x27;华为&#x27;</span>, <span class="string">&#x27;华为技术有限公司&#x27;</span>, <span class="number">100</span>, <span class="string">&#x27;华为致力于把数字世界带入每个人、每个家庭、每个组织，构建万物互联的智能世界&#x27;</span>, <span class="number">1</span>),</span><br><span class="line">       (<span class="string">&#x27;小米&#x27;</span>, <span class="string">&#x27;小米科技有限公司&#x27;</span>, <span class="number">50</span>, <span class="string">&#x27;are you ok&#x27;</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure></li><li><p>在pojo包下实体类 Brand</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 品牌</span></span><br><span class="line"><span class="comment"> * alt + 鼠标左键：整列编辑</span></span><br><span class="line"><span class="comment"> * 在实体类中，基本数据类型建议使用其对应的包装类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Brand</span> &#123;</span><br><span class="line">    <span class="comment">// id 主键</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="comment">// 品牌名称</span></span><br><span class="line">    <span class="keyword">private</span> String brandName;</span><br><span class="line">    <span class="comment">// 企业名称</span></span><br><span class="line">    <span class="keyword">private</span> String companyName;</span><br><span class="line">    <span class="comment">// 排序字段</span></span><br><span class="line">    <span class="keyword">private</span> Integer ordered;</span><br><span class="line">    <span class="comment">// 描述信息</span></span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">    <span class="comment">// 状态：0：禁用  1：启用</span></span><br><span class="line">    <span class="keyword">private</span> Integer status;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getBrandName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> brandName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBrandName</span><span class="params">(String brandName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.brandName = brandName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCompanyName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> companyName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCompanyName</span><span class="params">(String companyName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.companyName = companyName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getOrdered</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ordered;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOrdered</span><span class="params">(Integer ordered)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.ordered = ordered;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDescription</span><span class="params">(String description)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.description = description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getStatus</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStatus</span><span class="params">(Integer status)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.status = status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Brand&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, brandName=&#x27;&quot;</span> + brandName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, companyName=&#x27;&quot;</span> + companyName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, ordered=&quot;</span> + ordered +</span><br><span class="line">                <span class="string">&quot;, description=&#x27;&quot;</span> + description + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, status=&quot;</span> + status +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="5-2-2-查询所有"><a href="#5-2-2-查询所有" class="headerlink" title="5.2.2  查询所有"></a>5.2.2  查询所有</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 查询所有</span></span><br><span class="line"><span class="comment">   * 1. SQL：select * from tb_brand;</span></span><br><span class="line"><span class="comment">   * 2. 参数：不需要</span></span><br><span class="line"><span class="comment">   * 3. 结果：List&lt;Brand&gt;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectAll</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//1. 获取Connection</span></span><br><span class="line">    <span class="comment">//3. 加载配置文件</span></span><br><span class="line">    <span class="type">Properties</span> <span class="variable">prop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    prop.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;jdbc-demo/src/druid.properties&quot;</span>));</span><br><span class="line">    <span class="comment">//4. 获取连接池对象</span></span><br><span class="line">    <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> DruidDataSourceFactory.createDataSource(prop);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5. 获取数据库连接 Connection</span></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> dataSource.getConnection();</span><br><span class="line">    <span class="comment">//2. 定义SQL</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from tb_brand;&quot;</span>;</span><br><span class="line">    <span class="comment">//3. 获取pstmt对象</span></span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line">    <span class="comment">//4. 设置参数</span></span><br><span class="line">    <span class="comment">//5. 执行SQL</span></span><br><span class="line">    <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> pstmt.executeQuery();</span><br><span class="line">    <span class="comment">//6. 处理结果 List&lt;Brand&gt; 封装Brand对象，装载List集合</span></span><br><span class="line">    <span class="type">Brand</span> <span class="variable">brand</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    List&lt;Brand&gt; brands = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (rs.next())&#123;</span><br><span class="line">        <span class="comment">//获取数据</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">brandName</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;brand_name&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">companyName</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;company_name&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">ordered</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;ordered&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">description</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;description&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">status</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;status&quot;</span>);</span><br><span class="line">        <span class="comment">//封装Brand对象</span></span><br><span class="line">        brand = <span class="keyword">new</span> <span class="title class_">Brand</span>();</span><br><span class="line">        brand.setId(id);</span><br><span class="line">        brand.setBrandName(brandName);</span><br><span class="line">        brand.setCompanyName(companyName);</span><br><span class="line">        brand.setOrdered(ordered);</span><br><span class="line">        brand.setDescription(description);</span><br><span class="line">        brand.setStatus(status);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//装载集合</span></span><br><span class="line">        brands.add(brand);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(brands);</span><br><span class="line">    <span class="comment">//7. 释放资源</span></span><br><span class="line">    rs.close();</span><br><span class="line">    pstmt.close();</span><br><span class="line">    conn.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-3-添加数据"><a href="#5-2-3-添加数据" class="headerlink" title="5.2.3  添加数据"></a>5.2.3  添加数据</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 添加</span></span><br><span class="line"><span class="comment">  * 1. SQL：insert into tb_brand(brand_name, company_name, ordered, description, status) values(?,?,?,?,?);</span></span><br><span class="line"><span class="comment">  * 2. 参数：需要，除了id之外的所有参数信息</span></span><br><span class="line"><span class="comment">  * 3. 结果：boolean</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAdd</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 接收页面提交的参数</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">brandName</span> <span class="operator">=</span> <span class="string">&quot;香飘飘&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">companyName</span> <span class="operator">=</span> <span class="string">&quot;香飘飘&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ordered</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">description</span> <span class="operator">=</span> <span class="string">&quot;绕地球一圈&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">status</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 获取Connection</span></span><br><span class="line">    <span class="comment">//3. 加载配置文件</span></span><br><span class="line">    <span class="type">Properties</span> <span class="variable">prop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    prop.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;jdbc-demo/src/druid.properties&quot;</span>));</span><br><span class="line">    <span class="comment">//4. 获取连接池对象</span></span><br><span class="line">    <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> DruidDataSourceFactory.createDataSource(prop);</span><br><span class="line">    <span class="comment">//5. 获取数据库连接 Connection</span></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> dataSource.getConnection();</span><br><span class="line">    <span class="comment">//2. 定义SQL</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into tb_brand(brand_name, company_name, ordered, description, status) values(?,?,?,?,?);&quot;</span>;</span><br><span class="line">    <span class="comment">//3. 获取pstmt对象</span></span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line">    <span class="comment">//4. 设置参数</span></span><br><span class="line">    pstmt.setString(<span class="number">1</span>,brandName);</span><br><span class="line">    pstmt.setString(<span class="number">2</span>,companyName);</span><br><span class="line">    pstmt.setInt(<span class="number">3</span>,ordered);</span><br><span class="line">    pstmt.setString(<span class="number">4</span>,description);</span><br><span class="line">    pstmt.setInt(<span class="number">5</span>,status);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5. 执行SQL</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> pstmt.executeUpdate(); <span class="comment">// 影响的行数</span></span><br><span class="line">    <span class="comment">//6. 处理结果</span></span><br><span class="line">    System.out.println(count &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7. 释放资源</span></span><br><span class="line">    pstmt.close();</span><br><span class="line">    conn.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-4-修改数据"><a href="#5-2-4-修改数据" class="headerlink" title="5.2.4  修改数据"></a>5.2.4  修改数据</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 修改</span></span><br><span class="line"><span class="comment">  * 1. SQL：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     update tb_brand</span></span><br><span class="line"><span class="comment">         set brand_name  = ?,</span></span><br><span class="line"><span class="comment">         company_name= ?,</span></span><br><span class="line"><span class="comment">         ordered     = ?,</span></span><br><span class="line"><span class="comment">         description = ?,</span></span><br><span class="line"><span class="comment">         status      = ?</span></span><br><span class="line"><span class="comment">     where id = ?</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   * 2. 参数：需要，所有数据</span></span><br><span class="line"><span class="comment">   * 3. 结果：boolean</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUpdate</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 接收页面提交的参数</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">brandName</span> <span class="operator">=</span> <span class="string">&quot;香飘飘&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">companyName</span> <span class="operator">=</span> <span class="string">&quot;香飘飘&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ordered</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">description</span> <span class="operator">=</span> <span class="string">&quot;绕地球三圈&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">status</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 获取Connection</span></span><br><span class="line">    <span class="comment">//3. 加载配置文件</span></span><br><span class="line">    <span class="type">Properties</span> <span class="variable">prop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    prop.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;jdbc-demo/src/druid.properties&quot;</span>));</span><br><span class="line">    <span class="comment">//4. 获取连接池对象</span></span><br><span class="line">    <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> DruidDataSourceFactory.createDataSource(prop);</span><br><span class="line">    <span class="comment">//5. 获取数据库连接 Connection</span></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> dataSource.getConnection();</span><br><span class="line">    <span class="comment">//2. 定义SQL</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot; update tb_brand\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;         set brand_name  = ?,\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;         company_name= ?,\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;         ordered     = ?,\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;         description = ?,\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;         status      = ?\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;     where id = ?&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 获取pstmt对象</span></span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. 设置参数</span></span><br><span class="line">    pstmt.setString(<span class="number">1</span>,brandName);</span><br><span class="line">    pstmt.setString(<span class="number">2</span>,companyName);</span><br><span class="line">    pstmt.setInt(<span class="number">3</span>,ordered);</span><br><span class="line">    pstmt.setString(<span class="number">4</span>,description);</span><br><span class="line">    pstmt.setInt(<span class="number">5</span>,status);</span><br><span class="line">    pstmt.setInt(<span class="number">6</span>,id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5. 执行SQL</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> pstmt.executeUpdate(); <span class="comment">// 影响的行数</span></span><br><span class="line">    <span class="comment">//6. 处理结果</span></span><br><span class="line">    System.out.println(count &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7. 释放资源</span></span><br><span class="line">    pstmt.close();</span><br><span class="line">    conn.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-5-删除数据"><a href="#5-2-5-删除数据" class="headerlink" title="5.2.5  删除数据"></a>5.2.5  删除数据</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 删除</span></span><br><span class="line"><span class="comment">  * 1. SQL：</span></span><br><span class="line"><span class="comment">            delete from tb_brand where id = ?</span></span><br><span class="line"><span class="comment">  * 2. 参数：需要，id</span></span><br><span class="line"><span class="comment">  * 3. 结果：boolean</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDeleteById</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 接收页面提交的参数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">    <span class="comment">//1. 获取Connection</span></span><br><span class="line">    <span class="comment">//3. 加载配置文件</span></span><br><span class="line">    <span class="type">Properties</span> <span class="variable">prop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    prop.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;jdbc-demo/src/druid.properties&quot;</span>));</span><br><span class="line">    <span class="comment">//4. 获取连接池对象</span></span><br><span class="line">    <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> DruidDataSourceFactory.createDataSource(prop);</span><br><span class="line">    <span class="comment">//5. 获取数据库连接 Connection</span></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> dataSource.getConnection();</span><br><span class="line">    <span class="comment">//2. 定义SQL</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot; delete from tb_brand where id = ?&quot;</span>;</span><br><span class="line">    <span class="comment">//3. 获取pstmt对象</span></span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line">    <span class="comment">//4. 设置参数</span></span><br><span class="line">    pstmt.setInt(<span class="number">1</span>,id);</span><br><span class="line">    <span class="comment">//5. 执行SQL</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> pstmt.executeUpdate(); <span class="comment">// 影响的行数</span></span><br><span class="line">    <span class="comment">//6. 处理结果</span></span><br><span class="line">    System.out.println(count &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7. 释放资源</span></span><br><span class="line">    pstmt.close();</span><br><span class="line">    conn.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> JDBC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql高级</title>
      <link href="/post/ab2417d4.html"/>
      <url>/post/ab2417d4.html</url>
      
        <content type="html"><![CDATA[<h2 id="mysql高级"><a href="#mysql高级" class="headerlink" title="mysql高级"></a>mysql高级</h2><p><strong>今日目标</strong></p><blockquote><ul><li><p>掌握约束的使用</p></li><li><p>掌握表关系及建表原则</p></li><li><p>重点掌握多表查询操作</p></li><li><p>掌握事务操作</p></li></ul></blockquote><h2 id="1、约束"><a href="#1、约束" class="headerlink" title="1、约束"></a>1、约束</h2><h3 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1  概念"></a>1.1  概念</h3><ul><li><p>约束是作用于表中列上的规则，用于限制加入表的数据</p><p>例如：我们可以给id列加约束，让其值不能重复，不能为null值。</p></li><li><p>约束的存在保证了数据库中数据的正确性、有效性和完整性</p><p>添加约束可以在添加数据的时候就限制不正确的数据，年龄是3000，数学成绩是-5分这样无效的数据，继而保障数据的完整性。</p></li></ul><h3 id="1-2-分类"><a href="#1-2-分类" class="headerlink" title="1.2  分类"></a>1.2  分类</h3><ul><li><strong>非空约束： 关键字是 NOT NULL</strong></li></ul><p>  保证列中所有的数据不能有null值。</p><p>  例如：id列在添加 <code>马花疼</code> 这条数据时就不能添加成功。</p><ul><li><p><strong>唯一约束：关键字是  UNIQUE</strong></p><p>保证列中所有数据各不相同。</p><p>例如：id列中三条数据的值都是1，这样的数据在添加时是绝对不允许的。</p></li><li><p><strong>主键约束： 关键字是  PRIMARY KEY</strong></p></li></ul><p>  主键是一行数据的唯一标识，要求非空且唯一。一般我们都会给没张表添加一个主键列用来唯一标识数据。</p><p>  例如：上图表中id就可以作为主键，来标识每条数据。那么这样就要求数据中id的值不能重复，不能为null值。</p><ul><li><p><strong>检查约束： 关键字是  CHECK</strong> </p><p>保证列中的值满足某一条件。</p><p>例如：我们可以给age列添加一个范围，最低年龄可以设置为1，最大年龄就可以设置为300，这样的数据才更合理些。</p><blockquote><p>注意：MySQL不支持检查约束。</p><p>这样是不是就没办法保证年龄在指定的范围内了？从数据库层面不能保证，以后可以在java代码中进行限制，一样也可以实现要求。</p></blockquote></li><li><p><strong>默认约束： 关键字是   DEFAULT</strong></p><p>保存数据时，未指定值则采用默认值。</p><p>例如：我们在给english列添加该约束，指定默认值是0，这样在添加数据时没有指定具体值时就会采用默认给定的0。</p></li><li><p><strong>外键约束： 关键字是  FOREIGN KEY</strong></p><p>外键用来让两个表的数据之间建立链接，保证数据的一致性和完整性。</p><p>外键约束现在可能还不太好理解，后面我们会重点进行讲解。</p></li></ul><h3 id="1-3-非空约束"><a href="#1-3-非空约束" class="headerlink" title="1.3  非空约束"></a>1.3  非空约束</h3><ul><li><p>概念</p><p>非空约束用于保证列中所有数据不能有NULL值</p></li><li><p>语法</p><ul><li><p>添加约束</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建表时添加非空约束</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(</span><br><span class="line">   列名 数据类型 <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">   …</span><br><span class="line">); </span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 建完表后添加非空约束</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 MODIFY 字段名 数据类型 <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure></li><li><p>删除约束</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 MODIFY 字段名 数据类型;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="1-4-唯一约束"><a href="#1-4-唯一约束" class="headerlink" title="1.4  唯一约束"></a>1.4  唯一约束</h3><ul><li><p>概念</p><p>唯一约束用于保证列中所有数据各不相同</p></li><li><p>语法</p><ul><li><p>添加约束</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建表时添加唯一约束</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(</span><br><span class="line">   列名 数据类型 <span class="keyword">UNIQUE</span> [AUTO_INCREMENT],</span><br><span class="line">   <span class="comment">-- AUTO_INCREMENT: 当不指定值时自动增长</span></span><br><span class="line">   …</span><br><span class="line">); </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(</span><br><span class="line">   列名 数据类型,</span><br><span class="line">   …</span><br><span class="line">   [<span class="keyword">CONSTRAINT</span>] [约束名称] <span class="keyword">UNIQUE</span>(列名)</span><br><span class="line">); </span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 建完表后添加唯一约束</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 MODIFY 字段名 数据类型 <span class="keyword">UNIQUE</span>;</span><br></pre></td></tr></table></figure></li><li><p>删除约束</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">DROP</span> INDEX 字段名;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="1-5-主键约束"><a href="#1-5-主键约束" class="headerlink" title="1.5  主键约束"></a>1.5  主键约束</h3><ul><li><p>概念</p><p>主键是一行数据的唯一标识，要求非空且唯一</p><p>一张表只能有一个主键</p></li><li><p>语法</p><ul><li><p>添加约束</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建表时添加主键约束</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(</span><br><span class="line">   列名 数据类型 <span class="keyword">PRIMARY</span> KEY [AUTO_INCREMENT],</span><br><span class="line">   …</span><br><span class="line">); </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(</span><br><span class="line">   列名 数据类型,</span><br><span class="line">   [<span class="keyword">CONSTRAINT</span>] [约束名称] <span class="keyword">PRIMARY</span> KEY(列名)</span><br><span class="line">); </span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 建完表后添加主键约束</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> <span class="keyword">PRIMARY</span> KEY(字段名);</span><br></pre></td></tr></table></figure></li><li><p>删除约束</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">DROP</span> <span class="keyword">PRIMARY</span> KEY;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="1-6-默认约束"><a href="#1-6-默认约束" class="headerlink" title="1.6  默认约束"></a>1.6  默认约束</h3><ul><li><p>概念</p><p>保存数据时，未指定值则采用默认值</p></li><li><p>语法</p><ul><li><p>添加约束</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建表时添加默认约束</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(</span><br><span class="line">   列名 数据类型 <span class="keyword">DEFAULT</span> 默认值,</span><br><span class="line">   …</span><br><span class="line">); </span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 建完表后添加默认约束</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ALTER</span> 列名 <span class="keyword">SET</span> <span class="keyword">DEFAULT</span> 默认值;</span><br></pre></td></tr></table></figure></li><li><p>删除约束</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ALTER</span> 列名 <span class="keyword">DROP</span> <span class="keyword">DEFAULT</span>;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="1-7-约束练习"><a href="#1-7-约束练习" class="headerlink" title="1.7  约束练习"></a>1.7  约束练习</h3><p><strong>根据需求，为表添加合适的约束</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 员工表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp (</span><br><span class="line">id <span class="type">INT</span>,  <span class="comment">-- 员工id，主键且自增长</span></span><br><span class="line">    ename <span class="type">VARCHAR</span>(<span class="number">50</span>), <span class="comment">-- 员工姓名，非空且唯一</span></span><br><span class="line">    joindate <span class="type">DATE</span>,  <span class="comment">-- 入职日期，非空</span></span><br><span class="line">    salary <span class="keyword">DOUBLE</span>(<span class="number">7</span>,<span class="number">2</span>),  <span class="comment">-- 工资，非空</span></span><br><span class="line">    bonus <span class="keyword">DOUBLE</span>(<span class="number">7</span>,<span class="number">2</span>)  <span class="comment">-- 奖金，如果没有将近默认为0</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上面一定给出了具体的要求，我们可以根据要求创建这张表，并为每一列添加对应的约束。建表语句如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 员工表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp (</span><br><span class="line">  id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY, <span class="comment">-- 员工id，主键且自增长</span></span><br><span class="line">  ename <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">UNIQUE</span>, <span class="comment">-- 员工姓名，非空并且唯一</span></span><br><span class="line">  joindate <span class="type">DATE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> , <span class="comment">-- 入职日期，非空</span></span><br><span class="line">  salary <span class="keyword">DOUBLE</span>(<span class="number">7</span>,<span class="number">2</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> , <span class="comment">-- 工资，非空</span></span><br><span class="line">  bonus <span class="keyword">DOUBLE</span>(<span class="number">7</span>,<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="comment">-- 奖金，如果没有奖金默认为0</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>通过上面语句可以创建带有约束的 <code>emp</code> 表，约束能不能发挥作用呢。接下来我们一一进行验证，先添加一条没有问题的数据</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp(id,ename,joindate,salary,bonus) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;1999-11-11&#x27;</span>,<span class="number">8800</span>,<span class="number">5000</span>);</span><br></pre></td></tr></table></figure><ul><li><strong>验证主键约束，非空且唯一</strong></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp(id,ename,joindate,salary,bonus) <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;1999-11-11&#x27;</span>,<span class="number">8800</span>,<span class="number">5000</span>);</span><br></pre></td></tr></table></figure><p>从上面的结果可以看到，字段 <code>id</code> 不能为null。那我们重新添加一条数据，如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp(id,ename,joindate,salary,bonus) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;1999-11-11&#x27;</span>,<span class="number">8800</span>,<span class="number">5000</span>);</span><br></pre></td></tr></table></figure><p>从上面结果可以看到，1这个值重复了。所以主键约束是用来限制数据非空且唯一的。那我们再添加一条符合要求的数据</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp(id,ename,joindate,salary,bonus) <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="string">&#x27;1999-11-11&#x27;</span>,<span class="number">8800</span>,<span class="number">5000</span>);</span><br></pre></td></tr></table></figure><ul><li><strong>验证非空约束</strong></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp(id,ename,joindate,salary,bonus) <span class="keyword">values</span>(<span class="number">3</span>,<span class="keyword">null</span>,<span class="string">&#x27;1999-11-11&#x27;</span>,<span class="number">8800</span>,<span class="number">5000</span>);</span><br></pre></td></tr></table></figure><p>从上面结果可以看到，<code>ename</code> 字段的非空约束生效了。</p><ul><li><strong>验证唯一约束</strong></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp(id,ename,joindate,salary,bonus) <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="string">&#x27;1999-11-11&#x27;</span>,<span class="number">8800</span>,<span class="number">5000</span>);</span><br></pre></td></tr></table></figure><p>从上面结果可以看到，<code>ename</code> 字段的唯一约束生效了。</p><ul><li><strong>验证默认约束</strong></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp(id,ename,joindate,salary) <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">&#x27;王五&#x27;</span>,<span class="string">&#x27;1999-11-11&#x27;</span>,<span class="number">8800</span>);</span><br></pre></td></tr></table></figure><p>执行完上面语句后查询表中数据，可以看到王五这条数据的bonus列就有了默认值0。</p><p>&#x3D;&#x3D;注意：默认约束只有在不给值时才会采用默认值。如果给了null，那值就是null值。&#x3D;&#x3D;</p><p>如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp(id,ename,joindate,salary,bonus) <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">&#x27;赵六&#x27;</span>,<span class="string">&#x27;1999-11-11&#x27;</span>,<span class="number">8800</span>,<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>执行完上面语句后查询表中数据，可以看到赵六这条数据的bonus列的值是null。</p><ul><li><strong>验证自动增长： auto_increment  当列是数字类型 并且唯一约束</strong></li></ul><p>重新创建 <code>emp</code> 表，并给id列添加自动增长</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 员工表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp (</span><br><span class="line">  id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY auto_increment, <span class="comment">-- 员工id，主键且自增长</span></span><br><span class="line">  ename <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">UNIQUE</span>, <span class="comment">-- 员工姓名，非空并且唯一</span></span><br><span class="line">  joindate <span class="type">DATE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> , <span class="comment">-- 入职日期，非空</span></span><br><span class="line">  salary <span class="keyword">DOUBLE</span>(<span class="number">7</span>,<span class="number">2</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> , <span class="comment">-- 工资，非空</span></span><br><span class="line">  bonus <span class="keyword">DOUBLE</span>(<span class="number">7</span>,<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="comment">-- 奖金，如果没有奖金默认为0</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>接下来给emp添加数据，分别验证不给id列添加值以及给id列添加null值，id列的值会不会自动增长：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp(ename,joindate,salary,bonus) <span class="keyword">values</span>(<span class="string">&#x27;赵六&#x27;</span>,<span class="string">&#x27;1999-11-11&#x27;</span>,<span class="number">8800</span>,<span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp(id,ename,joindate,salary,bonus) <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;赵六2&#x27;</span>,<span class="string">&#x27;1999-11-11&#x27;</span>,<span class="number">8800</span>,<span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp(id,ename,joindate,salary,bonus) <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;赵六3&#x27;</span>,<span class="string">&#x27;1999-11-11&#x27;</span>,<span class="number">8800</span>,<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><h3 id="1-8-外键约束"><a href="#1-8-外键约束" class="headerlink" title="1.8  外键约束"></a>1.8  外键约束</h3><h4 id="1-8-1-概述"><a href="#1-8-1-概述" class="headerlink" title="1.8.1  概述"></a>1.8.1  概述</h4><p>外键用来让两个表的数据之间建立链接，保证数据的一致性和完整性。</p><p>如何理解上面的概念呢？有两张表，员工表和部门表，员工表中的dep_id字段是部门表的id字段关联，也就是说1号学生张三属于1号部门研发部的员工。现在我要删除1号部门，就会出现错误的数据（员工表中属于1号部门的数据）。而我们上面说的两张表的关系只是我们认为它们有关系，此时需要通过外键让这两张表产生数据库层面的关系，这样你要删除部门表中的1号部门的数据将无法删除。</p><h4 id="1-8-2-语法"><a href="#1-8-2-语法" class="headerlink" title="1.8.2  语法"></a>1.8.2  语法</h4><ul><li>添加外键约束</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建表时添加外键约束</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(</span><br><span class="line">   列名 数据类型,</span><br><span class="line">   …</span><br><span class="line">   [<span class="keyword">CONSTRAINT</span>] [外键名称] <span class="keyword">FOREIGN</span> KEY(外键列名) <span class="keyword">REFERENCES</span> 主表(主表列名) </span><br><span class="line">); </span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 建完表后添加外键约束</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> 外键名称 <span class="keyword">FOREIGN</span> KEY (外键字段名称) <span class="keyword">REFERENCES</span> 主表名称(主表列名称);</span><br></pre></td></tr></table></figure><ul><li>删除外键约束</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> KEY 外键名称;</span><br></pre></td></tr></table></figure><h4 id="1-8-3-练习"><a href="#1-8-3-练习" class="headerlink" title="1.8.3  练习"></a>1.8.3  练习</h4><p>根据上述语法创建员工表和部门表，并添加上外键约束：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 删除表</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> emp;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> dept;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 部门表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> dept(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">dep_name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">addr <span class="type">varchar</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 员工表 </span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">age <span class="type">int</span>,</span><br><span class="line">dep_id <span class="type">int</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加外键 dep_id,关联 dept 表的id主键</span></span><br><span class="line"><span class="keyword">CONSTRAINT</span> fk_emp_dept <span class="keyword">FOREIGN</span> KEY(dep_id) <span class="keyword">REFERENCES</span> dept(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>添加数据</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 添加 2 个部门</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dept(dep_name,addr) <span class="keyword">values</span></span><br><span class="line">(<span class="string">&#x27;研发部&#x27;</span>,<span class="string">&#x27;广州&#x27;</span>),(<span class="string">&#x27;销售部&#x27;</span>, <span class="string">&#x27;深圳&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加员工,dep_id 表示员工所在的部门</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp (NAME, age, dep_id) <span class="keyword">VALUES</span> </span><br><span class="line">(<span class="string">&#x27;张三&#x27;</span>, <span class="number">20</span>, <span class="number">1</span>),</span><br><span class="line">(<span class="string">&#x27;李四&#x27;</span>, <span class="number">20</span>, <span class="number">1</span>),</span><br><span class="line">(<span class="string">&#x27;王五&#x27;</span>, <span class="number">20</span>, <span class="number">1</span>),</span><br><span class="line">(<span class="string">&#x27;赵六&#x27;</span>, <span class="number">20</span>, <span class="number">2</span>),</span><br><span class="line">(<span class="string">&#x27;孙七&#x27;</span>, <span class="number">22</span>, <span class="number">2</span>),</span><br><span class="line">(<span class="string">&#x27;周八&#x27;</span>, <span class="number">18</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>此时删除 <code>研发部</code> 这条数据，会发现无法删除。</p><p>删除外键</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp <span class="keyword">drop</span> <span class="keyword">FOREIGN</span> key fk_emp_dept;</span><br></pre></td></tr></table></figure><p>重新添加外键</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp <span class="keyword">add</span> <span class="keyword">CONSTRAINT</span> fk_emp_dept <span class="keyword">FOREIGN</span> key(dep_id) <span class="keyword">REFERENCES</span> dept(id);</span><br></pre></td></tr></table></figure><h2 id="2，数据库设计"><a href="#2，数据库设计" class="headerlink" title="2，数据库设计"></a>2，数据库设计</h2><h3 id="2-1-数据库设计简介"><a href="#2-1-数据库设计简介" class="headerlink" title="2.1  数据库设计简介"></a>2.1  数据库设计简介</h3><ul><li><p>软件的研发步骤</p></li><li><p>数据库设计概念</p><ul><li>数据库设计就是根据业务系统的具体需求，结合我们所选用的DBMS，为这个业务系统构造出最优的数据存储模型。</li><li>建立数据库中的&#x3D;&#x3D;表结构&#x3D;&#x3D;以及&#x3D;&#x3D;表与表之间的关联关系&#x3D;&#x3D;的过程。</li><li>有哪些表？表里有哪些字段？表和表之间有什么关系？</li></ul></li><li><p>数据库设计的步骤</p><ul><li><p>需求分析（数据是什么? 数据具有哪些属性? 数据与属性的特点是什么）</p></li><li><p>逻辑分析（通过ER图对数据库进行逻辑建模，不需要考虑我们所选用的数据库管理系统）</p></li><li><p>物理设计（根据数据库自身的特点把逻辑设计转换为物理设计）</p></li><li><p>维护设计（1.对新的需求进行建表；2.表优化）</p></li></ul></li><li><p>表关系</p><ul><li><p>一对一</p><ul><li>如：用户 和 用户详情</li><li>一对一关系多用于表拆分，将一个实体中经常使用的字段放一张表，不经常使用的字段放另一张表，用于提升查询性能</li></ul></li><li><p>一对多</p><ul><li><p>如：部门 和 员工</p></li><li><p>一个部门对应多个员工，一个员工对应一个部门。</p></li></ul></li><li><p>多对多</p><ul><li><p>如：商品 和 订单</p></li><li><p>一个商品对应多个订单，一个订单包含多个商品。</p></li></ul></li></ul></li></ul><h3 id="2-2-表关系-一对多"><a href="#2-2-表关系-一对多" class="headerlink" title="2.2  表关系(一对多)"></a>2.2  表关系(一对多)</h3><ul><li><p>一对多</p><ul><li>如：部门 和 员工</li><li>一个部门对应多个员工，一个员工对应一个部门。</li></ul></li><li><p>实现方式</p><p>&#x3D;&#x3D;在多的一方建立外键，指向一的一方的主键&#x3D;&#x3D;</p></li><li><p>案例</p><p>我们还是以 <code>员工表</code> 和 <code>部门表</code> 举例。</p><p>经过分析发现，员工表属于多的一方，而部门表属于一的一方，此时我们会在员工表中添加一列（dep_id），指向于部门表的主键（id）。</p><p>建表语句如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 删除表</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> tb_emp;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> tb_dept;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 部门表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tb_dept(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">dep_name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">addr <span class="type">varchar</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 员工表 </span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tb_emp(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">age <span class="type">int</span>,</span><br><span class="line">dep_id <span class="type">int</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加外键 dep_id,关联 dept 表的id主键</span></span><br><span class="line"><span class="keyword">CONSTRAINT</span> fk_emp_dept <span class="keyword">FOREIGN</span> KEY(dep_id) <span class="keyword">REFERENCES</span> tb_dept(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-3-表关系-多对多"><a href="#2-3-表关系-多对多" class="headerlink" title="2.3  表关系(多对多)"></a>2.3  表关系(多对多)</h3><ul><li><p>多对多</p><ul><li>如：商品 和 订单</li><li>一个商品对应多个订单，一个订单包含多个商品</li></ul></li><li><p>实现方式</p><p>&#x3D;&#x3D;建立第三张中间表，中间表至少包含两个外键，分别关联两方主键&#x3D;&#x3D;</p></li><li><p>案例</p><p>我们以 <code>订单表</code> 和 <code>商品表</code> 举例。</p><p>经过分析发现，订单表和商品表都属于多的一方，此时需要创建一个中间表，在中间表中添加订单表的外键和商品表的外键指向两张表的主键。</p><p>建表语句如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 删除表</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> tb_order_goods;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> tb_order;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> tb_goods;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 订单表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tb_order(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">payment <span class="keyword">double</span>(<span class="number">10</span>,<span class="number">2</span>),</span><br><span class="line">payment_type TINYINT,</span><br><span class="line">status TINYINT</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 商品表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tb_goods(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">title <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">price <span class="keyword">double</span>(<span class="number">10</span>,<span class="number">2</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 订单商品中间表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tb_order_goods(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">order_id <span class="type">int</span>,</span><br><span class="line">goods_id <span class="type">int</span>,</span><br><span class="line">count <span class="type">int</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 建完表后，添加外键</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tb_order_goods <span class="keyword">add</span> <span class="keyword">CONSTRAINT</span> fk_order_id <span class="keyword">FOREIGN</span> key(order_id) <span class="keyword">REFERENCES</span> tb_order(id);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tb_order_goods <span class="keyword">add</span> <span class="keyword">CONSTRAINT</span> fk_goods_id <span class="keyword">FOREIGN</span> key(goods_id) <span class="keyword">REFERENCES</span> tb_goods(id);</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-4-表关系-一对一"><a href="#2-4-表关系-一对一" class="headerlink" title="2.4  表关系(一对一)"></a>2.4  表关系(一对一)</h3><ul><li><p>一对一</p><ul><li>如：用户 和 用户详情</li><li>一对一关系多用于表拆分，将一个实体中经常使用的字段放一张表，不经常使用的字段放另一张表，用于提升查询性能</li></ul></li><li><p>实现方式</p><p>&#x3D;&#x3D;在任意一方加入外键，关联另一方主键，并且设置外键为唯一(UNIQUE)&#x3D;&#x3D;</p></li><li><p>案例</p><p>我们以 <code>用户表</code> 举例。</p><p>而在真正使用过程中发现 id、photo、nickname、age、gender 字段比较常用，此时就可以将这张表查分成两张表。</p></li></ul><p>​建表语句如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tb_user_desc (</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">city <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">edu <span class="type">varchar</span>(<span class="number">10</span>),</span><br><span class="line">income <span class="type">int</span>,</span><br><span class="line">status <span class="type">char</span>(<span class="number">2</span>),</span><br><span class="line">des <span class="type">varchar</span>(<span class="number">100</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tb_user (</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">photo <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">nickname <span class="type">varchar</span>(<span class="number">50</span>),</span><br><span class="line">age <span class="type">int</span>,</span><br><span class="line">gender <span class="type">char</span>(<span class="number">1</span>),</span><br><span class="line">desc_id <span class="type">int</span> <span class="keyword">unique</span>,</span><br><span class="line"><span class="comment">-- 添加外键</span></span><br><span class="line"><span class="keyword">CONSTRAINT</span> fk_user_desc <span class="keyword">FOREIGN</span> KEY(desc_id) <span class="keyword">REFERENCES</span> tb_user_desc(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="2-5-数据库设计案例"><a href="#2-5-数据库设计案例" class="headerlink" title="2.5  数据库设计案例"></a>2.5  数据库设计案例</h3><p>经过分析，我们分为 <code>专辑表</code>  <code>曲目表</code>  <code>短评表</code>  <code>用户表</code>   4张表。</p><p>一个专辑可以有多个曲目，一个曲目只能属于某一张专辑，所以专辑表和曲目表的关系是&#x3D;&#x3D;一对多&#x3D;&#x3D;。</p><p>一个专辑可以被多个用户进行评论，一个用户可以对多个专辑进行评论，所以专辑表和用户表的关系是 &#x3D;&#x3D;多对多&#x3D;&#x3D;。</p><p>一个用户可以发多个短评，一个短评只能是某一个人发的，所以用户表和短评表的关系是 &#x3D;&#x3D;一对多&#x3D;&#x3D;。</p><h2 id="3，多表查询"><a href="#3，多表查询" class="headerlink" title="3，多表查询"></a>3，多表查询</h2><p>多表查询顾名思义就是从多张表中一次性的查询出我们想要的数据。我们通过具体的sql给他们演示，先准备环境</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> emp;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> dept;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 创建部门表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> dept(</span><br><span class="line">        did <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">        dname <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"># 创建员工表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp (</span><br><span class="line">        id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">        NAME <span class="type">VARCHAR</span>(<span class="number">10</span>),</span><br><span class="line">        gender <span class="type">CHAR</span>(<span class="number">1</span>), <span class="comment">-- 性别</span></span><br><span class="line">        salary <span class="keyword">DOUBLE</span>, <span class="comment">-- 工资</span></span><br><span class="line">        join_date <span class="type">DATE</span>, <span class="comment">-- 入职日期</span></span><br><span class="line">        dep_id <span class="type">INT</span>,</span><br><span class="line">        <span class="keyword">FOREIGN</span> KEY (dep_id) <span class="keyword">REFERENCES</span> dept(did) <span class="comment">-- 外键，关联部门表(部门表的主键)</span></span><br><span class="line">    );</span><br><span class="line"><span class="comment">-- 添加部门数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> dept (dNAME) <span class="keyword">VALUES</span> (<span class="string">&#x27;研发部&#x27;</span>),(<span class="string">&#x27;市场部&#x27;</span>),(<span class="string">&#x27;财务部&#x27;</span>),(<span class="string">&#x27;销售部&#x27;</span>);</span><br><span class="line"><span class="comment">-- 添加员工数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp(NAME,gender,salary,join_date,dep_id) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">&#x27;孙悟空&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="number">7200</span>,<span class="string">&#x27;2013-02-24&#x27;</span>,<span class="number">1</span>),</span><br><span class="line">(<span class="string">&#x27;猪八戒&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="number">3600</span>,<span class="string">&#x27;2010-12-02&#x27;</span>,<span class="number">2</span>),</span><br><span class="line">(<span class="string">&#x27;唐僧&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="number">9000</span>,<span class="string">&#x27;2008-08-08&#x27;</span>,<span class="number">2</span>),</span><br><span class="line">(<span class="string">&#x27;白骨精&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="number">5000</span>,<span class="string">&#x27;2015-10-07&#x27;</span>,<span class="number">3</span>),</span><br><span class="line">(<span class="string">&#x27;蜘蛛精&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="number">4500</span>,<span class="string">&#x27;2011-03-14&#x27;</span>,<span class="number">1</span>),</span><br><span class="line">(<span class="string">&#x27;小白龙&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="number">2500</span>,<span class="string">&#x27;2011-02-14&#x27;</span>,<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>执行下面的多表查询语句</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp , dept;  <span class="comment">-- 从emp和dept表中查询所有的字段数据</span></span><br></pre></td></tr></table></figure><p>从上面的结果我们看到有一些无效的数据，如 <code>孙悟空</code> 这个员工属于1号部门，但也同时关联的2、3、4号部门。所以我们要通过限制员工表中的 <code>dep_id</code> 字段的值和部门表 <code>did</code> 字段的值相等来消除这些无效的数据，</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp , dept <span class="keyword">where</span> emp.dep_id <span class="operator">=</span> dept.did;</span><br></pre></td></tr></table></figure><p>上面语句就是连接查询，那么多表查询都有哪些呢？</p><ul><li><p>连接查询</p><ul><li>内连接查询 ：相当于查询AB交集数据</li><li>外连接查询<ul><li>左外连接查询 ：相当于查询A表所有数据和交集部门数据</li><li>右外连接查询 ： 相当于查询B表所有数据和交集部分数据</li></ul></li></ul></li><li><p>子查询</p></li></ul><h3 id="3-1-内连接查询"><a href="#3-1-内连接查询" class="headerlink" title="3.1  内连接查询"></a>3.1  内连接查询</h3><ul><li>语法</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 隐式内连接</span></span><br><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span>,表<span class="number">2</span>… <span class="keyword">WHERE</span> 条件;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 显示内连接</span></span><br><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span> [<span class="keyword">INNER</span>] <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 条件;</span><br></pre></td></tr></table></figure><blockquote><p>内连接相当于查询 A B 交集数据</p></blockquote><ul><li><p>案例</p><ul><li><p>隐式内连接</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp,</span><br><span class="line">dept</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">emp.dep_id <span class="operator">=</span> dept.did;</span><br></pre></td></tr></table></figure></li><li><p>查询 emp的 name， gender，dept表的dname</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">emp. NAME,</span><br><span class="line">emp.gender,</span><br><span class="line">dept.dname</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp,</span><br><span class="line">dept</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">emp.dep_id <span class="operator">=</span> dept.did;</span><br></pre></td></tr></table></figure><p>上面语句中使用表名指定字段所属有点麻烦，sql也支持给表指别名，上述语句可以改进为</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">t1. NAME,</span><br><span class="line">t1.gender,</span><br><span class="line">t2.dname</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp t1,</span><br><span class="line">dept t2</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">t1.dep_id <span class="operator">=</span> t2.did;</span><br></pre></td></tr></table></figure></li><li><p>显式内连接</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">inner</span> <span class="keyword">join</span> dept <span class="keyword">on</span> emp.dep_id <span class="operator">=</span> dept.did;</span><br><span class="line"><span class="comment">-- 上面语句中的inner可以省略，可以书写为如下语句</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp  <span class="keyword">join</span> dept <span class="keyword">on</span> emp.dep_id <span class="operator">=</span> dept.did;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="3-2-外连接查询"><a href="#3-2-外连接查询" class="headerlink" title="3.2  外连接查询"></a>3.2  外连接查询</h3><ul><li><p>语法</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 左外连接</span></span><br><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span> <span class="keyword">LEFT</span> [<span class="keyword">OUTER</span>] <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 条件;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 右外连接</span></span><br><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span> <span class="keyword">RIGHT</span> [<span class="keyword">OUTER</span>] <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 条件;</span><br></pre></td></tr></table></figure><blockquote><p>左外连接：相当于查询A表所有数据和交集部分数据</p><p>右外连接：相当于查询B表所有数据和交集部分数据</p></blockquote></li><li><p>案例</p><ul><li><p>查询emp表所有数据和对应的部门信息（左外连接）</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">left</span> <span class="keyword">join</span> dept <span class="keyword">on</span> emp.dep_id <span class="operator">=</span> dept.did;</span><br></pre></td></tr></table></figure><p>结果显示查询到了左表（emp）中所有的数据及两张表能关联的数据。</p></li><li><p>查询dept表所有数据和对应的员工信息（右外连接）</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">right</span> <span class="keyword">join</span> dept <span class="keyword">on</span> emp.dep_id <span class="operator">=</span> dept.did;</span><br></pre></td></tr></table></figure><p>结果显示查询到了右表（dept）中所有的数据及两张表能关联的数据。</p><p>要查询出部门表中所有的数据，也可以通过左外连接实现，只需要将两个表的位置进行互换：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> dept <span class="keyword">left</span> <span class="keyword">join</span> emp <span class="keyword">on</span> emp.dep_id <span class="operator">=</span> dept.did;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="3-3-子查询"><a href="#3-3-子查询" class="headerlink" title="3.3  子查询"></a>3.3  子查询</h3><ul><li><p>概念</p><p>&#x3D;&#x3D;查询中嵌套查询，称嵌套查询为子查询。&#x3D;&#x3D;</p><p>什么是查询中嵌套查询呢？我们通过一个例子来看：</p><p><strong>需求：查询工资高于猪八戒的员工信息。</strong></p><p>来实现这个需求，我们就可以通过二步实现，第一步：先查询出来 猪八戒的工资</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> salary <span class="keyword">from</span> emp <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;猪八戒&#x27;</span></span><br></pre></td></tr></table></figure><p> 第二步：查询工资高于猪八戒的员工信息</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> salary <span class="operator">&gt;</span> <span class="number">3600</span>;</span><br></pre></td></tr></table></figure><p>第二步中的3600可以通过第一步的sql查询出来，所以将3600用第一步的sql语句进行替换</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> salary <span class="operator">&gt;</span> (<span class="keyword">select</span> salary <span class="keyword">from</span> emp <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;猪八戒&#x27;</span>);</span><br></pre></td></tr></table></figure><p>这就是查询语句中嵌套查询语句。</p></li><li><p>子查询根据查询结果不同，作用不同</p><ul><li>子查询语句结果是单行单列，子查询语句作为条件值，使用 &#x3D;  !&#x3D;  &gt;  &lt;  等进行条件判断</li><li>子查询语句结果是多行单列，子查询语句作为条件值，使用 in 等关键字进行条件判断</li><li>子查询语句结果是多行多列，子查询语句作为虚拟表</li></ul></li><li><p>案例</p><ul><li><p>查询 ‘财务部’ 和 ‘市场部’ 所有的员工信息</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询 &#x27;财务部&#x27; 或者 &#x27;市场部&#x27; 所有的员工的部门did</span></span><br><span class="line"><span class="keyword">select</span> did <span class="keyword">from</span> dept <span class="keyword">where</span> dname <span class="operator">=</span> <span class="string">&#x27;财务部&#x27;</span> <span class="keyword">or</span> dname <span class="operator">=</span> <span class="string">&#x27;市场部&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> dep_id <span class="keyword">in</span> (<span class="keyword">select</span> did <span class="keyword">from</span> dept <span class="keyword">where</span> dname <span class="operator">=</span> <span class="string">&#x27;财务部&#x27;</span> <span class="keyword">or</span> dname <span class="operator">=</span> <span class="string">&#x27;市场部&#x27;</span>);</span><br></pre></td></tr></table></figure></li><li><p>查询入职日期是 ‘2011-11-11’ 之后的员工信息和部门信息</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询入职日期是 &#x27;2011-11-11&#x27; 之后的员工信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> join_date <span class="operator">&gt;</span> <span class="string">&#x27;2011-11-11&#x27;</span> ;</span><br><span class="line"><span class="comment">-- 将上面语句的结果作为虚拟表和dept表进行内连接查询</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> join_date <span class="operator">&gt;</span> <span class="string">&#x27;2011-11-11&#x27;</span> ) t1, dept <span class="keyword">where</span> t1.dep_id <span class="operator">=</span> dept.did;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="3-4-案例"><a href="#3-4-案例" class="headerlink" title="3.4  案例"></a>3.4  案例</h3><ul><li>环境准备：</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> emp;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> dept;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> job;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> salarygrade;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 部门表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> dept (</span><br><span class="line">  did <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY <span class="keyword">PRIMARY</span> KEY, <span class="comment">-- 部门id</span></span><br><span class="line">  dname <span class="type">VARCHAR</span>(<span class="number">50</span>), <span class="comment">-- 部门名称</span></span><br><span class="line">  loc <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="comment">-- 部门所在地</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 职务表，职务名称，职务描述</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> job (</span><br><span class="line">  id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">  jname <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">  description <span class="type">VARCHAR</span>(<span class="number">50</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 员工表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp (</span><br><span class="line">  id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY, <span class="comment">-- 员工id</span></span><br><span class="line">  ename <span class="type">VARCHAR</span>(<span class="number">50</span>), <span class="comment">-- 员工姓名</span></span><br><span class="line">  job_id <span class="type">INT</span>, <span class="comment">-- 职务id</span></span><br><span class="line">  mgr <span class="type">INT</span> , <span class="comment">-- 上级领导</span></span><br><span class="line">  joindate <span class="type">DATE</span>, <span class="comment">-- 入职日期</span></span><br><span class="line">  salary <span class="type">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>), <span class="comment">-- 工资</span></span><br><span class="line">  bonus <span class="type">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>), <span class="comment">-- 奖金</span></span><br><span class="line">  dept_id <span class="type">INT</span>, <span class="comment">-- 所在部门编号</span></span><br><span class="line">  <span class="keyword">CONSTRAINT</span> emp_jobid_ref_job_id_fk <span class="keyword">FOREIGN</span> KEY (job_id) <span class="keyword">REFERENCES</span> job (id),</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> emp_deptid_ref_dept_id_fk <span class="keyword">FOREIGN</span> KEY (dept_id) <span class="keyword">REFERENCES</span> dept (id)</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 工资等级表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> salarygrade (</span><br><span class="line">  grade <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,   <span class="comment">-- 级别</span></span><br><span class="line">  losalary <span class="type">INT</span>,  <span class="comment">-- 最低工资</span></span><br><span class="line">  hisalary <span class="type">INT</span> <span class="comment">-- 最高工资</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加4个部门</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> dept(did,dname,loc) <span class="keyword">VALUES</span> </span><br><span class="line">(<span class="number">10</span>,<span class="string">&#x27;教研部&#x27;</span>,<span class="string">&#x27;北京&#x27;</span>),</span><br><span class="line">(<span class="number">20</span>,<span class="string">&#x27;学工部&#x27;</span>,<span class="string">&#x27;上海&#x27;</span>),</span><br><span class="line">(<span class="number">30</span>,<span class="string">&#x27;销售部&#x27;</span>,<span class="string">&#x27;广州&#x27;</span>),</span><br><span class="line">(<span class="number">40</span>,<span class="string">&#x27;财务部&#x27;</span>,<span class="string">&#x27;深圳&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加4个职务</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> job (id, jname, description) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">1</span>, <span class="string">&#x27;董事长&#x27;</span>, <span class="string">&#x27;管理整个公司，接单&#x27;</span>),</span><br><span class="line">(<span class="number">2</span>, <span class="string">&#x27;经理&#x27;</span>, <span class="string">&#x27;管理部门员工&#x27;</span>),</span><br><span class="line">(<span class="number">3</span>, <span class="string">&#x27;销售员&#x27;</span>, <span class="string">&#x27;向客人推销产品&#x27;</span>),</span><br><span class="line">(<span class="number">4</span>, <span class="string">&#x27;文员&#x27;</span>, <span class="string">&#x27;使用办公软件&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加员工</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp(id,ename,job_id,mgr,joindate,salary,bonus,dept_id) <span class="keyword">VALUES</span> </span><br><span class="line">(<span class="number">1001</span>,<span class="string">&#x27;孙悟空&#x27;</span>,<span class="number">4</span>,<span class="number">1004</span>,<span class="string">&#x27;2000-12-17&#x27;</span>,<span class="string">&#x27;8000.00&#x27;</span>,<span class="keyword">NULL</span>,<span class="number">20</span>),</span><br><span class="line">(<span class="number">1002</span>,<span class="string">&#x27;卢俊义&#x27;</span>,<span class="number">3</span>,<span class="number">1006</span>,<span class="string">&#x27;2001-02-20&#x27;</span>,<span class="string">&#x27;16000.00&#x27;</span>,<span class="string">&#x27;3000.00&#x27;</span>,<span class="number">30</span>),</span><br><span class="line">(<span class="number">1003</span>,<span class="string">&#x27;林冲&#x27;</span>,<span class="number">3</span>,<span class="number">1006</span>,<span class="string">&#x27;2001-02-22&#x27;</span>,<span class="string">&#x27;12500.00&#x27;</span>,<span class="string">&#x27;5000.00&#x27;</span>,<span class="number">30</span>),</span><br><span class="line">(<span class="number">1004</span>,<span class="string">&#x27;唐僧&#x27;</span>,<span class="number">2</span>,<span class="number">1009</span>,<span class="string">&#x27;2001-04-02&#x27;</span>,<span class="string">&#x27;29750.00&#x27;</span>,<span class="keyword">NULL</span>,<span class="number">20</span>),</span><br><span class="line">(<span class="number">1005</span>,<span class="string">&#x27;李逵&#x27;</span>,<span class="number">4</span>,<span class="number">1006</span>,<span class="string">&#x27;2001-09-28&#x27;</span>,<span class="string">&#x27;12500.00&#x27;</span>,<span class="string">&#x27;14000.00&#x27;</span>,<span class="number">30</span>),</span><br><span class="line">(<span class="number">1006</span>,<span class="string">&#x27;宋江&#x27;</span>,<span class="number">2</span>,<span class="number">1009</span>,<span class="string">&#x27;2001-05-01&#x27;</span>,<span class="string">&#x27;28500.00&#x27;</span>,<span class="keyword">NULL</span>,<span class="number">30</span>),</span><br><span class="line">(<span class="number">1007</span>,<span class="string">&#x27;刘备&#x27;</span>,<span class="number">2</span>,<span class="number">1009</span>,<span class="string">&#x27;2001-09-01&#x27;</span>,<span class="string">&#x27;24500.00&#x27;</span>,<span class="keyword">NULL</span>,<span class="number">10</span>),</span><br><span class="line">(<span class="number">1008</span>,<span class="string">&#x27;猪八戒&#x27;</span>,<span class="number">4</span>,<span class="number">1004</span>,<span class="string">&#x27;2007-04-19&#x27;</span>,<span class="string">&#x27;30000.00&#x27;</span>,<span class="keyword">NULL</span>,<span class="number">20</span>),</span><br><span class="line">(<span class="number">1009</span>,<span class="string">&#x27;罗贯中&#x27;</span>,<span class="number">1</span>,<span class="keyword">NULL</span>,<span class="string">&#x27;2001-11-17&#x27;</span>,<span class="string">&#x27;50000.00&#x27;</span>,<span class="keyword">NULL</span>,<span class="number">10</span>),</span><br><span class="line">(<span class="number">1010</span>,<span class="string">&#x27;吴用&#x27;</span>,<span class="number">3</span>,<span class="number">1006</span>,<span class="string">&#x27;2001-09-08&#x27;</span>,<span class="string">&#x27;15000.00&#x27;</span>,<span class="string">&#x27;0.00&#x27;</span>,<span class="number">30</span>),</span><br><span class="line">(<span class="number">1011</span>,<span class="string">&#x27;沙僧&#x27;</span>,<span class="number">4</span>,<span class="number">1004</span>,<span class="string">&#x27;2007-05-23&#x27;</span>,<span class="string">&#x27;11000.00&#x27;</span>,<span class="keyword">NULL</span>,<span class="number">20</span>),</span><br><span class="line">(<span class="number">1012</span>,<span class="string">&#x27;李逵&#x27;</span>,<span class="number">4</span>,<span class="number">1006</span>,<span class="string">&#x27;2001-12-03&#x27;</span>,<span class="string">&#x27;9500.00&#x27;</span>,<span class="keyword">NULL</span>,<span class="number">30</span>),</span><br><span class="line">(<span class="number">1013</span>,<span class="string">&#x27;小白龙&#x27;</span>,<span class="number">4</span>,<span class="number">1004</span>,<span class="string">&#x27;2001-12-03&#x27;</span>,<span class="string">&#x27;30000.00&#x27;</span>,<span class="keyword">NULL</span>,<span class="number">20</span>),</span><br><span class="line">(<span class="number">1014</span>,<span class="string">&#x27;关羽&#x27;</span>,<span class="number">4</span>,<span class="number">1007</span>,<span class="string">&#x27;2002-01-23&#x27;</span>,<span class="string">&#x27;13000.00&#x27;</span>,<span class="keyword">NULL</span>,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加5个工资等级</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> salarygrade(grade,losalary,hisalary) <span class="keyword">VALUES</span> </span><br><span class="line">(<span class="number">1</span>,<span class="number">7000</span>,<span class="number">12000</span>),</span><br><span class="line">(<span class="number">2</span>,<span class="number">12010</span>,<span class="number">14000</span>),</span><br><span class="line">(<span class="number">3</span>,<span class="number">14010</span>,<span class="number">20000</span>),</span><br><span class="line">(<span class="number">4</span>,<span class="number">20010</span>,<span class="number">30000</span>),</span><br><span class="line">(<span class="number">5</span>,<span class="number">30010</span>,<span class="number">99990</span>);</span><br></pre></td></tr></table></figure><ul><li><p>需求</p><ol><li><p>查询所有员工信息。查询员工编号，员工姓名，工资，职务名称，职务描述</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">分析：</span></span><br><span class="line"><span class="comment">1. 员工编号，员工姓名，工资 信息在emp 员工表中</span></span><br><span class="line"><span class="comment">2. 职务名称，职务描述 信息在 job 职务表中</span></span><br><span class="line"><span class="comment">3. job 职务表 和 emp 员工表 是 一对多的关系 emp.job_id = job.id</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">-- 方式一 ：隐式内连接</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">emp.id,</span><br><span class="line">emp.ename,</span><br><span class="line">emp.salary,</span><br><span class="line">job.jname,</span><br><span class="line">job.description</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp,</span><br><span class="line">job</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">emp.job_id <span class="operator">=</span> job.id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 方式二 ：显式内连接</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">emp.id,</span><br><span class="line">emp.ename,</span><br><span class="line">emp.salary,</span><br><span class="line">job.jname,</span><br><span class="line">job.description</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> job <span class="keyword">ON</span> emp.job_id <span class="operator">=</span> job.id;</span><br></pre></td></tr></table></figure></li><li><p>查询员工编号，员工姓名，工资，职务名称，职务描述，部门名称，部门位置</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">分析：</span></span><br><span class="line"><span class="comment">1. 员工编号，员工姓名，工资 信息在emp 员工表中</span></span><br><span class="line"><span class="comment">2. 职务名称，职务描述 信息在 job 职务表中</span></span><br><span class="line"><span class="comment">3. job 职务表 和 emp 员工表 是 一对多的关系 emp.job_id = job.id</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">4. 部门名称，部门位置 来自于 部门表 dept</span></span><br><span class="line"><span class="comment">5. dept 和 emp 一对多关系 dept.id = emp.dept_id</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 方式一 ：隐式内连接</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">emp.id,</span><br><span class="line">emp.ename,</span><br><span class="line">emp.salary,</span><br><span class="line">job.jname,</span><br><span class="line">job.description,</span><br><span class="line">dept.dname,</span><br><span class="line">dept.loc</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp,</span><br><span class="line">job,</span><br><span class="line">dept</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">emp.job_id <span class="operator">=</span> job.id</span><br><span class="line"><span class="keyword">and</span> dept.id <span class="operator">=</span> emp.dept_id</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 方式二 ：显式内连接</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">emp.id,</span><br><span class="line">emp.ename,</span><br><span class="line">emp.salary,</span><br><span class="line">job.jname,</span><br><span class="line">job.description,</span><br><span class="line">dept.dname,</span><br><span class="line">dept.loc</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> job <span class="keyword">ON</span> emp.job_id <span class="operator">=</span> job.id</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> dept <span class="keyword">ON</span> dept.id <span class="operator">=</span> emp.dept_id</span><br></pre></td></tr></table></figure></li><li><p>查询员工姓名，工资，工资等级</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">分析：</span></span><br><span class="line"><span class="comment">1. 员工姓名，工资 信息在emp 员工表中</span></span><br><span class="line"><span class="comment">2. 工资等级 信息在 salarygrade 工资等级表中</span></span><br><span class="line"><span class="comment">3. emp.salary &gt;= salarygrade.losalary  and emp.salary &lt;= salarygrade.hisalary</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">emp.ename,</span><br><span class="line">emp.salary,</span><br><span class="line">t2.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp,</span><br><span class="line">salarygrade t2</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">emp.salary <span class="operator">&gt;=</span> t2.losalary</span><br><span class="line"><span class="keyword">AND</span> emp.salary <span class="operator">&lt;=</span> t2.hisalary</span><br></pre></td></tr></table></figure></li><li><p>查询员工姓名，工资，职务名称，职务描述，部门名称，部门位置，工资等级</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">分析：</span></span><br><span class="line"><span class="comment">1. 员工编号，员工姓名，工资 信息在emp 员工表中</span></span><br><span class="line"><span class="comment">2. 职务名称，职务描述 信息在 job 职务表中</span></span><br><span class="line"><span class="comment">3. job 职务表 和 emp 员工表 是 一对多的关系 emp.job_id = job.id</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">4. 部门名称，部门位置 来自于 部门表 dept</span></span><br><span class="line"><span class="comment">5. dept 和 emp 一对多关系 dept.id = emp.dept_id</span></span><br><span class="line"><span class="comment">6. 工资等级 信息在 salarygrade 工资等级表中</span></span><br><span class="line"><span class="comment">7. emp.salary &gt;= salarygrade.losalary  and emp.salary &lt;= salarygrade.hisalary</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">emp.id,</span><br><span class="line">emp.ename,</span><br><span class="line">emp.salary,</span><br><span class="line">job.jname,</span><br><span class="line">job.description,</span><br><span class="line">dept.dname,</span><br><span class="line">dept.loc,</span><br><span class="line">t2.grade</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> job <span class="keyword">ON</span> emp.job_id <span class="operator">=</span> job.id</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> dept <span class="keyword">ON</span> dept.id <span class="operator">=</span> emp.dept_id</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> salarygrade t2 <span class="keyword">ON</span> emp.salary <span class="keyword">BETWEEN</span> t2.losalary <span class="keyword">and</span> t2.hisalary;</span><br></pre></td></tr></table></figure></li><li><p>查询出部门编号、部门名称、部门位置、部门人数</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">分析：</span></span><br><span class="line"><span class="comment">1. 部门编号、部门名称、部门位置 来自于部门 dept 表</span></span><br><span class="line"><span class="comment">2. 部门人数: 在emp表中 按照dept_id 进行分组，然后count(*)统计数量</span></span><br><span class="line"><span class="comment">3. 使用子查询，让部门表和分组后的表进行内连接</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">-- 根据部门id分组查询每一个部门id和员工数</span></span><br><span class="line"><span class="keyword">select</span> dept_id, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> dept_id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">dept.id,</span><br><span class="line">dept.dname,</span><br><span class="line">dept.loc,</span><br><span class="line">t1.count</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">dept,</span><br><span class="line">(</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">dept_id,</span><br><span class="line"><span class="built_in">count</span>(<span class="operator">*</span>) count</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">dept_id</span><br><span class="line">) t1</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">dept.id <span class="operator">=</span> t1.dept_id</span><br></pre></td></tr></table></figure></li></ol></li></ul><h2 id="4，事务"><a href="#4，事务" class="headerlink" title="4，事务"></a>4，事务</h2><h3 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1  概述"></a>4.1  概述</h3><blockquote><p>数据库的事务（Transaction）是一种机制、一个操作序列，包含了&#x3D;&#x3D;一组数据库操作命令&#x3D;&#x3D;。</p><p>事务把所有的命令作为一个整体一起向系统提交或撤销操作请求，即这一组数据库命令&#x3D;&#x3D;要么同时成功，要么同时失败&#x3D;&#x3D;。</p><p>事务是一个不可分割的工作逻辑单元。</p></blockquote><p>假设张三和李四账户中各有100块钱，现李四需要转换500块钱给张三，具体的转账操作为</p><ul><li>第一步：查询李四账户余额</li><li>第二步：从李四账户金额 -500</li><li>第三步：给张三账户金额 +500</li></ul><p>现在假设在转账过程中第二步完成后出现了异常第三步没有执行，就会造成李四账户金额少了500，而张三金额并没有多500；这样的系统是有问题的。如果解决呢？使用事务可以解决上述问题。如果出现了异常回滚事务，三步正常执行就提交事务，这样就可以完美解决问题。</p><h3 id="4-2-语法"><a href="#4-2-语法" class="headerlink" title="4.2  语法"></a>4.2  语法</h3><ul><li><p>开启事务</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line">或者  </span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br></pre></td></tr></table></figure></li><li><p>提交事务</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure></li><li><p>回滚事务</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">rollback</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-3-代码验证"><a href="#4-3-代码验证" class="headerlink" title="4.3  代码验证"></a>4.3  代码验证</h3><ul><li><p>环境准备</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> account;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建账户表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> account(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">PRIMARY</span> KEY auto_increment,</span><br><span class="line">name <span class="type">varchar</span>(<span class="number">10</span>),</span><br><span class="line">money <span class="keyword">double</span>(<span class="number">10</span>,<span class="number">2</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> account(name,money) <span class="keyword">values</span>(<span class="string">&#x27;张三&#x27;</span>,<span class="number">1000</span>),(<span class="string">&#x27;李四&#x27;</span>,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure></li><li><p>不加事务演示问题</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 转账操作</span></span><br><span class="line"><span class="comment">-- 1. 查询李四账户金额是否大于500</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 李四账户 -500</span></span><br><span class="line"><span class="keyword">UPDATE</span> account <span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">-</span> <span class="number">500</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;李四&#x27;</span>;</span><br><span class="line"></span><br><span class="line">出现异常了...  <span class="comment">-- 此处不是注释，在整体执行时会出问题，后面的sql则不执行</span></span><br><span class="line"><span class="comment">-- 3. 张三账户 +500</span></span><br><span class="line"><span class="keyword">UPDATE</span> account <span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">+</span> <span class="number">500</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span>;</span><br></pre></td></tr></table></figure><p>整体执行结果肯定会出问题，我们查询账户表中数据，发现李四账户少了500。</p></li><li><p>添加事务sql如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 开启事务</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="comment">-- 转账操作</span></span><br><span class="line"><span class="comment">-- 1. 查询李四账户金额是否大于500</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 李四账户 -500</span></span><br><span class="line"><span class="keyword">UPDATE</span> account <span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">-</span> <span class="number">500</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;李四&#x27;</span>;</span><br><span class="line"></span><br><span class="line">出现异常了...  <span class="comment">-- 此处不是注释，在整体执行时会出问题，后面的sql则不执行</span></span><br><span class="line"><span class="comment">-- 3. 张三账户 +500</span></span><br><span class="line"><span class="keyword">UPDATE</span> account <span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">+</span> <span class="number">500</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 提交事务</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 回滚事务</span></span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure><p>上面sql中的执行成功进选择执行提交事务，而出现问题则执行回滚事务的语句。以后我们肯定不可能这样操作，而是在java中进行操作，在java中可以抓取异常，没出现异常提交事务，出现异常回滚事务。</p></li></ul><h3 id="4-4-事务的四大特征"><a href="#4-4-事务的四大特征" class="headerlink" title="4.4  事务的四大特征"></a>4.4  事务的四大特征</h3><ul><li><p>原子性（Atomicity）: 事务是不可分割的最小操作单位，要么同时成功，要么同时失败</p></li><li><p>一致性（Consistency） :事务完成时，必须使所有的数据都保持一致状态</p></li><li><p>隔离性（Isolation） :多个事务之间，操作的可见性</p></li><li><p>持久性（Durability） :事务一旦提交或回滚，它对数据库中的数据的改变就是永久的</p></li></ul><blockquote><p>&#x3D;&#x3D;说明：&#x3D;&#x3D;</p><p>mysql中事务是自动提交的。</p><p>也就是说我们不添加事务执行sql语句，语句执行完毕会自动的提交事务。</p><p>可以通过下面语句查询默认提交方式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SELECT @<span class="meta">@autocommit</span>;</span><br></pre></td></tr></table></figure><p>查询到的结果是1 则表示自动提交，结果是0表示手动提交。当然也可以通过下面语句修改提交方式</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> @<span class="variable">@autocommit</span> <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础</title>
      <link href="/post/bce68613.html"/>
      <url>/post/bce68613.html</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL基础"><a href="#MySQL基础" class="headerlink" title="MySQL基础"></a>MySQL基础</h2><p><strong>今日目标：</strong></p><blockquote><ul><li>完成MySQL的安装及登陆基本操作</li><li>能通过SQL对数据库进行CRUD</li><li>能通过SQL对表进行CRUD</li><li>能通过SQL对数据进行CRUD</li></ul></blockquote><h2 id="1、数据库相关概念"><a href="#1、数据库相关概念" class="headerlink" title="1、数据库相关概念"></a>1、数据库相关概念</h2><p>以前我们做系统，数据持久化的存储采用的是文件存储。存储到文件中可以达到系统关闭数据不会丢失的效果，当然文件存储也有它的弊端。</p><p>假设在文件中存储以下的数据：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">姓名年龄性别住址</span><br><span class="line">张三23男北京西三旗</span><br><span class="line">李四24女北京西二旗</span><br><span class="line">王五25男西安软件新城</span><br></pre></td></tr></table></figure><p>现要修改李四这条数据的性别数据改为男，我们现学习的IO技术可以通过将所有的数据读取到内存中，然后进行修改再存到该文件中。通过这种方式操作存在很大问题，现在只有三条数据，如果文件中存储1T的数据，那么就会发现内存根本就存储不了。</p><p>现需要既能持久化存储数据，也要能避免上述问题的技术使用在我们的系统中。数据库就是这样的一门技术。</p><h3 id="1-1-数据库"><a href="#1-1-数据库" class="headerlink" title="1.1  数据库"></a>1.1  数据库</h3><ul><li><p>&#x3D;&#x3D;存储和管理数据的仓库，数据是有组织的进行存储。&#x3D;&#x3D;</p></li><li><p>数据库英文名是 DataBase，简称DB。</p></li></ul><p>数据库就是将数据存储在硬盘上，可以达到持久化存储的效果。那又是如何解决上述问题的？使用数据库管理系统。</p><h3 id="1-2-数据库管理系统"><a href="#1-2-数据库管理系统" class="headerlink" title="1.2  数据库管理系统"></a>1.2  数据库管理系统</h3><ul><li>&#x3D;&#x3D;管理数据库的大型软件&#x3D;&#x3D;</li><li>英文：DataBase Management System，简称 DBMS</li></ul><p>在电脑上安装了数据库管理系统后，就可以通过数据库管理系统创建数据库来存储数据，也可以通过该系统对数据库中的数据进行数据的增删改查相关的操作。我们平时说的MySQL数据库其实是MySQL数据库管理系统。</p><p>通过上面的描述，大家应该已经知道了 <code>数据库管理系统</code> 和 <code>数据库</code> 的关系。那么有有哪些常见的数据库管理系统呢？</p><h3 id="1-3-常见的数据库管理系统"><a href="#1-3-常见的数据库管理系统" class="headerlink" title="1.3  常见的数据库管理系统"></a>1.3  常见的数据库管理系统</h3><p>数据库管理系统介绍：</p><ul><li>Oracle：收费的大型数据库，Oracle 公司的产品</li><li>&#x3D;&#x3D;MySQL&#x3D;&#x3D;： 开源免费的中小型数据库。后来 Sun公司收购了 MySQL，而 Sun 公司又被 Oracle 收购</li><li>SQL Server：MicroSoft 公司收费的中型的数据库。C#、.net 等语言常使用</li><li>PostgreSQL：开源免费中小型的数据库</li><li>DB2：IBM 公司的大型收费数据库产品</li><li>SQLite：嵌入式的微型数据库。如：作为 Android 内置数据库</li><li>MariaDB：开源免费中小型的数据库</li></ul><h3 id="1-4-SQL"><a href="#1-4-SQL" class="headerlink" title="1.4  SQL"></a>1.4  SQL</h3><ul><li>英文：Structured Query Language，简称 SQL，结构化查询语言</li><li>操作关系型数据库的编程语言</li><li>定义操作所有关系型数据库的统一标准，可以使用SQL操作所有的关系型数据库管理系统，以后工作中如果使用到了其他的数据库管理系统，也同样的使用SQL来操作。</li></ul><h2 id="2、MySQL"><a href="#2、MySQL" class="headerlink" title="2、MySQL"></a>2、MySQL</h2><h3 id="2-1-MySQL安装"><a href="#2-1-MySQL安装" class="headerlink" title="2.1  MySQL安装"></a>2.1  MySQL安装</h3><blockquote><p><strong>安装环境:Win10 64位</strong><br><strong>软件版本:MySQL 5.7.24 解压版</strong></p></blockquote><h4 id="2-1-1-下载"><a href="#2-1-1-下载" class="headerlink" title="2.1.1  下载"></a>2.1.1  下载</h4><p><a href="https://downloads.mysql.com/archives/community/">https://downloads.mysql.com/archives/community/</a></p><p>选择选择和自己<strong>系统位数</strong>相对应的版本点击右边的<code>Download</code>，此时会进到另一个页面，同样在接近页面底部的地方找到如下图所示的位置：</p><img src="https://img2018.cnblogs.com/blog/1556823/201812/1556823-20181220194715840-436169502.png" alt="img" style="zoom:80%;" /><p>不用理会上面的登录和注册按钮，直接点击 <code>No thanks, just start my download.</code> 就可以下载。</p><h4 id="2-1-2-安装-解压"><a href="#2-1-2-安装-解压" class="headerlink" title="2.1.2  安装(解压)"></a>2.1.2  安装(解压)</h4><p>下载完成后我们得到的是一个压缩包，将其解压，我们就可以得到MySQL 5.7.24的软件本体了(就是一个文件夹)，我们可以把它放在你想安装的位置。</p><h3 id="2-2-MySQL卸载"><a href="#2-2-MySQL卸载" class="headerlink" title="2.2  MySQL卸载"></a>2.2  MySQL卸载</h3><p>如果你想卸载MySQL，也很简单。</p><p>右键开始菜单，选择<code>命令提示符(管理员)</code>，打开黑框。</p><ol><li>敲入<code>net stop mysql</code>，回车。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net stop mysql</span><br></pre></td></tr></table></figure><ol start="2"><li>再敲入<code>mysqld -remove mysql</code>，回车。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysqld -remove mysql</span><br></pre></td></tr></table></figure><ol start="3"><li>最后删除MySQL目录及相关的环境变量。</li></ol><p><strong>至此，MySQL卸载完成！</strong></p><h3 id="2-3-MySQL配置"><a href="#2-3-MySQL配置" class="headerlink" title="2.3  MySQL配置"></a>2.3  MySQL配置</h3><h4 id="2-3-1-添加环境变量"><a href="#2-3-1-添加环境变量" class="headerlink" title="2.3.1  添加环境变量"></a>2.3.1  添加环境变量</h4><blockquote><p>环境变量里面有很多选项，这里我们只用到<code>Path</code>这个参数。为什么在初始化的开始要添加环境变量呢？<br>在黑框(即CMD)中输入一个可执行程序的名字，Windows会先在环境变量中的<code>Path</code>所指的路径中寻找一遍，如果找到了就直接执行，没找到就在当前工作目录找，如果还没找到，就报错。我们添加环境变量的目的就是能够在任意一个黑框直接调用MySQL中的相关程序而不用总是修改工作目录，大大简化了操作。</p></blockquote><p><strong>如何验证是否添加成功？</strong></p><p>右键开始菜单(就是屏幕左下角)，选择<code>命令提示符(管理员)</code>，打开黑框，敲入<code>mysql</code>，回车。<br>如果提示<code>Can&#39;t connect to MySQL server on &#39;localhost&#39;</code>则证明添加成功；<br>如果提示<code>mysql不是内部或外部命令，也不是可运行的程序或批处理文件</code>则表示添加添加失败，请重新检查步骤并重试。</p><h4 id="2-3-2-新建配置文件"><a href="#2-3-2-新建配置文件" class="headerlink" title="2.3.2  新建配置文件"></a>2.3.2  新建配置文件</h4><p>新建一个文本文件，内容如下：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">[mysql]</span></span><br><span class="line"><span class="attr">default-character-set</span>=<span class="string">utf8</span></span><br><span class="line"></span><br><span class="line"><span class="attr">[mysqld]</span></span><br><span class="line"><span class="attr">character-set-server</span>=<span class="string">utf8</span></span><br><span class="line"><span class="attr">default-storage-engine</span>=<span class="string">INNODB</span></span><br><span class="line"><span class="attr">sql_mode</span>=<span class="string">STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION</span></span><br></pre></td></tr></table></figure><p>把上面的文本文件另存为，在保存类型里选<code>所有文件 (*.*)</code>，文件名叫<code>my.ini</code>，存放的路径为MySQL的<code>根目录</code>(例如我的是<code>D:\software\mysql-5.7.24-winx64</code>,根据自己的MySQL目录位置修改)。</p><p>上面代码意思就是配置数据库的默认编码集为utf-8和默认存储引擎为INNODB。</p><h4 id="2-3-3-初始化MySQL"><a href="#2-3-3-初始化MySQL" class="headerlink" title="2.3.3  初始化MySQL"></a>2.3.3  初始化MySQL</h4><p>在刚才的黑框中敲入<code>mysqld --initialize-insecure</code>，回车，稍微等待一会，如果出现没有出现报错信息(如下图)则证明data目录初始化没有问题，此时再查看MySQL目录下已经有data目录生成。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysqld --initialize-insecure</span><br></pre></td></tr></table></figure><p>tips：如果出现如下错误，可能是由于权限不足导致的，去<code>C:\Windows\System32</code> 下以管理员方式运行 cmd.exe</p><h4 id="2-3-4-注册MySQL服务"><a href="#2-3-4-注册MySQL服务" class="headerlink" title="2.3.4  注册MySQL服务"></a>2.3.4  注册MySQL服务</h4><p>在黑框里敲入<code>mysqld -install</code>，回车。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysqld -install</span><br></pre></td></tr></table></figure><p>现在计算机上已经安装好了MySQL服务了。</p><p>MySQL服务器</p><h4 id="2-3-5-启动MySQL服务"><a href="#2-3-5-启动MySQL服务" class="headerlink" title="2.3.5  启动MySQL服务"></a>2.3.5  启动MySQL服务</h4><p>在黑框里敲入<code>net start mysql</code>，回车。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">net start mysql  <span class="comment">// 启动mysql服务</span></span><br><span class="line">    </span><br><span class="line">net stop mysql  <span class="comment">// 停止mysql服务</span></span><br></pre></td></tr></table></figure><h4 id="2-3-6-修改默认账户密码"><a href="#2-3-6-修改默认账户密码" class="headerlink" title="2.3.6  修改默认账户密码"></a>2.3.6  修改默认账户密码</h4><p>在黑框里敲入<code>mysqladmin -u root password 1234</code>，这里的<code>1234</code>就是指默认管理员(即root账户)的密码，可以自行修改成你喜欢的。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysqladmin -u root password 1234</span><br></pre></td></tr></table></figure><p><strong>至此，MySQL 5.7 解压版安装完毕！</strong></p><h3 id="2-4-MySQL登陆和退出"><a href="#2-4-MySQL登陆和退出" class="headerlink" title="2.4  MySQL登陆和退出"></a>2.4  MySQL登陆和退出</h3><h4 id="2-4-1-登陆"><a href="#2-4-1-登陆" class="headerlink" title="2.4.1  登陆"></a>2.4.1  登陆</h4><p>右键开始菜单，选择<code>命令提示符</code>，打开黑框。<br>在黑框中输入，<code>mysql -uroot -p1234</code>，回车，出现下图且左下角为<code>mysql&gt;</code>，则登录成功。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p1234</span><br></pre></td></tr></table></figure><p><strong>到这里你就可以开始你的MySQL之旅了！</strong></p><p>登陆参数：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -u用户名 -p密码 -h要连接的mysql服务器的ip地址(默认127.0.0.1) -P端口号(默认3306)</span><br></pre></td></tr></table></figure><h4 id="2-4-2-退出"><a href="#2-4-2-退出" class="headerlink" title="2.4.2  退出"></a>2.4.2  退出</h4><p>退出mysql：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exit</span><br><span class="line">quit</span><br></pre></td></tr></table></figure><h3 id="2-5-MySQL数据模型"><a href="#2-5-MySQL数据模型" class="headerlink" title="2.5  MySQL数据模型"></a>2.5  MySQL数据模型</h3><p><strong>关系型数据库：</strong></p><blockquote><p>关系型数据库是建立在关系模型基础上的数据库，简单说，关系型数据库是由多张能互相连接的 二维表 组成的数据库</p></blockquote><p>如下图，<code>订单信息表</code> 和 <code>客户信息表</code> 都是有行有列二维表我们将这样的称为关系型数据库。</p><p><strong>接下来看关系型数据库的优点：</strong></p><ul><li>都是使用表结构，格式一致，易于维护。</li><li>使用通用的 SQL 语言操作，使用方便，可用于复杂查询。<ul><li>关系型数据库都可以通过SQL进行操作，所以使用方便。</li><li>复杂查询。现在需要查询001号订单数据，我们可以看到该订单是1号客户的订单，而1号订单是李聪这个客户。以后也可以在一张表中进行统计分析等操作。</li></ul></li><li>数据存储在磁盘中，安全。</li></ul><p><strong>数据模型：</strong></p><p>我们通过客户端可以通过数据库管理系统创建数据库，在数据库中创建表，在表中添加数据。创建的每一个数据库对应到磁盘上都是一个文件夹。比如可以通过SQL语句创建一个数据库（数据库名称为db1），语句如下。该语句咱们后面会学习。</p><p>我们可以在数据库安装目录下的data目录下看到多了一个 <code>db1</code> 的文件夹。所以，<strong>在MySQL中一个数据库对应到磁盘上的一个文件夹。</strong></p><p>而一个数据库下可以创建多张表，我们到MySQL中自带的mysql数据库的文件夹中，<code>db.frm</code> 是表文件，<code>db.MYD</code> 是数据文件，通过这两个文件就可以查询到数据展示成二维表的效果。</p><p><strong>小结：</strong></p><ul><li>MySQL中可以创建多个数据库，每个数据库对应到磁盘上的一个文件夹</li><li>在每个数据库中可以创建多个表，每张都对应到磁盘上一个 frm 文件</li><li>每张表可以存储多条数据，数据会被存储到磁盘中  MYD 文件中</li></ul><h2 id="3、SQL概述"><a href="#3、SQL概述" class="headerlink" title="3、SQL概述"></a>3、SQL概述</h2><p>了解了数据模型后，接下来我们就学习SQL语句，通过SQL语句对数据库、表、数据进行增删改查操作。 </p><h3 id="3-1-SQL简介"><a href="#3-1-SQL简介" class="headerlink" title="3.1  SQL简介"></a>3.1  SQL简介</h3><ul><li>英文：Structured Query Language，简称 SQL</li><li>结构化查询语言，一门操作关系型数据库的编程语言</li><li>定义操作所有关系型数据库的统一标准</li><li>对于同一个需求，每一种数据库操作的方式可能会存在一些不一样的地方，我们称为“方言”</li></ul><h3 id="3-2-通用语法"><a href="#3-2-通用语法" class="headerlink" title="3.2  通用语法"></a>3.2  通用语法</h3><ul><li><p>SQL 语句可以单行或多行书写，以分号结尾。</p></li><li><p>MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。</p><p>同样的一条sql语句写成下图的样子，一样可以运行处结果。</p></li><li><p>注释</p><ul><li><p>单行注释: – 注释内容 或 #注释内容(MySQL 特有) </p><blockquote><p>注意：使用– 添加单行注释时，–后面一定要加空格，而#没有要求。</p></blockquote></li><li><p>多行注释: &#x2F;* 注释 *&#x2F;</p></li></ul></li></ul><h3 id="3-3-SQL分类"><a href="#3-3-SQL分类" class="headerlink" title="3.3  SQL分类"></a>3.3  SQL分类</h3><ul><li><p>DDL(Data Definition Language) ： 数据定义语言，用来定义数据库对象：数据库，表，列等</p><p>DDL简单理解就是用来操作数据库，表等</p></li><li><p>DML(Data Manipulation Language) 数据操作语言，用来对数据库中表的数据进行增删改</p><p>DML简单理解就对表中数据进行增删改</p></li><li><p>DQL(Data Query Language) 数据查询语言，用来查询数据库中表的记录(数据)</p><p>DQL简单理解就是对数据进行查询操作。从数据库表中查询到我们想要的数据。</p></li><li><p>DCL(Data Control Language) 数据控制语言，用来定义数据库的访问权限和安全级别，及创建用户</p><p>DML简单理解就是对数据库进行权限控制。比如我让某一个数据库表只能让某一个用户进行操作等。</p></li></ul><blockquote><p>注意： 以后我们最常操作的是 <code>DML</code> 和 <code>DQL</code>  ，因为我们开发中最常操作的就是数据。</p></blockquote><h2 id="4、DDL-操作数据库"><a href="#4、DDL-操作数据库" class="headerlink" title="4、DDL:操作数据库"></a>4、DDL:操作数据库</h2><p>我们先来学习DDL来操作数据库。而操作数据库主要就是对数据库的增删查操作。</p><h3 id="4-1-查询"><a href="#4-1-查询" class="headerlink" title="4.1  查询"></a>4.1  查询</h3><p>查询所有的数据库</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> DATABASES;</span><br></pre></td></tr></table></figure><p>上述查询到的是的这些数据库是mysql安装好自带的数据库，我们以后不要操作这些数据库。</p><h3 id="4-2-创建数据库"><a href="#4-2-创建数据库" class="headerlink" title="4.2  创建数据库"></a>4.2  创建数据库</h3><ul><li><strong>创建数据库</strong>：</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE 数据库名称;</span><br></pre></td></tr></table></figure><p>而在创建数据库的时候，我并不知道db1数据库有没有创建，直接再次创建名为db1的数据库就会出现错误。</p><p>为了避免上面的错误，在创建数据库的时候先做判断，如果不存在再创建。</p><ul><li><strong>创建数据库(判断，如果不存在则创建)</strong></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> 数据库名称;</span><br></pre></td></tr></table></figure><h3 id="4-3-删除数据库"><a href="#4-3-删除数据库" class="headerlink" title="4.3  删除数据库"></a>4.3  删除数据库</h3><ul><li><strong>删除数据库</strong></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> DATABASE 数据库名称;</span><br></pre></td></tr></table></figure><ul><li><strong>删除数据库(判断，如果存在则删除)</strong></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> DATABASE IF <span class="keyword">EXISTS</span> 数据库名称;</span><br></pre></td></tr></table></figure><h3 id="4-4-使用数据库"><a href="#4-4-使用数据库" class="headerlink" title="4.4  使用数据库"></a>4.4  使用数据库</h3><p>数据库创建好了，要在数据库中创建表，得先明确在哪儿个数据库中操作，此时就需要使用数据库。</p><ul><li><strong>使用数据库</strong></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">USE 数据库名称;</span><br></pre></td></tr></table></figure><ul><li><strong>查看当前使用的数据库</strong></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DATABASE();</span><br></pre></td></tr></table></figure><h2 id="5、DDL-操作表"><a href="#5、DDL-操作表" class="headerlink" title="5、DDL:操作表"></a>5、DDL:操作表</h2><p>操作表也就是对表进行增（Create）删（Retrieve）改（Update）查（Delete）。</p><h3 id="5-1-查询表"><a href="#5-1-查询表" class="headerlink" title="5.1  查询表"></a>5.1  查询表</h3><ul><li><strong>查询当前数据库下所有表名称</strong></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> TABLES;</span><br></pre></td></tr></table></figure><ul><li><strong>查询表结构</strong></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DESC</span> 表名称;</span><br></pre></td></tr></table></figure><h3 id="5-2-创建表"><a href="#5-2-创建表" class="headerlink" title="5.2  创建表"></a>5.2  创建表</h3><ul><li><strong>创建表</strong></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名 (</span><br><span class="line">字段名<span class="number">1</span>  数据类型<span class="number">1</span>,</span><br><span class="line">字段名<span class="number">2</span>  数据类型<span class="number">2</span>,</span><br><span class="line">…</span><br><span class="line">字段名n  数据类型n</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>注意：最后一行末尾，不能加逗号</p></blockquote><p>知道了创建表的语句，那么我们创建如下结构的表</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tb_user (</span><br><span class="line">id <span class="type">int</span>,</span><br><span class="line">    username <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    password <span class="type">varchar</span>(<span class="number">32</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="5-3-数据类型"><a href="#5-3-数据类型" class="headerlink" title="5.3  数据类型"></a>5.3  数据类型</h3><p>MySQL 支持多种类型，可以分为三类：</p><ul><li><p>数值</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">tinyint : 小整数型，占一个字节</span><br><span class="line"><span class="type">int</span>： 大整数类型，占四个字节</span><br><span class="line">eg ： age <span class="type">int</span></span><br><span class="line"><span class="keyword">double</span> ： 浮点类型</span><br><span class="line">使用格式： 字段名 <span class="keyword">double</span>(总长度,小数点后保留的位数)</span><br><span class="line">eg ： score <span class="keyword">double</span>(<span class="number">5</span>,<span class="number">2</span>)   </span><br></pre></td></tr></table></figure></li><li><p>日期</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="type">date</span> ： 日期值。只包含年月日</span><br><span class="line">eg ：birthday <span class="type">date</span> ： </span><br><span class="line">datetime ： 混合日期和时间值。包含年月日时分秒</span><br></pre></td></tr></table></figure></li><li><p>字符串</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> ： 定长字符串。</span><br><span class="line">优点：存储性能高</span><br><span class="line">缺点：浪费空间</span><br><span class="line">eg ： name <span class="type">char</span>(<span class="number">10</span>)  如果存储的数据字符个数不足<span class="number">10</span>个，也会占<span class="number">10</span>个的空间</span><br><span class="line"><span class="type">varchar</span> ： 变长字符串。</span><br><span class="line">优点：节约空间</span><br><span class="line">缺点：存储性能底</span><br><span class="line">eg ： name <span class="type">varchar</span>(<span class="number">10</span>) 如果存储的数据字符个数不足<span class="number">10</span>个，那就数据字符个数是几就占几个的空间</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>注意：其他类型参考资料中的《MySQL数据类型].xlsx》</p></blockquote><p><strong>案例：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">需求：设计一张学生表，请注重数据类型、长度的合理性</span><br><span class="line">1. 编号</span><br><span class="line">2. 姓名，姓名最长不超过10个汉字</span><br><span class="line">3. 性别，因为取值只有两种可能，因此最多一个汉字</span><br><span class="line">4. 生日，取值为年月日</span><br><span class="line">5. 入学成绩，小数点后保留两位</span><br><span class="line">6. 邮件地址，最大长度不超过 64</span><br><span class="line">7. 家庭联系电话，不一定是手机号码，可能会出现 - 等字符</span><br><span class="line">8. 学生状态（用数字表示，正常、休学、毕业...）</span><br></pre></td></tr></table></figure><p>语句设计如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student (</span><br><span class="line">id <span class="type">int</span>,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">10</span>),</span><br><span class="line">    gender <span class="type">char</span>(<span class="number">1</span>),</span><br><span class="line">    birthday <span class="type">date</span>,</span><br><span class="line">    score <span class="keyword">double</span>(<span class="number">5</span>,<span class="number">2</span>),</span><br><span class="line">    email <span class="type">varchar</span>(<span class="number">15</span>),</span><br><span class="line">    tel <span class="type">varchar</span>(<span class="number">15</span>),</span><br><span class="line">    status tinyint</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="5-4-删除表"><a href="#5-4-删除表" class="headerlink" title="5.4  删除表"></a>5.4  删除表</h3><ul><li><strong>删除表</strong></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> 表名;</span><br></pre></td></tr></table></figure><ul><li><strong>删除表时判断表是否存在</strong></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> 表名;</span><br></pre></td></tr></table></figure><h3 id="5-5-修改表"><a href="#5-5-修改表" class="headerlink" title="5.5  修改表"></a>5.5  修改表</h3><ul><li><strong>修改表名</strong></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 RENAME <span class="keyword">TO</span> 新的表名;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将表名student修改为stu</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> student rename <span class="keyword">to</span> stu;</span><br></pre></td></tr></table></figure><ul><li><strong>添加一列</strong></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> 列名 数据类型;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 给stu表添加一列address，该字段类型是varchar(50)</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> stu <span class="keyword">add</span> address <span class="type">varchar</span>(<span class="number">50</span>);</span><br></pre></td></tr></table></figure><ul><li><strong>修改数据类型</strong></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 MODIFY 列名 新数据类型;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将stu表中的address字段的类型改为 char(50)</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> stu modify address <span class="type">char</span>(<span class="number">50</span>);</span><br></pre></td></tr></table></figure><ul><li><strong>修改列名和数据类型</strong></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 CHANGE 列名 新列名 新数据类型;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将stu表中的address字段名改为 addr，类型改为varchar(50)</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> stu change address addr <span class="type">varchar</span>(<span class="number">50</span>);</span><br></pre></td></tr></table></figure><ul><li><strong>删除列</strong></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">DROP</span> 列名;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将stu表中的addr字段 删除</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> stu <span class="keyword">drop</span> addr;</span><br></pre></td></tr></table></figure><h2 id="6、navicat使用"><a href="#6、navicat使用" class="headerlink" title="6、navicat使用"></a>6、navicat使用</h2><p>通过上面的学习，我们发现在命令行中写sql语句特别不方便，尤其是编写创建表的语句，我们只能在记事本上写好后直接复制到命令行进行执行。那么有没有刚好的工具提供给我们进行使用呢？ 有。</p><h3 id="6-1-navicat概述"><a href="#6-1-navicat概述" class="headerlink" title="6.1  navicat概述"></a>6.1  navicat概述</h3><ul><li>Navicat for MySQL 是管理和开发 MySQL 或 MariaDB 的理想解决方案。</li><li>这套全面的前端工具为数据库管理、开发和维护提供了一款直观而强大的图形界面。</li><li>官网： <a href="http://www.navicat.com.cn/">http://www.navicat.com.cn</a></li></ul><h3 id="6-2-navicat安装"><a href="#6-2-navicat安装" class="headerlink" title="6.2  navicat安装"></a>6.2  navicat安装</h3><p>参考 : 资料\navicat安装包\navicat_mysql_x86\navicat安装步骤.md</p><h3 id="6-3-navicat使用"><a href="#6-3-navicat使用" class="headerlink" title="6.3  navicat使用"></a>6.3  navicat使用</h3><h4 id="6-3-1-建立和mysql服务的连接"><a href="#6-3-1-建立和mysql服务的连接" class="headerlink" title="6.3.1  建立和mysql服务的连接"></a>6.3.1  建立和mysql服务的连接</h4><ol><li><strong>创建一个新连接</strong>：在Navicat的主界面中，点击”连接”（Connect）或类似的选项来创建一个新的数据库连接。</li><li><strong>选择数据库类型</strong>：在连接向导中，选择你要连接的数据库类型。在这里，你需要选择MySQL。</li><li><strong>填写连接信息</strong>：接下来，你需要提供连接MySQL数据库所需的信息，包括：<ul><li><strong>连接名称</strong>：给连接取一个易于识别的名称。</li><li><strong>主机名&#x2F;IP地址</strong>：这是你的MySQL服务器的地址。如果MySQL服务器在本地运行，可以使用”localhost”或”127.0.0.1”。</li><li><strong>端口</strong>：默认MySQL端口是3306，但你可以根据你的设置进行更改。</li><li><strong>用户名</strong>：连接MySQL数据库的用户名。</li><li><strong>密码</strong>：与用户名相关联的密码。</li></ul></li><li><strong>测试连接</strong>：在填写完连接信息后，可以选择测试连接以确保一切设置正确。</li><li><strong>保存连接</strong>：如果测试连接成功，点击”确定”或”保存”来保存连接配置。</li><li><strong>连接到MySQL</strong>：现在，你可以在Navicat中双击你创建的连接来连接到MySQL服务器。</li></ol><h2 id="7、DML"><a href="#7、DML" class="headerlink" title="7、DML"></a>7、DML</h2><p>DML主要是对数据进行增（insert）删（delete）改（update）操作。</p><h3 id="7-1-添加数据"><a href="#7-1-添加数据" class="headerlink" title="7.1  添加数据"></a>7.1  添加数据</h3><ul><li><strong>给指定列添加数据</strong></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名(列名<span class="number">1</span>,列名<span class="number">2</span>,…) <span class="keyword">VALUES</span>(值<span class="number">1</span>,值<span class="number">2</span>,…);</span><br></pre></td></tr></table></figure><ul><li><strong>给全部列添加数据</strong></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名 <span class="keyword">VALUES</span>(值<span class="number">1</span>,值<span class="number">2</span>,…);</span><br></pre></td></tr></table></figure><ul><li><strong>批量添加数据</strong></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名(列名<span class="number">1</span>,列名<span class="number">2</span>,…) <span class="keyword">VALUES</span>(值<span class="number">1</span>,值<span class="number">2</span>,…),(值<span class="number">1</span>,值<span class="number">2</span>,…),(值<span class="number">1</span>,值<span class="number">2</span>,…)…;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名 <span class="keyword">VALUES</span>(值<span class="number">1</span>,值<span class="number">2</span>,…),(值<span class="number">1</span>,值<span class="number">2</span>,…),(值<span class="number">1</span>,值<span class="number">2</span>,…)…;</span><br></pre></td></tr></table></figure><ul><li><strong>练习</strong></li></ul><p>为了演示以下的增删改操作是否操作成功，故先将查询所有数据的语句介绍给大家：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 给指定列添加数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stu (id, NAME) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;张三&#x27;</span>);</span><br><span class="line"><span class="comment">-- 给所有列添加数据，列名的列表可以省略的</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stu (id,NAME,sex,birthday,score,email,tel,STATUS) <span class="keyword">VALUES</span> (<span class="number">2</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;1999-11-11&#x27;</span>,<span class="number">88.88</span>,<span class="string">&#x27;lisi@itcast.cn&#x27;</span>,<span class="string">&#x27;13888888888&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stu <span class="keyword">VALUES</span> (<span class="number">2</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;1999-11-11&#x27;</span>,<span class="number">88.88</span>,<span class="string">&#x27;lisi@itcast.cn&#x27;</span>,<span class="string">&#x27;13888888888&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 批量添加数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stu <span class="keyword">VALUES</span> </span><br><span class="line">(<span class="number">2</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;1999-11-11&#x27;</span>,<span class="number">88.88</span>,<span class="string">&#x27;lisi@itcast.cn&#x27;</span>,<span class="string">&#x27;13888888888&#x27;</span>,<span class="number">1</span>),</span><br><span class="line">(<span class="number">2</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;1999-11-11&#x27;</span>,<span class="number">88.88</span>,<span class="string">&#x27;lisi@itcast.cn&#x27;</span>,<span class="string">&#x27;13888888888&#x27;</span>,<span class="number">1</span>),</span><br><span class="line">(<span class="number">2</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;1999-11-11&#x27;</span>,<span class="number">88.88</span>,<span class="string">&#x27;lisi@itcast.cn&#x27;</span>,<span class="string">&#x27;13888888888&#x27;</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h3 id="7-2-修改数据"><a href="#7-2-修改数据" class="headerlink" title="7.2  修改数据"></a>7.2  修改数据</h3><ul><li><strong>修改表数据</strong></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> 表名 <span class="keyword">SET</span> 列名<span class="number">1</span><span class="operator">=</span>值<span class="number">1</span>,列名<span class="number">2</span><span class="operator">=</span>值<span class="number">2</span>,… [<span class="keyword">WHERE</span> 条件] ;</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><ol><li>修改语句中如果不加条件，则将所有数据都修改！</li><li>像上面的语句中的中括号，表示在写sql语句中可以省略这部分</li></ol></blockquote><ul><li><p><strong>练习</strong></p><ul><li>将张三的性别改为女</li></ul>  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> stu <span class="keyword">set</span> sex <span class="operator">=</span> <span class="string">&#x27;女&#x27;</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li><p>将张三的生日改为 1999-12-12 分数改为99.99</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> stu <span class="keyword">set</span> birthday <span class="operator">=</span> <span class="string">&#x27;1999-12-12&#x27;</span>, score <span class="operator">=</span> <span class="number">99.99</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>注意：如果update语句没有加where条件，则会将表中所有数据全部修改！</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> stu <span class="keyword">set</span> sex <span class="operator">=</span> <span class="string">&#x27;女&#x27;</span>;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="7-3-删除数据"><a href="#7-3-删除数据" class="headerlink" title="7.3  删除数据"></a>7.3  删除数据</h3><ul><li><strong>删除数据</strong></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> 表名 [<span class="keyword">WHERE</span> 条件] ;</span><br></pre></td></tr></table></figure><ul><li><strong>练习</strong></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 删除张三记录</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> stu <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除stu表中所有的数据</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> stu;</span><br></pre></td></tr></table></figure><h2 id="8，DQL"><a href="#8，DQL" class="headerlink" title="8，DQL"></a>8，DQL</h2><p>先介绍查询的完整语法：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    字段列表</span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">    表名列表 </span><br><span class="line"><span class="keyword">WHERE</span> </span><br><span class="line">    条件列表</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">    分组字段</span><br><span class="line"><span class="keyword">HAVING</span></span><br><span class="line">    分组后条件</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">    排序字段</span><br><span class="line">LIMIT</span><br><span class="line">    分页限定</span><br></pre></td></tr></table></figure><p>为了演示查询的语句，需要先准备表及一些数据：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 删除stu表</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> stu;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建stu表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> stu (</span><br><span class="line"> id <span class="type">int</span>, <span class="comment">-- 编号</span></span><br><span class="line"> name <span class="type">varchar</span>(<span class="number">20</span>), <span class="comment">-- 姓名</span></span><br><span class="line"> age <span class="type">int</span>, <span class="comment">-- 年龄</span></span><br><span class="line"> sex <span class="type">varchar</span>(<span class="number">5</span>), <span class="comment">-- 性别</span></span><br><span class="line"> address <span class="type">varchar</span>(<span class="number">100</span>), <span class="comment">-- 地址</span></span><br><span class="line"> math <span class="keyword">double</span>(<span class="number">5</span>,<span class="number">2</span>), <span class="comment">-- 数学成绩</span></span><br><span class="line"> english <span class="keyword">double</span>(<span class="number">5</span>,<span class="number">2</span>), <span class="comment">-- 英语成绩</span></span><br><span class="line"> hire_date <span class="type">date</span> <span class="comment">-- 入学时间</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stu(id,NAME,age,sex,address,math,english,hire_date) </span><br><span class="line"><span class="keyword">VALUES</span> </span><br><span class="line">(<span class="number">1</span>,<span class="string">&#x27;马运&#x27;</span>,<span class="number">55</span>,<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;杭州&#x27;</span>,<span class="number">66</span>,<span class="number">78</span>,<span class="string">&#x27;1995-09-01&#x27;</span>),</span><br><span class="line">(<span class="number">2</span>,<span class="string">&#x27;马花疼&#x27;</span>,<span class="number">45</span>,<span class="string">&#x27;女&#x27;</span>,<span class="string">&#x27;深圳&#x27;</span>,<span class="number">98</span>,<span class="number">87</span>,<span class="string">&#x27;1998-09-01&#x27;</span>),</span><br><span class="line">(<span class="number">3</span>,<span class="string">&#x27;马斯克&#x27;</span>,<span class="number">55</span>,<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;香港&#x27;</span>,<span class="number">56</span>,<span class="number">77</span>,<span class="string">&#x27;1999-09-02&#x27;</span>),</span><br><span class="line">(<span class="number">4</span>,<span class="string">&#x27;柳白&#x27;</span>,<span class="number">20</span>,<span class="string">&#x27;女&#x27;</span>,<span class="string">&#x27;湖南&#x27;</span>,<span class="number">76</span>,<span class="number">65</span>,<span class="string">&#x27;1997-09-05&#x27;</span>),</span><br><span class="line">(<span class="number">5</span>,<span class="string">&#x27;柳青&#x27;</span>,<span class="number">20</span>,<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;湖南&#x27;</span>,<span class="number">86</span>,<span class="keyword">NULL</span>,<span class="string">&#x27;1998-09-01&#x27;</span>),</span><br><span class="line">(<span class="number">6</span>,<span class="string">&#x27;刘德花&#x27;</span>,<span class="number">57</span>,<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;香港&#x27;</span>,<span class="number">99</span>,<span class="number">99</span>,<span class="string">&#x27;1998-09-01&#x27;</span>),</span><br><span class="line">(<span class="number">7</span>,<span class="string">&#x27;张学右&#x27;</span>,<span class="number">22</span>,<span class="string">&#x27;女&#x27;</span>,<span class="string">&#x27;香港&#x27;</span>,<span class="number">99</span>,<span class="number">99</span>,<span class="string">&#x27;1998-09-01&#x27;</span>),</span><br><span class="line">(<span class="number">8</span>,<span class="string">&#x27;德玛西亚&#x27;</span>,<span class="number">18</span>,<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;南京&#x27;</span>,<span class="number">56</span>,<span class="number">65</span>,<span class="string">&#x27;1994-09-02&#x27;</span>);</span><br></pre></td></tr></table></figure><p>接下来咱们从最基本的查询语句开始学起。</p><h3 id="8-1-基础查询"><a href="#8-1-基础查询" class="headerlink" title="8.1  基础查询"></a>8.1  基础查询</h3><h4 id="8-1-1-语法"><a href="#8-1-1-语法" class="headerlink" title="8.1.1  语法"></a>8.1.1  语法</h4><ul><li><strong>查询多个字段( * )</strong></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名; <span class="comment">-- 查询所有数据</span></span><br></pre></td></tr></table></figure><ul><li><strong>去除重复记录(DISTINCT)</strong></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> 字段列表 <span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure><ul><li><strong>起别名(AS)</strong></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">AS</span>: <span class="keyword">AS</span> 也可以省略</span><br></pre></td></tr></table></figure><h4 id="8-1-2-练习"><a href="#8-1-2-练习" class="headerlink" title="8.1.2  练习"></a>8.1.2  练习</h4><ul><li><p>查询name、age两列</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> name,age <span class="keyword">from</span> stu;</span><br></pre></td></tr></table></figure></li><li><p>查询所有列的数据，列名的列表可以使用*替代</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu;</span><br></pre></td></tr></table></figure><p>上面语句中的*不建议大家使用，因为在这写*不方便我们阅读sql语句。我们写字段列表的话，可以添加注释对每一个字段进行说明。</p></li><li><p>查询地址信息</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> address <span class="keyword">from</span> stu;</span><br></pre></td></tr></table></figure><p>从上面的结果我们可以看到有重复的数据，我们也可以使用 <code>distinct</code> 关键字去重重复数据。</p></li><li><p>去除重复记录</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> address <span class="keyword">from</span> stu;</span><br></pre></td></tr></table></figure></li><li><p>查询姓名、数学成绩、英语成绩。并通过as给math和english起别名（as关键字可以省略）</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> name,math <span class="keyword">as</span> 数学成绩,english <span class="keyword">as</span> 英文成绩 <span class="keyword">from</span> stu;</span><br><span class="line"><span class="keyword">select</span> name,math 数学成绩,english 英文成绩 <span class="keyword">from</span> stu;</span><br></pre></td></tr></table></figure></li></ul><h3 id="8-2-条件查询-WHERE"><a href="#8-2-条件查询-WHERE" class="headerlink" title="8.2  条件查询(WHERE)"></a>8.2  条件查询(WHERE)</h3><h4 id="8-2-1-语法"><a href="#8-2-1-语法" class="headerlink" title="8.2.1  语法"></a>8.2.1  语法</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 条件列表;</span><br></pre></td></tr></table></figure><ul><li><strong>条件</strong></li></ul><p>条件列表可以使用以下运算符</p><h4 id="8-2-2-条件查询练习"><a href="#8-2-2-条件查询练习" class="headerlink" title="8.2.2  条件查询练习"></a>8.2.2  条件查询练习</h4><ul><li><p>查询年龄大于20岁的学员信息</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu <span class="keyword">where</span> age <span class="operator">&gt;</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure></li><li><p>查询年龄大于等于20岁的学员信息</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu <span class="keyword">where</span> age <span class="operator">&gt;=</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure></li><li><p>查询年龄大于等于20岁 并且 年龄 小于等于 30岁 的学员信息</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu <span class="keyword">where</span> age <span class="operator">&gt;=</span> <span class="number">20</span> <span class="operator">&amp;&amp;</span>  age <span class="operator">&lt;=</span> <span class="number">30</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu <span class="keyword">where</span> age <span class="operator">&gt;=</span> <span class="number">20</span> <span class="keyword">and</span>  age <span class="operator">&lt;=</span> <span class="number">30</span>;</span><br></pre></td></tr></table></figure><blockquote><p>上面语句中 &amp;&amp;  和  and  都表示并且的意思。建议使用 and 。</p><p>也可以使用  between … and 来实现上面需求</p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu <span class="keyword">where</span> age <span class="keyword">BETWEEN</span> <span class="number">20</span> <span class="keyword">and</span> <span class="number">30</span>;</span><br></pre></td></tr></table></figure></li><li><p>查询入学日期在’1998-09-01’ 到 ‘1999-09-01’  之间的学员信息</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu <span class="keyword">where</span> hire_date <span class="keyword">BETWEEN</span> <span class="string">&#x27;1998-09-01&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;1999-09-01&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>查询年龄等于18岁的学员信息</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu <span class="keyword">where</span> age <span class="operator">=</span> <span class="number">18</span>;</span><br></pre></td></tr></table></figure></li><li><p>查询年龄不等于18岁的学员信息</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu <span class="keyword">where</span> age <span class="operator">!=</span> <span class="number">18</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu <span class="keyword">where</span> age <span class="operator">&lt;&gt;</span> <span class="number">18</span>;</span><br></pre></td></tr></table></figure></li><li><p>查询年龄等于18岁 或者 年龄等于20岁 或者 年龄等于22岁的学员信息</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu <span class="keyword">where</span> age <span class="operator">=</span> <span class="number">18</span> <span class="keyword">or</span> age <span class="operator">=</span> <span class="number">20</span> <span class="keyword">or</span> age <span class="operator">=</span> <span class="number">22</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu <span class="keyword">where</span> age <span class="keyword">in</span> (<span class="number">18</span>,<span class="number">20</span> ,<span class="number">22</span>);</span><br></pre></td></tr></table></figure></li><li><p>查询英语成绩为 null的学员信息</p><p>null值的比较不能使用 &#x3D;  或者 !&#x3D; 。需要使用 is  或者 is not</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu <span class="keyword">where</span> english <span class="operator">=</span> <span class="keyword">null</span>; <span class="comment">-- 这个语句是不行的</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu <span class="keyword">where</span> english <span class="keyword">is</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu <span class="keyword">where</span> english <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure></li></ul><h4 id="8-2-3-模糊查询练习"><a href="#8-2-3-模糊查询练习" class="headerlink" title="8.2.3  模糊查询练习"></a>8.2.3  模糊查询练习</h4><blockquote><p>模糊查询使用like关键字，可以使用通配符进行占位:</p><p>（1）_ : 代表单个任意字符</p><p>（2）% : 代表任意个数字符</p></blockquote><ul><li><p>查询姓’马’的学员信息</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;马%&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>查询第二个字是’花’的学员信息  </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;_花%&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>查询名字中包含 ‘德’ 的学员信息</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;%德%&#x27;</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="8-3-排序查询-ORDER-BY"><a href="#8-3-排序查询-ORDER-BY" class="headerlink" title="8.3  排序查询(ORDER BY)"></a>8.3  排序查询(ORDER BY)</h3><h4 id="8-3-1-语法"><a href="#8-3-1-语法" class="headerlink" title="8.3.1  语法"></a>8.3.1  语法</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名 <span class="keyword">ORDER</span> <span class="keyword">BY</span> 排序字段名<span class="number">1</span> [排序方式<span class="number">1</span>],排序字段名<span class="number">2</span> [排序方式<span class="number">2</span>] …;</span><br></pre></td></tr></table></figure><p>上述语句中的排序方式有两种，分别是：</p><ul><li>ASC ： 升序排列小到大 <strong>（默认值）</strong></li><li>DESC ： 降序排列大到小</li></ul><blockquote><p>注意：如果有多个排序条件，当前边的条件值一样时，才会根据第二条件进行排序</p></blockquote><h4 id="8-3-2-练习"><a href="#8-3-2-练习" class="headerlink" title="8.3.2  练习"></a>8.3.2  练习</h4><ul><li><p>查询学生信息，按照年龄升序排列 </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu <span class="keyword">order</span> <span class="keyword">by</span> age ;</span><br></pre></td></tr></table></figure></li><li><p>查询学生信息，按照数学成绩降序排列</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu <span class="keyword">order</span> <span class="keyword">by</span> math <span class="keyword">desc</span> ;</span><br></pre></td></tr></table></figure></li><li><p>查询学生信息，按照数学成绩降序排列，如果数学成绩一样，再按照英语成绩升序排列</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu <span class="keyword">order</span> <span class="keyword">by</span> math <span class="keyword">desc</span> , english <span class="keyword">asc</span> ;</span><br></pre></td></tr></table></figure></li></ul><h3 id="8-4-聚合函数-纵向计算"><a href="#8-4-聚合函数-纵向计算" class="headerlink" title="8.4  聚合函数(纵向计算)"></a>8.4  聚合函数(纵向计算)</h3><h4 id="8-4-1-概念"><a href="#8-4-1-概念" class="headerlink" title="8.4.1  概念"></a>8.4.1  概念</h4><p> 将一列数据作为一个整体，进行纵向计算。</p><h4 id="8-4-2-聚合函数分类"><a href="#8-4-2-聚合函数分类" class="headerlink" title="8.4.2  聚合函数分类"></a>8.4.2  聚合函数分类</h4><table><thead><tr><th>函数名</th><th>功能</th></tr></thead><tbody><tr><td>count(列名)</td><td>统计数量（一般选用不为null的列）</td></tr><tr><td>max(列名)</td><td>最大值</td></tr><tr><td>min(列名)</td><td>最小值</td></tr><tr><td>sum(列名)</td><td>求和</td></tr><tr><td>avg(列名)</td><td>平均值</td></tr></tbody></table><h4 id="8-4-3-聚合函数语法"><a href="#8-4-3-聚合函数语法" class="headerlink" title="8.4.3  聚合函数语法"></a>8.4.3  聚合函数语法</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 聚合函数名(列名) <span class="keyword">FROM</span> 表;</span><br></pre></td></tr></table></figure><blockquote><p>注意：null 值不参与所有聚合函数运算</p></blockquote><h4 id="8-4-4-练习"><a href="#8-4-4-练习" class="headerlink" title="8.4.4  练习"></a>8.4.4  练习</h4><ul><li><p>统计班级一共有多少个学生</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(id) <span class="keyword">from</span> stu;</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(english) <span class="keyword">from</span> stu;</span><br></pre></td></tr></table></figure><p>上面语句根据某个字段进行统计，如果该字段某一行的值为null的话，将不会被统计。所以可以在count(*) 来实现。* 表示所有字段数据，一行中也不可能所有的数据都为null，所以建议使用 count(*)</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> stu;</span><br></pre></td></tr></table></figure></li><li><p>查询数学成绩的最高分</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">max</span>(math) <span class="keyword">from</span> stu;</span><br></pre></td></tr></table></figure></li><li><p>查询数学成绩的最低分</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">min</span>(math) <span class="keyword">from</span> stu;</span><br></pre></td></tr></table></figure></li><li><p>查询数学成绩的总分</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">sum</span>(math) <span class="keyword">from</span> stu;</span><br></pre></td></tr></table></figure></li><li><p>查询数学成绩的平均分</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">avg</span>(math) <span class="keyword">from</span> stu;</span><br></pre></td></tr></table></figure></li><li><p>查询英语成绩的最低分</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">min</span>(english) <span class="keyword">from</span> stu;</span><br></pre></td></tr></table></figure></li></ul><h3 id="8-5-分组查询-GROUP-BY"><a href="#8-5-分组查询-GROUP-BY" class="headerlink" title="8.5  分组查询(GROUP BY)"></a>8.5  分组查询(GROUP BY)</h3><h4 id="8-5-1-语法"><a href="#8-5-1-语法" class="headerlink" title="8.5.1  语法"></a>8.5.1  语法</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名 [<span class="keyword">WHERE</span> 分组前条件限定] <span class="keyword">GROUP</span> <span class="keyword">BY</span> 分组字段名 [<span class="keyword">HAVING</span> 分组后条件过滤];</span><br></pre></td></tr></table></figure><blockquote><p>注意：分组之后，查询的字段为聚合函数和分组字段，查询其他字段无任何意义</p></blockquote><h4 id="8-5-2-练习"><a href="#8-5-2-练习" class="headerlink" title="8.5.2  练习"></a>8.5.2  练习</h4><ul><li><p>查询男同学和女同学各自的数学平均分</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> sex, <span class="built_in">avg</span>(math) <span class="keyword">from</span> stu <span class="keyword">group</span> <span class="keyword">by</span> sex;</span><br></pre></td></tr></table></figure><blockquote><p>注意：分组之后，查询的字段为<strong>聚合函数和分组字段</strong>，查询其他字段无任何意义</p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> name, sex, <span class="built_in">avg</span>(math) <span class="keyword">from</span> stu <span class="keyword">group</span> <span class="keyword">by</span> sex;  <span class="comment">-- 这里查询name字段就没有任何意义</span></span><br></pre></td></tr></table></figure></li><li><p>查询男同学和女同学各自的数学平均分，以及各自人数</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> sex, <span class="built_in">avg</span>(math),<span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> stu <span class="keyword">group</span> <span class="keyword">by</span> sex;</span><br></pre></td></tr></table></figure></li><li><p>查询男同学和女同学各自的数学平均分，以及各自人数，要求：分数低于70分的不参与分组</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> sex, <span class="built_in">avg</span>(math),<span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> stu <span class="keyword">where</span> math <span class="operator">&gt;</span> <span class="number">70</span> <span class="keyword">group</span> <span class="keyword">by</span> sex;</span><br></pre></td></tr></table></figure></li><li><p>查询男同学和女同学各自的数学平均分，以及各自人数，要求：分数低于70分的不参与分组，分组之后人数大于2个的</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> sex, <span class="built_in">avg</span>(math),<span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> stu <span class="keyword">where</span> math <span class="operator">&gt;</span> <span class="number">70</span> <span class="keyword">group</span> <span class="keyword">by</span> sex <span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>)  <span class="operator">&gt;</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure></li></ul><p><strong>where 和 having 区别：</strong></p><ul><li><p>执行时机不一样：where 是分组之前进行限定，不满足where条件，则不参与分组，而having是分组之后对结果进行过滤。</p></li><li><p>可判断的条件不一样：where 不能对聚合函数进行判断，having 可以。</p></li></ul><h3 id="8-6-分页查询"><a href="#8-6-分页查询" class="headerlink" title="8.6  分页查询"></a>8.6  分页查询</h3><p>网站都见过类似的效果，如京东、百度、淘宝等。分页查询是将数据一页一页的展示给用户看，用户也可以通过点击查看下一页的数据。</p><p>接下来我们先说分页查询的语法。</p><h4 id="8-6-1-语法-LIMIT"><a href="#8-6-1-语法-LIMIT" class="headerlink" title="8.6.1  语法(LIMIT)"></a>8.6.1  语法(LIMIT)</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名 LIMIT  起始索引 , 查询条目数;</span><br></pre></td></tr></table></figure><blockquote><p>注意： 上述语句中的起始索引是从0开始</p></blockquote><p><strong>计算公式：起始索引 &#x3D; (当前页码 - 1) * 每页显示的条数</strong></p><h4 id="8-6-2-练习"><a href="#8-6-2-练习" class="headerlink" title="8.6.2  练习"></a>8.6.2  练习</h4><ul><li><p>从0开始查询，查询3条数据</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu limit <span class="number">0</span> , <span class="number">3</span>;</span><br></pre></td></tr></table></figure></li><li><p>每页显示3条数据，查询第1页数据</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu limit <span class="number">0</span> , <span class="number">3</span>;</span><br></pre></td></tr></table></figure></li><li><p>每页显示3条数据，查询第2页数据</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu limit <span class="number">3</span> , <span class="number">3</span>;</span><br></pre></td></tr></table></figure></li><li><p>每页显示3条数据，查询第3页数据</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu limit <span class="number">6</span> , <span class="number">3</span>;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>day23 - XML、xml解析、工厂模式、装饰模式</title>
      <link href="/post/2f2fc17e.html"/>
      <url>/post/2f2fc17e.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-XML"><a href="#1-XML" class="headerlink" title="1.XML"></a>1.XML</h3><h4 id="1-1XML概述"><a href="#1-1XML概述" class="headerlink" title="1.1XML概述"></a>1.1XML概述</h4><p><strong>XML概述</strong></p><ul><li>XML是可扩展标记语言（eXtensible Markup Language）的缩写，它是是一种数据表示格式，可以描述非常复杂的数据结构，常用于传输和存储数据。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;data&gt;</span><br><span class="line">&lt;sender&gt;张三&lt;/sender&gt;</span><br><span class="line">&lt;receiver&gt;李四&lt;/receiver&gt;</span><br><span class="line">&lt;src&gt;</span><br><span class="line">     &lt;addr&gt;北京&lt;/addr&gt;</span><br><span class="line">     &lt;date&gt;<span class="number">2022</span>-<span class="number">11</span>-<span class="number">11</span> <span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span>&lt;/date&gt;</span><br><span class="line">    &lt;/src&gt;</span><br><span class="line">    &lt;current&gt;武汉&lt;/current&gt;</span><br><span class="line">    &lt;dest&gt;广州&lt;/dest&gt;</span><br><span class="line">&lt;/data&gt;</span><br></pre></td></tr></table></figure><p><strong>XML的几个特点和使用场景</strong></p><ul><li><p>一是<strong>纯文本</strong>，默认使用UTF-8编码；二是<strong>可嵌套</strong>；</p></li><li><p>如果把XML内容存为文件，那么它就是一个XML文件。</p></li><li><p>XML的使用场景：XML内容经常被当成消息进行网络传输，或者作为配置文件用于存储系统的信息。</p></li></ul><h4 id="1-2XML的创建、语法规则"><a href="#1-2XML的创建、语法规则" class="headerlink" title="1.2XML的创建、语法规则"></a>1.2XML的创建、语法规则</h4><p><strong>XML的创建</strong></p><ul><li>就是创建一个XML类型的文件，要求<strong>【文件的后缀】必须使用xml</strong>，如<strong>hello_world.xml</strong></li></ul><p><strong>XML的语法规则</strong></p><ul><li><p>XML文件的后缀名为：xml</p></li><li><p>文档声明必须是第一行</p></li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line">//version：XML默认的版本号码、该属性是必须存在的</span><br><span class="line">//encoding：本XML文件的编码</span><br></pre></td></tr></table></figure><p><strong>XML的标签(元素)规则</strong></p><ul><li><p>标签由一对尖括号和合法标识符组成: <name></name>，<strong>必须存在一个根标签，有且只能有一个。</strong></p></li><li><p><strong>标签必须成对出现</strong>，有开始，有结束: <name></name></p></li><li><p><strong>特殊的标签可以不成对</strong>，但是必须有结束标记，如:<br/></p></li><li><p>标签中可以定义属性，<strong>属性和标签名空格隔开,属性值必须用引号引起来</strong>&lt;student id &#x3D; “1”&gt;</name></p></li></ul><p>l标签需要正确的嵌套</p><p><strong>XML的其他组成</strong></p><ul><li><p>XML文件中可以定义注释信息：<!-- 注释内容 --></p></li><li><p>XML文件中可以存在以下特殊字符</p></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;lt;    &lt;  小于</span><br><span class="line">&amp;gt;    &gt;  大于</span><br><span class="line">&amp;amp;   &amp;  和号</span><br><span class="line">&amp;apos;  &#x27;  单引号</span><br><span class="line">&amp;quot;  &quot;  引号</span><br></pre></td></tr></table></figure><ul><li>XML文件中可以存在CDATA区: <![CDATA[  …内容… ]]></li></ul><p><strong>xml文档：</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 注释：根标签有且仅能有一个 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">student</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>女儿国王<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sex</span>&gt;</span>女<span class="tag">&lt;/<span class="name">sex</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hobby</span>&gt;</span>唐僧，追唐僧<span class="tag">&lt;/<span class="name">hobby</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">info</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">age</span>&gt;</span>30<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">addr</span>&gt;</span>女儿国<span class="tag">&lt;/<span class="name">addr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">info</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sql</span>&gt;</span></span><br><span class="line">        select * from user where age <span class="symbol">&amp;lt;</span> 18;</span><br><span class="line">        select * from user where age <span class="symbol">&amp;lt;</span> 18 <span class="symbol">&amp;amp;</span><span class="symbol">&amp;amp;</span> age &gt; 10</span><br><span class="line">        &lt;![CDATA[</span><br><span class="line">                select * from user where age &lt; 18</span><br><span class="line">        ]]&gt;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="1-3XML文档约束方式一-DTD约束-了解"><a href="#1-3XML文档约束方式一-DTD约束-了解" class="headerlink" title="1.3XML文档约束方式一-DTD约束[了解]"></a>1.3XML文档约束方式一-DTD约束[了解]</h4><p><strong>什么是文档约束？</strong></p><p>由于XML文件可以自定义标签，导致XML文件可以随意定义，程序在解析的时候可能出现问题。</p><p><strong>文档约束</strong>：是用来限定xml文件中的标签以及属性应该怎么写。以此强制约束程序员必须按照文档约束的规定来编写xml文件。</p><p><strong>文档约束的分类</strong></p><ul><li><p>DTD</p></li><li><p>schema</p></li></ul><p><strong>XML文档约束-DTD的使用（了解）</strong></p><p><strong>需求：</strong></p><p>利用DTD文档约束，约束一个XML文件的编写。</p><p><strong>分析：</strong></p><p>①：编写DTD约束文档，后缀必须是.dtd</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ELEMENT 书架 (书+)&gt;</span><br><span class="line">&lt;!ELEMENT 书 (书名,作者,售价)&gt;</span><br><span class="line">&lt;!ELEMENT 书名 (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT 作者 (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT 售价 (#PCDATA)&gt;</span><br></pre></td></tr></table></figure><p>②：在需要编写的XML文件中导入该DTD约束文档</p><p>③：按照约束的规定编写XML文件的内容。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE 书架 <span class="keyword">SYSTEM</span> <span class="string">&quot;data.dtd&quot;</span>&gt;</span>  //导入该DTD约束文档</span><br><span class="line"><span class="tag">&lt;<span class="name">书架</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">书</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">书名</span>&gt;</span>精通JavaSE加强<span class="tag">&lt;/<span class="name">书名</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">作者</span>&gt;</span>dlei<span class="tag">&lt;/<span class="name">作者</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">售价</span>&gt;</span>很贵<span class="tag">&lt;/<span class="name">售价</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">书</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">书</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">书名</span>&gt;</span><span class="tag">&lt;/<span class="name">书名</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">作者</span>&gt;</span><span class="tag">&lt;/<span class="name">作者</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">售价</span>&gt;</span><span class="tag">&lt;/<span class="name">售价</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">书</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">书</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">书名</span>&gt;</span><span class="tag">&lt;/<span class="name">书名</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">作者</span>&gt;</span><span class="tag">&lt;/<span class="name">作者</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">售价</span>&gt;</span><span class="tag">&lt;/<span class="name">售价</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">书</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">书架</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="1-4XML文档约束方式二-schema约束-了解"><a href="#1-4XML文档约束方式二-schema约束-了解" class="headerlink" title="1.4XML文档约束方式二-schema约束[了解]"></a>1.4XML文档约束方式二-schema约束[了解]</h4><p><strong>文档约束-schema</strong></p><ul><li><p>schema可以约束具体的数据类型，约束能力上更强大。</p></li><li><p>schema本身也是一个xml文件，本身也受到其他约束文件的要求，所以编写的更加严谨</p></li></ul><p><strong>XML文档约束-schema的使用（了解）</strong></p><p><strong>需求：</strong></p><p>利用schema文档约束，约束一个XML文件的编写。</p><p><strong>分析：</strong></p><p>①：编写schema约束文档，后缀必须是.xsd，具体的形式到代码中观看。</p><figure class="highlight xsd"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 编写schema约束文档 (.xsd)--&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">schema</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">targetNamespace</span>=<span class="string">&quot;http://www.itcast.cn&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">elementFormDefault</span>=<span class="string">&quot;qualified&quot;</span> &gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- targetNamespace:申明约束文档的地址（命名空间）--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">element</span> <span class="attr">name</span>=<span class="string">&#x27;书架&#x27;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 写子元素 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">complexType</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- maxOccurs=&#x27;unbounded&#x27;: 书架下的子元素可以有任意多个！--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">sequence</span> <span class="attr">maxOccurs</span>=<span class="string">&#x27;unbounded&#x27;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">element</span> <span class="attr">name</span>=<span class="string">&#x27;书&#x27;</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!-- 写子元素 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">complexType</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">sequence</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">element</span> <span class="attr">name</span>=<span class="string">&#x27;书名&#x27;</span> <span class="attr">type</span>=<span class="string">&#x27;string&#x27;</span>/&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">element</span> <span class="attr">name</span>=<span class="string">&#x27;作者&#x27;</span> <span class="attr">type</span>=<span class="string">&#x27;string&#x27;</span>/&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">element</span> <span class="attr">name</span>=<span class="string">&#x27;售价&#x27;</span> <span class="attr">type</span>=<span class="string">&#x27;double&#x27;</span>/&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">sequence</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">complexType</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">element</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">sequence</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">complexType</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">element</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br></pre></td></tr></table></figure><p>②：在需要编写的XML文件中导入该schema约束文档</p><p>③：按照约束内容编写XML文件的标签。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">xml<span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">书架</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.itcast.cn&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.itcast.cn data.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- xmlns=&quot;http://www.itcast.cn&quot;  基本位置</span></span><br><span class="line"><span class="comment">         xsi:schemaLocation=&quot;http://www.itcast.cn books02.xsd&quot; 具体的位置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">书</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">书名</span>&gt;</span>神雕侠侣<span class="tag">&lt;/<span class="name">书名</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">作者</span>&gt;</span>金庸<span class="tag">&lt;/<span class="name">作者</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">售价</span>&gt;</span>399.9<span class="tag">&lt;/<span class="name">售价</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">书</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">书</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">书名</span>&gt;</span>神雕侠侣<span class="tag">&lt;/<span class="name">书名</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">作者</span>&gt;</span>金庸<span class="tag">&lt;/<span class="name">作者</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">售价</span>&gt;</span>19.5<span class="tag">&lt;/<span class="name">售价</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">书</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">书架</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-XML解析技术"><a href="#2-XML解析技术" class="headerlink" title="2.XML解析技术"></a>2.XML解析技术</h3><h4 id="2-1XML解析技术概述"><a href="#2-1XML解析技术概述" class="headerlink" title="2.1XML解析技术概述"></a>2.1XML解析技术概述</h4><p>XML的数据的作用是什么，最终需要怎么处理？</p><ul><li><p>存储数据、做配置信息、进行数据传输。</p></li><li><p>最终需要被程序进行读取，解析里面的信息。</p></li></ul><p><strong>什么是XML解析</strong></p><ul><li>使用程序读取XML中的数据</li></ul><p><strong>两种解析方式</strong></p><ul><li><p>SAX解析</p></li><li><p>DOM解析</p></li></ul><p><strong>Dom常见的解析工具</strong></p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>JAXP</td><td>SUN公司提供的一套XML的解析的API</td></tr><tr><td>JDOM</td><td>JDOM是一个开源项目，它基于树型结构，利用纯JAVA的技术对XML文档实现解析、生成、序列化以及多种操作。</td></tr><tr><td><strong>dom4j</strong></td><td><strong>是JDOM的升级品，用来读写XML文件的。具有性能优异、功能强大和极其易使用的特点，它的性能超过sun公司官方的dom  技术，同时它也是一个开放源代码的软件，Hibernate也用它来读写配置文件。</strong></td></tr><tr><td>jsoup</td><td>功能强大DOM方式的XML解析开发包，尤其对HTML解析更加方便</td></tr></tbody></table><p><strong>DOM解析解析文档对象模型</strong></p><p>DOM（文档对象模型）是一种编程接口，用于在浏览器中操作和访问HTML、XML和SVG等文档的结构和内容。它将文档表示为一个树状结构，其中每个节点代表文档中的一个部分（如元素、属性、文本等）。通过DOM，开发人员可以使用编程语言（通常是JavaScript）来操作和修改文档的内容、结构和样式。</p><p>DOM解析是指将HTML或XML文档解析为DOM树的过程。解析器将原始的HTML或XML代码解析为一个由节点和属性组成的树状结构，使开发人员可以使用代码来访问和操作文档中的各个部分。</p><p>在JavaScript中，可以使用以下方法来解析和操作DOM：</p><ol><li><strong>获取元素：</strong> 通过使用选择器（如ID、类名、标签名等）来获取DOM中的元素，例如 <code>document.getElementById(&#39;elementId&#39;)</code>。</li><li><strong>操作元素内容：</strong> 通过属性或方法来修改元素的文本内容或HTML内容，例如 <code>element.textContent</code> 或 <code>element.innerHTML</code>。</li><li><strong>修改属性：</strong> 可以使用属性来读取或修改元素的属性，例如 <code>element.getAttribute(&#39;attributeName&#39;)</code> 和 <code>element.setAttribute(&#39;attributeName&#39;, &#39;value&#39;)</code>。</li><li><strong>创建新元素：</strong> 使用 <code>document.createElement(&#39;tagName&#39;)</code> 来创建新的DOM元素，并将其添加到文档中。</li><li><strong>添加和移除元素：</strong> 使用 <code>parentNode.appendChild(childNode)</code> 或 <code>parentNode.removeChild(childNode)</code> 来添加或移除子元素。</li><li><strong>事件处理：</strong> 通过将事件处理程序附加到元素上来响应用户操作，例如 <code>element.addEventListener(&#39;eventName&#39;, eventHandler)</code>。</li></ol><h4 id="2-2Dom4J解析XML文件"><a href="#2-2Dom4J解析XML文件" class="headerlink" title="2.2Dom4J解析XML文件"></a>2.2Dom4J解析XML文件</h4><p><strong>导包：</strong></p><p>①下载Dom4j框架，官网下载。</p><p>②在项目中创建一个文件夹：lib</p><p>③将dom4j-2.1.1.jar文件复制到 lib 文件夹</p><p>④在jar文件上点右键，选择 Add as Library -&gt; 点击OK</p><p>⑤在类中导包使用</p><p><strong>Dom4j解析XML-得到Document对象</strong></p><p><strong>SAXReader类</strong></p><table><thead><tr><th>构造器&#x2F;方法</th><th>说明</th></tr></thead><tbody><tr><td>public <strong>SAXReader</strong>()</td><td><strong>创建Dom4J的解析器对象</strong></td></tr><tr><td>Document  <strong>read</strong>(String url)</td><td><strong>加载XML文件成为Document对象</strong></td></tr></tbody></table><p><strong>Document类</strong></p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>Element <strong>getRootElement</strong>()</td><td><strong>获得根元素对象</strong></td></tr></tbody></table><p><strong>使用Dom4J解析出XML文件</strong></p><p><strong>需求：</strong>使用Dom4J把一个XML文件进行解析</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--创建xml文档--&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">contactList</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">contact</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span> <span class="attr">vip</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>   潘金莲  <span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">gender</span>&gt;</span>女<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">email</span>&gt;</span>panpan@itcast.cn<span class="tag">&lt;/<span class="name">email</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">contact</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">contact</span> <span class="attr">id</span>=<span class="string">&quot;2&quot;</span> <span class="attr">vip</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>武松<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">gender</span>&gt;</span>男<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">email</span>&gt;</span>wusong@itcast.cn<span class="tag">&lt;/<span class="name">email</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">contact</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">contact</span> <span class="attr">id</span>=<span class="string">&quot;3&quot;</span> <span class="attr">vip</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>武大狼<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">gender</span>&gt;</span>男<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">email</span>&gt;</span>wuda@itcast.cn<span class="tag">&lt;/<span class="name">email</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">contact</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">user</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">contactList</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   目标：学会使用dom4j解析XML文件中的数据。</span></span><br><span class="line"><span class="comment">    1、准备一个XML文件。</span></span><br><span class="line"><span class="comment">    2、导入dom4j框架。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dom4JHelloWorldDemo1</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parseXMLData</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建一个Dom4j的解析器对象，代表了整个dom4j框架</span></span><br><span class="line">        <span class="type">SAXReader</span> <span class="variable">saxReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、把XML文件加载到内存中成为一个Document文档对象</span></span><br><span class="line">        <span class="comment">// File相对路径，需要通过模块名去定位</span></span><br><span class="line">        <span class="comment">// Document document = saxReader.read(new File(&quot;xml-app\\src\\Contacts.xml&quot;)); </span></span><br><span class="line">        <span class="comment">// 字节输入流，需要通过模块名去定位</span></span><br><span class="line">        <span class="comment">// Document document = saxReader.read(new FileInputStream(&quot;xml-app\\src\\Contacts.xml&quot;));</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用Class类对象提供的方法getResourceAsStream(获取资源成为流)</span></span><br><span class="line">        <span class="comment">// 注意: getResourceAsStream中的/是直接去src下寻找的文件</span></span><br><span class="line">        <span class="comment">// a.将路径下的XML文件储存在流中</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> Dom4JHelloWorldDemo1.class.getResourceAsStream(<span class="string">&quot;/Contacts.xml&quot;</span>); <span class="comment">// 最优雅的写法</span></span><br><span class="line">        <span class="comment">// b.把流读到Document对象中</span></span><br><span class="line">        <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> saxReader.read(is); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3Dom4J解析XML文件中的各种节点"><a href="#2-3Dom4J解析XML文件中的各种节点" class="headerlink" title="2.3Dom4J解析XML文件中的各种节点"></a>2.3Dom4J解析XML文件中的各种节点</h4><p><strong>Dom4j解析XML的元素、属性、文本</strong></p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>List<Element> elements()</td><td>得到当前元素下所有子元素</td></tr><tr><td>List<Element>  elements(String name)</td><td>得到当前元素下指定名字的子元素返回集合</td></tr><tr><td>Element  element(String name)</td><td>得到当前元素下指定名字的子元素,如果有很多名字相同的返回第一个</td></tr><tr><td>String  getName()</td><td>得到元素名字</td></tr><tr><td>String attributeValue(String name)</td><td>通过属性名直接得到属性值</td></tr><tr><td>String  elementText(子元素名)</td><td>得到指定名称的子元素的文本</td></tr><tr><td>String  getText()</td><td>得到文本</td></tr></tbody></table><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--创建xml文档--&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">contactList</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">contact</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span> <span class="attr">vip</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>   潘金莲  <span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">gender</span>&gt;</span>女<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">email</span>&gt;</span>panpan@itcast.cn<span class="tag">&lt;/<span class="name">email</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">contact</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">contact</span> <span class="attr">id</span>=<span class="string">&quot;2&quot;</span> <span class="attr">vip</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>武松<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">gender</span>&gt;</span>男<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">email</span>&gt;</span>wusong@itcast.cn<span class="tag">&lt;/<span class="name">email</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">contact</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">contact</span> <span class="attr">id</span>=<span class="string">&quot;3&quot;</span> <span class="attr">vip</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>武大狼<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">gender</span>&gt;</span>男<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">email</span>&gt;</span>wuda@itcast.cn<span class="tag">&lt;/<span class="name">email</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">contact</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">user</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">contactList</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.dom4j.Attribute;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.Document;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.DocumentException;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.Element;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.io.SAXReader;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   目标：学会使用dom4j解析XML文件中的数据。</span></span><br><span class="line"><span class="comment">    1、准备一个XML文件。</span></span><br><span class="line"><span class="comment">    2、导入dom4j框架。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dom4JHelloWorldDemo1</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parseXMLData</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建一个Dom4j的解析器对象，代表了整个dom4j框架</span></span><br><span class="line">        <span class="type">SAXReader</span> <span class="variable">saxReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、把XML文件加载到内存流中,成为一个Document文档对象</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> Dom4JHelloWorldDemo1.class.getResourceAsStream(<span class="string">&quot;/Contacts.xml&quot;</span>);</span><br><span class="line">        <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> saxReader.read(is);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、获取根元素对象</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">root</span> <span class="operator">=</span> document.getRootElement();</span><br><span class="line">        System.out.println(root.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、拿根元素下的全部子元素对象(一级)</span></span><br><span class="line">        <span class="comment">// List&lt;Element&gt; sonEles =  root.elements();</span></span><br><span class="line">        List&lt;Element&gt; sonEles =  root.elements(<span class="string">&quot;contact&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Element sonEle : sonEles) &#123;</span><br><span class="line">            System.out.println(sonEle.getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拿某个子元素</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">userEle</span> <span class="operator">=</span> root.element(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        System.out.println(userEle.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 默认提取第一个子元素对象 (Java语言。)</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">contact</span> <span class="operator">=</span> root.element(<span class="string">&quot;contact&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取子元素文本</span></span><br><span class="line">        System.out.println(contact.elementText(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">        <span class="comment">// 去掉前后空格</span></span><br><span class="line">        System.out.println(contact.elementTextTrim(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">        <span class="comment">// 获取当前元素下的子元素对象</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">email</span> <span class="operator">=</span> contact.element(<span class="string">&quot;email&quot;</span>);</span><br><span class="line">        System.out.println(email.getText());</span><br><span class="line">        <span class="comment">// 去掉前后空格</span></span><br><span class="line">        System.out.println(email.getTextTrim());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据元素获取属性值</span></span><br><span class="line">        <span class="type">Attribute</span> <span class="variable">idAttr</span> <span class="operator">=</span> contact.attribute(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">        System.out.println(idAttr.getName() + <span class="string">&quot;--&gt;&quot;</span> + idAttr.getValue());</span><br><span class="line">        <span class="comment">// 直接提取属性值</span></span><br><span class="line">        System.out.println(contact.attributeValue(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">        System.out.println(contact.attributeValue(<span class="string">&quot;vip&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4Dom4J解析XML文件-案例实战"><a href="#2-4Dom4J解析XML文件-案例实战" class="headerlink" title="2.4Dom4J解析XML文件-案例实战"></a>2.4Dom4J解析XML文件-案例实战</h4><p><strong>XML解析案例：</strong></p><p><strong>需求:</strong></p><p>利用Dom4J的知识，将Contact.xml文件中的联系人数据封装成List集合，其中每个元素是实体类Contact。打印输出 List 中的每个元素。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 创建xml文档 (Contact.xml) --&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">contactList</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">contact</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span> <span class="attr">vip</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>   潘金莲  <span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">gender</span>&gt;</span>女<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">email</span>&gt;</span>panpan@itcast.cn<span class="tag">&lt;/<span class="name">email</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">contact</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">contact</span> <span class="attr">id</span>=<span class="string">&quot;2&quot;</span> <span class="attr">vip</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>武松<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">gender</span>&gt;</span>男<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">email</span>&gt;</span>wusong@itcast.cn<span class="tag">&lt;/<span class="name">email</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">contact</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">contact</span> <span class="attr">id</span>=<span class="string">&quot;3&quot;</span> <span class="attr">vip</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>武大狼<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">gender</span>&gt;</span>男<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">email</span>&gt;</span>wuda@itcast.cn<span class="tag">&lt;/<span class="name">email</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">contact</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">user</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">contactList</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.dom4j.Document;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.Element;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.io.SAXReader;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dom4JTest2</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parseToList</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 需求：解析XML中的数据成为一个List集合对象。</span></span><br><span class="line">        <span class="comment">// 1、导入框架（做过）</span></span><br><span class="line">        <span class="comment">// 2、创建SaxReader对象</span></span><br><span class="line">        <span class="type">SAXReader</span> <span class="variable">saxReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line">        <span class="comment">// 3、加载XML文件成为文档对象Document对象。</span></span><br><span class="line">        <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span></span><br><span class="line">                saxReader.read(Dom4JTest2.class.getResourceAsStream(<span class="string">&quot;/Contacts.xml&quot;</span>));</span><br><span class="line">        <span class="comment">// 4、先拿根元素</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">root</span> <span class="operator">=</span> document.getRootElement();</span><br><span class="line">        <span class="comment">// 5、提取contact子元素</span></span><br><span class="line">        List&lt;Element&gt; contactEles = root.elements(<span class="string">&quot;contact&quot;</span>);</span><br><span class="line">        <span class="comment">// 6、准备一个ArrayList集合封装联系人信息</span></span><br><span class="line">        List&lt;Contact&gt; contacts = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 7、遍历Contact子元素</span></span><br><span class="line">        <span class="keyword">for</span> (Element contactEle : contactEles) &#123;</span><br><span class="line">            <span class="comment">// 8、每个子元素都是一个联系人对象</span></span><br><span class="line">            <span class="type">Contact</span> <span class="variable">contact</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Contact</span>();</span><br><span class="line">            contact.setId(Integer.valueOf(contactEle.attributeValue(<span class="string">&quot;id&quot;</span>)));</span><br><span class="line">            contact.setVip(Boolean.valueOf(contactEle.attributeValue(<span class="string">&quot;vip&quot;</span>)));</span><br><span class="line">            contact.setName(contactEle.elementTextTrim(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">            contact.setGender(contactEle.elementTextTrim(<span class="string">&quot;gender&quot;</span>).charAt(<span class="number">0</span>));</span><br><span class="line">            contact.setEmail(contactEle.elementText(<span class="string">&quot;email&quot;</span>));</span><br><span class="line">            <span class="comment">// 9、把联系人对象数据加入到List集合</span></span><br><span class="line">            contacts.add(contact);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 10、遍历List集合</span></span><br><span class="line">        <span class="keyword">for</span> (Contact contact : contacts) &#123;</span><br><span class="line">            System.out.println(contact);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-XML检索技术：Xpath"><a href="#3-XML检索技术：Xpath" class="headerlink" title="3.XML检索技术：Xpath"></a>3.XML检索技术：Xpath</h3><p>如果需要从XML文件中检索需要的某个信息（如name）怎么解决？</p><ul><li><p>Dom4j需要进行文件的全部解析，然后再寻找数据。</p></li><li><p><strong>Xpath技术更加适合做信息检索。</strong></p></li></ul><p><strong>XPath介绍</strong></p><ul><li><p>XPath在解析XML文档方面提供了一独树一帜的路径思想，更加优雅，高效</p></li><li><p>XPath使用路径表达式来定位XML文档中的元素节点或属性节点。</p></li><li><p><em><strong>导入jar包(dom4j和jaxen-1.1.2.jar)<strong>，</strong>Xpath技术依赖Dom4j技术</strong></em></p></li></ul><p><strong>使用Xpath检索出XML文件</strong></p><p><strong>需求：</strong></p><p>使用Dom4J把一个XML文件的数据进行解析</p><p><strong>分析：</strong></p><p>①导入jar包(dom4j和jaxen-1.1.2.jar)，Xpath技术依赖Dom4j技术</p><p>②通过dom4j的SAXReader获取Document对象</p><p>③利用XPath提供的API,结合XPath的语法完成选取XML文档元素节点进行解析操作。</p><p>④Document中与Xpath相关的API如下：</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>Node  <strong>selectSingleNode</strong>(“表达式”)</td><td><strong>获取符合表达式的唯一元素</strong></td></tr><tr><td>List<Node> <strong>selectNodes</strong>(“表达式”)</td><td><strong>获取符合表达式的元素集合</strong></td></tr></tbody></table><p><strong>Xpath的四大检索方案</strong></p><p><strong>绝对路径</strong></p><ul><li>采用绝对路径获取从根节点开始逐层的查找&#x2F;contactList&#x2F;contact&#x2F;name节点列表并打印信息</li></ul><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>&#x2F;根元素&#x2F;子元素&#x2F;孙元素</td><td>从根元素开始，一级一级向下查找，不能跨级</td></tr></tbody></table><p><strong>相对路径</strong></p><ul><li>先得到根节点contactList</li></ul><p>l再采用相对路径获取下一级contact 节点的name子节点并打印信息</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>.&#x2F;子元素&#x2F;孙元素</td><td>从当前元素开始，一级一级向下查找，不能跨级</td></tr></tbody></table><p><strong>全文检索</strong></p><ul><li>直接全文搜索所有的name元素并打印</li></ul><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>&#x2F;&#x2F;contact</td><td>找contact元素，无论元素在哪里</td></tr><tr><td>&#x2F;&#x2F;contact&#x2F;name</td><td>找contact，无论在哪一级，但name一定是contact的子节点</td></tr><tr><td>&#x2F;&#x2F;contact&#x2F;&#x2F;name</td><td>contact无论在哪一种，name只要是contact的子孙元素都可以找到</td></tr></tbody></table><p><strong>属性查找</strong></p><ul><li>在全文中搜索属性，或者带属性的元素</li></ul><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>&#x2F;&#x2F;@属性名</td><td>查找属性对象，无论是哪个元素，只要有这个属性即可。</td></tr><tr><td>&#x2F;&#x2F;元素[@属性名]</td><td>查找元素对象，全文搜索指定元素名和属性名。</td></tr><tr><td>&#x2F;&#x2F;元素&#x2F;&#x2F;[@属性名&#x3D;‘值’]</td><td>查找元素对象，全文搜索指定元素名和属性名，并且属性值相等。</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：XPath检索XML中的信息啊。(了解)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    引入：</span></span><br><span class="line"><span class="comment">        Dom4J可以用于解析整个XML的数据。</span></span><br><span class="line"><span class="comment">        但是如果要检索XML中的某些信息，建议使用XPath.（Xpath依赖Dom4j技术）</span></span><br><span class="line"><span class="comment">        Dom4J用于解析数据，Xpath用于检索数据。</span></span><br><span class="line"><span class="comment">    XPath使用步骤：</span></span><br><span class="line"><span class="comment">        1.导入dom4j框架。（XPath依赖于Dom4j技术,必须先导入dom4j框架！）</span></span><br><span class="line"><span class="comment">        2.导入XPath独有的框架包。jaxen-1.1.2.jar</span></span><br><span class="line"><span class="comment">    XPath常用API:</span></span><br><span class="line"><span class="comment">        List&lt;Node&gt; selectNodes(String var1):检索出一批节点集合。</span></span><br><span class="line"><span class="comment">        Node selectSingleNode(String var1)：检索出一个节点返回。</span></span><br><span class="line"><span class="comment">    XPath提供的四种检索数据的写法：</span></span><br><span class="line"><span class="comment">        1.绝对路径。</span></span><br><span class="line"><span class="comment">        2.相对路径。</span></span><br><span class="line"><span class="comment">        3.全文搜索。</span></span><br><span class="line"><span class="comment">        4.属性查找。</span></span><br><span class="line"><span class="comment">    小结：</span></span><br><span class="line"><span class="comment">         1.绝对路径： /根元素/子元素/子元素。</span></span><br><span class="line"><span class="comment">         2.相对路径： ./子元素/子元素。 (.代表了当前元素)</span></span><br><span class="line"><span class="comment">         3.全文搜索：</span></span><br><span class="line"><span class="comment">                //元素  在全文找这个元素</span></span><br><span class="line"><span class="comment">                //元素1/元素2  在全文找元素1下面的一级元素2</span></span><br><span class="line"><span class="comment">                //元素1//元素2  在全文找元素1下面的全部元素2</span></span><br><span class="line"><span class="comment">         4.属性查找。</span></span><br><span class="line"><span class="comment">                //@属性名称  在全文检索属性对象。</span></span><br><span class="line"><span class="comment">                //元素[@属性名称]  在全文检索包含该属性的元素对象。</span></span><br><span class="line"><span class="comment">                //元素[@属性名称=值]  在全文检索包含该属性的元素且属性值为该值的元素对象。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XPathDemo</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     1.绝对路径: /根元素/子元素/子元素。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parse01</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// a、创建解析器对象</span></span><br><span class="line">        <span class="type">SAXReader</span> <span class="variable">saxReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line">        <span class="comment">// b、把XML加载成Document文档对象</span></span><br><span class="line">        <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span></span><br><span class="line">                saxReader.read(XPathDemo.class.getResourceAsStream(<span class="string">&quot;/Contacts2.xml&quot;</span>));</span><br><span class="line">        <span class="comment">// c、检索全部的名称</span></span><br><span class="line">        List&lt;Node&gt; nameNodes = document.selectNodes(<span class="string">&quot;/contactList/contact/name&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Node nameNode : nameNodes) &#123;</span><br><span class="line">            <span class="type">Element</span>  <span class="variable">nameEle</span> <span class="operator">=</span> (Element) nameNode;</span><br><span class="line">            System.out.println(nameEle.getTextTrim());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     2.相对路径： ./子元素/子元素。 (.代表了当前元素)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parse02</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// a、创建解析器对象</span></span><br><span class="line">        <span class="type">SAXReader</span> <span class="variable">saxReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line">        <span class="comment">// b、把XML加载成Document文档对象</span></span><br><span class="line">        <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span></span><br><span class="line">                saxReader.read(XPathDemo.class.getResourceAsStream(<span class="string">&quot;/Contacts2.xml&quot;</span>));</span><br><span class="line">        <span class="type">Element</span> <span class="variable">root</span> <span class="operator">=</span> document.getRootElement();</span><br><span class="line">        <span class="comment">// c、检索全部的名称</span></span><br><span class="line">        List&lt;Node&gt; nameNodes = root.selectNodes(<span class="string">&quot;./contact/name&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Node nameNode : nameNodes) &#123;</span><br><span class="line">            <span class="type">Element</span>  <span class="variable">nameEle</span> <span class="operator">=</span> (Element) nameNode;</span><br><span class="line">            System.out.println(nameEle.getTextTrim());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     3.全文搜索：</span></span><br><span class="line"><span class="comment">     //元素  在全文找这个元素</span></span><br><span class="line"><span class="comment">     //元素1/元素2  在全文找元素1下面的一级元素2</span></span><br><span class="line"><span class="comment">     //元素1//元素2  在全文找元素1下面的全部元素2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parse03</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// a、创建解析器对象</span></span><br><span class="line">        <span class="type">SAXReader</span> <span class="variable">saxReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line">        <span class="comment">// b、把XML加载成Document文档对象</span></span><br><span class="line">        <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span></span><br><span class="line">                saxReader.read(XPathDemo.class.getResourceAsStream(<span class="string">&quot;/Contacts2.xml&quot;</span>));</span><br><span class="line">        <span class="comment">// c、检索数据</span></span><br><span class="line">        <span class="comment">//List&lt;Node&gt; nameNodes = document.selectNodes(&quot;//name&quot;);</span></span><br><span class="line">        <span class="comment">// List&lt;Node&gt; nameNodes = document.selectNodes(&quot;//contact/name&quot;);</span></span><br><span class="line">        List&lt;Node&gt; nameNodes = document.selectNodes(<span class="string">&quot;//contact//name&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Node nameNode : nameNodes) &#123;</span><br><span class="line">            <span class="type">Element</span>  <span class="variable">nameEle</span> <span class="operator">=</span> (Element) nameNode;</span><br><span class="line">            System.out.println(nameEle.getTextTrim());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     4.属性查找。</span></span><br><span class="line"><span class="comment">     //@属性名称  在全文检索属性对象。</span></span><br><span class="line"><span class="comment">     //元素[@属性名称]  在全文检索包含该属性的元素对象。</span></span><br><span class="line"><span class="comment">     //元素[@属性名称=值]  在全文检索包含该属性的元素且属性值为该值的元素对象。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parse04</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// a、创建解析器对象</span></span><br><span class="line">        <span class="type">SAXReader</span> <span class="variable">saxReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line">        <span class="comment">// b、把XML加载成Document文档对象</span></span><br><span class="line">        <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span></span><br><span class="line">                saxReader.read(XPathDemo.class.getResourceAsStream(<span class="string">&quot;/Contacts2.xml&quot;</span>));</span><br><span class="line">        <span class="comment">// c、检索数据</span></span><br><span class="line">        List&lt;Node&gt; nodes = document.selectNodes(<span class="string">&quot;//@id&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Node node : nodes) &#123;</span><br><span class="line">            <span class="type">Attribute</span> <span class="variable">attr</span> <span class="operator">=</span> (Attribute) node;</span><br><span class="line">            System.out.println(attr.getName() + <span class="string">&quot;===&gt;&quot;</span> + attr.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查询name元素（包含id属性的）</span></span><br><span class="line"><span class="comment">//      Node node = document.selectSingleNode(&quot;//name[@id]&quot;);</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> document.selectSingleNode(<span class="string">&quot;//name[@id=888]&quot;</span>);</span><br><span class="line">        <span class="type">Element</span> <span class="variable">ele</span> <span class="operator">=</span> (Element) node;</span><br><span class="line">        System.out.println(ele.getTextTrim());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-设计模式：工厂模式-代理创造对象"><a href="#4-设计模式：工厂模式-代理创造对象" class="headerlink" title="4.设计模式：工厂模式(代理创造对象)"></a>4.设计模式：工厂模式(代理创造对象)</h3><p><strong>什么是工厂设计模式？</strong></p><ul><li><p>之前我们创建类对象时, 都是使用new 对象的形式创建,在很多业务场景下也提供了不直接new的方式 。</p></li><li><p>工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一， 这种类型的设计模式属于创建型模式，它提供了一种获取对象的方式。</p></li><li><p>之前我们创建类对象时, 都是使用new 对象的形式创建, 除new 对象方式以外，工厂模式也可以创建对象。</p></li></ul><p><strong>工厂设计模式的作用：</strong></p><ul><li>工厂的方法可以封装对象的创建细节，比如：为该对象进行加工和数据注入。</li><li>可以实现类与类之间的解耦操作（核心思想，重点）。</li></ul><p><strong>代码：模仿设计工厂模式</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义电脑抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getPrice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPrice</span><span class="params">(<span class="type">double</span> price)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//电脑对象1实现抽象方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Huawei</span> <span class="keyword">extends</span> <span class="title class_">Computer</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(getName() + <span class="string">&quot;开机了，展示了华为的菊花图标~~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//电脑对象2实现抽象方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mac</span> <span class="keyword">extends</span> <span class="title class_">Computer</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(getName() + <span class="string">&quot;以非常优雅的方法启动了，展示了一个苹果logo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义工厂类，提供一个工厂方法返回对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FactoryPattern</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">       定义一个方法，创建对象返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Computer <span class="title function_">createComputer</span><span class="params">(String info)</span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (info)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;huawei&quot;</span>:</span><br><span class="line">                <span class="type">Computer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Huawei</span>();</span><br><span class="line">                c.setName(<span class="string">&quot;huawei pro 16&quot;</span>);</span><br><span class="line">                c.setPrice(<span class="number">5999</span>);</span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;mac&quot;</span>:</span><br><span class="line">                <span class="type">Computer</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Mac</span>();</span><br><span class="line">                c2.setName(<span class="string">&quot;MacBook pro&quot;</span>);</span><br><span class="line">                c2.setPrice(<span class="number">11999</span>);</span><br><span class="line">                <span class="keyword">return</span> c2;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：工厂模式。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FactoryDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Computer</span> <span class="variable">c1</span> <span class="operator">=</span> FactoryPattern.createComputer(<span class="string">&quot;huawei&quot;</span>); <span class="comment">// 调用工厂类的工厂方法，返回指定对象</span></span><br><span class="line">        c1.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">Computer</span> <span class="variable">c2</span> <span class="operator">=</span> FactoryPattern.createComputer(<span class="string">&quot;mac&quot;</span>);</span><br><span class="line">        c2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-设计模式：装饰模式-构造器层层包装"><a href="#5-设计模式：装饰模式-构造器层层包装" class="headerlink" title="5.设计模式：装饰模式(构造器层层包装)"></a>5.设计模式：装饰模式(构造器层层包装)</h3><p><strong>什么是装饰设计模式？</strong></p><ul><li>创建一个新类，包装原始类，从而在新类中提升原来类的功能。</li></ul><p><strong>装饰设计模式的作用：</strong></p><ul><li>作用：装饰模式指的是在不改变原类的基础上, 动态地扩展一个类的功能。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">InputStream(抽象父类)</span><br><span class="line">FileInputStream(实现子类，读写性能较差)</span><br><span class="line">BufferedInputStream(实现子类，装饰类，读写性能高)</span><br></pre></td></tr></table></figure><p><strong>设计过程说明：</strong></p><p>①定义父类。</p><p>②定义原始类，继承父类，定义功能。</p><p>③定义装饰类，继承父类，包装原始类，增强功能！！</p><p><strong>代码：模拟装饰模式</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   使用抽象类，定义共同父类(InputStream),提供抽象方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">InputStream</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">byte</span>[] buffer)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   定义原始类(FileInputStream)继承父类(InputStream)，设计原始方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileInputStream</span> <span class="keyword">extends</span> <span class="title class_">InputStream</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;低性能的方式读取了一个字节a&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">97</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">byte</span>[] buffer)</span> &#123;</span><br><span class="line">        buffer[<span class="number">0</span>] = <span class="number">97</span>;</span><br><span class="line">        buffer[<span class="number">1</span>] = <span class="number">98</span>;</span><br><span class="line">        buffer[<span class="number">2</span>] = <span class="number">99</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;低性能的方式读取了一个字节数组：&quot;</span> + Arrays.toString(buffer));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   定义装饰类，继承父类(InputStream) 拓展原始类的功能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedInputStream</span> <span class="keyword">extends</span> <span class="title class_">InputStream</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> InputStream is;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BufferedInputStream</span><span class="params">(InputStream is)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.is = is;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;提供8KB的缓冲区，提高读数据性能~~~~&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> is.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">byte</span>[] buffer)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;提供8KB的缓冲区，提高读数据性能~~~~&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> is.read(buffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  装饰模式模拟实现</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    1.定义父类：InputStream</span></span><br><span class="line"><span class="comment">    2.定义实现类：FileInputStream 继续父类 定义功能</span></span><br><span class="line"><span class="comment">    3.定义装饰实现类：BufferedInputStream 继承父类 定义功能 包装原始类，增强功能。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DecoratorPattern</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>());</span><br><span class="line">        System.out.println(is.read());</span><br><span class="line">        System.out.println(is.read(<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">3</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> java,面向对象进阶,XML,xml解析,工厂模式,装饰模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>day22 - 单元测试、反射、注解、动态代理</title>
      <link href="/post/a44e5d86.html"/>
      <url>/post/a44e5d86.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-单元测试"><a href="#1-单元测试" class="headerlink" title="1.单元测试"></a>1.单元测试</h3><h4 id="1-1单元测试概述"><a href="#1-1单元测试概述" class="headerlink" title="1.1单元测试概述"></a>1.1单元测试概述</h4><p><strong>单元测试</strong></p><ul><li>单元测试就是针对最小的功能单元编写测试代码，Java程序最小的功能单元是方法，因此，单元测试就是针对Java方法的测试，进而检查方法的正确性。</li></ul><p><strong>目前测试方法是怎么进行的，存在什么问题</strong></p><ul><li><p>只有一个main方法，如果一个方法的测试失败了，其他方法测试会受到影响。</p></li><li><p>无法得到测试的结果报告，需要程序员自己去观察测试是否成功。</p></li><li><p>无法实现自动化测试。</p></li></ul><p><strong>Junit单元测试框架</strong></p><ul><li><p>JUnit是使用Java语言实现的单元测试框架，它是开源的，Java开发者都应当学习并使用JUnit编写单元测试。</p></li><li><p>此外，几乎所有的IDE工具都集成了JUnit，这样我们就可以直接在IDE中编写并运行JUnit测试，JUnit目前最新版本是5。</p></li></ul><p><strong>JUnit优点</strong></p><ul><li><p>JUnit可以灵活的选择执行哪些测试方法，可以一键执行全部测试方法。</p></li><li><p>Junit可以生成全部方法的测试报告。</p></li><li><p>单元测试中的某个方法测试失败了，不会影响其他测试方法的测试。</p></li></ul><h4 id="1-2单元测试快速入门"><a href="#1-2单元测试快速入门" class="headerlink" title="1.2单元测试快速入门"></a>1.2单元测试快速入门</h4><p><strong>需求：</strong></p><p>使用单元测试进行业务方法预期结果、正确性测试的快速入门</p><p><strong>分析：</strong></p><ul><li><p>①将JUnit的jar包导入到项目中</p><ul><li>IDEA通常整合好了Junit框架，一般不需要导入。</li><li>如果IDEA没有整合好，需要自己手工导入如下2个JUnit的jar包到模块</li></ul></li><li><p>②编写测试方法：该测试方法必须是<strong>公共的无参数无返回值的非静态方法</strong>。</p></li><li><p>③在测试方法上<strong>使用@Test注解</strong>：标注该方法是一个测试方法</p></li><li><p>④在测试方法中完成被测试方法的预期正确性测试。</p></li><li><p>⑤选中测试方法，选择“JUnit运行” ，如果<strong>测试良好</strong>则是<strong>绿色</strong>；如果<strong>测试失败</strong>，则是<strong>红色</strong></p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   业务方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">loginName</span><span class="params">(String loginName , String passWord)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;admin&quot;</span>.equals(loginName) &amp;&amp; <span class="string">&quot;123456&quot;</span>.equals(passWord))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;登录成功&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;用户名或者密码有问题&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">selectNames</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="number">10</span>/<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;查询全部用户名称成功~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestUserService</span> &#123;</span><br><span class="line">    <span class="comment">// 修饰实例方法的</span></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===before方法执行一次===&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===after方法执行一次===&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修饰静态方法</span></span><br><span class="line">    <span class="meta">@BeforeClass</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">beforeClass</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===beforeClass方法执行一次===&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterClass</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">afterClass</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===afterClass方法执行一次===&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">       测试方法</span></span><br><span class="line"><span class="comment">       注意点：</span></span><br><span class="line"><span class="comment">            1、必须是公开的，无参数 无返回值的方法</span></span><br><span class="line"><span class="comment">            2、测试方法必须使用<span class="doctag">@Test</span>注解标记。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLoginName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//1.使用业务创建对象</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserService</span>(); </span><br><span class="line">        <span class="comment">//2.用对象调用需要测试的方法</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> userService.loginName(<span class="string">&quot;admin&quot;</span>,<span class="string">&quot;123456&quot;</span>); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进行预期结果的正确性测试：断言。</span></span><br><span class="line">        Assert.assertEquals(<span class="string">&quot;您的登录业务可能出现问题&quot;</span>, <span class="string">&quot;登录成功&quot;</span>, rs );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectNames</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserService</span>();</span><br><span class="line">        userService.selectNames();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3单元测试常用注解"><a href="#1-3单元测试常用注解" class="headerlink" title="1.3单元测试常用注解"></a>1.3单元测试常用注解</h4><p><strong>Junit常用注解(Junit 4.xxxx版本)</strong></p><table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td>@Test</td><td>测试方法</td></tr><tr><td>@Before</td><td>用来修饰实例方法，该方法会在每一个测试方法执行之前执行一次。</td></tr><tr><td>@After</td><td>用来修饰实例方法，该方法会在每一个测试方法执行之后执行一次。</td></tr><tr><td>@BeforeClass</td><td>用来静态修饰方法，该方法会在所有测试方法之前只执行一次。</td></tr><tr><td>@AfterClass</td><td>用来静态修饰方法，该方法会在所有测试方法之后只执行一次。</td></tr></tbody></table><ul><li><p>开始执行的方法:初始化资源。</p></li><li><p>执行完之后的方法:释放资源。</p></li></ul><p><strong>Junit常用注解(Junit 5.xxxx版本)</strong></p><table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td>@Test</td><td>测试方法</td></tr><tr><td>@BeforeEach</td><td>用来修饰实例方法，该方法会在每一个测试方法执行之前执行一次。</td></tr><tr><td>@AfterEach</td><td>用来修饰实例方法，该方法会在每一个测试方法执行之后执行一次。</td></tr><tr><td>@BeforeAll</td><td>用来静态修饰方法，该方法会在所有测试方法之前只执行一次。</td></tr><tr><td>@AfterAll</td><td>用来静态修饰方法，该方法会在所有测试方法之后只执行一次。</td></tr></tbody></table><ul><li><p>开始执行的方法:初始化资源。</p></li><li><p>执行完之后的方法:释放资源。</p></li></ul><h3 id="2-反射"><a href="#2-反射" class="headerlink" title="2.反射"></a>2.反射</h3><h4 id="2-1反射概述"><a href="#2-1反射概述" class="headerlink" title="2.1反射概述"></a>2.1反射概述</h4><p><strong>反射概述</strong></p><ul><li><p>反射是指对于任何一个Class类，在”运行的时候”都可以直接得到这个类全部成分。</p></li><li><p>在运行时,可以直接得到这个类的构造器对象：Constructor</p></li><li><p>在运行时,可以直接得到这个类的成员变量对象：Field</p></li><li><p>在运行时,可以直接得到这个类的成员方法对象：Method</p></li><li><p>这种运行时动态获取类信息以及动态调用类中成分的能力称为Java语言的反射机制。</p></li></ul><p><strong>反射的关键：</strong></p><ul><li>反射的第一步都是先得到编译后的Class类对象，然后就可以得到Class的全部成分。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HelloWorld.java -&gt; javac -&gt; HelloWorld.class</span><br><span class="line">Class c = HelloWorld.class;</span><br></pre></td></tr></table></figure><h4 id="2-2反射获取类对象"><a href="#2-2反射获取类对象" class="headerlink" title="2.2反射获取类对象"></a>2.2反射获取类对象</h4><p><strong>获取Class类的对象的三种方法</strong></p><p><strong>使用对象的getClass()方法</strong>：如果已经有一个对象，可以使用该对象的getClass()方法来获取它的Class类对象。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javaCopy <span class="type">codeMyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">Class&lt;?&gt; clazz = obj.getClass();</span><br></pre></td></tr></table></figure><p><strong>使用类的.class属性</strong>：每个类都有一个特殊的属性，通过在类名后面加上”.class”来获取该类的Class类对象。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javaCopy code</span><br><span class="line">Class&lt;?&gt; clazz = MyClass.class;</span><br></pre></td></tr></table></figure><p><strong>使用Class类的forName()方法</strong>：可以通过提供类的全限定名（包括包名）来使用Class类的forName()方法来获取Class类对象。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javaCopy code</span><br><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.example.MyClass&quot;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个学生类</span></span><br><span class="line"><span class="keyword">package</span> com.itheima.d2_reflect_class;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   目标：反射的第一步：获取学生类的Class对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、Class类中的一个静态方法：forName(全限名：包名 + 类名)</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.itheima.d2_reflect_class.Student&quot;</span>);</span><br><span class="line">        System.out.println(c); <span class="comment">// Student.class</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、类名.class (常用)</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> Student.class;</span><br><span class="line">        System.out.println(c1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、对象.getClass() 获取对象对应类的Class对象。</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        <span class="type">Class</span> <span class="variable">c2</span> <span class="operator">=</span> s.getClass();</span><br><span class="line">        System.out.println(c2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3反射获取构造器对象"><a href="#2-3反射获取构造器对象" class="headerlink" title="2.3反射获取构造器对象"></a>2.3反射获取构造器对象</h4><p><strong>使用反射技术获取构造器对象并使用</strong></p><p>反射是一种在运行时检查、访问和操作类、接口、字段、方法等程序元素的能力。在Java中，您可以使用反射技术来获取构造器对象并使用它来创建新的实例。下面是一个使用反射获取构造器对象并创建实例的示例：</p><p>假设有一个类 <code>Person</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javaCopy codepublic <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">introduce</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, I&#x27;m &quot;</span> + name + <span class="string">&quot; and I&#x27;m &quot;</span> + age + <span class="string">&quot; years old.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用以下代码来使用反射获取构造器对象并创建 <code>Person</code> 类的实例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javaCopy code<span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectionExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取Person类的Class对象</span></span><br><span class="line">        Class&lt;Person&gt; personClass = Person.class;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取带有两个参数的构造器</span></span><br><span class="line">        Constructor&lt;Person&gt; constructor = personClass.getConstructor(String.class, <span class="type">int</span>.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用构造器创建实例</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> constructor.newInstance(<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用实例方法</span></span><br><span class="line">        person.introduce();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用反射技术获取构造器对象并使用</strong></p><ul><li><p>反射的第一步是先得到类对象，然后从类对象中获取类的成分对象。</p></li><li><p>Class类中用于获取构造器的方法</p></li><li><p>获取构造器的作用依然是初始化一个对象返回。</p></li></ul><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>Constructor&lt;?&gt;[]  <strong>getConstructors</strong>()</td><td>返回<strong>所有 public</strong> 修饰的构造器对象的数组</td></tr><tr><td>Constructor&lt;?&gt;[]  <strong>getDeclaredConstructors</strong>()</td><td>返回<strong>所有构造器对象</strong>的数组，存在就能拿到</td></tr><tr><td>Constructor<T>  <strong>getConstructor</strong>(Class&lt;?&gt;…  parameterTypes)</td><td>返回<strong>单个 public</strong> 修饰构造器对象</td></tr><tr><td>Constructor<T>  <strong>getDeclaredConstructor</strong>(Class&lt;?&gt;…  parameterTypes)</td><td>返回<strong>单个构造器对象</strong>，存在就能拿到</td></tr></tbody></table><p><strong>Constructor类中用于创建对象的方法</strong></p><table><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody><tr><td>T <strong>newInstance</strong>(Object…  initargs)</td><td>根据指定的构造器创建对象</td></tr><tr><td>public  void <strong>setAccessible</strong>(boolean  flag)</td><td>设置为true,表示取消访问检查，进行暴力反射</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个学生类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Student</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;无参数构造器执行！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;有参数构造器执行！&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>获取<Constructor>构造器对象</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：反射_获取&lt;Constructor&gt;构造器对象.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    反射的第一步是先得到Class类对象。（Class文件）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">小结：</span></span><br><span class="line"><span class="comment">        2获取类的全部构造器对象： Constructor[] getDeclaredConstructors()</span></span><br><span class="line"><span class="comment">            -- 获取所有申明的构造器，只要你写我就能拿到，无所谓权限。建议使用！</span></span><br><span class="line"><span class="comment">        4获取类的某个构造器对象：Constructor getDeclaredConstructor(Class... parameterTypes)</span></span><br><span class="line"><span class="comment">            -- 根据参数匹配获取某个构造器，只要申明就可以定位，不关心权限修饰符，建议使用！</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStudent01</span> &#123;</span><br><span class="line">    <span class="comment">// 1. getConstructors</span></span><br><span class="line">    <span class="comment">//获取全部的构造器：只能获取public修饰的构造器。</span></span><br><span class="line">    <span class="comment">// Constructor[] - getConstructors()</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getConstructors</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// a.第一步：获取类对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Student.class;</span><br><span class="line">        <span class="comment">// b.提取类中的全部的构造器对象(这里只能拿public修饰)</span></span><br><span class="line">        Constructor[] constructors = c.getConstructors();</span><br><span class="line">        <span class="comment">// c.遍历构造器</span></span><br><span class="line">        <span class="keyword">for</span> (Constructor constructor : constructors) &#123;</span><br><span class="line">            System.out.println(constructor.getName() + <span class="string">&quot;===&gt;&quot;</span> + constructor.getParameterCount());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.getDeclaredConstructors():</span></span><br><span class="line">    <span class="comment">// 获取全部的构造器数组：只要你敢写，这里就能拿到，无所谓权限是否可及。</span></span><br><span class="line">    <span class="comment">//Constructor[] - getDeclaredConstructors()</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getDeclaredConstructors</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// a.第一步：获取类对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Student.class;</span><br><span class="line">        <span class="comment">// b.提取类中的全部的构造器对象</span></span><br><span class="line">        Constructor[] constructors = c.getDeclaredConstructors();</span><br><span class="line">        <span class="comment">// c.遍历构造器</span></span><br><span class="line">        <span class="keyword">for</span> (Constructor constructor : constructors) &#123;</span><br><span class="line">            System.out.println(constructor.getName() + <span class="string">&quot;===&gt;&quot;</span> + constructor.getParameterCount());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.getConstructor(Class... parameterTypes)</span></span><br><span class="line">    <span class="comment">// 获取某个构造器：只能拿public修饰的某个构造器</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getConstructor</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// a.第一步：获取类对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Student.class;</span><br><span class="line">        <span class="comment">// b.定位单个构造器对象 (按照参数定位无参数构造器 只能拿public修饰的某个构造器)</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">cons</span> <span class="operator">=</span> c.getConstructor();</span><br><span class="line">        System.out.println(cons.getName() + <span class="string">&quot;===&gt;&quot;</span> + cons.getParameterCount());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.getConstructor(Class... parameterTypes)</span></span><br><span class="line">    <span class="comment">// 获取某个构造器：只要你敢写，这里就能拿到，无所谓权限是否可及。</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getDeclaredConstructor</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// a.第一步：获取类对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Student.class;</span><br><span class="line">        <span class="comment">// b.定位单个构造器对象 (按照参数定位无参数构造器)</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">cons</span> <span class="operator">=</span> c.getDeclaredConstructor();</span><br><span class="line">        System.out.println(cons.getName() + <span class="string">&quot;===&gt;&quot;</span> + cons.getParameterCount());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// c.定位某个有参构造器</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">cons1</span> <span class="operator">=</span> c.getDeclaredConstructor(String.class, <span class="type">int</span>.class);</span><br><span class="line">        System.out.println(cons1.getName() + <span class="string">&quot;===&gt;&quot;</span> + cons1.getParameterCount());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><Constructor>构造器初始化对象</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标: 反射_获取Constructor构造器然后通过这个构造器初始化对象。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    反射获取Class中的构造器对象Constructor作用：</span></span><br><span class="line"><span class="comment">            也是初始化并得到类的一个对象返回。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Constructor的API:</span></span><br><span class="line"><span class="comment">         1. T newInstance(Object... initargs)</span></span><br><span class="line"><span class="comment">                创建对象，注入构造器需要的数据。</span></span><br><span class="line"><span class="comment">         2. void setAccessible(true)</span></span><br><span class="line"><span class="comment">                修改访问权限，true代表暴力攻破权限，false表示保留不可访问权限(暴力反射)</span></span><br><span class="line"><span class="comment">    小结：</span></span><br><span class="line"><span class="comment">        可以通过定位类的构造器对象。</span></span><br><span class="line"><span class="comment">        如果构造器对象没有访问权限可以通过：void setAccessible(true)打开权限</span></span><br><span class="line"><span class="comment">        构造器可以通过T newInstance(Object... initargs)调用自己，传入参数！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStudent02</span> &#123;</span><br><span class="line">    <span class="comment">// 1.调用构造器得到一个类的对象返回。</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getDeclaredConstructor</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// a.第一步：获取类对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Student.class;</span><br><span class="line">        <span class="comment">// b.定位单个构造器对象 </span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">cons</span> <span class="operator">=</span> c.getDeclaredConstructor(); <span class="comment">//按照参数定位无参数构造器</span></span><br><span class="line">        System.out.println(cons.getName() + <span class="string">&quot;===&gt;&quot;</span> + cons.getParameterCount());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果遇到了私有的构造器，可以暴力反射</span></span><br><span class="line">        cons.setAccessible(<span class="literal">true</span>); <span class="comment">// 权限被打开</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> (Student) cons.newInstance(); <span class="comment">//创建无参构造器对象</span></span><br><span class="line">        System.out.println(s);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// c.定位某个有参构造器</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">cons1</span> <span class="operator">=</span> c.getDeclaredConstructor(String.class, <span class="type">int</span>.class); <span class="comment">//按照参数定位有参构造器</span></span><br><span class="line">        System.out.println(cons1.getName() + <span class="string">&quot;===&gt;&quot;</span> + cons1.getParameterCount());</span><br><span class="line"></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> (Student) cons1.newInstance(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">1000</span>); <span class="comment">//创建有参构造器对象</span></span><br><span class="line">        System.out.println(s1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4反射获取成员变量对象"><a href="#2-4反射获取成员变量对象" class="headerlink" title="2.4反射获取成员变量对象"></a>2.4反射获取成员变量对象</h4><p><strong>使用反射技术获取成员变量对象并使用</strong></p><p>假设有一个名为<code>Person</code>的类，其中包含一个成员变量<code>name</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javaCopy codepublic <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用反射来获取并操作<code>Person</code>类的成员变量<code>name</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javaCopy code<span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectionExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line">        <span class="comment">// 创建一个Person对象</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取Person类的Class对象</span></span><br><span class="line">        Class&lt;Person&gt; personClass = Person.class;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取名为 &quot;name&quot; 的成员变量</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">nameField</span> <span class="operator">=</span> personClass.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置允许访问私有字段</span></span><br><span class="line">        nameField.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取字段的值</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">nameValue</span> <span class="operator">=</span> (String) nameField.get(person);</span><br><span class="line">            System.out.println(<span class="string">&quot;Original Name: &quot;</span> + nameValue);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 修改字段的值</span></span><br><span class="line">            nameField.set(person, <span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">newNameValue</span> <span class="operator">=</span> (String) nameField.get(person);</span><br><span class="line">            System.out.println(<span class="string">&quot;New Name: &quot;</span> + newNameValue);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用反射技术获取成员变量对象并使用</strong></p><ul><li><p>反射的第一步是先得到类对象，然后从类对象中获取类的成分对象。</p></li><li><p>Class类中用于获取成员变量的方法</p></li><li><p>获取成员变量的作用依然是在某个对象中取值、赋值</p></li></ul><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>Field[]  <strong>getFields</strong>()</td><td>返回所有成员变量对象的数组（只能拿public的）</td></tr><tr><td>Field[]  <strong>getDeclaredFields</strong>()</td><td>返回所有成员变量对象的数组，存在就能拿到</td></tr><tr><td>Field  <strong>getField</strong>(String  name)</td><td>返回单个成员变量对象（只能拿public的）</td></tr><tr><td>Field  <strong>getDeclaredField</strong>(String  name)</td><td>返回单个成员变量对象，存在就能拿到</td></tr></tbody></table><p><strong>Field类中用于取值、赋值的方法</strong></p><table><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody><tr><td>void  <strong>set</strong>(Object obj, Object value)：</td><td>赋值</td></tr><tr><td>Object  <strong>get</strong>(Object obj)</td><td>获取值。</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个学生类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name; </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String schoolName;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">COUNTTRY</span> <span class="operator">=</span> <span class="string">&quot;中国&quot;</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;无参数构造器执行！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;有参数构造器执行！&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>获取<Field>成员变量对象</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     目标：反射_获取Field成员变量对象。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     反射的第一步是先得到Class类对象。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     1、Field getField(String name);</span></span><br><span class="line"><span class="comment">            根据成员变量名获得对应Field对象，只能获得public修饰</span></span><br><span class="line"><span class="comment">     2.Field getDeclaredField(String name);</span></span><br><span class="line"><span class="comment">            根据成员变量名获得对应Field对象，只要申明了就可以得到</span></span><br><span class="line"><span class="comment">     3.Field[] getFields();</span></span><br><span class="line"><span class="comment">            获得所有的成员变量对应的Field对象，只能获得public的</span></span><br><span class="line"><span class="comment">     4.Field[] getDeclaredFields();</span></span><br><span class="line"><span class="comment">            获得所有的成员变量对应的Field对象，只要申明了就可以得到</span></span><br><span class="line"><span class="comment">     小结：</span></span><br><span class="line"><span class="comment">        获取全部成员变量：getDeclaredFields</span></span><br><span class="line"><span class="comment">        获取某个成员变量：getDeclaredField</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FieldDemo01</span> &#123;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">//1.获取全部的成员变量。</span></span><br><span class="line">     <span class="comment">//Field[] - getDeclaredFields();</span></span><br><span class="line">     <span class="comment">//获得所有的成员变量对应的Field对象，只要申明了就可以得到</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getDeclaredFields</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// a.定位Class对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Student.class;</span><br><span class="line">        <span class="comment">// b.定位全部成员变量</span></span><br><span class="line">        Field[] fields = c.getDeclaredFields();</span><br><span class="line">        <span class="comment">// c.遍历一下</span></span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            System.out.println(field.getName() + <span class="string">&quot;==&gt;&quot;</span> + field.getType());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">———————————————————————————————————————————————————————————————————————————————————————————————————————————— </span><br><span class="line">    </span><br><span class="line">        <span class="comment">//2.获取某个成员变量对象</span></span><br><span class="line">        <span class="comment">//Field - getDeclaredField(String name);</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getDeclaredField</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// a.定位Class对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Student.class;</span><br><span class="line">        <span class="comment">// b.根据名称定位某个成员变量</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">        System.out.println(f.getName() +<span class="string">&quot;===&gt;&quot;</span> + f.getType());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><Field>成员变量对象赋值</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：反射获取成员变量: 取值和赋值。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Field的方法：给成员变量赋值和取值</span></span><br><span class="line"><span class="comment">        void set(Object obj, Object value)：给对象注入某个成员变量数据</span></span><br><span class="line"><span class="comment">        Object get(Object obj):获取对象的成员变量的值。</span></span><br><span class="line"><span class="comment">        void setAccessible(true);暴力反射，设置为可以直接访问私有类型的属性。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FieldDemo02</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setField</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// a.反射第一步，获取类对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Student.class;</span><br><span class="line">        <span class="comment">// b.提取某个成员变量</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">ageF</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ageF.setAccessible(<span class="literal">true</span>); <span class="comment">// 暴力打开权限</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// c.赋值</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        ageF.set(s , <span class="number">18</span>);  <span class="comment">// s.setAge(18);</span></span><br><span class="line">        System.out.println(s);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// d、取值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> (<span class="type">int</span>) ageF.get(s);</span><br><span class="line">        System.out.println(age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-5反射获取方法对象"><a href="#2-5反射获取方法对象" class="headerlink" title="2.5反射获取方法对象"></a>2.5反射获取方法对象</h4><p><strong>使用反射技术获取方法对象并使用</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectionExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Class&lt;?&gt; targetClass = Class.forName(<span class="string">&quot;com.example.TargetClass&quot;</span>); <span class="comment">// 替换成目标类名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> <span class="string">&quot;methodName&quot;</span>; <span class="comment">// 替换成方法名</span></span><br><span class="line">        Class&lt;?&gt;[] parameterTypes = &#123;String.class, <span class="type">int</span>.class&#125;; <span class="comment">// 替换成参数类型</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> targetClass.getDeclaredMethod(methodName, parameterTypes);</span><br><span class="line">        method.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> targetClass.getDeclaredConstructor().newInstance();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(instance, <span class="string">&quot;argument1&quot;</span>, <span class="number">42</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Result: &quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用反射技术获取方法对象并使用</strong></p><ul><li><p>反射的第一步是先得到类对象，然后从类对象中获取类的成分对象。</p></li><li><p>Class类中用于获取成员方法的方法</p></li><li><p>获取成员方法的作用依然是在某个对象中进行执行此方法</p></li></ul><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>Method[]  <strong>getMethods</strong>()</td><td>返回所有成员方法对象的数组（只能拿public的）</td></tr><tr><td>Method[]  <strong>getDeclaredMethods</strong>()</td><td>返回所有成员方法对象的数组，存在就能拿到</td></tr><tr><td>Method  <strong>getMethod</strong>(String  name, Class&lt;?&gt;… parameterTypes)</td><td>返回单个成员方法对象（只能拿public的）</td></tr><tr><td>Method  <strong>getDeclaredMethod</strong>(String  name, Class&lt;?&gt;… parameterTypes)</td><td>返回单个成员方法对象，存在就能拿到</td></tr></tbody></table><p><strong>Method类中用于触发执行的方法</strong></p><table><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody><tr><td>Object <strong>invoke</strong>(Object obj, Object… args)</td><td>运行方法                                                                                                                                                                             参数一：<strong>用obj对象调用该方法</strong>                                                                                                                                           参数二：<strong>调用方法传递的参数</strong>（如果没有就不写）                                                                                                               返回值：<strong>方法的返回值</strong>（如果没有就不写）</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个dog类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name ;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗跑的贼快~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗吃骨头&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">eat</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗吃&quot;</span> + name);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;吃的很开心！&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">inAddr</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;在黑马学习Java!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>获取<Method>方法对象</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：反射——获取Method方法对象</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    反射获取类的Method方法对象：</span></span><br><span class="line"><span class="comment">         1、Method getMethod(String name,Class...args);</span></span><br><span class="line"><span class="comment">             根据方法名和参数类型获得对应的方法对象，只能获得public的</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         2、Method getDeclaredMethod(String name,Class...args);</span></span><br><span class="line"><span class="comment">             根据方法名和参数类型获得对应的方法对象，包括private的</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         3、Method[] getMethods();</span></span><br><span class="line"><span class="comment">             获得类中的所有成员方法对象，返回数组，只能获得public修饰的且包含父类的</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         4、Method[] getDeclaredMethods();</span></span><br><span class="line"><span class="comment">            获得类中的所有成员方法对象，返回数组,只获得本类申明的方法。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Method的方法执行：</span></span><br><span class="line"><span class="comment">        Object invoke(Object obj, Object... args)</span></span><br><span class="line"><span class="comment">          参数一：触发的是哪个对象的方法执行。</span></span><br><span class="line"><span class="comment">          参数二： args：调用方法时传递的实际参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodDemo01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.获得类中的所有成员方法对象</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getDeclaredMethods</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// a.获取类对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Dog.class;</span><br><span class="line">        <span class="comment">// b.提取全部方法；包括私有的</span></span><br><span class="line">        Method[] methods = c.getDeclaredMethods();</span><br><span class="line">        <span class="comment">// c.遍历全部方法</span></span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            System.out.println(method.getName() +<span class="string">&quot; 返回值类型：&quot;</span> + method.getReturnType() + <span class="string">&quot; 参数个数：&quot;</span> + method.getParameterCount());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   ————————————————————————————————————————————————————————————————————————————————————————————————————————————</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2. 获取某个方法对象</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getDeclardMethod</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// a.获取类对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Dog.class;</span><br><span class="line">        <span class="comment">// b.提取单个方法对象</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> c.getDeclaredMethod(<span class="string">&quot;eat&quot;</span>); <span class="comment">//方法名</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">m2</span> <span class="operator">=</span> c.getDeclaredMethod(<span class="string">&quot;eat&quot;</span>, String.class); <span class="comment">//方法名，传入参数类型</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 暴力打开权限了</span></span><br><span class="line">        m.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        m2.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// c.触发方法的执行</span></span><br><span class="line">        <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="comment">// 注意：方法如果是没有结果回来的，那么返回的是null.</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> m.invoke(d);</span><br><span class="line">        System.out.println(result);</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result2</span> <span class="operator">=</span> m2.invoke(d, <span class="string">&quot;骨头&quot;</span>); <span class="comment">//对象，传入参数</span></span><br><span class="line">        System.out.println(result2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-6反射的作用-绕过编译阶段为集合添加数据"><a href="#2-6反射的作用-绕过编译阶段为集合添加数据" class="headerlink" title="2.6反射的作用-绕过编译阶段为集合添加数据"></a>2.6反射的作用-绕过编译阶段为集合添加数据</h4><p><strong>反射的作用-绕过编译阶段为集合添加数据</strong></p><ul><li>反射是作用在运行时的技术，此时集合的泛型将不能产生约束了，此时是可以为集合存入其他任意类型的元素的。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="number">100</span>);</span><br><span class="line"><span class="comment">// list.add(“黑马&quot;); // 报错</span></span><br><span class="line">list.add(<span class="number">99</span>);</span><br></pre></td></tr></table></figure><ul><li>泛型只是在编译阶段可以约束集合只能操作某种数据类型，在编译成Class文件进入运行阶段的时候，其真实类型都是ArrayList了，泛型相当于被擦除了。</li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 需求：反射实现泛型擦除后，加入其他类型的元素</span></span><br><span class="line">        ArrayList&lt;String&gt; lists1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; lists2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        System.out.println(lists1.getClass());</span><br><span class="line">        System.out.println(lists2.getClass());</span><br><span class="line"></span><br><span class="line">        System.out.println(lists1.getClass() ==  lists2.getClass());  <span class="comment">// 运行阶段的，泛型将不存在，其真实类型都是ArrayList，都具有相同地址</span></span><br><span class="line"></span><br><span class="line">————————————————————————————————————————————————————————————————————————————————————————————————————————————</span><br><span class="line">    </span><br><span class="line">        ArrayList&lt;Integer&gt; lists3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        lists3.add(<span class="number">23</span>); </span><br><span class="line">        lists3.add(<span class="number">22</span>);</span><br><span class="line">        <span class="comment">// lists3.add(&quot;黑马&quot;); //此时不能添加String类型</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//a.获取lists3集合类的对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> lists3.getClass(); <span class="comment">// ArrayList.class  ===&gt; public boolean add(E e)</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//b.定位c类中的add方法</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">add</span> <span class="operator">=</span> c.getDeclaredMethod(<span class="string">&quot;add&quot;</span>, Object.class);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//c.调用invoke触发执行的方法,执行add添加内容</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">rs</span> <span class="operator">=</span> (<span class="type">boolean</span>) add.invoke(lists3, <span class="string">&quot;黑马&quot;</span>);</span><br><span class="line">        System.out.println(rs);</span><br><span class="line"></span><br><span class="line">        System.out.println(lists3);</span><br><span class="line"></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">list4</span> <span class="operator">=</span> lists3;</span><br><span class="line">        list4.add(<span class="string">&quot;白马&quot;</span>);</span><br><span class="line">        list4.add(<span class="literal">false</span>);</span><br><span class="line">        System.out.println(lists3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-7反射的作用-通用框架的底层原理"><a href="#2-7反射的作用-通用框架的底层原理" class="headerlink" title="2.7反射的作用-通用框架的底层原理"></a>2.7反射的作用-通用框架的底层原理</h4><p><strong>反射做通用框架</strong></p><p><strong>需求：</strong></p><p>给你任意一个对象，在不清楚对象字段的情况可以，可以把对象的字段名称和对应值存储到文件中去。</p><p><strong>需求</strong></p><ul><li>给你任意一个对象，在不清楚对象字段的情况可以，可以把对象的字段名称和对应值存储到文件中去。</li></ul><p><strong>分析</strong></p><p>①定义一个方法，可以接收任意类的对象。</p><p>②每次收到一个对象后，需要解析这个对象的全部成员变量名称。</p><p>③这个对象可能是任意的，那么怎么样才可以知道这个对象的全部成员变量名称呢？</p><p>④使用反射获取对象的Class类对象，然后获取全部成员变量信息。</p><p>⑤遍历成员变量信息，然后提取本成员变量在对象中的具体值</p><p>⑥存入成员变量名称和值到文件中去即可。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建学生类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span> sex;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String className;</span><br><span class="line">    <span class="keyword">private</span> String hobby;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">char</span> sex, <span class="type">int</span> age, String className, String hobby)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.className = className;</span><br><span class="line">        <span class="built_in">this</span>.hobby = hobby;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">getSex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSex</span><span class="params">(<span class="type">char</span> sex)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getClassName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> className;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setClassName</span><span class="params">(String className)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.className = className;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getHobby</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> hobby;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHobby</span><span class="params">(String hobby)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.hobby = hobby;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建老师类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span> sex;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> salary;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Teacher</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Teacher</span><span class="params">(String name, <span class="type">char</span> sex, <span class="type">double</span> salary)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">        <span class="built_in">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">getSex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSex</span><span class="params">(<span class="type">char</span> sex)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getSalary</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSalary</span><span class="params">(<span class="type">double</span> salary)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    创建save方法 </span></span><br><span class="line"><span class="comment">    保存任意类型的对象到文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;junit-reflect-annotation-proxy-app/src/data.txt&quot;</span>, <span class="literal">true</span>));</span><br><span class="line">        )&#123;</span><br><span class="line">            <span class="comment">// 1、提取这个对象的全部成员变量：只有反射可以解决</span></span><br><span class="line">            <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> obj.getClass();  </span><br><span class="line">            <span class="comment">// c.getSimpleName()获取当前类名   c.getName获取全限名：包名+类名</span></span><br><span class="line">            ps.println(<span class="string">&quot;================&quot;</span> + c.getSimpleName() + <span class="string">&quot;================&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2、提取它的全部成员变量</span></span><br><span class="line">            Field[] fields = c.getDeclaredFields(); </span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 3、遍历 获取成员变量的信息</span></span><br><span class="line">            <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> field.getName();</span><br><span class="line">                <span class="comment">// 提取本成员变量在obj对象中的值（取值）</span></span><br><span class="line">                field.setAccessible(<span class="literal">true</span>); <span class="comment">//暴力反射</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> field.get(obj) + <span class="string">&quot;&quot;</span>;</span><br><span class="line">                ps.println(name  + <span class="string">&quot;=&quot;</span> + value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   目标：提供一个通用框架，支持保存所有对象的具体信息。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        s.setName(<span class="string">&quot;猪八戒&quot;</span>);</span><br><span class="line">        s.setClassName(<span class="string">&quot;西天跑路1班&quot;</span>);</span><br><span class="line">        s.setAge(<span class="number">1000</span>);</span><br><span class="line">        s.setHobby(<span class="string">&quot;吃，睡&quot;</span>);</span><br><span class="line">        s.setSex(<span class="string">&#x27;男&#x27;</span>);</span><br><span class="line">        MybatisUtil.save(s);</span><br><span class="line"></span><br><span class="line">        <span class="type">Teacher</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>();</span><br><span class="line">        t.setName(<span class="string">&quot;波仔&quot;</span>);</span><br><span class="line">        t.setSex(<span class="string">&#x27;男&#x27;</span>);</span><br><span class="line">        t.setSalary(<span class="number">6000</span>);</span><br><span class="line">        MybatisUtil.save(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-注解"><a href="#3-注解" class="headerlink" title="3.注解"></a>3.注解</h3><h4 id="3-1注解概述"><a href="#3-1注解概述" class="headerlink" title="3.1注解概述"></a>3.1注解概述</h4><p><strong>注解概述、作用</strong></p><ul><li><p>Java 注解（Annotation）又称 Java 标注，是 JDK5.0 引入的一种注释机制。</p></li><li><p>Java 语言中的类、构造器、方法、成员变量、参数等都可以被注解进行标注。</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceTest</span> &#123;</span><br><span class="line"><span class="meta">@Test</span> <span class="comment">//注解（Annotation）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLogin</span><span class="params">()</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="meta">@Test</span> <span class="comment">//注解（Annotation）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testChu</span><span class="params">()</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注解的作用是什么呢？</strong></p><ul><li><p>对Java中类、方法、成员变量做<strong>标记，然后进行特殊处理</strong>，至于到底做何种处理由业务需求来决定。</p></li><li><p>例如：JUnit框架中，标记了注解@Test的方法就可以被当成测试方法执行，而没有标记的就不能当成测试方法执行。</p></li></ul><h4 id="3-2自定义注解"><a href="#3-2自定义注解" class="headerlink" title="3.2自定义注解"></a>3.2自定义注解</h4><p><strong>自定义注解</strong> <strong>—</strong> <strong>格式</strong></p><ul><li>自定义注解就是自己做一个注解来使用。</li></ul><p>属性类型：Java支持的数据类型基本上都支持</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> 注解名称 &#123; <span class="comment">// @interface为自定义注解</span></span><br><span class="line"><span class="keyword">public</span>(可省略) 属性类型 属性名() <span class="keyword">default</span> 默认值 ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>特殊属性</strong></p><ul><li><p>value属性，如果只有一个value属性的情况下，使用value属性的时候可以省略value名称不写!!</p></li><li><p>但是如果有多个属性, 且多个属性没有默认值，那么value名称是不能省略的。</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Book &#123;  <span class="comment">// @interface注解标识</span></span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>; <span class="comment">// 特殊属性</span></span><br><span class="line">    <span class="type">double</span> <span class="title function_">price</span><span class="params">()</span> ;</span><br><span class="line">    <span class="comment">//double price() default 9.9; // 默认值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   目标：学会自定义注解。掌握其定义格式和语法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//注解</span></span><br><span class="line"><span class="meta">@MyBook(name=&quot;《精通JavaSE》&quot;,authors = &#123;&quot;黑马&quot;, &quot;dlei&quot;&#125; , price = 199.5)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationDemo1</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//注解</span></span><br><span class="line">    <span class="meta">@MyBook(name=&quot;《精通JavaSE2》&quot;,authors = &#123;&quot;黑马&quot;, &quot;dlei&quot;&#125; , price = 199.5)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">AnnotationDemo1</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注解</span></span><br><span class="line">    <span class="meta">@MyBook(name=&quot;《精通JavaSE1》&quot;,authors = &#123;&quot;黑马&quot;, &quot;dlei&quot;&#125; , price = 199.5)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//注解</span></span><br><span class="line">        <span class="meta">@MyBook(name=&quot;《精通JavaSE2》&quot;,authors = &#123;&quot;黑马&quot;, &quot;dlei&quot;&#125; , price = 199.5)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">21</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3元注解"><a href="#3-3元注解" class="headerlink" title="3.3元注解"></a>3.3元注解</h4><p><strong>元注解</strong></p><ul><li>元注解：就是注解注解的注解。</li></ul><p><strong>元注解常用的两个：</strong></p><ul><li><p><strong>@Target</strong>: 约束自定义注解只能在哪些地方使用，</p></li><li><p><strong>@Retention</strong>：申明注解的生命周期</p></li></ul><p>@Target中可使用的值定义在ElementType枚举类中，常用值如下</p><ul><li><p>TYPE，类，接口</p></li><li><p>FIELD, 成员变量</p></li><li><p>METHOD, 成员方法</p></li><li><p>PARAMETER, 方法参数</p></li><li><p>CONSTRUCTOR, 构造器</p></li><li><p>LOCAL_VARIABLE, 局部变量</p></li></ul><p>@Retention中可使用的值定义在RetentionPolicy枚举类中，常用值如下</p><ul><li><p>SOURCE： 注解只作用在源码阶段，生成的字节码文件中不存在</p></li><li><p>CLASS： 注解作用在源码阶段，字节码文件阶段，运行阶段不存在，默认值.</p></li><li><p><strong>RUNTIME</strong>：注解作用在源码阶段，字节码文件阶段，运行阶段（开发常用）</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个元注解, 注解注解的注解。 </span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD,ElementType.FIELD&#125;)</span> <span class="comment">// 元注解 (METHOD注解成员方法，FIELD注解成员变量)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span> <span class="comment">// 一直活着，在运行阶段这个注解也不消失</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyTest &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   目标：认识元注解</span></span><br><span class="line"><span class="comment">   <span class="doctag">@MyTest</span> 只能注解方法和成员变量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//@MyTest //元注解未提供TYPE，此时不可以注解类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationDemo2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MyTest</span>  <span class="comment">//注解成员变量</span></span><br><span class="line">    <span class="keyword">private</span> String name; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">         <span class="meta">@MyTest</span>  <span class="comment">//注解成员方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-4注解解析"><a href="#3-4注解解析" class="headerlink" title="3.4注解解析"></a>3.4注解解析</h4><p><strong>注解的解析</strong></p><ul><li>注解的操作中经常需要进行解析，注解的解析就是判断是否存在注解，存在注解就解析出内容。</li></ul><p><strong>与注解解析相关的接口</strong></p><ul><li><p><strong>Annotation: 注解的顶级接口</strong>，注解都是Annotation类型的对象</p></li><li><p>AnnotatedElement:该接口定义了与注解解析相关的解析方法</p></li></ul><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>Annotation[]  <strong>getDeclaredAnnotations</strong>()</td><td>获得当前对象上使用的所有注解，返回注解数组。</td></tr><tr><td>T <strong>getDeclaredAnnotation</strong>(Class<T>  annotationClass)</td><td>根据注解类型获得对应注解对象</td></tr><tr><td>boolean <strong>isAnnotationPresent</strong>(Class<Annotation>  annotationClass)</td><td>判断当前对象是否使用了指定的注解，如果使用了则返回true，否则false</td></tr></tbody></table><ul><li>所有的类成分Class, Method , Field , Constructor，都实现了AnnotatedElement接口他们都拥有解析注解的能力：</li></ul><p><strong>解析注解的技巧</strong></p><ul><li><p>注解在哪个成分上，我们就先拿哪个成分对象。</p></li><li><p>比如注解作用成员方法，则要获得该成员方法对应的Method对象，再来拿上面的注解</p></li><li><p>比如注解作用在类上，则要该类的Class对象，再来拿上面的注解</p></li><li><p>比如注解作用在成员变量上，则要获得该成员变量对应的Field对象，再来拿上面的注解</p></li></ul><p><strong>案例:</strong></p><p><strong>需求：</strong></p><p>注解解析的案例</p><p><strong>分析</strong></p><p>①定义注解Bookk，要求如下：<br>     - 包含属性：String value()  书名<br>     - 包含属性：double price() 价格，默认值为 100<br>     - 包含属性：String[] authors() 多位作者<br>     - 限制注解使用的位置：类和成员方法上<br>     - 指定注解的有效范围：RUNTIME</p><p>②定义BookStore类，在类和成员方法上使用Bookk注解</p><p>③定义AnnotationDemo01测试类获取Bookk注解上的数据</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义注解Bookk</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span> <span class="comment">//注解 类和方法</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Bookk &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">double</span> <span class="title function_">price</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">100</span>;</span><br><span class="line">    String[] author();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义BookStore类，在类和成员方法上使用Bookk注解</span></span><br><span class="line"><span class="comment">//1.注解类</span></span><br><span class="line"><span class="meta">@Bookk(value = &quot;《情深深雨濛濛》&quot;, price = 99.9, author = &#123;&quot;琼瑶&quot;, &quot;dlei&quot;&#125;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BookStore</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.注解方法</span></span><br><span class="line">    <span class="meta">@Bookk(value = &quot;《三少爷的剑》&quot;, price = 399.9, author = &#123;&quot;古龙&quot;, &quot;熊耀华&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   目标：完成注解的解析</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationDemo3</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parseClass</span><span class="params">()</span>&#123; <span class="comment">// 解析类</span></span><br><span class="line">        <span class="comment">// a.先得到类对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> BookStore.class;</span><br><span class="line">        <span class="comment">// b.判断这个类上面是否存在这个注解</span></span><br><span class="line">        <span class="keyword">if</span>(c.isAnnotationPresent(Bookk.class))&#123;</span><br><span class="line">            <span class="comment">//c.直接获取该注解对象</span></span><br><span class="line">            <span class="type">Bookk</span> <span class="variable">book</span> <span class="operator">=</span> (Bookk) c.getDeclaredAnnotation(Bookk.class);</span><br><span class="line">            System.out.println(book.value());</span><br><span class="line">            System.out.println(book.price());</span><br><span class="line">            System.out.println(Arrays.toString(book.author()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parseMethod</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123; <span class="comment">// 解析方法</span></span><br><span class="line">        <span class="comment">// a.先得到类对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> BookStore.class;</span><br><span class="line"></span><br><span class="line">        <span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> c.getDeclaredMethod(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// b.判断这个类上面是否存在这个注解</span></span><br><span class="line">        <span class="keyword">if</span>(m.isAnnotationPresent(Bookk.class))&#123;</span><br><span class="line">            <span class="comment">//c.直接获取该注解对象</span></span><br><span class="line">            <span class="type">Bookk</span> <span class="variable">book</span> <span class="operator">=</span> (Bookk) m.getDeclaredAnnotation(Bookk.class);</span><br><span class="line">            System.out.println(book.value());</span><br><span class="line">            System.out.println(book.price());</span><br><span class="line">            System.out.println(Arrays.toString(book.author()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-5注解的应用场景一：junit框架"><a href="#3-5注解的应用场景一：junit框架" class="headerlink" title="3.5注解的应用场景一：junit框架"></a>3.5注解的应用场景一：junit框架</h4><p><strong>案例：</strong></p><p>模拟Junit框架</p><p><strong>需求</strong></p><ul><li>定义若干个方法，只要加了MyTest注解，就可以在启动时被触发执行</li></ul><p><strong>分析</strong></p><p>①定义一个自定义注解MyTest，只能注解方法，存活范围是一直都在。</p><p>②定义若干个方法，只要有@MyTest注解的方法就能在启动时被触发执行，没有这个注解的方法不能执行。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个自定义注解MyTest</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD,ElementType.FIELD&#125;)</span> <span class="comment">// 元注解</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span> <span class="comment">// 一直活着，在运行阶段这个注解也不消失</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyTest &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationDemo4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===test1===&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MyTest</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===test2===&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MyTest</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===test3===&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      启动菜单：有注解的才被调用。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">AnnotationDemo4</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationDemo4</span>();</span><br><span class="line">        <span class="comment">// a.获取类对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> AnnotationDemo4.class;</span><br><span class="line">        <span class="comment">// b.提取全部方法</span></span><br><span class="line">        Method[] methods = c.getDeclaredMethods();</span><br><span class="line">        <span class="comment">// c.遍历方法，看是否有MyTest注解，有就跑它</span></span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            <span class="keyword">if</span>(method.isAnnotationPresent(MyTest.class))&#123;</span><br><span class="line">                <span class="comment">// 跑它</span></span><br><span class="line">                method.invoke(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-动态代理"><a href="#4-动态代理" class="headerlink" title="4.动态代理"></a>4.动态代理</h3><h4 id="4-1准备案例、提出问题"><a href="#4-1准备案例、提出问题" class="headerlink" title="4.1准备案例、提出问题"></a>4.1准备案例、提出问题</h4><p><strong>案例：</strong></p><p>模拟企业业务功能开发，并完成每个功能的性能统计</p><p><strong>需求</strong></p><ul><li>模拟某企业用户管理业务，需包含用户登录，用户删除，用户查询功能，并要统计每个功能的耗时。</li></ul><p><strong>分析</strong></p><p>①定义一个UserService表示用户业务接口，规定必须完成用户登录，用户删除，用户查询功能。</p><p>②定义一个实现类UserServiceImpl实现UserService，并完成相关功能，且统计每个功能的耗时。</p><p>③定义测试类，创建实现类对象，调用方法。</p><p><strong>本案例存在哪些问题？</strong></p><p>答：业务对象的的每个方法都要进行性能统计，存在大量重复的代码。</p><h4 id="4-2使用动态代理解决问题"><a href="#4-2使用动态代理解决问题" class="headerlink" title="4.2使用动态代理解决问题"></a>4.2使用动态代理解决问题</h4><p>动态代理</p><ul><li>代理就是被代理者没有能力或者不愿意去完成某件事情，需要找个人代替自己去完成这件事，动态代理就是用来对业务功能（方法）进行代理的。</li></ul><p><strong>关键步骤</strong></p><ul><li><p><strong>必须有接口，实现类要实现接口</strong>（代理通常是基于接口实现的）。</p></li><li><p><strong>创建一个实现类的对象</strong>，该对象为业务对象，紧接着为业务对象做一个代理对象。</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">定义接口</span></span><br><span class="line"><span class="comment">   模拟用户业务功能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    String <span class="title function_">login</span><span class="params">(String loginName , String passWord)</span> ;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">selectUsers</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">deleteUsers</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">updateUsers</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">定义实现类，实现UserService接口</span></span><br><span class="line"><span class="comment">   模拟用户业务功能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">login</span><span class="params">(String loginName, String passWord)</span>  &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;admin&quot;</span>.equals(loginName) &amp;&amp; <span class="string">&quot;1234&quot;</span>.equals(passWord)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;登录名和密码可能有毛病&quot;</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">selectUsers</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;查询了100个用户数据！&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">deleteUsers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;删除100个用户数据！&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUsers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;修改100个用户数据！&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    public static Object newProxyInstance(ClassLoader loader,  Class&lt;?&gt;[] interfaces, InvocationHandler h)</span></span><br><span class="line"><span class="comment">    参数一：类加载器，负责加载代理类到内存中使用。</span></span><br><span class="line"><span class="comment">    参数二：获取被代理对象实现的全部接口。代理要为全部接口的全部方法进行代理</span></span><br><span class="line"><span class="comment">    参数三：代理的核心处理逻辑</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyUtil</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      生成业务对象的代理对象。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T  <span class="title function_">getProxy</span><span class="params">(T obj)</span> &#123; <span class="comment">// 参数类型和返回值类型都为任意类型</span></span><br><span class="line">        <span class="comment">// 1.调用Proxy.newProxyInstance创建一个实现类的对象，返回一个代理对象</span></span><br><span class="line">        <span class="keyword">return</span> (T)Proxy.newProxyInstance(obj.getClass().getClassLoader(),</span><br><span class="line">                obj.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                        <span class="comment">// 参数一：代理对象本身。一般不管</span></span><br><span class="line">                        <span class="comment">// 参数二：正在被代理的方法</span></span><br><span class="line">                        <span class="comment">// 参数三：被代理方法，应该传入的参数</span></span><br><span class="line">                       <span class="type">long</span> <span class="variable">startTimer</span> <span class="operator">=</span> System .currentTimeMillis(); <span class="comment">// 创建开始时间</span></span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 2.触发方法的真正执行。(触发真正的业务功能)</span></span><br><span class="line">                        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(obj, args); <span class="comment">//obj真实业务对象</span></span><br><span class="line"></span><br><span class="line">                        <span class="type">long</span> <span class="variable">endTimer</span> <span class="operator">=</span> System.currentTimeMillis(); <span class="comment">// 创建结束时间</span></span><br><span class="line">                        System.out.println(method.getName() + <span class="string">&quot;方法耗时：&quot;</span> + (endTimer - startTimer) / <span class="number">1000.0</span> + <span class="string">&quot;s&quot;</span>); <span class="comment">// 计算时间差</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 3.把业务功能方法执行的结果返回给调用者</span></span><br><span class="line">                        <span class="keyword">return</span> result;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、把业务对象，直接做成一个代理对象返回，代理对象的类型也是 UserService类型</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> ProxyUtil.getProxy(<span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>());</span><br><span class="line">        System.out.println(userService.login(<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;1234&quot;</span>));</span><br><span class="line">        System.out.println(userService.deleteUsers());</span><br><span class="line">        userService.selectUsers();</span><br><span class="line">        userService.updateUsers(); <span class="comment">// 走代理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>动态代理的优点</strong></p><ul><li><p>非常的灵活，支持任意接口类型的实现类对象做代理，也可以直接为接本身做代理。</p></li><li><p>可以为被代理对象的所有方法做代理。</p></li><li><p>可以在不改变方法源码的情况下，实现对方法功能的增强。</p></li><li><p>不仅简化了编程工作、提高了软件系统的可扩展性，同时也提高了开发效率。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> java,面向对象进阶,单元测试,反射,注解,动态代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>day21 - 网络编程</title>
      <link href="/post/9d3e5e46.html"/>
      <url>/post/9d3e5e46.html</url>
      
        <content type="html"><![CDATA[<p>什么是网络编程？</p><ul><li>网络编程可以让程序与网络上的其他设备中的程序进行数据交互。</li></ul><p>网络通信基本模式</p><ul><li>常见的通信模式有如下2种形式：Client-Server(CS 、 Browser&#x2F;Server(BS)</li></ul><h3 id="1-网络通信三要素"><a href="#1-网络通信三要素" class="headerlink" title="1.网络通信三要素"></a>1.网络通信三要素</h3><p><strong>实现网络编程关键的三要素</strong></p><p><strong>IP地址</strong>：设备在网络中的地址，是唯一的标识。</p><p><strong>端口：</strong>应用程序在设备中唯一的标识。</p><p><strong>协议</strong>: 数据在网络中传输的规则，常见的协议有UDP协议和TCP协议。</p><h4 id="1-1三要素概述、"><a href="#1-1三要素概述、" class="headerlink" title="1.1三要素概述、"></a>1.1三要素概述、</h4><h4 id="要素一：IP地址"><a href="#要素一：IP地址" class="headerlink" title="要素一：IP地址"></a>要素一：IP地址</h4><p>IP（Internet Protocol）：全称”互联网协议地址”，是分配给上网设备的唯一标志。</p><p>常见的IP分类为：IPv4和IPv6</p><p> <strong>IPv4</strong></p><ul><li><strong>地址空间：</strong> IPv4使用32位地址，共有约42亿个可能的地址。由于互联网的爆炸式增长，IPv4地址已经不够用，导致IPv4地址短缺问题。</li><li><strong>地址表示：</strong> IPv4地址使用四个十进制数，每个数范围在0到255之间，通过点分十进制表示（例如：192.168.1.1）。</li><li><strong>地址配置：</strong> IPv4地址可以是静态分配或动态分配（使用DHCP等协议）。</li><li><strong>网络地址转换（NAT）：</strong> 由于地址短缺，IPv4常常使用NAT技术将多个设备共享同一个公网IP地址。</li><li><strong>不足之处：</strong> 除了地址短缺，IPv4还存在一些安全性和管理方面的问题，如IP地址伪造等。</li></ul><p><strong>IPv6：</strong></p><ul><li><strong>地址空间：</strong> IPv6使用128位地址，地址空间极其庞大，约为3.4 x 10^38个地址，解决了IPv4地址不足的问题。128位（16个字节），号称可以为地球每一粒沙子编号。</li><li><strong>地址表示：</strong> IPv6地址使用八组四位十六进制数字，通过冒号分隔（例如：2001:0db8:85a3:0000:0000:8a2e:0370:7334）。</li><li><strong>地址配置：</strong> IPv6引入了更灵活的地址配置方式，可以使用自动配置或者动态主机配置协议。</li><li><strong>NAT不再是必需：</strong> 由于IPv6地址充足，不再需要像IPv4那样频繁使用NAT技术，每个设备都可以拥有公网IP地址。</li><li><strong>安全性和其他改进：</strong> IPv6引入了一些安全性和性能方面的改进，同时也考虑了移动设备、多播通信等需求。</li></ul><p><strong>IP地址形式：</strong></p><ul><li><p>公网地址、和私有地址(局域网使用)。</p></li><li><p>192.168. 开头的就是常见的局域网地址，范围即为192.168.0.0–192.168.255.255，专门为组织机构内部使用。</p></li></ul><p><strong>IP常用命令：</strong></p><ul><li><p>ipconfig：查看本机IP地址</p></li><li><p>ping IP地址：检查网络是否连通</p></li></ul><p><strong>特殊IP地址</strong>：</p><ul><li>本机IP: 127.0.0.1或者localhost：称为回送地址也可称本地回环地址，只会寻找当前所在本机。</li></ul><h4 id="IP地址操作类-InetAddress"><a href="#IP地址操作类-InetAddress" class="headerlink" title="IP地址操作类-InetAddress"></a>IP地址操作类-InetAddress</h4><p><strong>InetAddress</strong> <strong>的使用</strong></p><ul><li>此类表示Internet协议（IP）地址。</li></ul><p><strong>InetAddress  API如下</strong></p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>public static InetAddress <strong>getLocalHost</strong>()</td><td>返回<strong>本主机的地址对象</strong></td></tr><tr><td>public static  InetAddress getByName(String host)</td><td>得到指定主机的IP地址对象，参数是域名或者IP地址</td></tr><tr><td>public String  getHostName()</td><td>获取此IP地址的主机名</td></tr><tr><td>public String  getHostAddress()</td><td>返回IP地址字符串</td></tr><tr><td>public boolean isReachable(int timeout)</td><td>在指定毫秒内连通该IP地址对应的主机，连通返回true</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：InetAddress类概述（了解）</span></span><br><span class="line"><span class="comment">         一个该类的对象就代表一个IP地址对象。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    InetAddress类成员方法：</span></span><br><span class="line"><span class="comment">         static InetAddress getLocalHost()</span></span><br><span class="line"><span class="comment">            * 获得本地主机IP地址对象。</span></span><br><span class="line"><span class="comment">         static InetAddress getByName(String host)</span></span><br><span class="line"><span class="comment">            * 根据IP地址字符串或主机名获得对应的IP地址对象。</span></span><br><span class="line"><span class="comment">         String getHostName()</span></span><br><span class="line"><span class="comment">            * 获得主机名。</span></span><br><span class="line"><span class="comment">         String getHostAddress()</span></span><br><span class="line"><span class="comment">            * 获得IP地址字符串。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InetAddressDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.获取本机地址对象。</span></span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">ip1</span> <span class="operator">=</span> InetAddress.getLocalHost();</span><br><span class="line">        System.out.println(ip1.getHostName());</span><br><span class="line">        System.out.println(ip1.getHostAddress());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.获取域名ip对象</span></span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">ip2</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;www.baidu.com&quot;</span>);</span><br><span class="line">        System.out.println(ip2.getHostName());</span><br><span class="line">        System.out.println(ip2.getHostAddress());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.获取公网IP对象。</span></span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">ip3</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;112.80.248.76&quot;</span>);</span><br><span class="line">        System.out.println(ip3.getHostName());</span><br><span class="line">        System.out.println(ip3.getHostAddress());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.判断是否能通： ping  5s之前测试是否可通</span></span><br><span class="line">        System.out.println(ip3.isReachable(<span class="number">5000</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="要素二：端口号"><a href="#要素二：端口号" class="headerlink" title="要素二：端口号"></a>要素二：端口号</h4><p><strong>端口号</strong></p><ul><li>端口号：标识正在计算机设备上运行的进程（程序），被规定为一个 16 位的二进制，范围是 0~65535。</li></ul><p><strong>端口类型</strong></p><ul><li><p>周知端口：0~1023，被预先定义的知名应用占用（如：HTTP占用 80，FTP占用21） </p></li><li><p><strong>注册端口</strong>：1024~49151，分配给用户进程或某些应用程序。（如：Tomcat占 用8080，MySQL占用3306）</p></li><li><p>动态端口：49152到65535，之所以称为动态端口，是因为它 一般不固定分配某种进程，而是动态分配。</p></li></ul><p><strong>注意：我们自己开发的程序选择注册端口，且一个设备中不能出现两个程序的端口号一样，否则出错。</strong></p><h4 id="要素三：协议"><a href="#要素三：协议" class="headerlink" title="要素三：协议"></a>要素三：协议</h4><p><strong>通信协议</strong></p><ul><li>连接和通信数据的规则被称为网络通信协议</li></ul><p><strong>网络通信协议有两套参考模型</strong></p><ul><li><p>OSI参考模型：世界互联协议标准，全球通信规范，由于此模型过于理想化，未能在因特网上进行广泛推广。</p></li><li><p>TCP&#x2F;IP参考模型(或TCP&#x2F;IP协议)：事实上的国际标准。</p></li></ul><table><thead><tr><th>OSI参考模型</th><th>TCP&#x2F;IP参考模型</th><th>各层对应</th><th>面向操作</th></tr></thead><tbody><tr><td>应用层</td><td>应用层</td><td>HTTP、FTP、DNS、SMTP…</td><td>应用程序需要关注的：浏览器，邮箱。程序员一般在这一层开发</td></tr><tr><td>表示层</td><td></td><td></td><td></td></tr><tr><td>会话层</td><td></td><td></td><td></td></tr><tr><td>传输层</td><td>传输层</td><td>TCP、UDP…</td><td>选择使用的TCP , UDP协议</td></tr><tr><td>网络层</td><td>网络层</td><td>IP、ICMP…</td><td>封装源和目标IP，进行路径选择</td></tr><tr><td>数据链路层</td><td>数据链路层+物理</td><td>物理寻址、比特流…</td><td>物理设备中传输</td></tr><tr><td>物理层</td><td></td><td></td><td></td></tr></tbody></table><p><strong>传输层的2个常见协议</strong></p><ul><li><p>TCP(Transmission Control Protocol) ：传输控制协议</p></li><li><p>UDP(User Datagram Protocol)：用户数据报协议</p></li></ul><p><strong>TCP协议特点</strong></p><ul><li><p>使用TCP协议，必须双方先建立连接，它是一种面向连接的<strong>可靠通信协议</strong>。</p></li><li><p>传输前，采用<strong>“三次握手”</strong>方式建立连接，所以是可靠的 。</p></li><li><p>在连接中可进行<strong>大数据量</strong>的传输 。</p></li><li><p>连接、发送数据都<strong>需要确认</strong>，且传输完毕后，还需释放已建立的连接，通信效率较低。</p></li></ul><p><strong>TCP协议通信场景</strong></p><ul><li>对信息安全要求较高的场景，例如：文件下载、金融等数据通信。</li></ul><p><strong>TCP三次握手确立连接</strong></p><ol><li><strong>第一次握手</strong>：客户端向服务器发送一个SYN（同步）标志位，请求建立连接。</li><li><strong>第二次握手</strong>：服务器接收到客户端的SYN请求后，会发送一个SYN+ACK（同步和确认）标志位作为回应，表示同意建立连接。</li><li><strong>第三次握手</strong>：客户端接收到服务器的SYN+ACK后，会发送一个ACK（确认）标志位，确认连接已经建立。</li></ol><p>通过这个过程，客户端和服务器都确认了彼此可以通信，并且双方已经准备好开始传输数据。</p><p><strong>TCP四次挥手断开连接</strong></p><ol><li><strong>第一次挥手</strong>：当客户端有数据要传输完成后，它会向服务器发送一个FIN（结束）标志位，表示它已经完成了数据的发送。</li><li><strong>第二次挥手</strong>：服务器收到客户端的FIN后，会发送一个ACK标志位，确认收到了客户端的关闭请求。</li><li><strong>第三次挥手</strong>：服务器自己完成数据的发送后，会发送一个FIN标志位给客户端，表示服务器也准备好关闭连接了。</li><li><strong>第四次挥手</strong>：客户端接收到服务器的FIN后，发送一个ACK标志位作为确认。此时连接被彻底关闭。</li></ol><p>通过这个过程，双方确认彼此都没有数据需要传输了，并且连接被正确地关闭。</p><p><strong>UDP协议：</strong> </p><ul><li><p>UDP是一种<strong>无连接、不可靠</strong>传输的协议。</p></li><li><p>将数据源IP、目的地IP和端口封装成数据包，<strong>不需要建立连接</strong></p></li><li><p>每个数据包的大小限制在<strong>64KB内</strong></p></li><li><p>发送不管对方是否准备好，接收方收到也不确认，故是不可靠的 </p></li><li><p>可以广播发送 ，发送数据结束时无需释放资源，开销小，速度快。</p></li></ul><p><strong>UDP协议通信场景</strong></p><ul><li>语音通话，视频会话等。</li></ul><h3 id="2-UDP通信-快速入门"><a href="#2-UDP通信-快速入门" class="headerlink" title="2.UDP通信-快速入门"></a>2.UDP通信-快速入门</h3><h4 id="2-1UDP通信：快速入门"><a href="#2-1UDP通信：快速入门" class="headerlink" title="2.1UDP通信：快速入门"></a>2.1UDP通信：快速入门</h4><p><strong>UDP协议的特点</strong></p><ul><li><p>UDP是一种无连接、不可靠传输的协议。</p></li><li><p>将数据源IP、目的地IP和端口以及数据封装成数据包，大小限制在64KB内，直接发送出去即可。</p></li></ul><p><strong>DatagramPacket：数据包对象（容器）</strong></p><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public <strong>DatagramPacket</strong>(byte[] buf, int  length, InetAddress address,  int port)</td><td>创建发送端数据包对象 字节数组  <strong>buf：要发送的内容</strong>，  <strong>length：要发送内容的字节长度</strong>，  <strong>address：接收端的IP地址对象</strong>，  <strong>port：接收端的端口号</strong></td></tr><tr><td>public <strong>DatagramPacket</strong>(byte[] buf, int  length)</td><td>创建接收端的数据包对象 字节数组 <strong>buf：用来存储接收的内容</strong>，   <strong>length：能够接收内容的长度</strong></td></tr></tbody></table><p><strong>DatagramPacket常用方法</strong>   </p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public int <strong>getLength</strong>()</td><td>获得实际接收到的<strong>字节个数</strong></td></tr></tbody></table><p><strong>DatagramSocket：发送端和接收端对象（人）</strong></p><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public <strong>DatagramSocket</strong>()</td><td><strong>创建发送端的Socket对象</strong>，系统会随机分配一个端口号。</td></tr><tr><td>public <strong>DatagramSocket</strong>(int port)</td><td><strong>创建接收端的Socket对象</strong>，并指定端口号</td></tr></tbody></table><p><strong>DatagramSocket类成员方法</strong></p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public void <strong>send</strong>(DatagramPacket dp)</td><td><strong>发送数据包</strong></td></tr><tr><td>public void <strong>receive</strong>(DatagramPacket p)</td><td><strong>接收数据包</strong></td></tr></tbody></table><p><strong>案例：</strong></p><p>使用UDP通信实现：发送消息、接收消息</p><p><strong>需求：</strong></p><p><strong>客户端实现步骤</strong></p><p>①创建DatagramSocket对象（发送端对象）           扔韭菜的人</p><p>②创建DatagramPacket对象封装需要发送的数据（数据包对象）        韭菜盘子</p><p>③使用DatagramSocket对象的send方法传入DatagramPacket对象         开始抛出韭菜</p><p>④释放资源</p><p><strong>接收端实现步骤</strong></p><p>①创建DatagramSocket对象并指定端口（接收端对象）           接韭菜的人</p><p>②创建DatagramPacket对象接收数据（数据包对象）         韭菜盘子</p><p>③使用DatagramSocket对象的receive方法传入DatagramPacket对象         开始接收韭菜</p><p>④释放资源</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  发送端 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====客户端启动======&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、创建发送端对象：发送端自带默认的端口号（人）</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">6666</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、创建一个数据包对象封装数据（容器）</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         public DatagramPacket(byte buf[], int length,</span></span><br><span class="line"><span class="comment">         InetAddress address, int port)</span></span><br><span class="line"><span class="comment">         参数一：封装要发送的数据（韭菜）</span></span><br><span class="line"><span class="comment">         参数二：发送数据的大小</span></span><br><span class="line"><span class="comment">         参数三：服务端的主机IP地址</span></span><br><span class="line"><span class="comment">         参数四：服务端的端口</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="string">&quot;我是一个数据包&quot;</span>.getBytes();</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buffer, buffer.length, InetAddress.getLocalHost(), <span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、发送数据出去</span></span><br><span class="line">        socket.send(packet);</span><br><span class="line"></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  接收端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====服务端启动======&quot;</span>);</span><br><span class="line">        <span class="comment">// 1、创建接收端对象：注册端口（人）</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、创建一个数据包对象接收数据（容器）</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">64</span>]; <span class="comment">//64kb</span></span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buffer, buffer.length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、等待接收数据。</span></span><br><span class="line">        socket.receive(packet);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、取出数据即可</span></span><br><span class="line">        <span class="comment">// 读取多少倒出多少</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> packet.getLength();</span><br><span class="line">        <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer,<span class="number">0</span>, len);</span><br><span class="line">        System.out.println(<span class="string">&quot;收到了：&quot;</span> + rs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取发送端的ip和端口</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">ip</span>  <span class="operator">=</span>packet.getSocketAddress().toString();</span><br><span class="line">        System.out.println(<span class="string">&quot;对方地址：&quot;</span> + ip);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span>  <span class="operator">=</span> packet.getPort();</span><br><span class="line">        System.out.println(<span class="string">&quot;对方端口：&quot;</span> + port);</span><br><span class="line"></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2UDP通信：多发多收"><a href="#2-2UDP通信：多发多收" class="headerlink" title="2.2UDP通信：多发多收"></a>2.2UDP通信：多发多收</h4><p><strong>案例：</strong></p><p>使用UDP通信实现：多发多收消息</p><p><strong>需求</strong></p><ul><li>使用UDP通信方式开发接收端和发送端。</li></ul><p><strong>分析</strong></p><p>①发送端可以一直发送消息。</p><p>②接收端可以不断的接收多个发送端的消息展示。</p><p>③发送端输入了exit则结束发送端程序。</p><p><strong>客户端实现步骤</strong></p><p>①创建DatagramSocket对象（发送端对象）           扔韭菜的人</p><p>②使用while死循环不断的接收用户的数据输入，如果用户输入的exit则退出程序</p><p>③如果用户输入的不是exit, 把数据封装成DatagramPacket           韭菜盘子</p><p>④使用DatagramSocket对象的send方法将数据包对象进行发送          开始抛出韭菜</p><p>⑤释放资源</p><p><strong>接收端实现步骤</strong></p><p>①创建DatagramSocket对象并指定端口（接收端对象）           接韭菜的人</p><p>②创建DatagramPacket对象接收数据（数据包对象）         韭菜盘子</p><p>③使用while死循环不断的进行第4步</p><p>④使用DatagramSocket对象的receive方法传入DatagramPacket对象         开始接收韭菜</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  发送端  多发 多收</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====客户端启动======&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、创建发送端对象：发送端自带默认的端口号（人）</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">7777</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in); <span class="comment">//键盘录入</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请说：&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;exit&quot;</span>.equals(msg))&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;离线成功！&quot;</span>);</span><br><span class="line">                socket.close();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2、创建一个数据包对象封装数据（容器）</span></span><br><span class="line">            <span class="type">byte</span>[] buffer = msg.getBytes();</span><br><span class="line">            <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buffer, buffer.length, InetAddress.getLocalHost(), <span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3、发送数据出去</span></span><br><span class="line">            socket.send(packet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  接收端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====服务端启动======&quot;</span>);</span><br><span class="line">        <span class="comment">// 1、创建接收端对象：注册端口（人）</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、创建一个数据包对象接收数据（韭菜盘子）</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">64</span>];  <span class="comment">//64kb</span></span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buffer, buffer.length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 3、等待接收数据。</span></span><br><span class="line">            socket.receive(packet);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 4、取出数据即可</span></span><br><span class="line">            <span class="comment">// 读取多少倒出多少</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> packet.getLength();</span><br><span class="line">            <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer, <span class="number">0</span>, len);</span><br><span class="line">            System.out.println(<span class="string">&quot;收到了来自：&quot;</span> + packet.getAddress() +<span class="string">&quot;, 对方端口是&quot;</span> + packet.getPort() +<span class="string">&quot;的消息：&quot;</span> + rs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-UDP通信-广播、组播"><a href="#3-UDP通信-广播、组播" class="headerlink" title="3.UDP通信-广播、组播"></a>3.UDP通信-广播、组播</h3><p><strong>UDP的三种通信方式</strong></p><p>单播：单台主机与单台主机之间的通信。</p><p>广播：当前主机与所在网络中的所有主机通信。</p><p>组播：当前主机与选定的一组主机的通信。</p><p><strong>UDP如何实现广播</strong></p><ul><li><strong>使用广播地址：255.255.255.255</strong></li></ul><p>具体操作：</p><p>①发送端发送的数据包的目的地写的是广播地址、且指定端口。 （255.255.255.255 ,  9999）</p><p>②本机所在网段的其他主机的程序只要注册对应端口就可以收到消息了。（9999）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   广播  发送端  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====客户端启动======&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、创建发送端对象：发送端自带默认的端口号（人）</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请说：&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;exit&quot;</span>.equals(msg))&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;离线成功！&quot;</span>);</span><br><span class="line">                socket.close();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2、创建一个数据包对象封装数据（韭菜盘子）</span></span><br><span class="line">            <span class="type">byte</span>[] buffer = msg.getBytes();</span><br><span class="line">            <span class="comment">// 注意：只要目的地IP是 255.255.255.255 这个消息将以广播的形式对外发送</span></span><br><span class="line">            <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>( buffer, buffer.length,</span><br><span class="line">                    InetAddress.getByName(<span class="string">&quot;255.255.255.255&quot;</span>) , <span class="number">8888</span>);  </span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3、发送数据出去</span></span><br><span class="line">            socket.send(packet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   广播  接收端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====服务端启动======&quot;</span>);</span><br><span class="line">        <span class="comment">// 1、创建接收端对象：注册端口（人）</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、创建一个数据包对象接收数据（韭菜盘子）</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">64</span>];</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buffer, buffer.length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 3、等待接收数据。</span></span><br><span class="line">            socket.receive(packet);</span><br><span class="line">            <span class="comment">// 4、取出数据即可</span></span><br><span class="line">            <span class="comment">// 读取多少倒出多少</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> packet.getLength();</span><br><span class="line">            <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer,<span class="number">0</span>, len);</span><br><span class="line">            System.out.println(<span class="string">&quot;收到了来自：&quot;</span> + packet.getAddress() +<span class="string">&quot;, 对方端口是&quot;</span> + packet.getPort() +<span class="string">&quot;的消息：&quot;</span> + rs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>UDP如何实现组播</strong></p><ul><li><strong>使用组播地址：224.0.0.0 ~ 239.255.255.255</strong></li></ul><p>具体操作：</p><p>①发送端的数据包的目的地是组播IP (例如：224.0.1.1, 端口：9999)</p><p>②接收端必须绑定该组播IP(224.0.1.1)，端口还要注册发送端的目的端口9999 ，这样即可接收该组播消息。</p><p>③DatagramSocket的子类MulticastSocket可以在接收端绑定组播IP。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   组播  发送端  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====客户端启动======&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、创建发送端对象：发送端自带默认的端口号（人）</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请说：&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;exit&quot;</span>.equals(msg))&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;离线成功！&quot;</span>);</span><br><span class="line">                socket.close();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2、创建一个数据包对象封装数据（韭菜盘子）</span></span><br><span class="line">            <span class="type">byte</span>[] buffer = msg.getBytes();</span><br><span class="line">            <span class="comment">// 注意：只要目的地IP是 224.0.0.0 ~ 239.255.255.255 这个消息将以组播的形式对外发</span></span><br><span class="line">            <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>( buffer, buffer.length,</span><br><span class="line">                    InetAddress.getByName(<span class="string">&quot;224.0.1.1&quot;</span>) , <span class="number">9898</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3、发送数据出去</span></span><br><span class="line">            socket.send(packet);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   组播  接收端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerDemo3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====服务端启动======&quot;</span>);</span><br><span class="line">        <span class="comment">// 1、创建接收端对象：注册端口（人）</span></span><br><span class="line">        <span class="type">MulticastSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MulticastSocket</span>(<span class="number">9898</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意：绑定组播地址（加群）要有和发送到相同的IP和端口号</span></span><br><span class="line">        socket.joinGroup(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(InetAddress.getByName(<span class="string">&quot;224.0.1.1&quot;</span>) , <span class="number">9898</span>),</span><br><span class="line">                NetworkInterface.getByInetAddress(InetAddress.getLocalHost()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、创建一个数据包对象接收数据（韭菜盘子）</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">64</span>];</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buffer, buffer.length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 3、等待接收数据。</span></span><br><span class="line">            socket.receive(packet);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 4、取出数据即可</span></span><br><span class="line">            <span class="comment">// 读取多少倒出多少</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> packet.getLength();</span><br><span class="line">            <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer,<span class="number">0</span>, len);</span><br><span class="line">            System.out.println(<span class="string">&quot;收到了来自：&quot;</span> + packet.getAddress() +<span class="string">&quot;, 对方端口是&quot;</span> + packet.getPort() +<span class="string">&quot;的消息：&quot;</span> + rs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-TCP通信-快速入门"><a href="#4-TCP通信-快速入门" class="headerlink" title="4.TCP通信-快速入门"></a>4.TCP通信-快速入门</h3><h4 id="4-1编写客户端代码"><a href="#4-1编写客户端代码" class="headerlink" title="4.1编写客户端代码"></a>4.1编写客户端代码</h4><p><strong>TCP协议回顾：</strong> </p><ul><li><p>TCP是一种面向连接，安全、可靠的传输数据的协议 </p></li><li><p>传输前，采用“三次握手”方式，点对点通信，是可靠的 </p></li><li><p>在连接中可进行大数据量的传输</p></li></ul><p><strong>注意：在java中只要是使用 java.net.Socket 类实现通信，底层即是使用了 TCP 协议</strong></p><p><strong>Socket(发送端)</strong></p><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public <strong>Socket</strong>(String host , int port)</td><td><strong>创建发送端的Socket对象</strong>与服务端连接，参数为服务端程序的ip和端口。</td></tr></tbody></table><p> <strong>Socket类成员方法</strong></p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>OutputStream <strong>getOutputStream</strong>()</td><td>获得<strong>字节输出流</strong>对象</td></tr><tr><td>InputStream <strong>getInputStream</strong>()</td><td>获得<strong>字节输入流</strong>对象</td></tr></tbody></table><p><strong>客户端发送消息</strong></p><p><strong>需求：</strong></p><p>客户端实现步骤</p><p>①创建客户端的Socket对象，请求与服务端的连接。</p><p>②使用socket对象调用getOutputStream()方法得到字节输出流。</p><p>③使用字节输出流完成数据的发送。</p><p>④释放资源：关闭socket管道。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   目标：完成Socket网络编程入门案例的客户端开发，实现1发1收。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;====客户端启动===&quot;</span>);</span><br><span class="line">            <span class="comment">// 1、创建Socket通信管道请求有服务端的连接</span></span><br><span class="line">            <span class="comment">// public Socket(String host, int port)</span></span><br><span class="line">            <span class="comment">// 参数一：服务端的IP地址</span></span><br><span class="line">            <span class="comment">// 参数二：服务端的端口</span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">7777</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2、从socket通信管道中得到一个字节输出流 负责发送数据</span></span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3、把低级的字节流包装成打印流</span></span><br><span class="line">            <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(os);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4、发送消息</span></span><br><span class="line">            ps.println(<span class="string">&quot;我是TCP的客户端，我已经与你对接，并发出邀请&quot;</span>);</span><br><span class="line">            ps.flush();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 关闭资源。</span></span><br><span class="line">            <span class="comment">// socket.close(); </span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2编写服务端代码"><a href="#4-2编写服务端代码" class="headerlink" title="4.2编写服务端代码"></a>4.2编写服务端代码</h4><p><strong>ServerSocket(服务端)</strong></p><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public <strong>ServerSocket</strong>(int port)</td><td><strong>注册服务端端口</strong></td></tr></tbody></table><p> <strong>ServerSocket类成员方法</strong></p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public Socket <strong>accept</strong>()</td><td><strong>等待接收客户端的Socket通信连接</strong>  连接成功返回Socket对象与客户端建立端到端通信</td></tr></tbody></table><p><strong>服务端实现接收消息</strong></p><p><strong>需求：</strong></p><p>服务端实现步骤</p><p>①创建ServerSocket对象，注册服务端端口。</p><p>②调用ServerSocket对象的accept()方法，等待客户端的连接，并得到Socket管道对象。</p><p>③通过Socket对象调用getInputStream()方法得到字节输入流、完成数据的接收。</p><p>④释放资源：关闭socket管道</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   目标：开发Socket网络编程入门代码的服务端，实现接收消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;===服务端启动成功===&quot;</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 1、 注册服务端端口</span></span><br><span class="line">            <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">7777</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 2、必须调用accept方法：等待接收客户端的Socket连接请求，建立Socket通信管道</span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 3、从socket通信管道中得到一个字节输入流</span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 4、把字节输入流包装成缓冲字符输入流进行消息的接收</span></span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is));</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 5、按照行读取消息</span></span><br><span class="line">            String msg;</span><br><span class="line">            <span class="keyword">if</span> ((msg = br.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">                System.out.println(socket.getRemoteSocketAddress() + <span class="string">&quot;说了：: &quot;</span> + msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Socket类(客户端的代表类)</strong></p><ul><li><p>public Socket(String host , int port)</p></li><li><p>使用Socket管道发送、接收数据。</p><ul><li><p>OutputStream getOutputStream() : 获得字节输出流对象(发）</p></li><li><p>InputStream getInputStream() : 获得字节输入流对象(收）</p></li></ul></li></ul><p><strong>ServerSocket类(服务端用的代表类)</strong></p><ul><li>ServerSocket类,注册端口。</li><li>等待接收客户端连接。<ul><li>调用accept()方法阻塞,得到Socket对象。</li></ul></li></ul><h5 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h5><p>TCP通信的基本原理</p><ul><li><p><strong>客户端怎么发，服务端就应该怎么收。</strong></p></li><li><p><strong>客户端如果没有消息，服务端会进入阻塞等待。</strong></p></li><li><p><strong>Socket一方关闭或者出现异常、对方Socket也会失效或者出错。</strong></p></li></ul><h3 id="5-TCP通信-多发多收消息"><a href="#5-TCP通信-多发多收消息" class="headerlink" title="5.TCP通信-多发多收消息"></a>5.TCP通信-多发多收消息</h3><p><strong>案例：</strong></p><p>使用TCP通信实现：多发多收消息</p><p><strong>需求：</strong></p><p>使用TCP通信方式实现：多发多收消息。</p><p>具体要求：</p><p>①可以使用死循环控制服务端收完消息继续等待接收下一个消息。</p><p>②客户端也可以使用死循环等待用户不断输入消息。</p><p>③客户端一旦输入了exit，则关闭客户端程序，并释放资源。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   目标：实现多发和多收</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;====客户端启动===&quot;</span>);</span><br><span class="line">            <span class="comment">// 1、创建Socket通信管道请求有服务端的连接</span></span><br><span class="line">            <span class="comment">// public Socket(String host, int port)</span></span><br><span class="line">            <span class="comment">// 参数一：服务端的IP地址</span></span><br><span class="line">            <span class="comment">// 参数二：服务端的端口</span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">7777</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2、从socket通信管道中得到一个字节输出流 负责发送数据</span></span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3、把低级的字节流包装成打印流</span></span><br><span class="line">            <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(os);</span><br><span class="line"></span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;请说：&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">                <span class="comment">// 4、发送消息</span></span><br><span class="line">                ps.println(msg);</span><br><span class="line">                ps.flush();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 关闭资源。</span></span><br><span class="line">            <span class="comment">// socket.close();</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   目标：开发Socket网络编程入门代码的服务端，实现接收消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;===服务端启动成功===&quot;</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 1、注册服务端端口</span></span><br><span class="line">            <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">7777</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 2、必须调用accept方法：等待接收客户端的Socket连接请求，建立Socket通信管道</span></span><br><span class="line">                <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 3、从socket通信管道中得到一个字节输入流</span></span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 4、把字节输入流包装成缓冲字符输入流进行消息的接收</span></span><br><span class="line">                <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is));</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 5、按照行读取消息</span></span><br><span class="line">                String msg;</span><br><span class="line">                <span class="keyword">while</span> ((msg = br.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">                    System.out.println(socket.getRemoteSocketAddress() + <span class="string">&quot;说了：: &quot;</span> + msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-TCP通信-同时接受多个客户端消息"><a href="#6-TCP通信-同时接受多个客户端消息" class="headerlink" title="6.TCP通信-同时接受多个客户端消息"></a>6.TCP通信-同时接受多个客户端消息</h3><p>1、之前我们的通信是否可以同时与多个客户端通信，为什么？</p><ul><li><p><strong>不可以的</strong></p></li><li><p><strong>单线程每次只能处理一个客户端的Socket通信</strong></p></li></ul><p>2、如何才可以让服务端可以处理多个客户端的通信需求？</p><ul><li><strong>引入多线程。</strong></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">客户端</span></span><br><span class="line"><span class="comment">    目标：实现服务端可以同时处理多个客户端的消息。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;====客户端启动===&quot;</span>);</span><br><span class="line">            <span class="comment">// 1、创建Socket通信管道请求有服务端的连接</span></span><br><span class="line">            <span class="comment">// public Socket(String host, int port)</span></span><br><span class="line">            <span class="comment">// 参数一：服务端的IP地址</span></span><br><span class="line">            <span class="comment">// 参数二：服务端的端口</span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">7777</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2、从socket通信管道中得到一个字节输出流 负责发送数据</span></span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3、把低级的字节流包装成打印流</span></span><br><span class="line">            <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(os);</span><br><span class="line"></span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;请说：&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">                <span class="comment">// 4、发送消息</span></span><br><span class="line">                ps.println(msg);</span><br><span class="line">                ps.flush();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 关闭资源。</span></span><br><span class="line">            <span class="comment">// socket.close();</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">服务端</span></span><br><span class="line"><span class="comment">   目标：实现服务端可以同时处理多个客户端的消息。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;===服务端启动成功===&quot;</span>);</span><br><span class="line">            <span class="comment">// 1、注册端口</span></span><br><span class="line">            <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">7777</span>);</span><br><span class="line">            <span class="comment">// a.定义一个死循环由主线程负责不断的接收客户端的Socket管道连接。</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 2、每接收到一个客户端的Socket管道，交给一个独立的子线程负责读取消息</span></span><br><span class="line">                <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">                System.out.println(socket.getRemoteSocketAddress()+ <span class="string">&quot;它来了，上线了！&quot;</span>);</span><br><span class="line">                <span class="comment">// 3、开始创建独立线程处理socket</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ServerReaderThread</span>(socket).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个多线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerReaderThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServerReaderThread</span><span class="params">(Socket socket)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 3、从socket通信管道中得到一个字节输入流</span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">            <span class="comment">// 4、把字节输入流包装成缓冲字符输入流进行消息的接收</span></span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is));</span><br><span class="line">            <span class="comment">// 5、按照行读取消息</span></span><br><span class="line">            String msg;</span><br><span class="line">            <span class="keyword">while</span> ((msg = br.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">                System.out.println(socket.getRemoteSocketAddress() + <span class="string">&quot;说了：: &quot;</span> + msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(socket.getRemoteSocketAddress() + <span class="string">&quot;下线了！！！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-TCP通信-使用线程池优化"><a href="#7-TCP通信-使用线程池优化" class="headerlink" title="7.TCP通信-使用线程池优化"></a>7.TCP通信-使用线程池优化</h3><p>1、目前的通信架构存在什么问题？</p><ul><li><p><strong>客户端与服务端的线程模型是： N-N的关系。</strong></p></li><li><p><strong>客户端并发越多，系统瘫痪的越快。</strong></p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">客户端</span></span><br><span class="line"><span class="comment">    拓展：使用线程池优化：实现通信。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;====客户端启动===&quot;</span>);</span><br><span class="line">            <span class="comment">// 1、创建Socket通信管道请求有服务端的连接</span></span><br><span class="line">            <span class="comment">// public Socket(String host, int port)</span></span><br><span class="line">            <span class="comment">// 参数一：服务端的IP地址</span></span><br><span class="line">            <span class="comment">// 参数二：服务端的端口</span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6666</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2、从socket通信管道中得到一个字节输出流 负责发送数据</span></span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3、把低级的字节流包装成打印流</span></span><br><span class="line">            <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(os);</span><br><span class="line"></span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;请说：&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">                <span class="comment">// 4、发送消息</span></span><br><span class="line">                ps.println(msg);</span><br><span class="line">                ps.flush();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 关闭资源。</span></span><br><span class="line">            <span class="comment">// socket.close();</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">服务端</span></span><br><span class="line"><span class="comment">   目标：实现服务端可以同时处理多个客户端的消息。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerDemo2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用静态变量记住一个线程池对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">300</span>,</span><br><span class="line">            <span class="number">1500</span>, <span class="number">6</span>, TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">2</span>)</span><br><span class="line">    , Executors.defaultThreadFactory(), <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;===服务端启动成功===&quot;</span>);</span><br><span class="line">            <span class="comment">// 1、注册端口</span></span><br><span class="line">            <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">6666</span>);</span><br><span class="line">            <span class="comment">// a.定义一个死循环由主线程负责不断的接收客户端的Socket管道连接。</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 2、每接收到一个客户端的Socket管道，</span></span><br><span class="line">                <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">                System.out.println(socket.getRemoteSocketAddress()+ <span class="string">&quot;它来了，上线了！&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 任务对象负责读取消息。</span></span><br><span class="line">                <span class="type">Runnable</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerReaderRunnable</span>(socket);</span><br><span class="line">                pool.execute(target);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-TCP通信实战案例-即时通信"><a href="#8-TCP通信实战案例-即时通信" class="headerlink" title="8.TCP通信实战案例-即时通信"></a>8.TCP通信实战案例-即时通信</h3><p>1、即时通信是什么含义，要实现怎么样的设计？</p><ul><li><p><strong>即时通信，是指一个客户端的消息发出去，其他客户端可以接收到。</strong></p></li><li><p><strong>之前我们的消息都是发给服务端的。</strong></p></li><li><p><strong>即时通信需要进行端口转发的设计思想。(发送端可以接受消息)</strong></p></li></ul><p><strong>客户端:</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    拓展：即时通信</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    客户端：发消息的同时，随时有人发消息过来。</span></span><br><span class="line"><span class="comment">    服务端：接收消息后，推送给其他所有的在线socket</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;====客户端启动===&quot;</span>);</span><br><span class="line">            <span class="comment">// 1、创建Socket通信管道请求有服务端的连接</span></span><br><span class="line">            <span class="comment">// public Socket(String host, int port)</span></span><br><span class="line">            <span class="comment">// 参数一：服务端的IP地址</span></span><br><span class="line">            <span class="comment">// 参数二：服务端的端口</span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6868</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 马上为客户端分配一个独立的线程负责读取它收到的消息</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ClientReaderThread</span>(socket).start();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2、从socket通信管道中得到一个字节输出流 负责发送数据</span></span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3、把低级的字节流包装成打印流</span></span><br><span class="line">            <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(os);</span><br><span class="line"></span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;请说：&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">                <span class="comment">// 4、发送消息</span></span><br><span class="line">                ps.println(msg);</span><br><span class="line">                ps.flush();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 关闭资源。</span></span><br><span class="line">            <span class="comment">// socket.close();</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientReaderThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ClientReaderThread</span><span class="params">(Socket socket)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 3、从socket通信管道中得到一个字节输入流</span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">            <span class="comment">// 4、把字节输入流包装成缓冲字符输入流进行消息的接收</span></span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is));</span><br><span class="line">            <span class="comment">// 5、按照行读取消息</span></span><br><span class="line">            String msg;</span><br><span class="line">            <span class="keyword">while</span> ((msg = br.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">                System.out.println(socket.getRemoteSocketAddress() + <span class="string">&quot;收到了: &quot;</span> + msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;服务端把你踢出去了~~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>服务端:</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   目标: 即时通信</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerDemo2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Socket&gt; onLineSockets = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;===服务端启动成功===&quot;</span>);</span><br><span class="line">            <span class="comment">// 1、注册端口</span></span><br><span class="line">            <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">6868</span>);</span><br><span class="line">            <span class="comment">// a.定义一个死循环由主线程负责不断的接收客户端的Socket管道连接。</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 2、每接收到一个客户端的Socket管道，交给一个独立的子线程负责读取消息</span></span><br><span class="line">                <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">                System.out.println(socket.getRemoteSocketAddress()+ <span class="string">&quot;它来了，上线了！&quot;</span>);</span><br><span class="line">                <span class="comment">// 把当前客户端管道Socket加入到在线集合中去</span></span><br><span class="line">                onLineSockets.add(socket);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3、开始创建独立线程处理socket</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ServerReaderThread</span>(socket).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerReaderThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServerReaderThread</span><span class="params">(Socket socket)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 3、从socket通信管道中得到一个字节输入流</span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">            <span class="comment">// 4、把字节输入流包装成缓冲字符输入流进行消息的接收</span></span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is));</span><br><span class="line">            <span class="comment">// 5、按照行读取消息</span></span><br><span class="line">            String msg;</span><br><span class="line">            <span class="keyword">while</span> ((msg = br.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">                System.out.println(socket.getRemoteSocketAddress() + <span class="string">&quot;说了：: &quot;</span> + msg);</span><br><span class="line">                <span class="comment">// 把这个消息发给当前所有在线socket</span></span><br><span class="line">                sendMsgToAll(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(socket.getRemoteSocketAddress() + <span class="string">&quot;下线了！！！&quot;</span>);</span><br><span class="line">            <span class="comment">// 从在线集合中抹掉本客户端socket</span></span><br><span class="line">            ServerDemo2.onLineSockets.remove(socket);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sendMsgToAll</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 遍历全部的在线 socket给他们发消息</span></span><br><span class="line">            <span class="keyword">for</span> (Socket onLineSocket : ServerDemo2.onLineSockets) &#123;</span><br><span class="line">                <span class="comment">// 除了自己的socket，其他socket我都发！！</span></span><br><span class="line">                <span class="keyword">if</span>(onLineSocket != socket)&#123;</span><br><span class="line">                    <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(socket.getOutputStream());</span><br><span class="line">                    ps.println(msg);</span><br><span class="line">                    ps.flush();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-TCP通信实战案例-模拟BS系统"><a href="#9-TCP通信实战案例-模拟BS系统" class="headerlink" title="9.TCP通信实战案例-模拟BS系统"></a>9.TCP通信实战案例-模拟BS系统</h3><p>1、之前的客户端都是什么样的</p><ul><li><strong>其实就是CS架构，客户端实需要我们自己开发实现的。</strong></li></ul><p>2、BS结构是什么样的，需要开发客户端吗？</p><ul><li><p><strong>浏览器访问服务端，不需要开发客户端。</strong></p></li><li><p><strong>HTTP响应数据的协议格式：就是给浏览器显示的网页信息</strong></p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    了解：BS-浏览器-服务器基本了解。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    引入：</span></span><br><span class="line"><span class="comment">        之前客户端和服务端都需要自己开发。也就是CS架构。</span></span><br><span class="line"><span class="comment">        接下来模拟一下BS架构。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    客户端：浏览器。（无需开发）</span></span><br><span class="line"><span class="comment">    服务端：自己开发。</span></span><br><span class="line"><span class="comment">    需求：在浏览器中请求本程序，响应一个网页文字给浏览器显示</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BSserverDemo</span> &#123;</span><br><span class="line">    <span class="comment">// 使用静态变量记住一个线程池对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">3</span>,</span><br><span class="line">            <span class="number">5</span>, <span class="number">6</span>, TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">2</span>)</span><br><span class="line">            , Executors.defaultThreadFactory(), <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1.注册端口</span></span><br><span class="line">            <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8080</span>);</span><br><span class="line">            <span class="comment">// 2.创建一个循环接收多个客户端的请求。</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> ss.accept();</span><br><span class="line">                <span class="comment">// 3.交给一个独立的线程来处理！</span></span><br><span class="line">                pool.execute(<span class="keyword">new</span> <span class="title class_">ServerReaderRunnable</span>(socket));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//多线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerReaderRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServerReaderRunnable</span><span class="params">(Socket socket)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 浏览器 已经与本线程建立了Socket管道</span></span><br><span class="line">            <span class="comment">// 响应消息给浏览器显示</span></span><br><span class="line">            <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(socket.getOutputStream());</span><br><span class="line">            <span class="comment">// 必须响应HTTP协议格式数据，否则浏览器不认识消息</span></span><br><span class="line">            ps.println(<span class="string">&quot;HTTP/1.1 200 OK&quot;</span>); <span class="comment">// 协议类型和版本 响应成功的消息！</span></span><br><span class="line">            ps.println(<span class="string">&quot;Content-Type:text/html;charset=UTF-8&quot;</span>); <span class="comment">// 响应的数据类型：文本/网页</span></span><br><span class="line"></span><br><span class="line">            ps.println(); <span class="comment">// 必须发送一个空行</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 才可以响应数据回去给浏览器</span></span><br><span class="line">            ps.println(<span class="string">&quot;&lt;span style=&#x27;color:red;font-size:90px&#x27;&gt;《最牛的149期》 &lt;/span&gt;&quot;</span>);</span><br><span class="line">            ps.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(socket.getRemoteSocketAddress() + <span class="string">&quot;下线了！！！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> java,面向对象进阶,网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>day20 - 多线程</title>
      <link href="/post/c880ece8.html"/>
      <url>/post/c880ece8.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-多线程的创建"><a href="#1-多线程的创建" class="headerlink" title="1.多线程的创建"></a>1.多线程的创建</h3><h4 id="1-1方式一：继承Thread类"><a href="#1-1方式一：继承Thread类" class="headerlink" title="1.1方式一：继承Thread类"></a>1.1方式一：继承Thread类</h4><p><strong>Thread类</strong></p><ul><li><p>Java是通过java.lang.Thread 类来代表线程的。 </p></li><li><p>按照面向对象的思想，Thread类应该提供了实现多线程的方式。</p></li></ul><p><strong>继承Thread类</strong></p><p><strong>①定义一个子类MyThread继承线程类java.lang.Thread，重写run()方法</strong></p><p><strong>②创建MyThread类的对象</strong></p><p><strong>③调用线程对象的start()方法启动线程（启动后还是执行run方法的）</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   目标：多线程的创建方式一：继承Thread类实现。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 3、new一个新线程对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="comment">// 4、调用start方法启动线程（执行的还是run方法）</span></span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;主线程执行输出：&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   1、定义一个线程类继承Thread类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;  <span class="comment">//继承Thread类</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">       2、重写run方法，里面是定义线程以后要干啥</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;子线程执行输出：&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方式一优缺点：</strong></p><ul><li><p>优点：编码简单</p></li><li><p>缺点：线程类已经继承Thread，无法继承其他类，不利于扩展。</p></li></ul><h4 id="1-2方式二：实现Runnable接口"><a href="#1-2方式二：实现Runnable接口" class="headerlink" title="1.2方式二：实现Runnable接口"></a>1.2方式二：实现Runnable接口</h4><p><strong>Thread的构造器</strong></p><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public Thread(String name)</td><td>可以为当前线程指定名称</td></tr><tr><td>public Thread(Runnable target)</td><td>封装Runnable对象成为线程对象</td></tr><tr><td>public Thread(Runnable target ，String name )</td><td>封装Runnable对象成为线程对象，并指定线程名称</td></tr></tbody></table><p><strong>(一).实现Runnable接口(普通形式)</strong></p><p><strong>①定义一个线程任务类MyRunnable实现Runnable接口，重写run()方法</strong></p><p><strong>②创建MyRunnable任务对象</strong></p><p><strong>③把MyRunnable任务对象交给Thread处理。</strong></p><p><strong>④调用线程对象的start()方法启动线程</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   目标：学会线程的创建方式二，理解它的优缺点。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 3、创建一个任务对象</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">        <span class="comment">// 4、把任务对象交给Thread处理</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(target);</span><br><span class="line">        <span class="comment">// Thread t = new Thread(target, &quot;1号&quot;); //第二个参数可以给线程取名</span></span><br><span class="line">        <span class="comment">// 5、启动线程</span></span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;主线程执行输出：&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   1、定义一个线程任务类 实现Runnable接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;  <span class="comment">//实现Runnable接口</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">       2、重写run方法，定义线程的执行任务的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;子线程执行输出：&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(二).实现Runnable接口(匿名内部类形式–&gt;简化语法)</strong></p><p>①可以创建Runnable的匿名内部类对象。</p><p>②交给Thread处理。</p><p>③调用线程对象的start()启动线程。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   目标：学会线程的创建方式二(匿名内部类方式实现，语法形式)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo2Other</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//子线程1</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;子线程1执行输出：&quot;</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(target);</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//子线程2</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;子线程2执行输出：&quot;</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//子线程3</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;子线程3执行输出：&quot;</span> + i);</span><br><span class="line">            &#125;&#125;).start();</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment">//主线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;主线程执行输出：&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>方式二优缺点：</strong></p><ul><li><p>优点：线程任务类只是实现接口，可以继续继承类和实现接口，扩展性强。</p></li><li><p>缺点：编程多一层对象包装，如果线程有执行结果是不可以直接返回的。</p></li></ul><h4 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h4><ul><li><p><strong>前2种方式都存在一个问题：</strong></p><ul><li><strong>他们重写的run方法均不能直接返回结果。</strong></li><li><strong>不适合需要返回线程执行结果的业务场景。</strong></li></ul></li><li><p><strong>怎么解决这个问题呢？</strong></p><ul><li><p><strong>JDK 5.0提供了Callable和FutureTask来实现(及方式三)。</strong></p></li><li><p><strong>这种方式的优点是：可以得到线程执行的结果。</strong></p></li></ul></li></ul><h4 id="1-3方式三：JDK-5-0新增：实现Callable接口"><a href="#1-3方式三：JDK-5-0新增：实现Callable接口" class="headerlink" title="1.3方式三：JDK 5.0新增：实现Callable接口"></a>1.3方式三：JDK 5.0新增：实现Callable接口</h4><p><strong>利用Callable、FutureTask接口实现。</strong></p><ol><li><p><strong>得到任务对象</strong></p><p><strong>①定义类实现Callable&lt;&gt;接口，重写call方法，封装要做的事情。</strong></p><p><strong>②获得Callable&lt;&gt;对象</strong></p><p><strong>③把Callable任务对象 交给 FutureTask 对象</strong><br>（FutureTask对象的作用1： FutureTask是Runnable的对象（因为实现了Runnable接口），可以交给Thread了<br>FutureTask对象的作用2： 可以在线程执行完毕之后通过调用其get方法得到线程执行完成的结果）</p></li><li><p><strong>把线程任务对象交给Thread处理。</strong></p></li><li><p><strong>调用Thread的start方法启动线程，执行任务</strong></p></li><li><p><strong>线程执行完毕后、通过FutureTask的get方法去获取任务执行的结果。</strong></p></li></ol><p><strong>FutureTask的API</strong></p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>public FutureTask&lt;&gt;(Callable call)</td><td>把Callable对象封装成FutureTask对象。</td></tr><tr><td>public V get() throws Exception</td><td>获取线程执行call方法返回的结果。</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   目标：学会线程的创建方式三：实现Callable接口，结合FutureTask完成。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 3、创建Callable任务对象</span></span><br><span class="line">        Callable&lt;String&gt; call = <span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">100</span>);</span><br><span class="line">        <span class="comment">// 4、把Callable任务对象 交给 FutureTask 对象</span></span><br><span class="line">        <span class="comment">//  FutureTask对象的作用1： 是Runnable的对象（实现了Runnable接口），可以交给Thread了</span></span><br><span class="line">        <span class="comment">//  FutureTask对象的作用2： 可以在线程执行完毕之后通过调用其get方法得到线程执行完成的结果</span></span><br><span class="line">        FutureTask&lt;String&gt; f1 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(call);</span><br><span class="line">        <span class="comment">// 5、交给线程处理</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(f1);</span><br><span class="line">        <span class="comment">// 6、启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Callable&lt;String&gt; call2 = <span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">200</span>);</span><br><span class="line">        FutureTask&lt;String&gt; f2 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(call2);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(f2);</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 如果f1任务没有执行完毕，这里的代码会等待，直到线程1跑完才提取结果。</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">rs1</span> <span class="operator">=</span> f1.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;第一个结果：&quot;</span> + rs1);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 如果f2任务没有执行完毕，这里的代码会等待，直到线程2跑完才提取结果。</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">rs2</span> <span class="operator">=</span> f2.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;第二个结果：&quot;</span> + rs2);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1、定义一个任务类 实现Callable接口  应该申明线程任务执行完毕后的结果的数据类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt;&#123;  <span class="comment">//实现Callable接口</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyCallable</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">       2、重写call方法（任务方法）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n ; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;子线程执行的结果是：&quot;</span> + sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方式三优缺点：</strong></p><ul><li><p>优点：线程任务类只是实现接口，可以继续继承类和实现接口，扩展性强。</p><p><strong>可以在线程执行完毕后去获取线程执行的结果。</strong></p></li><li><p>缺点：编码复杂一点。</p></li></ul><p>3种方式对比</p><table><thead><tr><th>方式</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>继承Thread类</td><td>编程比较简单，可以直接使用Thread类中的方法</td><td>扩展性较差，不能再继承其他的类，不能返回线程执行的结果</td></tr><tr><td>实现Runnable接口</td><td>扩展性强，实现该接口的同时还可以继承其他的类。</td><td>编程相对复杂，不能返回线程执行的结果</td></tr><tr><td>实现Callable接口</td><td>扩展性强，实现该接口的同时还可以继承其他的类。可以得到线程执行的结果</td><td>编程相对复杂</td></tr></tbody></table><h3 id="2-Thread的常用方法"><a href="#2-Thread的常用方法" class="headerlink" title="2.Thread的常用方法"></a>2.Thread的常用方法</h3><p><strong>Thread常用API说明</strong></p><ul><li><p>Thread常用方法：获取线程名称<strong>getName</strong>()、设置名称<strong>setName</strong>()、获取当前线程对象<strong>currentThread</strong>()。</p></li><li><p>至于Thread类提供的诸如：yield、join、interrupt、不推荐的方法 stop 、守护线程、线程优先级等线程的控制方法，在开发中很少使用，这些方法会在高级篇以及后续需要用到的时候再为大家讲解。</p></li></ul><p>当有很多线程在执行的时候，我们怎么去区分这些线程呢？</p><ul><li><strong>此时需要使用Thread的常用方法：getName()、setName()、currentThread</strong>()<strong>等。</strong></li></ul><p><strong>Thread获取和设置线程名称</strong></p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>String  getName()</td><td>获取当前线程的名称，默认线程名称是Thread-索引</td></tr><tr><td>void  setName(String  name)</td><td>将此线程的名称更改为指定的名称，通过构造器也可以设置线程名称</td></tr></tbody></table><p><strong>Thread类获得当前线程的对象</strong></p><p><strong>注意:</strong></p><ul><li><p>此方法是Thread类的静态方法，可以直接使用Thread类调用。</p></li><li><p><strong>这个方法是在哪个线程执行中调用的，就会得到哪个线程对象。</strong></p></li></ul><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>public  static Thread currentThread()：</td><td>返回对当前正在执行的线程对象的引用</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：线程的API  </span></span><br><span class="line"><span class="comment">     getName、setName、currentThread</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo01</span> &#123;</span><br><span class="line">    <span class="comment">// main方法是由主线程负责调度的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;1号&quot;</span>);</span><br><span class="line">        <span class="comment">// t1.setName(&quot;1号&quot;);</span></span><br><span class="line">        t1.start();</span><br><span class="line">        System.out.println(t1.getName());</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;2号&quot;</span>);</span><br><span class="line">        <span class="comment">// t2.setName(&quot;2号&quot;);</span></span><br><span class="line">        t2.start();</span><br><span class="line">        System.out.println(t2.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 哪个线程执行它，它就得到哪个线程对象（当前线程对象）</span></span><br><span class="line">        <span class="comment">// 主线程的名称就叫main</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">m</span> <span class="operator">=</span> Thread.currentThread(<span class="string">&quot;最牛的线程&quot;</span>);</span><br><span class="line">        System.out.println(m.getName());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println( m.getName() + <span class="string">&quot;输出：&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Thread其他常用方法、构造器</strong></p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>public  static void sleep(long time)</td><td>让当前线程休眠指定的时间后再继续执行，单位为毫秒。</td></tr><tr><td>public  void run()</td><td>线程任务方法</td></tr><tr><td>public  void start()</td><td>线程启动方法</td></tr></tbody></table><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public  Thread(String name)</td><td>可以为当前线程指定名称</td></tr><tr><td>public  Thread(Runnable target)</td><td>封装Runnable对象成为线程对象</td></tr><tr><td>public  Thread(Runnable target  ，String  name )</td><td>封装Runnable对象成为线程对象，并指定线程名称</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;第一&quot;</span>);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(target);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(target,<span class="string">&quot;第二&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="3-线程安全"><a href="#3-线程安全" class="headerlink" title="3.线程安全"></a>3.线程安全</h3><h4 id="3-1线程安全问题是什么、发生的原因"><a href="#3-1线程安全问题是什么、发生的原因" class="headerlink" title="3.1线程安全问题是什么、发生的原因"></a>3.1线程安全问题是什么、发生的原因</h4><p><strong>线程安全问题</strong></p><ul><li>多个线程同时操作同一个共享资源的时候可能会出现业务安全问题，称为线程安全问题。</li></ul><p>线程安全问题出现的原因？</p><ul><li><p><strong>存在多线程并发</strong></p></li><li><p><strong>同时访问共享资源</strong></p></li><li><p><strong>存在修改共享资源</strong></p></li></ul><h4 id="3-2线程安全问题案例模拟"><a href="#3-2线程安全问题案例模拟" class="headerlink" title="3.2线程安全问题案例模拟"></a>3.2线程安全问题案例模拟</h4><p><strong>需求：</strong></p><ul><li>小明和小红是一对夫妻，他们有一个共同的账户，余额是10万元，模拟2人同时去取钱10万。</li></ul><p><strong>分析：</strong></p><p>①：需要提供一个账户类，创建一个账户对象代表2个人的共享账户。</p><p>②：需要定义一个线程类，线程类可以处理账户对象。</p><p>③：创建2个线程对象，传入同一个账户对象。</p><p>④：启动2个线程，去同一个账户对象中取钱10万。</p><h3 id="4-线程同步"><a href="#4-线程同步" class="headerlink" title="4.线程同步"></a>4.线程同步</h3><h4 id="4-1同步思想概述"><a href="#4-1同步思想概述" class="headerlink" title="4.1同步思想概述"></a>4.1同步思想概述</h4><p><strong>线程同步</strong></p><ul><li>为了解决线程安全问题。</li></ul><p>1、取钱案例出现问题的原因？</p><ul><li>多个线程同时执行，发现账户都是够钱的。</li></ul><p>2、如何才能保证线程安全呢？</p><ul><li>让多个线程实现先后依次访问共享资源，这样就解决了安全问题</li></ul><p><strong>线程同步的核心思想:</strong></p><p><strong>加锁，把共享资源进行上锁</strong>，每次只能一个线程进入访问完毕以后解锁，然后其他线程才能进来。</p><h4 id="4-2方式一：同步代码块"><a href="#4-2方式一：同步代码块" class="headerlink" title="4.2方式一：同步代码块"></a>4.2方式一：同步代码块</h4><p><strong>同步代码块</strong></p><ul><li><p>作用：把出现线程安全问题的核心代码给上锁。</p></li><li><p>原理：每次只能一个线程进入，执行完毕后自动解锁，其他线程才可以进来执行。</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步锁对象) &#123;</span><br><span class="line">操作共享资源的代码(核心代码)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试线程安全问题</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSafeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、创建一个共享的账户对象。</span></span><br><span class="line">        <span class="type">Account</span> <span class="variable">acc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span>(<span class="string">&quot;ICBC-111&quot;</span> , <span class="number">100000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、创建2个线程对象，操作同一个账户对象</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DrawThread</span>(acc, <span class="string">&quot;小明&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DrawThread</span>(acc,<span class="string">&quot;小红&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">————————————————————————————————————————————————————————————————————————————————————————————————————————————</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    账户类：余额，卡号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String cardId;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> money; <span class="comment">// 余额 关键信息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">(String cardId, <span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cardId = cardId;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCardId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cardId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCardId</span><span class="params">(String cardId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cardId = cardId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getMoney</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMoney</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="comment">//小明 小红</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawMoney</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、拿到是谁来取钱</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">        <span class="comment">// 同步代码块</span></span><br><span class="line">        <span class="comment">// 小明 小红</span></span><br><span class="line">        <span class="comment">// this == acc 共享账户</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="comment">// 2、判断余额是否足够</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span>.money &gt;= money)&#123;</span><br><span class="line">                <span class="comment">// 钱够了</span></span><br><span class="line">                System.out.println(name+<span class="string">&quot;来取钱，吐出：&quot;</span> + money);</span><br><span class="line">                <span class="comment">// 更新余额</span></span><br><span class="line">                <span class="built_in">this</span>.money -= money;</span><br><span class="line">                System.out.println(name+<span class="string">&quot;取钱后，余额剩余：&quot;</span> + <span class="built_in">this</span>.money);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 3、余额不足</span></span><br><span class="line">                System.out.println(name+<span class="string">&quot;来取钱，余额不足！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">————————————————————————————————————————————————————————————————————————————————————————————————————————————</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  线程类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DrawThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;  <span class="comment">//继承Thread</span></span><br><span class="line">    <span class="keyword">private</span> Account acc;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DrawThread</span><span class="params">(Account acc, String name)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.acc = acc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写run()方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 小明 小红  ： acc</span></span><br><span class="line">        acc.drawMoney(<span class="number">100000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><p><strong>锁对象要求</strong></p><ul><li>理论上：锁对象只要对于当前同时执行的线程来说是同一个对象即可。</li></ul><p><strong>锁对象用任意唯一的对象好不好呢</strong><strong>?</strong></p><ul><li>不好，会影响其他无关线程的执行。</li></ul><p><strong>锁对象的规范要求</strong></p><ul><li><p>规范上：建议使用共享资源作为锁对象。</p></li><li><p>对于<strong>实例方法</strong>建议使用<strong>this</strong>作为锁对象。</p></li><li><p>对于<strong>静态方法</strong>建议使用字节码（<strong>类名.class</strong>）对象作为锁对象。</p></li></ul><h4 id="4-3方式二：同步方法"><a href="#4-3方式二：同步方法" class="headerlink" title="4.3方式二：同步方法"></a>4.3方式二：同步方法</h4><p><strong>同步方法</strong></p><ul><li><p>作用：把出现线程安全问题的核心方法给上锁。</p></li><li><p>原理：每次只能一个线程进入，执行完毕以后自动解锁，其他线程才可以进来执行。</p></li></ul><p><strong>格式</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 <span class="keyword">synchronized</span> 返回值类型 方法名称(形参列表) &#123;</span><br><span class="line">(操作共享资源的代码)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    账户类：余额，卡号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String cardId;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> money; <span class="comment">// 余额 关键信息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">(String cardId, <span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cardId = cardId;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCardId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cardId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCardId</span><span class="params">(String cardId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cardId = cardId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getMoney</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMoney</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//小明 小红  this == acc</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">drawMoney</span><span class="params">(<span class="type">double</span> money)</span> &#123; <span class="comment">//synchronized修饰符</span></span><br><span class="line">        <span class="comment">// 1、拿到是谁来取钱</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">        <span class="comment">// 2、判断余额是否足够</span></span><br><span class="line">        <span class="comment">// 小明  小红</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.money &gt;= money)&#123;</span><br><span class="line">            <span class="comment">// 钱够了</span></span><br><span class="line">            System.out.println(name+<span class="string">&quot;来取钱，吐出：&quot;</span> + money);</span><br><span class="line">            <span class="comment">// 更新余额</span></span><br><span class="line">            <span class="built_in">this</span>.money -= money;</span><br><span class="line">            System.out.println(name+<span class="string">&quot;取钱后，余额剩余：&quot;</span> + <span class="built_in">this</span>.money);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 3、余额不足</span></span><br><span class="line">            System.out.println(name+<span class="string">&quot;来取钱，余额不足！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>同步方法底层原理</strong></p><ul><li><p>同步方法其实底层也是有隐式锁对象的，只是锁的范围是整个方法代码。</p></li><li><p>如果方法是<strong>实例方法</strong>：同步方法默认用<strong>this</strong>作为的锁对象。但是代码要高度面向对象！</p></li><li><p>如果方法是<strong>静态方法</strong>：同步方法默认<strong>用类名.class</strong>作为的锁对象。</p></li></ul><p><strong>是同步代码块好还是同步方法好一点？</strong></p><ul><li><strong>同步代码块锁的范围更小，同步方法锁的范围更大。</strong></li></ul><h4 id="4-4方式三：Lock锁"><a href="#4-4方式三：Lock锁" class="headerlink" title="4.4方式三：Lock锁"></a>4.4方式三：Lock锁</h4><p><strong>Lock锁</strong></p><ul><li><p>为了更清晰的表达如何加锁和释放锁，JDK5以后提供了一个新的锁对象Lock，更加灵活、方便。</p></li><li><p>Lock实现提供比使用synchronized方法和语句可以获得更广泛的锁定操作。</p></li><li><p>Lock是接口不能直接实例化，这里采用它的实现类ReentrantLock来构建Lock锁对象。</p></li></ul><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>public ReentrantLock()</td><td>获得Lock锁的实现类对象</td></tr></tbody></table><p><strong>Lock的API</strong></p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>void lock()</td><td>获得锁</td></tr><tr><td>void  unlock()</td><td>释放锁</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    账户类：余额 , 卡号。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String cardId;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> money; <span class="comment">// 余额 关键信息</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//一.获得Lock锁的实现类对象  </span></span><br><span class="line">    <span class="comment">// final修饰后：锁对象是唯一和不可替换的，非常专业</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">(String cardId, <span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cardId = cardId;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCardId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cardId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCardId</span><span class="params">(String cardId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cardId = cardId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getMoney</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMoney</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  小明 小红</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawMoney</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、拿到是谁来取钱</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">        <span class="comment">// 2、判断余额是否足够</span></span><br><span class="line">        <span class="comment">// 小明  小红</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//二.获得锁 | 释放锁 </span></span><br><span class="line">        lock.lock(); <span class="comment">// 上锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span>.money &gt;= money)&#123;</span><br><span class="line">                <span class="comment">// 钱够了</span></span><br><span class="line">                System.out.println(name+<span class="string">&quot;来取钱，吐出：&quot;</span> + money);</span><br><span class="line">                <span class="comment">// 更新余额</span></span><br><span class="line">                <span class="built_in">this</span>.money -= money;</span><br><span class="line">                System.out.println(name+<span class="string">&quot;取钱后，余额剩余：&quot;</span> + <span class="built_in">this</span>.money);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 3、余额不足</span></span><br><span class="line">                System.out.println(name+<span class="string">&quot;来取钱，余额不足！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;  <span class="comment">// finally是必须执行，防止代码锁死</span></span><br><span class="line">            lock.unlock(); <span class="comment">// 解锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-线程通信"><a href="#5-线程通信" class="headerlink" title="5.线程通信"></a>5.线程通信</h3><p><strong>什么是线程通信、如何实现？</strong></p><ul><li>所谓线程通信就是线程间相互发送数据，线程间共享一个资源即可实现线程通信。</li></ul><p><strong>线程通信常见形式</strong></p><ul><li><p>通过共享一个数据的方式实现。</p></li><li><p>根据共享数据的情况决定自己该怎么做，以及通知其他线程怎么做。</p></li></ul><p><strong>线程通信实际应用场景</strong></p><ul><li><p>生产者与消费者模型：生产者线程负责生产数据，消费者线程负责消费生产者产生的数据。</p></li><li><p>要求：生产者线程生产完数据后唤醒消费者，然后等待自己，消费者消费完该数据后唤醒生产者，然后等待自己。</p></li></ul><p><strong>线程通信案例模拟</strong></p><ul><li><p>模拟客服系统，系统可以不断的接入电话 和 分发给客服。</p></li><li><p>线程通信的前提：线程通信通常是在多个线程操作同一个共享资源的时候需要进行通信，且要保证线程安全。</p></li></ul><p><strong>Object类的等待和唤醒方法：</strong></p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>void  wait()</td><td>让当前线程等待并释放所占锁，直到另一个线程调用notify()方法或 notifyAll()方法</td></tr><tr><td>void  notify()</td><td>唤醒正在等待的单个线程</td></tr><tr><td>void notifyAll()</td><td>唤醒正在等待的所有线程</td></tr></tbody></table><p><strong>注意</strong></p><ul><li>上述方法应该使用当前同步锁对象进行调用。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   接电话线程类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 1号  2号</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            CallSystem.receive();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 不断的打入电话</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            CallSystem.call();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  线程类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DrawThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Account acc;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DrawThread</span><span class="params">(Account acc, String name)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.acc = acc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 小明 小红  ： acc</span></span><br><span class="line">        acc.drawMoney(<span class="number">100000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   呼叫系统。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallSystem</span> &#123;</span><br><span class="line">    <span class="comment">// 定义一个变量记录当前呼入进来的电话。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 最多只接听一个。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 接入电话</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            number++;</span><br><span class="line">            System.out.println(<span class="string">&quot;成功接入一个用户，等待分发~~~~&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 唤醒别人 : 1个</span></span><br><span class="line">            CallSystem.class.notify();</span><br><span class="line">            <span class="comment">// 让当前线程对象进入等待状态。</span></span><br><span class="line">            CallSystem.class.wait();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">       分发电话</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">receive</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">            <span class="keyword">if</span>(number == <span class="number">1</span>)&#123;</span><br><span class="line">                System.out.println(name + <span class="string">&quot;此电话已经分发给客服并接听完毕了~~~~~&quot;</span>);</span><br><span class="line">                number--;</span><br><span class="line">                <span class="comment">// 唤醒别人 : 1个</span></span><br><span class="line">                CallSystem.class.notify();</span><br><span class="line">                CallSystem.class.wait(); <span class="comment">// 让当前线程等待</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 唤醒别人 : 1个</span></span><br><span class="line">                CallSystem.class.notify();</span><br><span class="line">                CallSystem.class.wait(); <span class="comment">// 让当前线程等待</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-线程池"><a href="#6-线程池" class="headerlink" title="6.线程池"></a>6.线程池</h3><h4 id="6-1线程池概述"><a href="#6-1线程池概述" class="headerlink" title="6.1线程池概述"></a>6.1线程池概述</h4><p><strong>什么是线程池？</strong></p><ul><li>线程池就是一个可以复用线程的技术。</li></ul><p><strong>不使用线程池的问题</strong> </p><ul><li>如果用户每发起一个请求，后台就创建一个新线程来处理，下次新任务来了又要创建新线程，而创建新线程的开销是很大的，这样会严重影响系统的性能。</li></ul><h4 id="6-2线程池实现的API、参数说明"><a href="#6-2线程池实现的API、参数说明" class="headerlink" title="6.2线程池实现的API、参数说明"></a>6.2线程池实现的API、参数说明</h4><p><strong>谁代表线程池？</strong></p><ul><li>JDK 5.0起提供了代表线程池<strong>ExecutorService接口</strong></li></ul><p><strong>如何得到线程池对象</strong></p><ul><li><p>方式一：使用ExecutorService的实现类ThreadPoolExecutor自创建一个线程池对象</p></li><li><p>方式二：使用Executors（线程池的工具类）调用方法返回不同特点的线程池对象</p></li></ul><p><strong>ThreadPoolExecutor构造器的参数说明</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">  <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">  <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">  TimeUnit unit,</span></span><br><span class="line"><span class="params">  BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">  ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">  RejectedExecutionHandler handler)</span> </span><br></pre></td></tr></table></figure><table><thead><tr><th>参数一：指定线程池的线程数量（核心线程）： corePoolSize</th><th>不能小于0</th></tr></thead><tbody><tr><td>参数二：指定线程池可支持的最大线程数： maximumPoolSize</td><td>最大数量 &gt;&#x3D; 核心线程数量</td></tr><tr><td>参数三：指定临时线程的最大存活时间： keepAliveTime</td><td>不能小于0</td></tr><tr><td>参数四：指定存活时间的单位(秒、分、时、天)： unit</td><td>时间单位</td></tr><tr><td>参数五：指定任务队列： workQueue</td><td>不能为null</td></tr><tr><td>参数六：指定用哪个线程工厂创建线程： threadFactory</td><td>不能为null</td></tr><tr><td>参数七：指定线程忙，任务满的时候，新任务来了怎么办： handler</td><td>不能为null</td></tr></tbody></table><p><strong>ExecutorService的常用方法</strong></p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>void <strong>execute</strong>(Runnable command)</td><td>执行任务&#x2F;命令，没有返回值，一般用来<strong>执行  Runnable 任务</strong></td></tr><tr><td>Future<T>  <strong>submit</strong>(Callable<T> task)</td><td>执行任务，返回未来任务对象获取线程结果，一般拿来<strong>执行  Callable  任务</strong></td></tr><tr><td>void  <strong>shutdown</strong>()</td><td>等<strong>任务执行完毕后关闭线程池</strong></td></tr><tr><td><strong><a href="mk:@MSITStore:D:\course\jdk-11中文api修订版.CHM::/java.base/java/util/List.html">List</a><Runnable> shutdownNow</strong>()</td><td><strong>立刻关闭</strong>，停止正在执行的任务，并返回队列中未执行的任务</td></tr></tbody></table><p><strong>新任务拒绝策略</strong></p><table><thead><tr><th>策略</th><th>详解</th></tr></thead><tbody><tr><td>ThreadPoolExecutor.AbortPolicy</td><td>丢弃任务并抛出RejectedExecutionException异常。<strong>是默认的策略</strong></td></tr><tr><td>ThreadPoolExecutor.DiscardPolicy：</td><td>丢弃任务，但是不抛出异常  这是不推荐的做法</td></tr><tr><td>ThreadPoolExecutor.DiscardOldestPolicy</td><td>抛弃队列中等待最久的任务  然后把当前任务加入队列中</td></tr><tr><td>ThreadPoolExecutor.CallerRunsPolicy</td><td>由主线程负责调用任务的run()方法从而绕过线程池直接执行</td></tr></tbody></table><p><strong>线程池常见面试题</strong></p><p><strong>临时线程什么时候创建啊？</strong></p><ul><li>新任务提交时发现核心线程都在忙，任务队列也满了，并且还可以创建临时线程，此时才会创建临时线程。</li></ul><p><strong>什么时候会开始拒绝任务？</strong></p><ul><li>核心线程和临时线程都在忙，任务队列也满了，新的任务过来的时候才会开始任务拒绝。</li></ul><h4 id="6-3线程池处理"><a href="#6-3线程池处理" class="headerlink" title="6.3线程池处理"></a><strong>6.3线程池处理</strong></h4><h5 id="方式一：Runnable任务"><a href="#方式一：Runnable任务" class="headerlink" title="方式一：Runnable任务"></a>方式一：Runnable任务</h5><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>void <strong>execute</strong>(Runnable command)</td><td>执行任务&#x2F;命令，没有返回值，一般用来执行  <strong>Runnable 任务</strong></td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首先，自定义线程，实现Runnable接口，重写Run方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*目标：自定义一个线程池对象，并测试其特性。 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、创建线程池对象</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         public ThreadPoolExecutor(int corePoolSize,</span></span><br><span class="line"><span class="comment">                                  int maximumPoolSize,</span></span><br><span class="line"><span class="comment">                                  long keepAliveTime,</span></span><br><span class="line"><span class="comment">                                  TimeUnit unit,</span></span><br><span class="line"><span class="comment">                                  BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="comment">                                  ThreadFactory threadFactory,</span></span><br><span class="line"><span class="comment">                                  RejectedExecutionHandler handler)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, TimeUnit.SECONDS, </span><br><span class="line">                                                      <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">5</span>) , </span><br><span class="line">                                                      Executors.defaultThreadFactory(),</span><br><span class="line">                                                      <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy() );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、给任务线程池处理。 </span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">        pool.execute(target);  <span class="comment">//调用execute方法</span></span><br><span class="line">        pool.execute(target);</span><br><span class="line">        pool.execute(target);</span><br><span class="line"></span><br><span class="line">        pool.execute(target);</span><br><span class="line">        pool.execute(target);</span><br><span class="line">        pool.execute(target);</span><br><span class="line">        pool.execute(target);</span><br><span class="line">        pool.execute(target);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建临时线程</span></span><br><span class="line">        pool.execute(target);</span><br><span class="line">        pool.execute(target);</span><br><span class="line">      </span><br><span class="line"><span class="comment">//      pool.execute(target);  // 最多10个线程，此时不创建，拒绝策略被触发！！！</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池（开发中一般不会使用）。</span></span><br><span class="line"><span class="comment">//      pool.shutdownNow(); // 立即关闭，即使任务没有完成，会丢失任务的！</span></span><br><span class="line">        pool.shutdown(); <span class="comment">// 会等待全部任务执行完毕之后再关闭（建议使用的）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="方式二：Callable任务"><a href="#方式二：Callable任务" class="headerlink" title="方式二：Callable任务"></a>方式二：Callable任务</h5><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>Future<T> <strong>submit</strong>(Callable<T> task)</td><td>返回未来任务对象获取线程结果 ，执行  <strong>Callable任务</strong></td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：自定义一个线程池对象，并测试其特性。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建线程池对象</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         public ThreadPoolExecutor(int corePoolSize,</span></span><br><span class="line"><span class="comment">                                  int maximumPoolSize,</span></span><br><span class="line"><span class="comment">                                  long keepAliveTime,</span></span><br><span class="line"><span class="comment">                                  TimeUnit unit,</span></span><br><span class="line"><span class="comment">                                  BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="comment">                                  ThreadFactory threadFactory,</span></span><br><span class="line"><span class="comment">                                  RejectedExecutionHandler handler)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">3</span>, <span class="number">5</span> ,<span class="number">6</span>, TimeUnit.SECONDS, </span><br><span class="line">                                                      <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">5</span>) , </span><br><span class="line">                                                      Executors.defaultThreadFactory(),</span><br><span class="line">                                                      <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy() );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、给任务线程池处理。</span></span><br><span class="line"><span class="comment">//        Callable call = new MyCallable(100);</span></span><br><span class="line"><span class="comment">//        Future&lt;String&gt; f1 = pool.submit(call); // 有返回值，返回未来任务对象</span></span><br><span class="line">        </span><br><span class="line">        Future&lt;String&gt; f1 = pool.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">100</span>));</span><br><span class="line">        Future&lt;String&gt; f2 = pool.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">200</span>));</span><br><span class="line">        Future&lt;String&gt; f3 = pool.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">300</span>));</span><br><span class="line">        Future&lt;String&gt; f4 = pool.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">400</span>));</span><br><span class="line">        Future&lt;String&gt; f5 = pool.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">500</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.调用get方法输出返回值</span></span><br><span class="line"><span class="comment">//        String rs = f1.get();</span></span><br><span class="line"><span class="comment">//        System.out.println(rs);</span></span><br><span class="line"></span><br><span class="line">        System.out.println(f1.get());</span><br><span class="line">        System.out.println(f2.get());</span><br><span class="line">        System.out.println(f3.get());</span><br><span class="line">        System.out.println(f4.get());</span><br><span class="line">        System.out.println(f5.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-4Executors工具类实现线程池"><a href="#6-4Executors工具类实现线程池" class="headerlink" title="6.4Executors工具类实现线程池"></a><strong>6.4Executors工具类实现线程池</strong></h4><p><strong>Executors得到线程池对象的常用方法</strong></p><ul><li>Executors：线程池的工具类通过调用方法返回不同类型的线程池对象。</li></ul><p><strong>注意：大型并发系统环境中使用Executors如果不注意可能会出现系统风险。</strong></p><table><thead><tr><th>方法名称</th><th>说明</th><th>存在问题</th></tr></thead><tbody><tr><td>public  static <a href="mk:@MSITStore:D:\course\jdk-11中文api修订版.CHM::/java.base/java/util/concurrent/ExecutorService.html">ExecutorService</a> newCachedThreadPool()</td><td>线程数量随着任务增加而增加，如果线程任务执行完毕且空闲了一段时间则会被回收掉。</td><td>创建的线程数量最大上限是Integer.MAX_VALUE，  线程数可能会随着任务1:1增长，也可能出现OOM错误（ java.lang.OutOfMemoryError ）</td></tr><tr><td>public  static <a href="mk:@MSITStore:D:\course\jdk-11中文api修订版.CHM::/java.base/java/util/concurrent/ScheduledExecutorService.html">ScheduledExecutorService</a> newScheduledThreadPool(int corePoolSize)</td><td>创建一个线程池，可以实现在给定的延迟后运行任务，或者定期执行任务。</td><td>同上</td></tr><tr><td>public static <a href="mk:@MSITStore:D:\course\jdk-11中文api修订版.CHM::/java.base/java/util/concurrent/ExecutorService.html">ExecutorService</a> newFixedThreadPool(int nThreads)</td><td>创建固定线程数量的线程池，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程替代它。</td><td>允许请求的任务队列长度是Integer.MAX_VALUE，可能出现OOM错误（ java.lang.OutOfMemoryError ）</td></tr><tr><td>public  static <a href="mk:@MSITStore:D:\course\jdk-11中文api修订版.CHM::/java.base/java/util/concurrent/ExecutorService.html">ExecutorService</a> newSingleThreadExecutor ()</td><td>创建只有一个线程的线程池对象，如果该线程出现异常而结束，那么线程池会补充一个新线程。</td><td>同上</td></tr></tbody></table><p><strong>注意：Executors的底层其实也是基于线程池的实现类ThreadPoolExecutor创建线程池对象的。</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：使用Executors的工具方法直接得到一个线程池对象。</span></span><br><span class="line"><span class="comment">    newFixedThreadPool方法，创建固定线程数量的线程池</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolDemo3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建固定线程数据的线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        pool.execute(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">        pool.execute(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">        pool.execute(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">        pool.execute(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>()); <span class="comment">// 已经没有多余线程了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Executors使用可能存在的陷阱</strong></p><ul><li>大型并发系统环境中使用Executors如果不注意可能会出现系统风险。</li></ul><h3 id="7-补充知识："><a href="#7-补充知识：" class="headerlink" title="7.补充知识："></a><strong>7.补充知识：</strong></h3><h4 id="7-1定时器"><a href="#7-1定时器" class="headerlink" title="7.1定时器"></a><strong>7.1定时器</strong></h4><p><strong>定时器</strong></p><ul><li><p>定时器是一种控制任务延时调用，或者周期调用的技术。</p></li><li><p>作用：闹钟、定时邮件发送。</p></li></ul><p><strong>定时器的实现方式</strong></p><ul><li><p>方式一：Timer</p></li><li><p>方式二： ScheduledExecutorService</p></li></ul><h5 id="方式一：Timer定时器"><a href="#方式一：Timer定时器" class="headerlink" title="方式一：Timer定时器"></a>方式一：Timer定时器</h5><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public  <strong>Timer</strong>()</td><td>创建Timer定时器对象</td></tr></tbody></table><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public void <strong>schedule</strong>(<a href="file:///D:/course/%E5%9F%BA%E7%A1%80%E9%98%B6%E6%AE%B5/API%E6%96%87%E6%A1%A3/docs/api/java.base/java/util/TimerTask.html">TimerTask</a> task,  long delay, long period)</td><td>开启一个定时器，按照计划处理TimerTask任务</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：Timer定时器的使用和了解。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimerDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、创建Timer定时器</span></span><br><span class="line">        <span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>();  <span class="comment">// 定时器本身就是一个单线程。</span></span><br><span class="line">        <span class="comment">// 2、调用方法，处理定时任务</span></span><br><span class="line">        <span class="comment">//线程一：</span></span><br><span class="line">        timer.schedule(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行AAA~~~&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>, <span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//线程二：</span></span><br><span class="line">        timer.schedule(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行BBB~~~&quot;</span>+ <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">                System.out.println(<span class="number">10</span>/<span class="number">0</span>);  <span class="comment">// ** &gt;注意：此时代码异常  后续方法不执行  &lt;**</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>, <span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//线程三：</span></span><br><span class="line">        timer.schedule(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行CCC~~~&quot;</span>+ <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>, <span class="number">3000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Timer定时器的特点和存在的问题</strong></p><ol><li><p>Timer是单线程，处理多个任务按照顺序执行，存在延时与设置定时器的时间有出入。</p></li><li><p>可能因为其中的某个任务的异常使Timer线程死掉，从而影响后续任务执行。</p></li></ol><h5 id="方式二：-ScheduledExecutorService定时器"><a href="#方式二：-ScheduledExecutorService定时器" class="headerlink" title="方式二： ScheduledExecutorService定时器"></a>方式二： ScheduledExecutorService<strong>定时器</strong></h5><ul><li>ScheduledExecutorService是 jdk1.5中引入了并发包，目的是为了弥补Timer的缺陷, ScheduledExecutorService内部为线程池。</li></ul><table><thead><tr><th>Executors的方法</th><th>说明</th></tr></thead><tbody><tr><td>public static ScheduledExecutorService <strong>newScheduledThreadPool</strong>(int corePoolSize)</td><td>得到线程池对象</td></tr></tbody></table><table><thead><tr><th>ScheduledExecutorService的方法</th><th>说明</th></tr></thead><tbody><tr><td>public ScheduledFuture&lt;?&gt; <strong>scheduleAtFixedRate</strong>(Runnable command, long initialDelay, long period,                              TimeUnit unit)</td><td>周期调度方法</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标： ScheduledExecutorService定时器的使用和了解。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimerDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、创建ScheduledExecutorService线程池，做定时器</span></span><br><span class="line">        <span class="type">ScheduledExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、开启定时任务</span></span><br><span class="line">        <span class="comment">//线程一：</span></span><br><span class="line">        pool.scheduleAtFixedRate(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行输出：AAA  ==》 &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>, <span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//线程二：</span></span><br><span class="line">        pool.scheduleAtFixedRate(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行输出：BBB  ==》 &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">                System.out.println(<span class="number">10</span> / <span class="number">0</span>);  <span class="comment">// ** &gt;注意：此时代码异常  后续线程还会执行  &lt;**</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>, <span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//线程三：</span></span><br><span class="line">        pool.scheduleAtFixedRate(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行输出：CCC  ==》 &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>, <span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ScheduledExecutorService的优点</strong></p><ul><li>基于线程池，某个任务的执行情况不会影响其他定时任务的执行。</li></ul><h4 id="7-2-并发、并行"><a href="#7-2-并发、并行" class="headerlink" title="7.2.并发、并行"></a><strong>7.2.并发、并行</strong></h4><p><strong>并发与并行</strong></p><ul><li>正在运行的程序（软件）就是一个独立的进程， 线程是属于进程的，多个线程其实是并发与并行同时进行的。</li></ul><p><strong>并发的理解：</strong></p><ul><li><p>CPU同时处理线程的数量有限。</p></li><li><p>CPU会轮询为系统的每个线程服务，由于CPU切换的速度很快，给我们的感觉这些线程在同时执行，这就是并发。</p></li></ul><p><strong>并行的理解：</strong></p><ul><li>在同一个时刻上，同时有多个线程在被CPU处理并执行。</li></ul><h4 id="7-3线程的生命周期"><a href="#7-3线程的生命周期" class="headerlink" title="7.3线程的生命周期"></a><strong>7.3线程的生命周期</strong></h4><p><strong>线程的状态</strong></p><ul><li><p>线程的状态：也就是线程从生到死的过程，以及中间经历的各种状态及状态转换。</p></li><li><p>理解线程的状态有利于提升并发编程的理解能力。</p></li></ul><p><strong>Java线程的状态</strong></p><ul><li>Java总共定义了6种状态</li><li>6种状态都定义在Thread类的内部枚举类中。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">     ...</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">     NEW,</span><br><span class="line">     RUNNABLE,</span><br><span class="line">     BLOCKED,</span><br><span class="line">     WAITING,</span><br><span class="line">     TIMED_WAITING,</span><br><span class="line">     TERMINATED;</span><br><span class="line">     &#125;</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>线程的6种状态</strong></p><ol><li><strong>新建（New）状态</strong>：当创建一个线程对象但尚未调用其<code>start()</code>方法时，线程处于新建状态。</li><li><strong>就绪（Runnable）状态</strong>：一旦调用了线程对象的<code>start()</code>方法，线程进入就绪状态。在就绪状态下，线程已经准备好执行，但尚未分配到CPU时间片。</li><li><strong>运行（Running）状态</strong>：当线程获取到CPU时间片并真正开始执行时，线程处于运行状态。</li><li><strong>阻塞（Blocked）状态</strong>：线程可能因为某些条件无法继续执行，比如等待某个资源、等待用户输入等情况。在这种情况下，线程会进入阻塞状态。阻塞状态分为多个子状态，比如等待阻塞、同步阻塞、等待超时阻塞等。</li><li><strong>等待（Waiting）状态</strong>：线程在某些特定条件下等待一段时间，等待条件满足后会进入就绪状态。线程可以通过调用<code>Object.wait()</code>方法、<code>Thread.join()</code>方法等进入等待状态。</li><li><strong>终止（Terminated）状态</strong>：线程执行完任务或者出现异常导致线程终止时，线程进入终止状态。</li></ol><p><strong>线程的6种状态互相转换</strong></p><ol><li>新建（New） -&gt; 就绪（Runnable）：调用线程对象的<code>start()</code>方法。</li><li>就绪（Runnable） -&gt; 运行（Running）：获取到CPU时间片。</li><li>运行（Running） -&gt; 就绪（Runnable）：时间片用完，或线程主动释放CPU。</li><li>运行（Running） -&gt; 阻塞（Blocked）：线程等待某些条件，如等待I&#x2F;O操作完成。</li><li>阻塞（Blocked） -&gt; 就绪（Runnable）：条件满足，或等待超时。</li><li>运行（Running） -&gt; 等待（Waiting）：线程调用了<code>Object.wait()</code>等方法。</li><li>等待（Waiting） -&gt; 就绪（Runnable）：等待时间结束或其他线程通知。</li><li>运行（Running） -&gt; 终止（Terminated）：线程执行完毕或出现未捕获的异常。</li></ol><p><strong>线程的6种状态总结</strong></p><table><thead><tr><th align="left">线程状态</th><th align="left">描述</th><th>状态</th></tr></thead><tbody><tr><td align="left">NEW(新建)</td><td align="left">线程刚被创建，但是并未启动。</td><td>创建线程对象</td></tr><tr><td align="left">Runnable(可运行)</td><td align="left">线程已经调用了start()等待CPU调度</td><td>start方法</td></tr><tr><td align="left">Blocked(锁阻塞)</td><td align="left">线程在执行的时候未竞争到锁对象，则该线程进入Blocked状态</td><td>无法获得锁对象</td></tr><tr><td align="left">Waiting(无限等待)</td><td align="left">一个线程进入Waiting状态，另一个线程调用notify或者notifyAll方法才能够唤醒</td><td>wait方法</td></tr><tr><td align="left">Timed Waiting(计时等待)</td><td align="left">同waiting状态，有几个方法有超时参数，调用他们将进入Timed Waiting状态。带有超时参数的常用方法有Thread.sleep 、Object.wait</td><td>sleep方法</td></tr><tr><td align="left">Teminated(被终止)</td><td align="left">因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡</td><td>全部代码运行完毕</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> java,面向对象进阶,多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>day19 - Io二</title>
      <link href="/post/c0dc36c0.html"/>
      <url>/post/c0dc36c0.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-缓冲流"><a href="#1-缓冲流" class="headerlink" title="1.缓冲流"></a>1.缓冲流</h3><h4 id="1-缓冲流概述"><a href="#1-缓冲流概述" class="headerlink" title="1.缓冲流概述"></a>1.缓冲流概述</h4><p><strong>缓冲流概述</strong></p><ul><li><p>缓冲流也称为高效流、或者高级流。之前学习的字节流可以称为原始流。</p></li><li><p>作用：缓冲流自带缓冲区、可以提高原始字节流、字符流读写数据的性能</p></li></ul><p><strong>4种缓冲流</strong></p><ul><li><p><strong>字节缓冲流</strong></p><ul><li><strong>字节缓冲输入流：</strong> <strong>BufferedInputStream</strong></li><li><strong>字节缓冲输出流：BufferedOutputStream</strong></li></ul></li><li><p><strong>字符缓冲流</strong></p><ul><li><strong>字符缓冲输入流：BufferedReader</strong></li><li><strong>字符缓冲输出流：BufferedWriter</strong></li></ul></li></ul><h4 id="1-2字节缓冲流"><a href="#1-2字节缓冲流" class="headerlink" title="1.2字节缓冲流"></a>1.2字节缓冲流</h4><p><strong>字节缓冲流性能优化原理：</strong></p><ul><li><p>字节缓冲输入流自带了8KB缓冲池，以后我们直接从缓冲池读取数据，所以性能较好。</p></li><li><p>字节缓冲输出流自带了8KB缓冲池，数据就直接写入到缓冲池中去，写数据性能极高了。</p></li></ul><p><strong>字节缓冲流</strong></p><ul><li><p>字节缓冲输入流：BufferedInputStream，提高字节输入流读取数据的性能，读写功能上并无变化。</p></li><li><p>字节缓冲输出流：BufferedOutputStream，提高字节输出流读取数据的性能，读写功能上并无变化。</p></li></ul><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public <strong>BufferedInputStream</strong>(InputStream is)</td><td>可以把低级的字节输入流包装成一个高级的缓冲字节输入流管道，从而提高字节输入流读数据的性能</td></tr><tr><td>public <strong>BufferedOutputStream</strong>(OutputStream os)</td><td>可以把低级的字节输出流包装成一个高级的缓冲字节输出流，从而提高写数据的性能</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：使用字节缓冲流完成数据的读写操作。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ByteBufferDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">// 这里面只能放置资源对象，用完会自动关闭：自动调用资源对象的close方法关闭资源（即使出现异常也会做关闭操作）</span></span><br><span class="line">                <span class="comment">// 1、创建一个字节输入流管道与原始管道接通</span></span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\\resources\\newmeinv.jpeg&quot;</span>);</span><br><span class="line">                <span class="comment">// a.把原始的字节输入流包装成高级的缓冲字节输入流</span></span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(is);</span><br><span class="line">            </span><br><span class="line">                <span class="comment">// 2、创建一个字节输出流管道与目标文件接通</span></span><br><span class="line">                <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D:\\resources\\newmeinv222.jpeg&quot;</span>);</span><br><span class="line">                <span class="comment">// b.把字节输出流管道包装成高级的缓冲字节输出流管道</span></span><br><span class="line">                <span class="type">OutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(os);</span><br><span class="line">) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 3、定义一个字节数组转移数据</span></span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> len; <span class="comment">// 记录每次读取的字节数。</span></span><br><span class="line">            <span class="keyword">while</span> ((len = bis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                bos.write(buffer, <span class="number">0</span> , len);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;复制完成了！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3字节缓冲流的性能分析"><a href="#1-3字节缓冲流的性能分析" class="headerlink" title="1.3字节缓冲流的性能分析"></a>1.3字节缓冲流的性能分析</h4><p><strong>1、我们已经说明了字节缓冲流的性能高效，但是没有直接感受到。</strong></p><p><strong>2、如何测试字节缓冲流的读写性能呢？</strong></p><p><strong>案例：</strong></p><p>分别使用不同的方式复制大视频观察性能情况</p><p><strong>需求</strong></p><ul><li>分别使用低级字节流和高级字节缓冲流拷贝大视频，记录耗时。</li></ul><p><strong>分析</strong></p><p>①使用低级的字节流按照一个一个字节的形式复制文件。</p><p>②使用低级的字节流按照一个一个字节数组的形式复制文件。</p><p>③使用高级的缓冲字节流按照一个一个字节的形式复制文件。</p><p>④使用高级的缓冲字节流按照一个一个字节数组的形式复制文件。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：利用字节流的复制统计各种写法形式下缓冲流的性能执行情况。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    复制流：</span></span><br><span class="line"><span class="comment">        （1）使用低级的字节流按照一个一个字节的形式复制文件。</span></span><br><span class="line"><span class="comment">        （2）使用低级的字节流按照一个一个字节数组的形式复制文件。</span></span><br><span class="line"><span class="comment">        （3）使用高级的缓冲字节流按照一个一个字节的形式复制文件。</span></span><br><span class="line"><span class="comment">        （4）使用高级的缓冲字节流按照一个一个字节数组的形式复制文件。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    源文件：C:\course\3-视频\18、IO流-文件字节输出流FileOutputStream写字节数据出去.avi</span></span><br><span class="line"><span class="comment">    目标文件：C:\course\</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    小结：</span></span><br><span class="line"><span class="comment">        使用高级的缓冲字节流按照一个一个字节数组的形式复制文件，性能好，建议开发使用！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ByteBufferTimeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SRC_FILE</span> <span class="operator">=</span> <span class="string">&quot;D:\\course\\基础加强\\day08-日志框架、阶段项目\\视频\\14、用户购票功能.avi&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEST_FILE</span> <span class="operator">=</span> <span class="string">&quot;D:\\course\\&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// copy01(); // 使用低级的字节流按照一个一个字节的形式复制文件：慢的让人简直无法忍受。直接被淘汰。</span></span><br><span class="line">        copy02(); <span class="comment">// 使用低级的字节流按照一个一个字节数组的形式复制文件: 比较慢，但是还是可以忍受的！</span></span><br><span class="line">        <span class="comment">// copy03(); // 缓冲流一个一个字节复制：很慢，不建议使用。</span></span><br><span class="line">        copy04(); <span class="comment">// 缓冲流一个一个字节数组复制：飞快，简直太完美了（推荐使用）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//（4）使用高级的缓冲字节流按照一个一个字节数组的形式复制文件。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copy04</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">// 1、创建低级的字节输入流与源文件接通</span></span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(SRC_FILE);</span><br><span class="line">                <span class="comment">// a.把原始的字节输入流包装成高级的缓冲字节输入流</span></span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(is);</span><br><span class="line">                <span class="comment">// 2、创建低级的字节输出流与目标文件接通</span></span><br><span class="line">                <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(DEST_FILE + <span class="string">&quot;video4.avi&quot;</span>);</span><br><span class="line">                <span class="comment">// b.把字节输出流管道包装成高级的缓冲字节输出流管道</span></span><br><span class="line">                <span class="type">OutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(os);</span><br><span class="line">        ) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3、定义一个字节数组转移数据</span></span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> len; <span class="comment">// 记录每次读取的字节数。</span></span><br><span class="line">            <span class="keyword">while</span> ((len = bis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                bos.write(buffer, <span class="number">0</span> , len);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;使用缓冲的字节流按照一个一个字节数组的形式复制文件耗时：&quot;</span> + (endTime - startTime)/<span class="number">1000.0</span> + <span class="string">&quot;s&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//（3）使用高级的缓冲字节流按照一个一个字节的形式复制文件。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copy03</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">// 1、创建低级的字节输入流与源文件接通</span></span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(SRC_FILE);</span><br><span class="line">                <span class="comment">// a.把原始的字节输入流包装成高级的缓冲字节输入流</span></span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(is);</span><br><span class="line">                <span class="comment">// 2、创建低级的字节输出流与目标文件接通</span></span><br><span class="line">                <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(DEST_FILE + <span class="string">&quot;video3.avi&quot;</span>);</span><br><span class="line">                <span class="comment">// b.把字节输出流管道包装成高级的缓冲字节输出流管道</span></span><br><span class="line">                <span class="type">OutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(os);</span><br><span class="line">        )&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3、定义一个变量记录每次读取的字节（一个一个字节的复制）</span></span><br><span class="line">            <span class="type">int</span> b;</span><br><span class="line">            <span class="keyword">while</span> ((b = bis.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">                bos.write(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;使用缓冲的字节流按照一个一个字节的形式复制文件耗时：&quot;</span> + (endTime - startTime)/<span class="number">1000.0</span> + <span class="string">&quot;s&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//（2）使用低级的字节流按照一个一个字节数组的形式复制文件。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copy02</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">// 这里面只能放置资源对象，用完会自动关闭：自动调用资源对象的close方法关闭资源（即使出现异常也会做关闭操作）</span></span><br><span class="line">                <span class="comment">// 1、创建一个字节输入流管道与原视频接通</span></span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(SRC_FILE);</span><br><span class="line">                <span class="comment">// 2、创建一个字节输出流管道与目标文件接通</span></span><br><span class="line">                <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(DEST_FILE + <span class="string">&quot;video2.avi&quot;</span>)</span><br><span class="line">        ) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3、定义一个字节数组转移数据</span></span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> len; <span class="comment">// 记录每次读取的字节数。</span></span><br><span class="line">            <span class="keyword">while</span> ((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                os.write(buffer, <span class="number">0</span> , len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;使用低级的字节流按照一个一个字节数组的形式复制文件耗时：&quot;</span> + (endTime - startTime)/<span class="number">1000.0</span> + <span class="string">&quot;s&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//（1）使用低级的字节流按照一个一个字节的形式复制文件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copy01</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">// 1、创建低级的字节输入流与源文件接通</span></span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(SRC_FILE);</span><br><span class="line">                <span class="comment">// 2、创建低级的字节输出流与目标文件接通</span></span><br><span class="line">                <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(DEST_FILE + <span class="string">&quot;video1.avi&quot;</span>)</span><br><span class="line">                )&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3、定义一个变量记录每次读取的字节（一个一个字节的复制）</span></span><br><span class="line">            <span class="type">int</span> b;</span><br><span class="line">            <span class="keyword">while</span> ((b = is.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">                os.write(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;使用低级的字节流按照一个一个字节的形式复制文件耗时：&quot;</span> + (endTime - startTime)/<span class="number">1000.0</span> + <span class="string">&quot;s&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>推荐使用哪种方式提高字节流读写数据的性能？</p><ul><li><strong>建议使用字节缓冲输入流、字节缓冲输出流，结合字节数组的方式，目前来看是性能最优的组合。</strong></li></ul><h4 id="1-4字符缓冲流"><a href="#1-4字符缓冲流" class="headerlink" title="1.4字符缓冲流"></a>1.4字符缓冲流</h4><p><strong>字符缓冲输入流</strong></p><ul><li><p>字符缓冲输入流：BufferedReader。</p></li><li><p>作用：提高字符输入流读取数据的性能，除此之外多了按照行读取数据的功能。</p></li></ul><p><strong>字符缓冲输出流</strong></p><ul><li><p>字符缓冲输出流：BufferedWriter。</p></li><li><p>作用：提高字符输出流写取数据的性能，除此之外多了换行功能</p></li></ul><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public  <strong>BufferedReader</strong>(Reader r)</td><td>可以把低级的字符输入流包装成一个高级的<strong>缓冲字符输入流</strong>管道，从而提高字符输入流读数据的性能</td></tr><tr><td>public <strong>BufferedWriter</strong>(Writer  w)</td><td>可以把低级的字符输出流包装成一个高级的<strong>缓冲字符输出流</strong>管道，从而提高字符输出流写数据的性能</td></tr></tbody></table><p><strong>字符缓冲输入流新增功能</strong></p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public  String <strong>readLine</strong>()</td><td>读取一行数据返回，如果读取没有完毕，无行可读返回null</td></tr></tbody></table><p><strong>字符缓冲输出流新增功能</strong></p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public  void <strong>newLine</strong>()</td><td>换行操作</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：学会使用缓冲字符输入流提高字符输入流的性能，新增了按照行读取的方法(经典代码)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedReaderDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">// 1、创建一个文件字符输入流与源文件接通。</span></span><br><span class="line">                <span class="type">Reader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;io-app2/src/data01.txt&quot;</span>);</span><br><span class="line">                <span class="comment">// a、把低级的字符输入流包装成高级的缓冲字符输入流。</span></span><br><span class="line">                <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(fr);</span><br><span class="line">                )&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2、用循环，每次读取一个字符数组的数据。  1024 + 1024 + 8</span></span><br><span class="line"><span class="comment">//            char[] buffer = new char[1024]; // 1K字符</span></span><br><span class="line"><span class="comment">//            int len;</span></span><br><span class="line"><span class="comment">//            while ((len = br.read(buffer)) != -1) &#123;</span></span><br><span class="line"><span class="comment">//                String rs = new String(buffer, 0, len);</span></span><br><span class="line"><span class="comment">//                System.out.print(rs);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"></span><br><span class="line">              String line;</span><br><span class="line">              <span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">                  System.out.println(line);</span><br><span class="line">              &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     目标：缓冲字符输出流的使用，学会它多出来的一个功能：newLine();</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedWriterDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建一个字符输出流管道与目标文件接通</span></span><br><span class="line">        <span class="type">Writer</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;io-app2/src/out02.txt&quot;</span>); <span class="comment">// 覆盖管道，每次启动都会清空文件之前的数据</span></span><br><span class="line">       <span class="comment">//Writer fw = new FileWriter(&quot;io-app2/src/out02.txt&quot;, true); // 追加数据</span></span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(fw);</span><br><span class="line"></span><br><span class="line"><span class="comment">//      a.public void write(int c):写一个字符出去</span></span><br><span class="line">        bw.write(<span class="number">98</span>);</span><br><span class="line">        bw.write(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        bw.write(<span class="string">&#x27;徐&#x27;</span>); <span class="comment">// 不会出问题了</span></span><br><span class="line">        bw.newLine(); <span class="comment">// bw.write(&quot;\r\n&quot;); // 换行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//       b.public void write(String c)写一个字符串出去</span></span><br><span class="line">        bw.write(<span class="string">&quot;abc我是中国人&quot;</span>);</span><br><span class="line">        bw.newLine(); <span class="comment">// bw.write(&quot;\r\n&quot;); // 换行</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//       c.public void write(char[] buffer):写一个字符数组出去</span></span><br><span class="line">        <span class="type">char</span>[] chars = <span class="string">&quot;abc我是中国人&quot;</span>.toCharArray();</span><br><span class="line">        bw.write(chars);</span><br><span class="line">        bw.newLine(); <span class="comment">// bw.write(&quot;\r\n&quot;); // 换行</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//       d.public void write(String c ,int pos ,int len):写字符串的一部分出去</span></span><br><span class="line">        bw.write(<span class="string">&quot;abc我是中国人&quot;</span>, <span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">        bw.newLine(); <span class="comment">// bw.write(&quot;\r\n&quot;); // 换行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//       e.public void write(char[] buffer ,int pos ,int len):写字符数组的一部分出去</span></span><br><span class="line">        bw.write(chars, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">        bw.newLine(); <span class="comment">// bw.write(&quot;\r\n&quot;); // 换行</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// fw.flush();// 刷新后流可以继续使用</span></span><br><span class="line">        bw.close(); <span class="comment">// 关闭包含刷线，关闭后流不能使用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.字符缓冲流为什么提高了操作数据的性能？</p><ul><li><p><strong>字符缓冲流自带8k缓冲区</strong></p></li><li><p><strong>可以提高原始字符流读写数据的性能</strong></p></li></ul><p>2.字符缓冲流的功能如何使用？</p><ul><li><p><strong>public BufferedReader(Reader r)</strong></p><p><strong>性能提升了, 多了readLine()  按照行读取的功能</strong></p></li><li><p><strong>public BufferedWriter(Writer w)</strong></p><p><strong>性能提升了, 多了newLine()  换行的功能</strong></p></li></ul><p><strong>案例：</strong></p><p>拷贝出师表到另一个文件，恢复顺序</p><p>需求：</p><p>把《出师表》的文章顺序进行恢复到一个新文件中。</p><p>分析：</p><p>①定义一个缓存字符输入流管道与源文件接通。</p><p>②定义一个List集合存储读取的每行数据。</p><p>③定义一个循环按照行读取数据，存入到List集合中去。</p><p>④对List集合中的每行数据按照首字符编号升序排序。</p><p>⑤定义一个缓存字符输出管道与目标文件接通。</p><p>⑥遍历List集合中的每个元素，用缓冲输出管道写出并换行。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   目标：完成出师表顺序的恢复，并存入到另一个新文件中去。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedCharTest3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>(</span><br><span class="line">                <span class="comment">// 1、创建缓冲字符输入流管道与源文件接通</span></span><br><span class="line">                <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;io-app2/src/csb.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 5、定义缓冲字符输出管道与目标文件接通</span></span><br><span class="line">                <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;io-app2/src/new.txt&quot;</span>));</span><br><span class="line">                ) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2、定义一个List集合存储每行内容</span></span><br><span class="line">            List&lt;String&gt; data = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="comment">// 3、定义循环，按照行读取文章</span></span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">                data.add(line);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(data);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4、排序</span></span><br><span class="line">            <span class="comment">// 自定义排序规则</span></span><br><span class="line">            List&lt;String&gt; sizes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            Collections.addAll(sizes, <span class="string">&quot;一&quot;</span>,<span class="string">&quot;二&quot;</span>,<span class="string">&quot;三&quot;</span>,<span class="string">&quot;四&quot;</span>,<span class="string">&quot;五&quot;</span>,<span class="string">&quot;陆&quot;</span>,<span class="string">&quot;柒&quot;</span>,<span class="string">&quot;八&quot;</span>,<span class="string">&quot;九&quot;</span>,<span class="string">&quot;十&quot;</span>,<span class="string">&quot;十一&quot;</span>);</span><br><span class="line"></span><br><span class="line">            Collections.sort(data, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String o1, String o2)</span> &#123;</span><br><span class="line">                    <span class="comment">// o1   八.,....</span></span><br><span class="line">                    <span class="comment">// o2   柒.,....</span></span><br><span class="line">                    <span class="keyword">return</span> sizes.indexOf(o1.substring(<span class="number">0</span>, o1.indexOf(<span class="string">&quot;.&quot;</span>)))</span><br><span class="line">                            - sizes.indexOf(o2.substring(<span class="number">0</span>, o2.indexOf(<span class="string">&quot;.&quot;</span>)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            System.out.println(data);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 6、遍历集合中的每行文章写出去，且要换行</span></span><br><span class="line">            <span class="keyword">for</span> (String datum : data) &#123;</span><br><span class="line">                bw.write(datum);</span><br><span class="line">                bw.newLine(); <span class="comment">// 换行</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-转换"><a href="#2-转换" class="headerlink" title="2.转换"></a>2.转换</h3><h4 id="2-1问题引出：不同编码读取乱码问题"><a href="#2-1问题引出：不同编码读取乱码问题" class="headerlink" title="2.1问题引出：不同编码读取乱码问题"></a>2.1问题引出：不同编码读取乱码问题</h4><p>1、之前我们使用字符流读取中文是否有乱码？</p><ul><li><strong>没有的，因为代码编码和文件编码都是UTF-8。</strong></li></ul><p>2、如果代码编码和文件编码不一致，使用字符流直接读取还能不乱码吗？</p><ul><li><p><strong>会乱码。</strong></p></li><li><p><strong>文件编码和读取的编码必须一致才不会乱码。</strong></p></li></ul><p><strong>使用相同编码读取不同编码的文件内容</strong></p><p>需求：</p><p>分别使用如下两种方式读取文件内容</p><p>①代码编码是UTF-8，文件编码也是UTF-8，使用字符流读取观察输出的中文字符结果。</p><p>②代码编码是UTF-8，文件编码使用GBK，使用字符流读取观察输出的中文字符结果</p><p><strong>结论：</strong></p><p>字符流直接读取文本内容。</p><ul><li><p><strong>必须文件和代码编码一致才不会乱码</strong></p></li><li><p><strong>如果文件和代码编码不一致，读取将出现乱码。</strong></p></li></ul><h4 id="2-2字符输入转换流"><a href="#2-2字符输入转换流" class="headerlink" title="2.2字符输入转换流"></a>2.2字符输入转换流</h4><p>1、如果代码编码和文件编码不一致，使用字符流直接读取还能不乱码吗？</p><ul><li><strong>会乱码。</strong></li></ul><p>2、如果如何解决呢？</p><ul><li><p><strong>使用字符输入转换流</strong></p></li><li><p><strong>可以提取文件（GBK）的原始字节流，原始字节不会存在问题。</strong></p></li><li><p><strong>然后把字节流以指定编码转换成字符输入流，这样字符输入流中的字符就不乱码了</strong></p></li></ul><p><strong>字符输入转换流</strong></p><ul><li>字符输入转换流：<strong>InputStreamReader</strong>，可以把原始的字节流按照指定编码转换成字符输入流。</li></ul><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public InputStreamReader(InputStream is)</td><td>可以把原始的字节流按照代码默认编码转换成字符输入流。几乎不用，与默认的FileReader一样。</td></tr><tr><td>public InputStreamReader(InputStream is ，String charset)</td><td>可以把原始的字节流按照指定编码转换成字符输入流，这样字符流中的字符就不乱码了(重点)</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     目标：字符输入转换流InputStreamReader的使用。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     作用：可以解决字符流读取不同编码乱码的问题。</span></span><br><span class="line"><span class="comment">          也可以把原始的字节流按照指定编码转换成字符输入流</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     小结：</span></span><br><span class="line"><span class="comment">        字符输入转换流InputStreamReader:作用：可以解决字符流读取不同编码乱码的问题。</span></span><br><span class="line"><span class="comment">        public InputStreamReader(InputStream is,String charset):可以指定编码把字节流转换成字符流(核心)</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InputStreamReaderDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 代码UTF-8   文件 GBK  &quot;D:\\resources\\data.txt&quot;</span></span><br><span class="line">        <span class="comment">// 1、提取GBK文件的原始字节流。   abc 我</span></span><br><span class="line">        <span class="comment">//                            ooo oo</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\\resources\\data.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 2、把原始字节流转换成字符输入流</span></span><br><span class="line">        <span class="comment">// Reader isr = new InputStreamReader(is); // 默认以UTF-8的方式转换成字符流。 还是会乱码的  跟直接使用FileReader是一样的</span></span><br><span class="line">        <span class="type">Reader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is , <span class="string">&quot;GBK&quot;</span>); <span class="comment">// 以指定的GBK编码转换成字符输入流  完美的解决了乱码问题</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、把低级的字符输入流包装成高级的缓冲字符输入流。</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(isr);</span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3字符输出转换流"><a href="#2-3字符输出转换流" class="headerlink" title="2.3字符输出转换流"></a>2.3字符输出转换流</h4><p>1、如果需要控制写出去的字符使用的编码，怎么办？</p><ul><li><p><strong>可以把字符以指定编码获取字节后再使用字节输出流写出去：</strong></p><p><strong>“我爱你中国”.getBytes(编码)</strong></p></li><li><p><strong>也可以使用字符输出转换流实现。</strong></p></li></ul><p><strong>字符输出转换流</strong></p><ul><li>字符输入转换流：<strong>OutputStreamWriter</strong>，可以把字节输出流按照指定编码转换成字符输出流。</li></ul><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public OutputStreamWriter(OutputStream os)</td><td>可以把原始的字节输出流按照代码默认编码转换成字符输出流。几乎不用。</td></tr><tr><td>public OutputStreamWriter(OutputStream os，String  charset)</td><td>可以把原始的字节输出流按照指定编码转换成字符输出流(重点)</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     目标：字符输出转换OutputStreamWriter流的使用。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     作用：可以指定编码把字节输出流转换成字符输出流。</span></span><br><span class="line"><span class="comment">                   可以指定写出去的字符的编码。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     小结：</span></span><br><span class="line"><span class="comment">        字符输出转换流OutputStreamWriter可以指定编码把字节输出流转换成字符输出流。</span></span><br><span class="line"><span class="comment">        从而实现指定写出去的字符编码！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OutputStreamWriterDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、定义一个字节输出流</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;io-app2/src/out03.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、把原始的字节输出流转换成字符输出流</span></span><br><span class="line">        <span class="comment">// Writer osw = new OutputStreamWriter(os); // 以默认的UTF-8写字符出去 跟直接写FileWriter一样</span></span><br><span class="line">        <span class="type">Writer</span> <span class="variable">osw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(os , <span class="string">&quot;GBK&quot;</span>); <span class="comment">// 指定GBK的方式写字符出去</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、把低级的字符输出流包装成高级的缓冲字符输出流。</span></span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(osw);</span><br><span class="line"></span><br><span class="line">        bw.write(<span class="string">&quot;我爱中国1~~&quot;</span>);</span><br><span class="line">        bw.write(<span class="string">&quot;我爱中国2~~&quot;</span>);</span><br><span class="line">        bw.write(<span class="string">&quot;我爱中国3~~&quot;</span>);</span><br><span class="line"></span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-序列化对象"><a href="#3-序列化对象" class="headerlink" title="3.序列化对象"></a>3.序列化对象</h3><h4 id="3-1对象序列化"><a href="#3-1对象序列化" class="headerlink" title="3.1对象序列化"></a>3.1对象序列化</h4><p><strong>对象序列化：</strong></p><ul><li><p>作用：以内存为基准，把内存中的对象存储到磁盘文件中去，称为对象序列化。</p></li><li><p><strong>使用到的流是对象字节输出流：ObjectOutputStream</strong></p></li></ul><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public <strong>ObjectOutputStream</strong>(OutputStream  out)</td><td>把低级字节输出流包装成高级的对象字节输出流</td></tr></tbody></table><p><strong>ObjectOutputStream序列化方法</strong></p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>public final void <strong>writeObject</strong>(Object obj)</td><td>把对象写出去到对象序列化流的文件中去</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     目标：学会对象序列化，使用 ObjectOutputStream 把内存中的对象存入到磁盘文件中。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> 注意：对象如果要序列化，必须实现Serializable序列化接口。</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> 拓展知识：1.transient修饰的成员变量不参与序列化了</span></span><br><span class="line"><span class="comment">             2.申明序列化的版本号码，序列化的版本号与反序列化的版本号必须一致才不会出错！</span></span><br><span class="line"><span class="comment">     private static final long serialVersionUID = 1;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectOutputStreamDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建学生对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;陈磊&quot;</span>, <span class="string">&quot;chenlei&quot;</span>,<span class="string">&quot;1314520&quot;</span>, <span class="number">21</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、对象序列化：使用对象字节输出流包装字节输出流管道</span></span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;io-app2/src/obj.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、直接调用序列化方法</span></span><br><span class="line">        oos.writeObject(s);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、释放资源</span></span><br><span class="line">        oos.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;序列化完成了~~&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>创建学生对象，(注意：实现Serializable序列化接口)。</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  对象如果要序列化，必须实现Serializable序列化接口。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;  <span class="comment">//Serializable接口</span></span><br><span class="line">    <span class="comment">// 序列化的版本号与反序列化的版本号必须一致才不会出错！</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1</span>;  <span class="comment">// 申明序列化的版本号码</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String loginName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String passWord;  <span class="comment">// transient修饰的成员变量不参与序列化了，反序列化结果为null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, String loginName, String passWord, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.loginName = loginName;</span><br><span class="line">        <span class="built_in">this</span>.passWord = passWord;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getLoginName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> loginName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLoginName</span><span class="params">(String loginName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.loginName = loginName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPassWord</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> passWord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPassWord</span><span class="params">(String passWord)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.passWord = passWord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, loginName=&#x27;&quot;</span> + loginName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, passWord=&#x27;&quot;</span> + passWord + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p><strong>对象如果要序列化，必须实现Serializable序列化接口。</strong></p><p><strong>拓展知识：</strong></p><p><strong>1. transient修饰的成员变量不参与序列化了</strong></p><p>​ <strong>private transient String passWord;</strong></p><p><strong>2. 申明序列化的版本号码，序列化的版本号与反序列化的版本号必须一致才不会出错！</strong></p><pre><code> **private static final long serialVersionUID = 1;**</code></pre><h4 id="3-2对象反序列化"><a href="#3-2对象反序列化" class="headerlink" title="3.2对象反序列化"></a>3.2对象反序列化</h4><p><strong>对象反序列化：</strong></p><ul><li><p><strong>使用到的流是对象字节输入流：ObjectInputStream</strong></p></li><li><p>作用：以内存为基准，<strong>把存储到磁盘文件中去的对象数据恢复成内存中的对象</strong>，称为对象反序列化。</p></li></ul><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public <strong>ObjectInputStream</strong>(InputStream  out)</td><td>把低级字节输如流包装成高级的对象字节输入流</td></tr></tbody></table><p><strong>ObjectInputStream序列化方法</strong></p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>public  Object <strong>readObject</strong>()</td><td>把存储到磁盘文件中去的对象数据恢复成内存中的对象返回</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：学会进行对象反序列化：使用对象字节输入流把文件中的对象数据恢复成内存中的Java对象。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectInputStreamDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建对象字节输入流管道包装低级的字节输入流管道</span></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;io-app2/src/obj.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、调用对象字节输入流的反序列化方法</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> (Student) is.readObject();</span><br><span class="line"></span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-打印流"><a href="#4-打印流" class="headerlink" title="4.打印流"></a>4.打印流</h3><h4 id="4-1PrintStream、PrintWriter"><a href="#4-1PrintStream、PrintWriter" class="headerlink" title="4.1PrintStream、PrintWriter"></a>4.1PrintStream、PrintWriter</h4><p><strong>打印流</strong></p><ul><li><p>作用：打印流可以实现方便、高效的打印数据到文件中去。打印流一般是指：PrintStream，PrintWriter两个类。</p></li><li><p>可以实现打印什么数据就是什么数据，例如打印整数97写出去就是97，打印boolean的true，写出去就是true。</p></li></ul><p><strong>PrintStream</strong></p><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public PrintStream(OutputStream os)</td><td>打印流直接通向字节输出流管道</td></tr><tr><td>public PrintStream(File f)</td><td>打印流直接通向文件对象</td></tr><tr><td>public PrintStream(String filepath)</td><td>打印流直接通向文件路径</td></tr></tbody></table><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public void print(Xxx  xx)</td><td>打印任意类型的数据出去</td></tr></tbody></table><p><strong>PrintWriter</strong></p><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public PrintWriter(OutputStream os)</td><td>打印流直接通向字节输出流管道</td></tr><tr><td>public PrintWriter (Writer w)</td><td>打印流直接通向字符输出流管道</td></tr><tr><td>public PrintWriter (File f)</td><td>打印流直接通向文件对象</td></tr><tr><td>public PrintWriter (String filepath)</td><td>打印流直接通向文件路径</td></tr></tbody></table><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public void print(Xxx  xx)</td><td>打印任意类型的数据出去</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：学会使用打印流 高效 方便 写数据到文件。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建一个打印流对象</span></span><br><span class="line"><span class="comment">//        PrintStream ps = new PrintStream(new FileOutputStream(&quot;io-app2/src/ps.txt&quot;));</span></span><br><span class="line"><span class="comment">//        PrintStream ps = new PrintStream(new FileOutputStream(&quot;io-app2/src/ps.txt&quot; , true)); // 追加数据，在低级管道后面加True</span></span><br><span class="line"><span class="comment">//        PrintStream ps = new PrintStream(&quot;io-app2/src/ps.txt&quot; ); // PrintStream简化写法 </span></span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="string">&quot;io-app2/src/ps.txt&quot;</span>); <span class="comment">// 打印功能上与PrintStream的使用没有区别</span></span><br><span class="line"></span><br><span class="line">        ps.println(<span class="number">97</span>);</span><br><span class="line">        ps.println(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        ps.println(<span class="number">23.3</span>);</span><br><span class="line">        ps.println(<span class="literal">true</span>);</span><br><span class="line">        ps.println(<span class="string">&quot;我是打印流输出的，我是啥就打印啥&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ps.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>PrintStream和PrintWriter的区别</strong></p><ul><li><p>打印数据功能上是一模一样的，都是使用方便，性能高效（核心优势）</p></li><li><p>PrintStream继承自字节输出流OutputStream，支持写字节。</p></li><li><p>PrintWriter继承自字符输出流Writer，支持写字符数。</p></li></ul><h4 id="4-2输出语句的重定向"><a href="#4-2输出语句的重定向" class="headerlink" title="4.2输出语句的重定向"></a>4.2输出语句的重定向</h4><p><strong>输出语句重定向</strong></p><ul><li>属于打印流的一种应用，可以把输出语句的打印位置改到文件。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="string">&quot;文件地址&quot;</span>)</span><br><span class="line">System.setOut(ps);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：了解**PrintStream**改变输出语句的位置到文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 默认打印控制台 (默认)</span></span><br><span class="line">        System.out.println(<span class="string">&quot;锦瑟无端五十弦&quot;</span>); </span><br><span class="line">        System.out.println(<span class="string">&quot;一弦一柱思华年&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 改变输出语句的位置(重定向)</span></span><br><span class="line">        <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="string">&quot;io-app2/src/log.txt&quot;</span>); <span class="comment">//将打印位置改为io-app2/src/log.txt</span></span><br><span class="line">        System.setOut(ps); <span class="comment">// 把系统默认打印流改成我们自己的打印流</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;庄生晓梦迷蝴蝶&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;望帝春心托杜鹃&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-补充知识：Properties"><a href="#5-补充知识：Properties" class="headerlink" title="5.补充知识：Properties"></a>5.补充知识：Properties</h3><p><strong>Properties属性集对象</strong></p><ul><li>其实就是一个Map集合，但是我们一般不会当集合使用，因为HashMap更好用。</li></ul><p><strong>Properties核心作用：</strong></p><ul><li><p><strong>Properties代表的是一个属性文件</strong>，可以把自己对象中的键值对信息存入到一个属性文件中去。</p><p>void store((Writer writer), String comments)</p></li><li><p><strong>属性文件：后缀是.properties结尾的文件</strong>,里面的内容都是 key&#x3D;value，后续做系统配置信息的。</p></li><li><p>可以加载属性文件中的数据到Properties对象中来：</p><p>void load(Reader reader)</p></li></ul><p><strong>Properties的API:</strong></p><ul><li>Properties和IO流结合的方法：</li></ul><table><thead><tr><th><strong>构造器</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>public  Object <strong>setProperty</strong>(String key, String value)</td><td>保存键值对（put）</td></tr><tr><td>void  <strong>load</strong>(InputStream inStream)</td><td>从输入字节流读取属性列表（键和元素对）</td></tr><tr><td>void  load(Reader reader)</td><td>从输入字符流读取属性列表（键和元素对）</td></tr><tr><td>void  <strong>store</strong>((OutputStream out), String comments)</td><td>将此属性列表（键和元素对）写入此  Properties表中，以适合于使用  load(InputStream)方法的格式写入输出字节流</td></tr><tr><td>void  store((Writer writer), String comments)</td><td>将此属性列表（键和元素对）写入此  Properties表中，以适合使用  load(Reader)方法的格式写入输出字符流</td></tr><tr><td>public  String <strong>getProperty</strong>(String key)</td><td>使用此属性列表中指定的<strong>键搜索属性值</strong>  (get)</td></tr><tr><td>public  Set<String> <strong>stringPropertyNames</strong>()</td><td><strong>所有键的名称</strong>的集合  (keySet())</td></tr></tbody></table><p><strong>代码1：使用Properties对象生成一个属性文件(setProperty，store)</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     目标：Properties的概述和使用(框架底层使用，了解这个技术即可)（保存数据到属性文件）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     需求：使用Properties对象生成一个属性文件，里面存入用户名和密码信息。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     小结：Properties可以保存键值对数据到属性文件</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PropertiesDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 需求：使用Properties把键值对信息存入到属性文件中去。</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        properties.setProperty(<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;dlei&quot;</span>, <span class="string">&quot;003197&quot;</span>);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;heima&quot;</span>, <span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">        System.out.println(properties);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">           参数一：保存管道 字符输出流管道</span></span><br><span class="line"><span class="comment">           参数二：保存心得</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        properties.store(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;io-app2/src/users.properties&quot;</span>), <span class="string">&quot;i am very happy!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码2：使用Properties的方法</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：Properties读取属性文件中的键值对信息。（读取）</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    小结：</span></span><br><span class="line"><span class="comment">        属性集对象可以加载读取属性文件中的数据!!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PropertiesDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 需求：Properties读取属性文件中的键值对信息。（读取）</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        System.out.println(properties); <span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加载属性文件中的键值对数据到属性对象properties中去</span></span><br><span class="line">        properties.load(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;io-app2/src/users.properties&quot;</span>));</span><br><span class="line">        System.out.println(properties); <span class="comment">// 所有键值对信息</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;dlei&quot;</span>); </span><br><span class="line">        System.out.println(rs); <span class="comment">// 003194</span></span><br><span class="line">        </span><br><span class="line">        Set&lt;String&gt; sw = properties.stringPropertyNames();</span><br><span class="line">        System.out.println(sw); <span class="comment">// &#123;&quot;admin&quot;,&quot;dlei&quot;,&quot;heima&quot;&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>案例：</strong></p><p>拷贝文件夹</p><p>需求：</p><p>将某个磁盘的文件夹拷贝到另一个文件夹下去，包括文件夹中的全部信息</p><p>分析：</p><p>①：IO默认不可以拷贝文件夹</p><p>②：我们需要遍历文件夹，如果是文件则拷贝过去，如果是文件夹则要进行1-1创建，再递归。</p><h3 id="6-补充知识：IO框架"><a href="#6-补充知识：IO框架" class="headerlink" title="6.补充知识：IO框架"></a>6.补充知识：IO框架</h3><p><strong>commons-io概述</strong></p><ul><li><p>commons-io是apache开源基金组织提供的一组有关IO操作的类库，可以提高IO功能开发的效率。</p></li><li><p>commons-io工具包提供了很多有关io操作的类。有两个主要的类FileUtils, IOUtils</p></li></ul><p><strong>步骤：导入commons-io-2.6.jar做开发</strong></p><p><strong>需求</strong></p><ul><li>使用commons-io简化io流读写</li></ul><p><strong>分析</strong></p><p>①在项目中创建一个文件夹：lib</p><p>②将commons-io-2.6.jar文件复制到lib文件夹</p><p>③在jar文件上点右键，选择 Add as Library -&gt; 点击OK</p><p>④在类中导包使用</p><p><strong>FileUtils主要有如下方法:</strong></p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>String  readFileToString(File  file, String encoding)</td><td>读取文件中的数据, 返回字符串</td></tr><tr><td>void  copyFile(File  srcFile, File destFile)</td><td>复制文件。</td></tr><tr><td>void  copyDirectoryToDirectory(File  srcDir,  File destDir)</td><td>复制文件夹。</td></tr></tbody></table><p><strong>commons-io 的API文档：  <a href="C:\Users\廖永森\Desktop\JavaSE\day20、IO流二\资料\5-类库\commons-io-2.11.0\docs\index.html">index.html</a></strong> </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标:Commons-io包的使用介绍。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    见下表：</span></span><br><span class="line"><span class="comment">         | 包                                  | 功能描述                                     |</span></span><br><span class="line"><span class="comment">         | ----------------------------------- | :------------------------------------------- |</span></span><br><span class="line"><span class="comment">         | org.apache.commons.io               | 有关Streams、Readers、Writers、Files的工具类 |</span></span><br><span class="line"><span class="comment">         | org.apache.commons.io.input         | 输入流相关的实现类，包含Reader和InputStream  |</span></span><br><span class="line"><span class="comment">         | org.apache.commons.io.output        | 输出流相关的实现类，包含Writer和OutputStream |</span></span><br><span class="line"><span class="comment">         | org.apache.commons.io.serialization | 序列化相关的类</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    小结：</span></span><br><span class="line"><span class="comment">         IOUtils和FileUtils可以方便的复制文件和文件夹！！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonsIODemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">////        // 1.完成文件复制！</span></span><br><span class="line"><span class="comment">//        IOUtils.copy(new FileInputStream(&quot;D:\\resources\\hushui.jpeg&quot;),</span></span><br><span class="line"><span class="comment">//                new FileOutputStream(&quot;D:\\resources\\hushui2.jpeg&quot;));</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">////        // 2.完成文件复制到某个文件夹下！</span></span><br><span class="line"><span class="comment">//        FileUtils.copyFileToDirectory(new File(&quot;D:\\resources\\hushui.jpeg&quot;), new File(&quot;D:/&quot;));</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">          <span class="comment">// 3.完成文件夹复制到某个文件夹下！</span></span><br><span class="line"><span class="comment">//          FileUtils.copyDirectoryToDirectory(new File(&quot;D:\\resources&quot;) , new File(&quot;D:\\new&quot;));</span></span><br><span class="line"><span class="comment">//           FileUtils.deleteDirectory(new File(&quot;D:\\new&quot;));</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">// JDK1.7 自己也做了一些一行代码完成复制的操作:New IO的技术</span></span><br><span class="line">         <span class="comment">// Files.copy(Path.of(&quot;D:\\resources\\hushui.jpeg&quot;), Path.of(&quot;D:\\resources\\hushui3.jpeg&quot;));</span></span><br><span class="line"></span><br><span class="line">        FileUtils.deleteDirectory(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\new&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> java,面向对象进阶,IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>day18 - File、递归、IO一</title>
      <link href="/post/2edfce22.html"/>
      <url>/post/2edfce22.html</url>
      
        <content type="html"><![CDATA[<p><strong>1、目前是怎么样存储数据的？弊端是什么？</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> [] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><ul><li>在内存中存储的数据是用来处理、修改、运算的，不能长久保存。</li></ul><p><strong>2、计算机中，有没有一块硬件可以永久存储数据的？</strong></p><ul><li>磁盘中数据的形式就是文件，文件是数据的载体。</li></ul><p>1、先要定位文件</p><ul><li><p>File类可以定位文件：进行删除、获取文本本身信息等操作<strong>。</strong></p></li><li><p><strong>但是不能读写文件内容。</strong></p></li></ul><p>2、读写文件数据</p><ul><li>IO流技术可以对硬盘中的文件进行读写</li></ul><p>3、今日总体学习思路</p><ul><li><p><strong>先学会使用File类定位文件以及操作文件本身</strong></p></li><li><p><strong>然后学习IO流读写文件数据。</strong></p></li></ul><h3 id="1-File类概述"><a href="#1-File类概述" class="headerlink" title="1.File类概述"></a>1.File类概述</h3><p><strong>File类概述</strong></p><ul><li><p>File类在包java.io.File下、代表操作系统的文件对象（文件、文件夹）。</p></li><li><p>File类提供了诸如：定位文件，获取文件本身的信息、删除文件、创建文件（文件夹）等功能。</p></li></ul><p><strong>File类创建对象</strong></p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td><strong>public</strong> File(String  pathname)</td><td>根据文件路径创建文件对象</td></tr><tr><td><strong>public</strong> File(String  parent, String child)</td><td>从父路径名字符串和子路径名字符串创建文件对象</td></tr><tr><td><strong>public</strong> File(File parent, String child)</td><td>根据父路径对应文件对象和子路径名字符串创建文件对象</td></tr></tbody></table><ul><li><p>File对象可以定位文件和文件夹</p></li><li><p>File封装的对象仅仅是一个路径名，这个路径可以是存在的，也可以是不存在的。</p></li></ul><p><strong>绝对路径和相对路径</strong></p><ul><li>绝对路径：从盘符开始</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(“D:\\itheima\\a.txt”); </span><br></pre></td></tr></table></figure><ul><li>相对路径：不带盘符，默认直接到当前工程下的目录寻找文件。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(“模块名\\a.txt”);</span><br></pre></td></tr></table></figure><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1、创建File对象（指定了文件的路径）</span></span><br><span class="line"><span class="comment">// 路径写法：D:\\resources\\xueshan.jpeg</span></span><br><span class="line">        <span class="comment">// D:/resources/xueshan.jpeg</span></span><br><span class="line">        <span class="comment">// File.separator(转义的方法 = \\)</span></span><br><span class="line"><span class="comment">//      File f = new File(&quot;D:\\resources\\xueshan.jpeg&quot;);</span></span><br><span class="line"><span class="comment">//      File f = new File(&quot;D:/resources/xueshan.jpeg&quot;);</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:&quot;</span> + File.separator+<span class="string">&quot;resources&quot;</span>+ File.separator +<span class="string">&quot;xueshan.jpeg&quot;</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> f.length(); <span class="comment">// 是文件的字节大小</span></span><br><span class="line">        System.out.println(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、File创建对象，支持绝对路径 支持相对路径（重点）</span></span><br><span class="line"><span class="comment">// 绝对路径:从盘符开始</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\resources\\beauty.jpeg&quot;</span>); </span><br><span class="line">        System.out.println(f1.length());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 相对路径：一般定位模块中的文件的。 相对到工程下！！</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;file-io-app/src/data.txt&quot;</span>);</span><br><span class="line">        System.out.println(f2.length());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、File创建对象 ，可以是文件也可以是文件夹</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\resources&quot;</span>);</span><br><span class="line">        System.out.println(f3.exists()); <span class="comment">// 判断这个路径是否存在，这个文件夹存在否</span></span><br></pre></td></tr></table></figure><h3 id="2-File类的常用API"><a href="#2-File类的常用API" class="headerlink" title="2.File类的常用API"></a>2.File类的常用API</h3><h4 id="1-判断文件类型、获取文件信息"><a href="#1-判断文件类型、获取文件信息" class="headerlink" title="1.判断文件类型、获取文件信息"></a>1.判断文件类型、获取文件信息</h4><p><strong>File类的判断文件类型、获取文件信息功能</strong></p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>public  boolean isDirectory()</td><td>测试此抽象路径名表示的File是否为文件夹</td></tr><tr><td>public  boolean isFile()</td><td>测试此抽象路径名表示的File是否为文件</td></tr><tr><td>public  boolean  exists()</td><td>测试此抽象路径名表示的File是否存在</td></tr><tr><td>public  String getAbsolutePath()</td><td>返回此抽象路径名的绝对路径名字符串</td></tr><tr><td>public  String getPath()</td><td>将此抽象路径名转换为路径名字符串</td></tr><tr><td>public  String getName()</td><td>返回由此抽象路径名表示的文件或文件夹的名称</td></tr><tr><td>public  long lastModified()</td><td>返回文件最后修改的时间毫秒值</td></tr></tbody></table><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.绝对路径创建一个文件对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/resources/xueshan.jpeg&quot;</span>);</span><br><span class="line">        <span class="comment">// a.获取它的绝对路径。</span></span><br><span class="line">        System.out.println(f1.getAbsolutePath());</span><br><span class="line">        <span class="comment">// b.获取文件定义的时候使用的路径。</span></span><br><span class="line">        System.out.println(f1.getPath());</span><br><span class="line">        <span class="comment">// c.获取文件的名称：带后缀。</span></span><br><span class="line">        System.out.println(f1.getName()); <span class="comment">//xueshan.jpeg</span></span><br><span class="line">        <span class="comment">// d.获取文件的大小：字节个数。</span></span><br><span class="line">        System.out.println(f1.length()); <span class="comment">//字节大小</span></span><br><span class="line">        <span class="comment">// e.获取文件的最后修改时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> f1.lastModified();</span><br><span class="line">        System.out.println(<span class="string">&quot;最后修改时间：&quot;</span> + <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy/MM/dd HH:mm:ss&quot;</span>).format(time));</span><br><span class="line">        <span class="comment">// f、判断是否是文件</span></span><br><span class="line">        System.out.println(f1.isFile()); <span class="comment">// true</span></span><br><span class="line"><span class="comment">//判断是否是文件夹</span></span><br><span class="line">        System.out.println(f1.isDirectory()); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.相对路径创建一个文件对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;file-io-app\\src\\data.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// a.获取它的绝对路径。</span></span><br><span class="line">        System.out.println(f2.getAbsolutePath());</span><br><span class="line">        <span class="comment">// b.获取文件定义的时候使用的路径。</span></span><br><span class="line">        System.out.println(f2.getPath());</span><br><span class="line">        <span class="comment">// c.获取文件的名称：带后缀。</span></span><br><span class="line">        System.out.println(f2.getName());</span><br><span class="line">        <span class="comment">// d.获取文件的大小：字节个数。</span></span><br><span class="line">        System.out.println(f2.length()); <span class="comment">// 字节大小</span></span><br><span class="line">        <span class="comment">// e.获取文件的最后修改时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">time1</span> <span class="operator">=</span> f2.lastModified();</span><br><span class="line">        System.out.println(<span class="string">&quot;最后修改时间：&quot;</span> + <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy/MM/dd HH:mm:ss&quot;</span>).format(time1));</span><br><span class="line">        <span class="comment">// f、判断是否是文件</span></span><br><span class="line">        System.out.println(f2.isFile()); <span class="comment">// true</span></span><br><span class="line"><span class="comment">//判断是否是文件夹</span></span><br><span class="line">        System.out.println(f2.isDirectory()); <span class="comment">// false</span></span><br><span class="line"><span class="comment">//判断这个路径是否存在</span></span><br><span class="line">        System.out.println(f2.exists()); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/&quot;</span>);</span><br><span class="line">        System.out.println(file.isFile()); <span class="comment">// false</span></span><br><span class="line">        System.out.println(file.isDirectory()); <span class="comment">// true</span></span><br><span class="line">        System.out.println(file.exists()); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/aaa&quot;</span>);</span><br><span class="line">        System.out.println(file1.isFile()); <span class="comment">// false</span></span><br><span class="line">        System.out.println(file1.isDirectory()); <span class="comment">// false</span></span><br><span class="line">        System.out.println(file1.exists()); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h4 id="2-创建文件、删除文件功能"><a href="#2-创建文件、删除文件功能" class="headerlink" title="2.创建文件、删除文件功能"></a>2.创建文件、删除文件功能</h4><p><strong>File类创建文件的功能</strong></p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>public boolean createNewFile()</td><td>创建一个新的空的文件</td></tr><tr><td>public boolean mkdir()</td><td>只能创建一级文件夹</td></tr><tr><td>public boolean mkdirs()</td><td>可以创建多级文件夹</td></tr></tbody></table><p><strong>File类删除文件的功能</strong></p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>public  boolean delete()</td><td>删除由此抽象路径名表示的文件或空文件夹</td></tr></tbody></table><ul><li><p><strong>delete方法默认只能删除文件和空文件夹。</strong></p></li><li><p><strong>delete方法直接删除不走回收站</strong></p></li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.创建新文件，createNewFile,创建成功返回true ,反之 ,不需要这个，以后文件写出去的时候都会自动创建</span></span><br><span class="line"><span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;file-io-app\\src\\data.txt&quot;</span>);</span><br><span class="line">        System.out.println(f.createNewFile());</span><br><span class="line"></span><br><span class="line">        <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;file-io-app\\src\\data02.txt&quot;</span>);</span><br><span class="line">        System.out.println(f1.createNewFile()); <span class="comment">// （几乎不用的，因为以后文件都是自动创建的！）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// b.mkdir创建一级目录</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/resources/aaa&quot;</span>);</span><br><span class="line">        System.out.println(f2.mkdir());</span><br><span class="line"></span><br><span class="line"><span class="comment">// c.mkdirs创建多级目录(重点)</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/resources/ccc/ddd/eee/ffff&quot;</span>);</span><br><span class="line"><span class="comment">//System.out.println(f3.mkdir()); //mkdirs</span></span><br><span class="line">        System.out.println(f3.mkdirs()); <span class="comment">// 支持多级创建</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// d.删除文件或者空文件夹</span></span><br><span class="line">        System.out.println(f1.delete());</span><br><span class="line">        <span class="type">File</span> <span class="variable">f4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/resources/xueshan.jpeg&quot;</span>);</span><br><span class="line">        System.out.println(f4.delete()); <span class="comment">// 占用一样可以删除</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只能删除空文件夹,不能删除非空文件夹(多级文件夹).</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/resources/aaa&quot;</span>);</span><br><span class="line">        System.out.println(f5.delete()); </span><br></pre></td></tr></table></figure><h4 id="3-遍历文件夹"><a href="#3-遍历文件夹" class="headerlink" title="3.遍历文件夹"></a>3.遍历文件夹</h4><p><strong>File类的遍历功能</strong></p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>public String[] list()</td><td>获取当前目录下所有的”一级文件名称”到一个字符串数组中去返回。</td></tr><tr><td>public File[] listFiles()(常用)</td><td>获取当前目录下所有的”一级文件对象”到一个文件对象数组中去返回（重点）</td></tr></tbody></table><p><strong>listFiles方法注意事项：</strong></p><ul><li><p>当调用者不存在时，返回null</p></li><li><p>当调用者是一个文件时，返回null</p></li><li><p>当调用者是一个空文件夹时，返回一个长度为0的数组</p></li><li><p>当调用者是一个有内容的文件夹时，将里面所有文件和文件夹的路径放在File数组中返回</p></li><li><p>当调用者是一个有隐藏文件的文件夹时，将里面所有文件和文件夹的路径放在File数组中返回，包含隐藏内容</p></li><li><p>当调用者是一个需要权限才能进入的文件夹时，返回null</p></li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：File针对目录的遍历</span></span><br><span class="line"><span class="comment">    - public String[] list()：</span></span><br><span class="line"><span class="comment">         获取当前目录下所有的&quot;一级文件名称&quot;到一个字符串数组中去返回。</span></span><br><span class="line"><span class="comment">         </span></span><br><span class="line"><span class="comment">    - public File[] listFiles()(常用)：（重点）</span></span><br><span class="line"><span class="comment">         获取当前目录下所有的&quot;一级文件对象&quot;到一个文件对象数组中去返回</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、定位一个目录</span></span><br><span class="line"><span class="comment">//获取当前目录下所有的&quot;一级文件名称&quot;到一个字符串数组中去返回。</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/resources&quot;</span>);</span><br><span class="line">        String[] names = f1.list();</span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.一级文件对象</span></span><br><span class="line">        <span class="comment">// 获取当前目录下所有的&quot;一级文件对象&quot;到一个文件对象数组中去返回（重点）</span></span><br><span class="line"><span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/resources&quot;</span>);</span><br><span class="line">        File[] files = f1.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File f : files) &#123;</span><br><span class="line">            System.out.println(f.getAbsolutePath());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意事项</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">dir1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:/resources&quot;</span>); <span class="comment">//当调用者不存在时，返回null</span></span><br><span class="line"></span><br><span class="line"><span class="type">File</span> <span class="variable">dir2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/resources/xueshan&quot;</span>); <span class="comment">//当调用者是一个文件时，返回null</span></span><br><span class="line"></span><br><span class="line"><span class="type">File</span> <span class="variable">dir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/resources/ddd&quot;</span>); <span class="comment">//首先目录存在，当调用者是一个空文件夹时，返回一个长度为0的数组</span></span><br><span class="line">File[] fi = f1.listFiles();</span><br><span class="line">        System.out.println(Arrays.toString(fi)); <span class="comment">// [] </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-方法递归"><a href="#3-方法递归" class="headerlink" title="3.方法递归"></a>3.方法递归</h3><h4 id="3-1递归的形式和特点"><a href="#3-1递归的形式和特点" class="headerlink" title="3.1递归的形式和特点"></a>3.1递归的形式和特点</h4><p><strong>什么是方法递归?</strong></p><ul><li><p>方法直接调用自己或者间接调用自己的形式称为方法递归（ recursion）。</p></li><li><p>递归做为一种<a href="https://baike.baidu.com/item/%E7%AE%97%E6%B3%95">算法</a>在<a href="https://baike.baidu.com/item/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">程序设计语言</a>中广泛应用。</p></li></ul><p><strong>递归的形式</strong></p><ul><li><p>直接递归：方法自己调用自己。</p></li><li><p>间接递归：方法调用其他方法，其他方法又回调方法自己。</p></li></ul><p><strong>方法递归存在的问题？</strong></p><ul><li>递归如果没有控制好终止，会出现递归死循环，导致栈内存溢出现象。</li></ul><h4 id="3-2递归的算法流程、核心要素"><a href="#3-2递归的算法流程、核心要素" class="headerlink" title="3.2递归的算法流程、核心要素"></a>3.2递归的算法流程、核心要素</h4><p><strong>递归解决问题的思路：</strong></p><ul><li>把一个复杂的问题层层转化为一个<strong>与原问题相似的规模较小</strong>的问题来求解。</li></ul><p><strong>递归算法三要素大体可以总结为：</strong></p><ul><li><p><strong>递归的公式：</strong> <strong>f(n) &#x3D; f(n-1) * n</strong></p></li><li><p><strong>递归的终结点：f(1)</strong> </p></li><li><p><strong>递归的方向必须走向终结点：</strong></p></li></ul><h4 id="3-3递归常见案例"><a href="#3-3递归常见案例" class="headerlink" title="3.3递归常见案例"></a>3.3递归常见案例</h4><p><strong>递归案例导学-计算1-n的阶乘</strong></p><p><strong>需求：</strong></p><p>计算1-n的阶乘的结果，使用递归思想解决，我们先从数学思维上理解递归的流程和核心点。</p><p><strong>分析:</strong></p><p>①假如我们认为存在一个公式是 f(n) &#x3D; 1<em>2</em>3<em>4</em>5<em>6</em>7*…(n-1)*n;</p><p>②那么公式等价形式就是： f(n) &#x3D; f(n-1) *n</p><p>③如果求的是 1-5的阶乘 的结果，我们手工应该应该如何应用上述公式计算。</p><p>④f(5) &#x3D; f(4) * 5<br> f(4) &#x3D; f(3) * 4<br> f(3) &#x3D; f(2) * 3<br> f(2) &#x3D; f(1) * 2<br> f(1) &#x3D; 1</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">      目标：递归的算法和执行流程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RecursionDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(f(<span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> f(n - <span class="number">1</span>) * n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>递归案例导学-计算1–n的和</strong></p><p><strong>需求：</strong></p><p>计算1-n的和的结果，使用递归思想解决，我们先从数学思维上理解递归的流程和核心点。</p><p><strong>分析:</strong></p><p>①假如我们认为存在一个公式是 f(n) &#x3D; 1 + 2 + 3 + 4 + 5 + 6 + 7 + …(n-1) + n;</p><p>②那么公式等价形式就是： f(n) &#x3D; f(n-1) + n</p><p>③递归的终结点：f(1) &#x3D; 1</p><p>④如果求的是 1-5的和 的结果，应该如何计算。</p><p>⑤f(5) &#x3D; f(4)  + 5<br> f(4) &#x3D; f(3)  + 4<br> f(3) &#x3D; f(2)  + 3<br> f(2) &#x3D; f(1)  + 2<br> f(1) &#x3D; 1</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">      目标：1 - n求和</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RecursionDemo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(f(<span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> f(n - <span class="number">1</span>)  + n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-4递归的经典问题"><a href="#3-4递归的经典问题" class="headerlink" title="3.4递归的经典问题"></a>3.4递归的经典问题</h4><p><strong>猴子吃桃问题</strong></p><p>猴子第一天摘下若干桃子，当即吃了一半，觉得好不过瘾，于是又多吃了一个</p><p>第二天又吃了前天剩余桃子数量的一半，觉得好不过瘾，于是又多吃了一个</p><p>以后每天都是吃前天剩余桃子数量的一半，觉得好不过瘾，又多吃了一个</p><p>等到第10天的时候发现桃子只有1个了。</p><p>需求：请问猴子第一天摘了多少个桃子？</p><p><strong>分析：</strong></p><p>①整体来看，每一天都是做同一个事件，典型的规律化问题，考虑递归三要素：</p><p>②递归公式： </p><p>③递归终结点：</p><p>④递归方向：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     目标 猴子吃桃。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     公式（合理的）： f(x) - f(x)/2 - 1 = f(x+1)</span></span><br><span class="line"><span class="comment">                   2f(x) - f(x) - 2 = 2f(x + 1)</span></span><br><span class="line"><span class="comment">                   f(x) = 2f(x + 1) + 2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    求f(1) = ?</span></span><br><span class="line"><span class="comment">    终结点： f（10） = 1</span></span><br><span class="line"><span class="comment">    递归的方向：合理的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RecursionDemo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(f(<span class="number">1</span>));</span><br><span class="line">        System.out.println(f(<span class="number">2</span>));</span><br><span class="line">        System.out.println(f(<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">10</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span> * f(n + <span class="number">1</span>) + <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-5非规律化递归案例-文件搜索"><a href="#3-5非规律化递归案例-文件搜索" class="headerlink" title="3.5非规律化递归案例-文件搜索"></a>3.5非规律化递归案例-文件搜索</h4><p><strong>文件搜索：</strong></p><p><strong>需求：</strong></p><p>文件搜索、从C:盘中，搜索出某个文件名称并输出绝对路径。</p><p><strong>分析：</strong></p><p>①先定位出的应该是一级文件对象</p><p>②遍历全部一级文件对象，判断是否是文件</p><p>③如果是文件，判断是否是自己想要的</p><p>④如果是文件夹，需要继续递归进去重复上述过程</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：去D判断搜索 eDiary.exe文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RecursionDemo05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 2、传入目录 和  文件名称</span></span><br><span class="line">        searchFile(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/&quot;</span>) , <span class="string">&quot;eDiary.exe&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1、搜索某个目录下的全部文件，找到我们想要的文件。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dir  被搜索的源目录</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fileName 被搜索的文件名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">searchFile</span><span class="params">(File dir,String fileName)</span>&#123;</span><br><span class="line">        <span class="comment">// 3、判断dir是否是目录</span></span><br><span class="line">        <span class="keyword">if</span>(dir != <span class="literal">null</span> &amp;&amp; dir.isDirectory())&#123;</span><br><span class="line">            <span class="comment">// 可以找了</span></span><br><span class="line">            <span class="comment">// 4、提取当前目录下的一级文件对象</span></span><br><span class="line">            File[] files = dir.listFiles(); <span class="comment">// null  []</span></span><br><span class="line">            <span class="comment">// 5、判断是否存在一级文件对象，存在才可以遍历</span></span><br><span class="line">            <span class="keyword">if</span>(files != <span class="literal">null</span> &amp;&amp; files.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">                    <span class="comment">// 6、判断当前遍历的一级文件对象是文件 还是 目录</span></span><br><span class="line">                    <span class="keyword">if</span>(file.isFile())&#123;</span><br><span class="line">                        <span class="comment">// 7、是不是咱们要找的，是把其路径输出即可</span></span><br><span class="line">                        <span class="keyword">if</span>(file.getName().contains(fileName))&#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;找到了：&quot;</span> + file.getAbsolutePath());</span><br><span class="line">                            <span class="comment">// 启动它。</span></span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                <span class="type">Runtime</span> <span class="variable">r</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line">                                r.exec(file.getAbsolutePath());</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                                e.printStackTrace();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 8、是文件夹，需要继续递归寻找</span></span><br><span class="line">                        searchFile(file, fileName);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;对不起，当前搜索的位置不是文件夹！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-6非规律化递归案例-啤酒问题"><a href="#3-6非规律化递归案例-啤酒问题" class="headerlink" title="3.6非规律化递归案例-啤酒问题"></a>3.6非规律化递归案例-啤酒问题</h4><p><strong>啤酒问题:</strong></p><p><strong>需求：</strong></p><p>啤酒2元1瓶，4个盖子可以换一瓶，2个空瓶可以换一瓶，</p><p>请问10元钱可以喝多少瓶酒，剩余多少空瓶和盖子。</p><p><strong>答案：</strong></p><p>15瓶 3盖子 1瓶子</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：啤酒2元1瓶，4个盖子可以换一瓶，2个空瓶可以换一瓶，</span></span><br><span class="line"><span class="comment">        请问10元钱可以喝多少瓶酒，剩余多少空瓶和盖子。</span></span><br><span class="line"><span class="comment">        答案：15瓶 3盖子 1瓶子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RecursionDemo06</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个静态的成员变量用于存储可以买的酒数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> totalNumber; <span class="comment">// 总数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> lastBottleNumber; <span class="comment">// 记录每次剩余的瓶子个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> lastCoverNumber; <span class="comment">// 记录每次剩余的盖子个数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、拿钱买酒</span></span><br><span class="line">        buy(<span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;总数：&quot;</span> + totalNumber);</span><br><span class="line">        System.out.println(<span class="string">&quot;剩余盖子数：&quot;</span> + lastCoverNumber);</span><br><span class="line">        System.out.println(<span class="string">&quot;剩余瓶子数：&quot;</span> + lastBottleNumber);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">buy</span><span class="params">(<span class="type">int</span> money)</span>&#123;</span><br><span class="line">        <span class="comment">// 2、看可以立马买多少瓶</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">buyNumber</span> <span class="operator">=</span> money / <span class="number">2</span>; <span class="comment">// 5</span></span><br><span class="line">        totalNumber += buyNumber;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、把盖子 和瓶子换算成钱</span></span><br><span class="line">        <span class="comment">// 统计本轮总的盖子数  和 瓶子数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">coverNumber</span> <span class="operator">=</span> lastCoverNumber + buyNumber;</span><br><span class="line">        <span class="type">int</span> <span class="variable">bottleNumber</span> <span class="operator">=</span> lastBottleNumber + buyNumber;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 统计可以换算的钱</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">allMoney</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(coverNumber &gt;= <span class="number">4</span>)&#123;</span><br><span class="line">            allMoney += (coverNumber / <span class="number">4</span>) * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lastCoverNumber = coverNumber % <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(bottleNumber &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">            allMoney += (bottleNumber / <span class="number">2</span>) * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lastBottleNumber = bottleNumber % <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(allMoney &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">            buy(allMoney);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Integer[] arr2 = <span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>&#125;;</span><br><span class="line">        Arrays.sort(arr2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-字符集"><a href="#4-字符集" class="headerlink" title="4.字符集"></a>4.字符集</h3><h4 id="4-1常见字符集介绍"><a href="#4-1常见字符集介绍" class="headerlink" title="4.1常见字符集介绍"></a>4.1常见字符集介绍</h4><p><strong>字符集基础知识：</strong></p><ul><li><p>计算机底层不可以直接存储字符的。计算机中底层只能存储<strong>二进制(0、1)</strong></p></li><li><p>二进制是可以转换成十进制的</p></li></ul><p>11 &#x3D; 1<em>2^1 + 1</em>2^0 &#x3D; 2 + 1 &#x3D; 3<br>10 &#x3D; 1<em>2^1 + 0</em>2^0 &#x3D; 2 + 0 &#x3D; 2<br> 01 &#x3D; 0<em>2^1 + 1</em>2^0 &#x3D; 0 + 1 &#x3D; 1<br> 00 &#x3D; 0<em>2^1 + 0</em>2^0 &#x3D; 0 + 0 &#x3D; 0</p><p>‭01100001‬ &#x3D; 97</p><p>‭01100010‬ &#x3D; 98</p><p><strong>结论：计算机底层可以表示十进制编号。计算机可以给人类字符进行编号存储，这套编号规则就是字符集。</strong></p><p><strong>ASCII字符集：</strong></p><ul><li><p>ASCII(American Standard Code for Information Interchange，美国信息交换标准代码)：包括了数字、英文、符号。</p></li><li><p>ASCII使用1个字节存储一个字符，一个字节是8位，总共可以表示128个字符信息，对于英文，数字来说是够用的。</p></li></ul><p>01100001‬ &#x3D; 97 &#x3D;&gt; a</p><p>‭01100010‬ &#x3D; 98 &#x3D;&gt; b</p><p><strong>GBK：</strong></p><ul><li><p>window系统默认的码表。兼容ASCII码表，也包含了几万个汉字，并支持繁体汉字以及部分日韩文字。</p></li><li><p>注意：GBK是中国的码表，一个中文以<strong>两个字节</strong>的形式存储。但不包含世界上所有国家的文字。</p></li></ul><p><strong>Unicode码表：</strong></p><ul><li><p>unicode（又称统一码、万国码、单一码）是计算机科学领域里的一项业界字符编码标准。</p></li><li><p>容纳世界上大多数国家的所有常见文字和符号。</p></li><li><p>由于Unicode会先通过UTF-8，UTF-16，以及 UTF-32的编码成二进制后再存储到计算机，其中最为常见的就是UTF-8。</p></li></ul><p><strong>注意</strong></p><ul><li><p>Unicode是万国码，以UTF-8编码后一个中文一般以<strong>三个字节</strong>的形式存储。</p></li><li><p>UTF-8也要兼容ASCII编码表。</p></li><li><p>技术人员都应该使用UTF-8的字符集编码。</p></li><li><p>编码前和编码后的字符集需要一致，否则会出现中文乱码。</p></li></ul><h4 id="4-2字符集的编码、解码操作"><a href="#4-2字符集的编码、解码操作" class="headerlink" title="4.2字符集的编码、解码操作"></a>4.2字符集的编码、解码操作</h4><p><strong>String编码</strong></p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>byte[] getBytes()</td><td>使用平台的默认字符集将该  String编码为一系列字节，将结果存储到新的字节数组中</td></tr><tr><td>byte[] getBytes(String charsetName)</td><td>使用指定的字符集将该 String编码为一系列字节，将结果存储到新的字节数组中</td></tr></tbody></table><p><strong>String解码</strong></p><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>String(byte[] bytes)</td><td>通过使用平台的默认字符集解码指定的字节数组来构造新的  String</td></tr><tr><td>String(byte[] bytes, String charsetName)</td><td>通过指定的字符集解码指定的字节数组来构造新的 String</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     目标：学会自己进行文字的编码和解码，为以后可能用到的场景做准备。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、编码：把文字转换成字节</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;abc我爱你中国&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 以当前代码默认字符集进行编码 （UTF-8）</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = name.getBytes(); </span><br><span class="line">        System.out.println(bytes.length); <span class="comment">//18</span></span><br><span class="line">        System.out.println(Arrays.toString(bytes)); </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 指定编码</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = name.getBytes(<span class="string">&quot;GBK&quot;</span>); </span><br><span class="line">        System.out.println(bytes.length); <span class="comment">//13</span></span><br><span class="line">        System.out.println(Arrays.toString(bytes));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、解码：把字节转换成对应的中文形式（编码前 和 编码后的字符集必须一致，否则乱码 ）</span></span><br><span class="line">        <span class="comment">// 默认的UTF-8</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes); </span><br><span class="line">        <span class="comment">// 指定GBK解码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="string">&quot;GBK&quot;</span>); </span><br><span class="line">        System.out.println(rs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-IO流概述"><a href="#5-IO流概述" class="headerlink" title="5.IO流概述"></a>5.IO流概述</h3><p><strong>IO流概述</strong></p><ul><li><p>I 表示intput，是数据从硬盘文件读入到内存的过程，称之输入，负责读。</p></li><li><p>O表示output，是内存程序的数据从内存到写出到硬盘文件的过程，称之输出，负责写。</p></li></ul><p><strong>IO流的作用</strong></p><ul><li>读写文件数据</li></ul><p><strong>IO流的分类</strong></p><ol><li><p><strong>字节流（Byte Streams）</strong>：字节流以字节为单位进行数据的输入和输出。它们适用于处理二进制数据或字符数据，不关心数据的具体含义。在Java中，<code>InputStream</code>和<code>OutputStream</code>是字节流的基本抽象类。</p><ul><li><code>InputStream</code>：用于从数据源（如文件、网络等）读取字节数据。</li><li><code>OutputStream</code>：用于将字节数据写入目标（如文件、网络等）。</li></ul></li><li><p><strong>字符流（Character Streams）</strong>：字符流以字符为单位进行数据的输入和输出，可以更方便地处理文本数据。在处理字符数据时，字符流会考虑字符的编码方式，如UTF-8、UTF-16等。在Java中，<code>Reader</code>和<code>Writer</code>是字符流的基本抽象类。</p><ul><li><code>Reader</code>：用于从数据源读取字符数据。</li><li><code>Writer</code>：用于将字符数据写入目标。</li></ul></li><li><p><strong>节点流（Node Streams）</strong>：节点流直接与数据源或目标进行连接，是I&#x2F;O流的最基本形式。例如，从文件中读取数据的<code>FileInputStream</code>和向文件写入数据的<code>FileOutputStream</code>就是节点流。</p></li><li><p><strong>处理流（Filter Streams）</strong>：处理流是建立在节点流之上的，它们提供了一些额外的功能，如缓冲、数据转换等。处理流可以通过链式结构进行组合，将多个处理流串联起来以实现更复杂的数据处理操作。例如，<code>BufferedReader</code>和<code>BufferedWriter</code>就是处理流的例子，它们可以用来缓冲字符流的输入和输出。</p></li><li><p><strong>对象流（Object Streams）</strong>：对象流可以用来读写Java对象，而不仅仅是字节或字符数据。这对于在应用程序之间传递复杂的数据结构非常有用。<code>ObjectInputStream</code>和<code>ObjectOutputStream</code>用于实现对象流。</p></li><li><p><strong>数据流（Data Streams）</strong>：数据流允许以基本数据类型（如整数、浮点数等）的形式进行读写操作，而不必考虑字节的表示。<code>DataInputStream</code>和<code>DataOutputStream</code>提供了数据流的功能。</p></li><li><p><strong>输入流和输出流</strong>：根据数据流的方向，可以将I&#x2F;O流分为输入流和输出流。输入流用于读取数据，输出流用于写入数据。</p></li></ol><p><strong>总结流的四大类:</strong></p><ul><li><p>字节输入流：以内存为基准，来自磁盘文件&#x2F;网络中的数据以字节的形式读入到内存中去的流称为字节输入流。</p></li><li><p>字节输出流：以内存为基准，把内存中的数据以字节写出到磁盘文件或者网络中去的流称为字节输出流。</p></li><li><p>字符输入流：以内存为基准，来自磁盘文件&#x2F;网络中的数据以字符的形式读入到内存中去的流称为字符输入流。</p></li><li><p>字符输出流：以内存为基准，把内存中的数据以字符写出到磁盘文件或者网络介质中去的流称为字符输出流。</p></li></ul><p><strong>IO流体系</strong></p><ol><li><strong>字节流（Byte Streams）</strong>： 字节流操作以字节为单位进行读写，适用于处理任何类型的数据，包括文本和二进制数据。主要的字节流类有：<ul><li><code>InputStream</code>：字节输入流的基类。</li><li><code>OutputStream</code>：字节输出流的基类。</li><li><code>FileInputStream</code>：从文件中读取字节数据的输入流。</li><li><code>FileOutputStream</code>：向文件写入字节数据的输出流。</li><li><code>BufferedInputStream</code> 和 <code>BufferedOutputStream</code>：带有缓冲功能的字节流。</li><li><code>DataInputStream</code> 和 <code>DataOutputStream</code>：用于读写基本数据类型的字节流。</li></ul></li><li><strong>字符流（Character Streams）</strong>： 字符流操作以字符为单位进行读写，适用于处理文本数据。字符流会自动处理字符编码和解码，以确保正确处理各种字符集。主要的字符流类有：<ul><li><code>Reader</code>：字符输入流的基类。</li><li><code>Writer</code>：字符输出流的基类。</li><li><code>FileReader</code>：从文件中读取字符数据的输入流。</li><li><code>FileWriter</code>：向文件写入字符数据的输出流。</li><li><code>BufferedReader</code> 和 <code>BufferedWriter</code>：带有缓冲功能的字符流。</li><li><code>InputStreamReader</code> 和 <code>OutputStreamWriter</code>：将字节流转换为字符流的桥梁。</li></ul></li></ol><h3 id="6-字节流的使用"><a href="#6-字节流的使用" class="headerlink" title="6.字节流的使用"></a>6.字节流的使用</h3><h4 id="6-1文件字节输入流：FileInputStream"><a href="#6-1文件字节输入流：FileInputStream" class="headerlink" title="6.1文件字节输入流：FileInputStream"></a>6.1文件字节输入流：FileInputStream</h4><p><strong>注意：读数据会自己换行</strong></p><p><strong>构造器</strong></p><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public  <strong>FileInputStream</strong>(File file)</td><td>创建字节输入流管道与源文件对象接通</td></tr><tr><td>public  <strong>FileInputStream</strong>(String pathname)</td><td>创建字节输入流管道与源文件路径接通</td></tr></tbody></table><h5 id="6-1-1每次读取一个字节"><a href="#6-1-1每次读取一个字节" class="headerlink" title="6.1.1每次读取一个字节"></a>6.1.1每次读取一个字节</h5><ul><li>作用：以内存为基准，把磁盘文件中的数据以字节的形式读取到内存中去。</li></ul><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>public int  read()</td><td>每次读取一个字节返回，如果字节已经没有可读的返回-1</td></tr></tbody></table><p><strong>每次读取一个字节存在什么问题？</strong></p><ul><li><p><strong>性能较慢</strong></p></li><li><p><strong>读取中文字符输出无法避免乱码问题。</strong></p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：字节输入流的使用。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    IO流的体系：</span></span><br><span class="line"><span class="comment">                    字节流                                     字符流</span></span><br><span class="line"><span class="comment">        字节输入流             字节输出流               字符输入流         字符输出流</span></span><br><span class="line"><span class="comment">        InputStream          OutputStream            Reader           Writer  (抽象类)</span></span><br><span class="line"><span class="comment">        FileInputStream      FileOutputStream        FileReader       FileWriter(实现类，可以使用的)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    小结：</span></span><br><span class="line"><span class="comment">        一个一个字节读取中文数据输出其实是被淘汰的，性能极差！</span></span><br><span class="line"><span class="comment">         一个一个字节读取中文数据输出，会出现截断中文字节的情况，无法避免读取中文输出乱码的问题。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileInputStreamDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建一个文件字节输入流管道与源文件接通。</span></span><br><span class="line">        <span class="comment">// InputStream is = new FileInputStream(new File(&quot;file-io-app\\src\\data.txt&quot;));</span></span><br><span class="line">        <span class="comment">// 简化写法</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;file-io-app\\src\\data.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、读取一个字节返回 （每次读取一滴水）</span></span><br><span class="line"><span class="comment">//        int b1 = is.read();</span></span><br><span class="line"><span class="comment">//        System.out.println((char)b1);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        int b2 = is.read();</span></span><br><span class="line"><span class="comment">//        System.out.println((char)b2);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        int b3 = is.read();</span></span><br><span class="line"><span class="comment">//        System.out.println((char)b3);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        int b4 = is.read(); // 读取完毕返回-1</span></span><br><span class="line"><span class="comment">//        System.out.println(b4);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、使用循环改进</span></span><br><span class="line">        <span class="comment">// 定义一个变量记录每次读取的字节    a  b  3    爱</span></span><br><span class="line">        <span class="comment">//                              o  o  o   [ooo]</span></span><br><span class="line">        <span class="type">int</span> b;</span><br><span class="line">        <span class="keyword">while</span> (( b = is.read() ) != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print((<span class="type">char</span>) b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="6-1-2每次读取一个字节数组"><a href="#6-1-2每次读取一个字节数组" class="headerlink" title="6.1.2每次读取一个字节数组"></a>6.1.2每次读取一个字节数组</h5><ul><li>作用：以内存为基准，把磁盘文件中的数据以字节的形式读取到内存中去。</li></ul><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>public int read(byte[] buffer)</td><td>每次读取一个字节数组返回，如果字节已经没有可读的返回-1</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   目标：使用文件字节输入流每次读取一个字节数组的数据。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileInputStreamDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建一个文件字节输入流管道与源文件接通</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;file-io-app/src/data02.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、定义一个字节数组，用于读取字节数组</span></span><br><span class="line"><span class="comment">//        byte[] buffer = new byte[3]; // 3B</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//        int len = is.read(buffer); // 3</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;读取了几个字节：&quot; + len); / 3</span></span><br><span class="line"><span class="comment">//        String rs = new String(buffer);</span></span><br><span class="line"><span class="comment">//        System.out.println(rs);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        int len1 = is.read(buffer);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;读取了几个字节：&quot; + len1);</span></span><br><span class="line"><span class="comment">//        String rs1 = new String(buffer);</span></span><br><span class="line"><span class="comment">//        System.out.println(rs1);</span></span><br><span class="line"><span class="comment">//        // buffer = [a b c]</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        // buffer = [a b c]  ==&gt;  [c d c]</span></span><br><span class="line"><span class="comment">//        int len2 = is.read(buffer);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;读取了几个字节：&quot; + len2);</span></span><br><span class="line"><span class="comment">//        // 读取多少倒出多少</span></span><br><span class="line"><span class="comment">//        String rs2 = new String(buffer,0 ,len2);</span></span><br><span class="line"><span class="comment">//        System.out.println(rs2);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        int len3 = is.read(buffer);</span></span><br><span class="line"><span class="comment">//        System.out.println(len3); // 读取完毕返回-1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、改进使用循环，每次读取一个字节数组</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="type">int</span> len; <span class="comment">// 记录每次读取的字节数。</span></span><br><span class="line">        <span class="keyword">while</span> ((len = is.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 读取多少倒出多少</span></span><br><span class="line">            System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(buffer, <span class="number">0</span> , len));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="6-1-3一次读完全部字节"><a href="#6-1-3一次读完全部字节" class="headerlink" title="6.1.3一次读完全部字节"></a>6.1.3一次读完全部字节</h5><p>1、如何使用字节输入流读取中文内容输出不乱码呢？</p><ul><li><strong>定义一个与文件一样大的字节数组，一次性读取完文件的全部字节。</strong></li></ul><p>2、直接把文件数据全部读取到一个字节数组可以避免乱码，是否存在问题？</p><ul><li><strong>如果文件过大，字节数组可能引起内存溢出。</strong></li></ul><p><strong>方式一</strong></p><ul><li>自己定义一个字节数组与文件的大小一样大，然后使用读取字节数组的方法，一次性读取完成。</li></ul><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>public int  read(byte[] buffer)</td><td>每次读取一个字节数组返回，如果字节已经没有可读的返回-1</td></tr></tbody></table><p><strong>方式二</strong></p><ul><li>官方为字节输入流InputStream提供了如下<strong>API</strong>可以直接把文件的全部数据读取到一个字节数组中</li></ul><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>public byte[] readAllBytes() throws IOException</td><td>直接将当前字节输入流对应的文件对象的字节数据装到一个字节数组返回</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   目标：使用文件字节输入流一次读完文件的全部字节。可以解决乱码问题。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileInputStreamDemo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建一个文件字节输入流管道与源文件接通</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;file-io-app/src/data03.txt&quot;</span>);</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(f);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方法一:定义一个字节数组与文件的大小刚刚一样大。</span></span><br><span class="line">        <span class="comment">// f.length()为long 型，需要强转</span></span><br><span class="line"><span class="comment">//        byte[] buffer = new byte[(int) f.length()]; </span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//        int len = is.read(buffer); //(int) f.length()</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;读取了多少个字节：&quot; + len); </span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;文件大小：&quot; + f.length());</span></span><br><span class="line"><span class="comment">//        System.out.println(new String(buffer));</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方法二:官方APIreadAllBytes，读取全部字节数组</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = is.readAllBytes();</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(buffer));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-2文件字节输出流：FileOutputStream"><a href="#6-2文件字节输出流：FileOutputStream" class="headerlink" title="6.2文件字节输出流：FileOutputStream"></a>6.2文件字节输出流：FileOutputStream</h4><p><strong>写字节数据到文件</strong></p><ul><li>作用：以内存为基准，把内存中的数据以字节的形式写出到磁盘文件中去的流。</li></ul><p><strong>构造器</strong></p><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public <strong>FileOutputStream</strong>(File file , boolean append)</td><td>创建一个追加数据的字节输出流管道通向目标文件对象。</td></tr><tr><td>public <strong>FileOutputStream</strong>(String filepath，boolean append)</td><td>创建字节输出流管道与源文件路径接通，可追加数据</td></tr></tbody></table><p><strong>FileOutputStream写数据出去的API</strong></p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>public void write(int a)</td><td>写一个字节出去</td></tr><tr><td>public void write(byte[] buffer)</td><td>写一个字节数组出去</td></tr><tr><td>public void write(byte[] buffer , int pos , int len)</td><td>写一个字节数组的一部分出去。</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：字节输出流的使用。</span></span><br><span class="line"><span class="comment">         把内存数据按照字节写出到磁盘文件中去。</span></span><br><span class="line"><span class="comment">         </span></span><br><span class="line"><span class="comment">-- 构造器：</span></span><br><span class="line"><span class="comment">         public FileOutputStream(File file):创建一个字节输出流管道通向目标文件对象。</span></span><br><span class="line"><span class="comment">         public FileOutputStream(String file):创建一个字节输出流管道通向目标文件路径。</span></span><br><span class="line"><span class="comment">         public FileOutputStream(File file , boolean append):创建一个追加数据的字节输出流管道通向目标文件对象。</span></span><br><span class="line"><span class="comment">         public FileOutputStream(String file , boolean append):创建一个追加数据的字节输出流管道通向目标文件路径。</span></span><br><span class="line"><span class="comment">         </span></span><br><span class="line"><span class="comment">-- 方法：</span></span><br><span class="line"><span class="comment">         public void write(int a):写一个字节出去 。</span></span><br><span class="line"><span class="comment">         public void write(byte[] buffer):写一个字节数组出去。</span></span><br><span class="line"><span class="comment">         public void write(byte[] buffer , int pos , int len):写一个字节数组的一部分出去。</span></span><br><span class="line"><span class="comment">         参数一，字节数组；参数二：起始字节索引位置，参数三：写多少个字节数出去。</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">         换行：  os.write(&quot;\r\n&quot;.getBytes()); // 换行</span></span><br><span class="line"><span class="comment">   追加数据管道： OutputStream os = new FileOutputStream(&quot;day10_demo/out01.txt&quot; , true); // 追加管道！！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OutputStreamDemo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="comment">// 1、创建一个文件字节输出流管道与目标文件接通</span></span><br><span class="line">        <span class="comment">// 追加数据管道</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;file-io-app/src/out04.txt&quot;</span> , <span class="literal">true</span>); </span><br><span class="line">        <span class="comment">// 先清空之前的数据，写新数据进入</span></span><br><span class="line">        <span class="comment">//OutputStream os = new FileOutputStream(&quot;file-io-app/src/out04.txt&quot;); </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、写数据出去</span></span><br><span class="line">        <span class="comment">// a.public void write(int a):写一个字节出去</span></span><br><span class="line">        os.write(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        os.write(<span class="number">98</span>);</span><br><span class="line">        os.write(<span class="string">&quot;\r\n&quot;</span>.getBytes()); <span class="comment">// 换行</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// b.public void write(byte[] buffer):写一个字节数组出去。</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = &#123;<span class="string">&#x27;a&#x27;</span> , <span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>&#125;;</span><br><span class="line">        os.write(buffer);</span><br><span class="line">        os.write(<span class="string">&quot;\r\n&quot;</span>.getBytes()); <span class="comment">// 换行</span></span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] buffer2 = <span class="string">&quot;我是中国人&quot;</span>.getBytes();</span><br><span class="line">        <span class="comment">//byte[] buffer2 = &quot;我是中国人&quot;.getBytes(&quot;GBK&quot;);</span></span><br><span class="line">        os.write(buffer2);</span><br><span class="line">        os.write(<span class="string">&quot;\r\n&quot;</span>.getBytes()); <span class="comment">// 换行</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// c. public void write(byte[] buffer , int pos , int len):写一个字节数组的一部分出去。</span></span><br><span class="line">        <span class="type">byte</span>[] buffer3 = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>&#125;;</span><br><span class="line">        os.write(buffer3, <span class="number">0</span> , <span class="number">3</span>); <span class="comment">//从索引0开始 ，三个字节</span></span><br><span class="line">        os.write(<span class="string">&quot;\r\n&quot;</span>.getBytes()); <span class="comment">// 换行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>流的关闭与刷新</strong> </p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><strong>flush</strong>()</td><td>刷新流，还可以继续写数据</td></tr><tr><td><strong>close</strong>()</td><td>关闭流，释放资源，但是在关闭之前会先刷新流。一旦关闭，就不能再写数据</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写数据必须，刷新数据 可以继续使用流</span></span><br><span class="line">os.flush();</span><br><span class="line"><span class="comment">// 释放资源，包含了刷新的！关闭后流不可以使用了</span></span><br><span class="line">os.close(); </span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>字节输出流如何实现写出去的数据能换行?</p><ul><li><strong>os.write(“\r\n”.getBytes());</strong></li></ul><p>如何让写出去的数据能成功生效？</p><ul><li><p><strong>flush()刷新数据</strong></p></li><li><p><strong>close()方法是关闭流，关闭包含刷新，关闭后流不可以继续使用了。</strong></p></li></ul><h4 id="6-3文件拷贝"><a href="#6-3文件拷贝" class="headerlink" title="6.3文件拷贝"></a>6.3文件拷贝</h4><p><strong>文件拷贝</strong></p><p><strong>需求：</strong></p><p>把某个视频复制到其他目录下的“b.avi”</p><p><strong>思路</strong>：</p><p>①根据数据源创建字节输入流对象</p><p>②根据目的地创建字节输出流对象</p><p>③读写数据，复制视频</p><p>④释放资源</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *   目标：学会使用字节流完成文件的复制（支持一切文件类型的复制）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopyDemo05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1、创建一个字节输入流管道与原视频接通</span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;file-io-app/src/out04.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2、创建一个字节输出流管道与目标文件接通</span></span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;file-io-app/src/out05.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3、定义一个字节数组转移数据</span></span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> len; <span class="comment">// 记录每次读取的字节数。</span></span><br><span class="line">            <span class="keyword">while</span> ((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                os.write(buffer, <span class="number">0</span> , len);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            System.out.println(<span class="string">&quot;复制完成了！&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4、关闭流。</span></span><br><span class="line">            os.close();</span><br><span class="line">            is.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-资源释放的方式"><a href="#7-资源释放的方式" class="headerlink" title="7.资源释放的方式"></a>7.资源释放的方式</h3><h4 id="7-1try-catch-finally"><a href="#7-1try-catch-finally" class="headerlink" title="7.1try-catch-finally"></a>7.1try-catch-finally</h4><p><strong>try-catch-finally</strong></p><ul><li><p>finally：在异常处理时提供finally块来执行所有清除操作，比如说IO流中的释放资源</p></li><li><p><strong>特点：被finally控制的语句最终一定会执行，除非JVM退出</strong></p></li><li><p>异常处理标准格式：<strong>try….catch…finally</strong></p></li></ul><p><strong>try-catch-finally格式</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//手动释放资源</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">可能出现异常的代码;</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类名 变量名)&#123;</span><br><span class="line">异常的处理代码;</span><br><span class="line"> &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">执行所有资源释放操作;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//代码繁琐</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *   目标：学会使用finally释放资源。</span></span><br><span class="line"><span class="comment">   try….catch…finally</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TryCatchFinallyDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// System.out.println(10/ 0);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1、创建一个字节输入流管道与原视频接通</span></span><br><span class="line">             is = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;file-io-app/src/out04.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2、创建一个字节输出流管道与目标文件接通</span></span><br><span class="line">             os = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;file-io-app/src/out05.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3、定义一个字节数组转移数据</span></span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> len; <span class="comment">// 记录每次读取的字节数。</span></span><br><span class="line">            <span class="keyword">while</span> ((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                os.write(buffer, <span class="number">0</span> , len);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;复制完成了！&quot;</span>);</span><br><span class="line"></span><br><span class="line">         <span class="comment">//   System.out.println( 10 / 0);</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 无论代码是正常结束，还是出现异常都要最后执行这里</span></span><br><span class="line">            System.out.println(<span class="string">&quot;========finally=========&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 4、关闭流。</span></span><br><span class="line">                <span class="keyword">if</span>(os!=<span class="literal">null</span>)os.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(is != <span class="literal">null</span>) is.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(test(<span class="number">10</span>, <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a , <span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a / b;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">111111</span>; <span class="comment">// 计算出现bug.</span></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;--finally--&quot;</span>);</span><br><span class="line">            <span class="comment">// 哪怕上面有return语句执行，也必须先执行完这里才可以！</span></span><br><span class="line">            <span class="comment">// 开发中不建议在这里加return ，如果加了，返回的永远是这里的数据了，这样会出问题！</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-2try-with-resource-改进方案"><a href="#7-2try-with-resource-改进方案" class="headerlink" title="7.2try-with-resource(改进方案)"></a>7.2try-with-resource(改进方案)</h4><p><strong>JDK7 和 JDK9 中都简化了资源释放操作</strong></p><p><strong>JDK7改进方案(较常用)：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//资源用完最终自动释放</span></span><br><span class="line"><span class="keyword">try</span>(定义流对象)&#123;</span><br><span class="line">可能出现异常的代码;</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类名 变量名)&#123;</span><br><span class="line">异常的处理代码;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *   目标：学会使用JDK 7的新方式释放资源 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TryCatchResouceDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">// 这里面只能放置资源对象，用完会自动关闭：自动调用资源对象的close方法关闭资源（即使出现异常也会做关闭操作）</span></span><br><span class="line">                <span class="comment">// 1、创建一个字节输入流管道与原视频接通</span></span><br><span class="line">               <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;file-io-app/src/out04.txt&quot;</span>);</span><br><span class="line">                <span class="comment">// 2、创建一个字节输出流管道与目标文件接通</span></span><br><span class="line">               <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;file-io-app/src/out05.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">               <span class="comment">// int age = 23; // 这里只能放资源</span></span><br><span class="line">                <span class="type">MyConnection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyConnection</span>(); <span class="comment">// 最终会自动调用资源的close方法</span></span><br><span class="line">                ) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3、定义一个字节数组转移数据</span></span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> len; <span class="comment">// 记录每次读取的字节数。</span></span><br><span class="line">            <span class="keyword">while</span> ((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                os.write(buffer, <span class="number">0</span> , len);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;复制完成了！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyConnection</span> <span class="keyword">implements</span> <span class="title class_">AutoCloseable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;连接资源被成功释放了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>JDK9改进方案：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//资源用完最终自动释放</span></span><br><span class="line">定义输入流对象;</span><br><span class="line">定义输出流对象;</span><br><span class="line"><span class="keyword">try</span>(输入流对象；输出流对象)&#123;</span><br><span class="line">可能出现异常的代码;</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类名 变量名)&#123;</span><br><span class="line">异常的处理代码;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *   目标：JDK 9释放资源的方式：可以了解下。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TryCatchResouceDemo3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123; <span class="comment">//这里必须抛出错误</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里面只能放置资源对象，用完会自动关闭：自动调用资源对象的close方法关闭资源（即使出现异常也会做关闭操作）</span></span><br><span class="line">        <span class="comment">// 1、创建一个字节输入流管道与原视频接通</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;file-io-app/src/out04.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 2、创建一个字节输出流管道与目标文件接通</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;file-io-app/src/out05.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> ( is ; os ) &#123;</span><br><span class="line">            <span class="comment">// 3、定义一个字节数组转移数据</span></span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> len; <span class="comment">// 记录每次读取的字节数。</span></span><br><span class="line">            <span class="keyword">while</span> ((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                os.write(buffer, <span class="number">0</span> , len);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;复制完成了！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><ul><li><p>JDK 7 以及 JDK 9的()中只能放置资源对象，否则报错</p></li><li><p>什么是资源呢？</p><p>资源都是实现了Closeable&#x2F;AutoCloseable接口的类对象</p></li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">InputStream</span> <span class="keyword">implements</span> <span class="title class_">Closeable</span> &#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">OutputStream</span> <span class="keyword">implements</span> <span class="title class_">Closeable</span>, Flushable&#123;&#125; </span><br></pre></td></tr></table></figure><p><strong>案例：</strong></p><p><strong>拷贝文件夹</strong></p><p>需求：</p><p>将某个磁盘的文件夹拷贝到另一个文件夹下去，包括文件夹中的全部信息</p><p>分析：</p><p>①：IO默认不可以拷贝文件夹</p><p>②：我们需要遍历文件夹，如果是文件则拷贝过去，如果是文件夹则要进行1-1创建，继续复制内容。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   目标：拷贝文件夹</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">         <span class="comment">// D:\resources</span></span><br><span class="line">        copy(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\resources&quot;</span>) , <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\new&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copy</span><span class="params">(File src , File dest)</span>&#123;</span><br><span class="line">        <span class="comment">// 1、判断源目录是否存在</span></span><br><span class="line">        <span class="keyword">if</span>(src!= <span class="literal">null</span> &amp;&amp; src.exists() &amp;&amp; src.isDirectory())&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 2、目标目录需要创建一下  D:\new\resources</span></span><br><span class="line">            <span class="type">File</span> <span class="variable">destOne</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(dest , src.getName());</span><br><span class="line">            destOne.mkdirs(); <span class="comment">//创建多级</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3、提取原目录下的全部一级文件对象</span></span><br><span class="line">            File[] files = src.listFiles();</span><br><span class="line">            <span class="comment">// 4、判断是否存在一级文件对象</span></span><br><span class="line">            <span class="keyword">if</span>(files != <span class="literal">null</span> &amp;&amp; files.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 5、遍历一级文件对象</span></span><br><span class="line">                <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">                    <span class="comment">// 6、判断是文件还是文件夹，是文件直接复制过去</span></span><br><span class="line">                    <span class="keyword">if</span>(file.isFile())&#123;</span><br><span class="line">                        copyFile(file, <span class="keyword">new</span> <span class="title class_">File</span>(destOne , file.getName()));</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 7、当前遍历的是文件夹，递归复制</span></span><br><span class="line">                        copy(file, destOne);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copyFile</span><span class="params">(File srcFile, File destFile)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">// 1、创建一个字节输入流管道与原视频接通</span></span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcFile);</span><br><span class="line">                <span class="comment">// 2、创建一个字节输出流管道与目标文件接通</span></span><br><span class="line">                <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destFile);</span><br><span class="line">                ) &#123;</span><br><span class="line">            <span class="comment">// 3、定义一个字节数组转移数据</span></span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> len; <span class="comment">// 记录每次读取的字节数。</span></span><br><span class="line">            <span class="keyword">while</span> ((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                os.write(buffer, <span class="number">0</span> , len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-字符流的使用"><a href="#8-字符流的使用" class="headerlink" title="8.字符流的使用"></a>8.字符流的使用</h3><h4 id="8-1文件字符输入流"><a href="#8-1文件字符输入流" class="headerlink" title="8.1文件字符输入流"></a>8.1文件字符输入流</h4><p>1.字节流读取中文输出会存在什么问题？</p><ul><li><strong>会乱码。或者内存溢出。</strong></li></ul><p>2.读取中文输出，哪个流更合适，为什么？</p><ul><li><p><strong>字符流更合适，最小单位是按照单个字符读取的。</strong></p><p><strong>构造器  Reader</strong></p></li><li><p>作用：以内存为基准，把磁盘文件中的数据以字符的形式读取到内存中去。</p></li></ul><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public <strong>FileReader</strong>(File file)</td><td>创建字符输入流管道与源文件对象接通</td></tr><tr><td>public <strong>FileReader</strong>(String  pathname)</td><td>创建字符输入流管道与源文件路径接通</td></tr></tbody></table><h5 id="8-1-1一次读取一个字符"><a href="#8-1-1一次读取一个字符" class="headerlink" title="8.1.1一次读取一个字符"></a>8.1.1一次读取一个字符</h5><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>public int read()</td><td>每次读取一个字符返回，如果字符已经没有可读的返回-1</td></tr></tbody></table><p>1.字符流的好处。每次读取一个字符存在什么问题？</p><ul><li><p><strong>读取中文字符不会出现乱码（如果代码文件编码一致）</strong></p></li><li><p><strong>性能较慢</strong></p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     目标：字符输入流的使用。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  读取文本文件内容到内存中去。</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">小结：</span></span><br><span class="line"><span class="comment">    字符流一个一个字符的读取文本内容输出，可以解决中文读取输出乱码的问题。</span></span><br><span class="line"><span class="comment">    字符流很适合操作文本文件内容。</span></span><br><span class="line"><span class="comment">    但是：一个一个字符的读取文本内容性能较差！！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileReaderDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 目标：每次读取一个字符。</span></span><br><span class="line">        <span class="comment">// 1、创建一个字符输入流管道与源文件接通</span></span><br><span class="line">        <span class="type">Reader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;file-io-app\\src\\data06.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、读取一个字符返回，没有可读的字符了返回-1</span></span><br><span class="line"><span class="comment">//        int code = fr.read();</span></span><br><span class="line"><span class="comment">//        System.out.print((char)code);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        int code1 = fr.read();</span></span><br><span class="line"><span class="comment">//        System.out.print((char)code1);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、使用循环读取字符</span></span><br><span class="line">        <span class="type">int</span> code;</span><br><span class="line">        <span class="keyword">while</span> ((code = fr.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print((<span class="type">char</span>) code);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="8-1-2文件字符输入流-一次读取一个字符数组"><a href="#8-1-2文件字符输入流-一次读取一个字符数组" class="headerlink" title="8.1.2文件字符输入流-一次读取一个字符数组"></a>8.1.2文件字符输入流-一次读取一个字符数组</h5><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>public int  read(char[] buffer)</td><td>每次读取一个字符数组，返回读取的字符数，如果字符已经没有可读的返回-1</td></tr></tbody></table><p>1.每次读取一个字符数组的优势？</p><ul><li><p><strong>读取的性能得到了提升</strong></p></li><li><p><strong>读取中文字符输出不会乱码。</strong></p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     目标：字符输入流的使用-按照字符数组读取。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  读取文本文件内容到内存中去。</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">     小结：</span></span><br><span class="line"><span class="comment">         字符流按照字符数组循环读取数据，可以解决中文读取输出乱码的问题，而且性能也较好！！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileReaderDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建一个文件字符输入流与源文件接通</span></span><br><span class="line">        <span class="type">Reader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;file-io-app/src/data07.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、用循环，每次读取一个字符数组的数据。  1024 + 1024 + 8</span></span><br><span class="line">        <span class="type">char</span>[] buffer = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>]; <span class="comment">// 1K字符</span></span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = fr.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer, <span class="number">0</span>, len);</span><br><span class="line">            System.out.print(rs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-2文件字符输出流"><a href="#8-2文件字符输出流" class="headerlink" title="8.2文件字符输出流"></a>8.2文件字符输出流</h4><p><strong>构造器 FileWriter</strong></p><ul><li>作用：以内存为基准，把内存中的数据以字符的形式写出到磁盘文件中去的流。</li></ul><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public FileWriter(File file)</td><td>创建字符输出流管道与源文件对象接通</td></tr><tr><td>public FileWriter(File file，boolean append)</td><td>创建字符输出流管道与源文件对象接通，可追加数据</td></tr><tr><td>public FileWriter(String filepath)</td><td>创建字符输出流管道与源文件路径接通</td></tr><tr><td>public FileWriter(String filepath，boolean append)</td><td>创建字符输出流管道与源文件路径接通，可追加数据</td></tr></tbody></table><p><strong>（FileWriter）写数据出去的API</strong></p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>void  write(int c)</td><td>写一个字符</td></tr><tr><td>void  write(char[] cbuf)</td><td>写入一个字符数组</td></tr><tr><td>void  write(char[] cbuf, int off, int len)</td><td>写入字符数组的一部分</td></tr><tr><td>void  write(String str)</td><td>写一个字符串</td></tr><tr><td>void  write(String str, int off, int len)</td><td>写一个字符串的一部分</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     目标：字符输出流的使用。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment"> 作用：以内存为基准，把内存中的数据按照字符的形式写出到磁盘文件中去。</span></span><br><span class="line"><span class="comment">            </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     小结：</span></span><br><span class="line"><span class="comment">        字符输出流可以写字符数据出去，总共有5个方法写字符。</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">  覆盖管道：</span></span><br><span class="line"><span class="comment">             Writer fw = new FileWriter(&quot;Day10Demo/src/dlei03.txt&quot;); // 覆盖数据管道</span></span><br><span class="line"><span class="comment">        追加数据管道：</span></span><br><span class="line"><span class="comment">             Writer fw = new FileWriter(&quot;Day10Demo/src/dlei03.txt&quot;,true); // 追加数据管道</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">     换行：fw.write(&quot;\r\n&quot;); // 换行</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">     结论：读写字符文件数据建议使用字符流。复制文件建议使用字节流。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileWriterDemo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建一个字符输出流管道与目标文件接通</span></span><br><span class="line">        <span class="comment">// Writer fw = new FileWriter(&quot;file-io-app/src/out08.txt&quot;); // 覆盖管道，每次启动都会清空文件之前的数据</span></span><br><span class="line">        <span class="type">Writer</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;file-io-app/src/out08.txt&quot;</span>, <span class="literal">true</span>); <span class="comment">// 覆盖管道，每次启动都会清空文件之前的数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//      a.public void write(int c):写一个字符出去</span></span><br><span class="line">        fw.write(<span class="number">98</span>);</span><br><span class="line">        fw.write(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        fw.write(<span class="string">&#x27;徐&#x27;</span>); <span class="comment">// 不会出问题了</span></span><br><span class="line">        fw.write(<span class="string">&quot;\r\n&quot;</span>); <span class="comment">// 换行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//       b.public void write(String c)写一个字符串出去</span></span><br><span class="line">        fw.write(<span class="string">&quot;abc我是中国人&quot;</span>);</span><br><span class="line">        fw.write(<span class="string">&quot;\r\n&quot;</span>); <span class="comment">// 换行</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//       c.public void write(char[] buffer):写一个字符数组出去</span></span><br><span class="line">        <span class="type">char</span>[] chars = <span class="string">&quot;abc我是中国人&quot;</span>.toCharArray();</span><br><span class="line">        fw.write(chars);</span><br><span class="line">        fw.write(<span class="string">&quot;\r\n&quot;</span>); <span class="comment">// 换行</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//       d.public void write(String c ,int pos ,int len):写字符串的一部分出去</span></span><br><span class="line">        fw.write(<span class="string">&quot;abc我是中国人&quot;</span>, <span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">        fw.write(<span class="string">&quot;\r\n&quot;</span>); <span class="comment">// 换行</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//       e.public void write(char[] buffer ,int pos ,int len):写字符数组的一部分出去</span></span><br><span class="line">        fw.write(chars, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">        fw.write(<span class="string">&quot;\r\n&quot;</span>); <span class="comment">// 换行</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// fw.flush();// 刷新后流可以继续使用</span></span><br><span class="line">        fw.close(); <span class="comment">// 关闭包含刷线，关闭后流不能使用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>流的关闭与刷新 (同字节流)</strong></p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>flush()</td><td>刷新流，还可以继续写数据</td></tr><tr><td>close()</td><td>关闭流，释放资源，但是在关闭之前会先刷新流。一旦关闭，就不能再写数据</td></tr></tbody></table><p><strong>注意：</strong></p><p>1.字符输出流如何实现写出去的数据能换行</p><ul><li><strong>fw.write(“\r\n”)</strong></li></ul><p>2.字符输出流如何实现写出去的数据能换行</p><ul><li><p>flush()刷新数据</p></li><li><p>close()方法是关闭流，关闭包含刷新，关闭后流不可以继续使用了。</p></li></ul><p><strong>字节流、字符流如何选择使用？</strong></p><ul><li><p><strong>字节流适合做一切文件数据的拷贝（音视频，文本）</strong></p></li><li><p><strong>字节流不适合读取中文内容输出</strong></p></li><li><p><strong>你字符流适合做文本文件的操作（读，写）</strong></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> java,面向对象进阶,File,递归,IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>day17 - 日志框架、阶段项目</title>
      <link href="/post/ca240fc7.html"/>
      <url>/post/ca240fc7.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-日志框架"><a href="#1-日志框架" class="headerlink" title="1.日志框架"></a>1.日志框架</h3><h4 id="1-1日志技术的概述"><a href="#1-1日志技术的概述" class="headerlink" title="1.1日志技术的概述"></a>1.1日志技术的概述</h4><p><strong>想清楚的知道一个系统运行的过程和详情怎么办？</strong></p><p><strong>日志</strong></p><ul><li><p>生活中的日志： 生活中的日志就好比日记，可以记录你生活的点点滴滴。</p></li><li><p>程序中的日志： 程序中的日志可以用来记录程序运行过程中的信息，并可以进行永久存储。</p></li></ul><p><strong>以前记录日志的方式</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">System.out.println(<span class="string">&quot;请输入一个整数&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">number</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Integer.parseInt(number);</span><br><span class="line">System.out.println(<span class="string">&quot;输入的数字为&quot;</span> + result);</span><br><span class="line">&#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;输入的数字有误，请输入一个整数&quot;</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>输出语句的弊端</strong></p><ul><li><p>信息只能展示在控制台</p></li><li><p>不能将其记录到其他的位置（文件，数据库）</p></li><li><p>想取消记录的信息需要修改代码才可以完成</p></li></ul><p><strong>日志技术具备的优势</strong></p><ul><li><p>可以将系统执行的信息选择性的记录到指定的位置（控制台、文件中、数据库中）。</p></li><li><p>可以随时以<strong>开关的形式控制</strong>是否记录日志，无需修改源代码。</p></li></ul><table><thead><tr><th></th><th><strong>输出语句</strong></th><th><strong>日志技术</strong></th></tr></thead><tbody><tr><td>输出位置</td><td>只能是控制台</td><td>可以将日志信息写入到文件或者数据库中</td></tr><tr><td>取消日志</td><td>需要修改代码，灵活性比较差</td><td>不需要修改代码，灵活性比较好</td></tr><tr><td>多线程</td><td>性能较差</td><td>性能较好</td></tr></tbody></table><h4 id="1-2日志技术体系结构"><a href="#1-2日志技术体系结构" class="headerlink" title="1.2日志技术体系结构"></a>1.2日志技术体系结构</h4><p><strong>体系结构</strong></p><ol><li><strong>日志源（Log Sources）</strong>： 这是生成日志信息的实体，可以是应用程序、服务器、网络设备等。日志源负责生成各种事件和状态信息，以便后续记录和分析。</li><li><strong>日志记录器（Loggers）</strong>： 日志记录器是负责将日志消息从日志源发送到日志系统的组件。它们通常具有各种日志级别，如调试、信息、警告和错误，可以根据事件的重要性选择适当的级别进行记录。</li><li><strong>日志处理器（Log Processors）</strong>： 日志处理器负责接收、过滤、格式化和处理日志消息。它们可以将日志消息存储到文件、数据库或发送到监控系统。处理器还可以执行预处理操作，如数据转换、脱敏等。</li><li><strong>日志存储（Log Storage）</strong>： 这是用于保存日志消息的地方，可以是本地文件系统、云存储、数据库等。存储通常需要支持高效的读写操作，以及对日志数据的搜索和检索功能。</li><li><strong>日志检索和查询（Log Retrieval and Querying）</strong>： 这些组件允许用户从日志存储中检索和查询特定的日志消息。它们提供了搜索、过滤和排序等功能，以帮助用户找到所需的信息。</li><li><strong>实时监控和报警（Real-time Monitoring and Alerting）</strong>： 日志技术体系结构通常还包括监控和报警功能，以便在发生重要事件或异常时能够实时通知相关人员。这可以通过设置警报规则和触发条件来实现。</li><li><strong>可视化和分析工具（Visualization and Analysis Tools）</strong>： 可视化工具可以将日志数据以图表、图形和仪表板的形式展示出来，帮助用户更好地理解系统的状态和性能。分析工具则可以对日志数据进行深入分析，识别趋势、异常模式和潜在问题。</li><li><strong>日志轮换和管理（Log Rotation and Management）</strong>： 长时间保存所有日志数据可能会占用大量存储空间，因此日志系统通常会实施日志轮换策略，以便定期删除或归档旧的日志数据。</li></ol><ul><li><p><strong>日志规范：</strong>一些接口，提供给日志的实现框架设计的标准。</p><p>​常见的规范是：</p><p>​Commons Logging</p><p>​Simple Logging Facade for Java</p></li><li><p><strong>日志框架：</strong>牛人或者第三方公司已经做好的日志记录实现代码，后来者直接可以拿去使用。</p><p>​日志常见的实现框架</p><p>​                     Log4J</p><p>​                     Logback(我们重点学习的，其他的都大同小异)</p></li><li><p>因为对Commons Logging的接口不满意，有人就搞了SLF4J。因为对Log4j的性能不满意，有人就搞了Logback。</p></li></ul><h4 id="1-3Logback概述"><a href="#1-3Logback概述" class="headerlink" title="1.3Logback概述"></a>1.3Logback概述</h4><p><strong>Logback日志框架</strong></p><ul><li><p>Logback是由log4j创始人设计的另一个开源日志组件，性能比log4j要好</p></li><li><p>官方网站：<a href="https://logback.qos.ch/index.htmlLogback">https://logback.qos.ch/index.htmlLogback</a></p></li><li><p>Logback是基于slf4j的日志规范实现的框架。</p></li></ul><p><strong>Logback主要分为三个技术模块：</strong></p><ul><li><p>logback-core： logback-core 模块为其他两个模块奠定了基础，必须有。</p></li><li><p>logback-classic：它是log4j的一个改良版本，同时它完整实现了slf4j API。</p></li><li><p>logback-access 模块与 Tomcat 和 Jetty 等 Servlet 容器集成，以提供 HTTP 访问日志功能</p></li></ul><p><strong>使用Logback需要使用哪几个模块，各自的作用是什么。</strong></p><ul><li><p><strong>slf4j-api</strong>：日志规范</p></li><li><p><strong>logback-core</strong>：基础模块。</p></li><li><p><strong>logback-classic</strong>：它是log4j的一个改良版本，同时它完整实现了slf4j API</p></li></ul><h4 id="1-4Logback快速入门-文档"><a href="#1-4Logback快速入门-文档" class="headerlink" title="1.4Logback快速入门(文档)"></a>1.4Logback快速入门(文档)</h4><p> <a href="....%5CDesktop%5CJavaSE%5Cday18%E3%80%81%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E3%80%81%E9%98%B6%E6%AE%B5%E9%A1%B9%E7%9B%AE%5C%E8%B5%84%E6%96%99%5C%E7%B1%BB%E5%BA%93%5CLogback%E7%B1%BB%E5%BA%93%5Clogback-core-1.2.3.jar">logback-core-1.2.3.jar</a> </p><p> <a href="....%5CDesktop%5CJavaSE%5Cday18%E3%80%81%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E3%80%81%E9%98%B6%E6%AE%B5%E9%A1%B9%E7%9B%AE%5C%E8%B5%84%E6%96%99%5C%E7%B1%BB%E5%BA%93%5CLogback%E7%B1%BB%E5%BA%93%5Cslf4j-api-1.7.26.jar">slf4j-api-1.7.26.jar</a> </p><p> <a href="....%5CDesktop%5CJavaSE%5Cday18%E3%80%81%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E3%80%81%E9%98%B6%E6%AE%B5%E9%A1%B9%E7%9B%AE%5C%E8%B5%84%E6%96%99%5C%E7%B1%BB%E5%BA%93%5CLogback%E7%B1%BB%E5%BA%93%5Clogback-classic-1.2.3.jar">logback-classic-1.2.3.jar</a> </p><p> <a href="....%5CDesktop%5CJavaSE%5Cday18%E3%80%81%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E3%80%81%E9%98%B6%E6%AE%B5%E9%A1%B9%E7%9B%AE%5C%E8%B5%84%E6%96%99%5C%E7%B1%BB%E5%BA%93%5Clogback.xml">logback.xml</a> </p><p>需求：</p><p>导入Logback日志技术到项目中，用于纪录系统的日志信息</p><p>分析：</p><p>①：在项目下新建文件夹lib，导入Logback的相关jar包到该文件夹下，并添加到项目依赖库中去。</p><p>②：将Logback的核心配置文件logback.xml直接拷贝到src目录下（必须是src下）。</p><p>③：在代码中获取日志的对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="string">&quot;类对象&quot;</span>);</span><br></pre></td></tr></table></figure><p>④：使用日志对象LOGGER调用其方法输出日志信息</p><p> <strong>方法详解：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">一： 1.在模块下创建一个lib包</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2.将Logbake的三个Jar文件拷贝到lib下</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3.右键Add as Library将三个Jar文件加到依赖库中</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">二：将核心配置文件logBake.xml拷贝到src目录下</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">三：在代码中获取日志对象</span></span><br><span class="line"><span class="comment">    public static final Logger LOGGER = LoggerFactory.getLogger(&quot;Test.class&quot;);                      */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">//快速搭建logBack日志框架，记录程序的执行到控制台 到文件中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="comment">//创建logBack的日志对象，代表日志技术</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="string">&quot;Test.class&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            LOGGER.debug(<span class="string">&quot;main开始了&quot;</span>);</span><br><span class="line">            LOGGER.info(<span class="string">&quot;除法&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            LOGGER.trace(<span class="string">&quot;a=&quot;</span> + a);</span><br><span class="line">            LOGGER.trace(<span class="string">&quot;b=&quot;</span> + b);</span><br><span class="line"></span><br><span class="line">            System.out.println(a / b);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            LOGGER.error(<span class="string">&quot;功能出错&quot;</span>+ e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-5Logback配置详解-输出位置、格式设置"><a href="#1-5Logback配置详解-输出位置、格式设置" class="headerlink" title="1.5Logback配置详解-输出位置、格式设置"></a>1.5Logback配置详解-输出位置、格式设置</h4><p>Logback日志系统的特性都是通过核心配置文件logback.xml控制的。</p><p><strong>Logback日志输出位置、格式设置：</strong></p><ul><li><p>通过logback.xml 中的<append>标签可以设置输出位置和日志信息的详细格式。</p></li><li><p>通常可以设置2个日志输出位置：一个是控制台、一个是系统文件中</p></li></ul><p><strong>输出到控制台的配置标志</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;appender name=<span class="string">&quot;CONSOLE&quot;</span> class=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p><strong>输出到系统文件的配置标志</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;appender name=<span class="string">&quot;FILE&quot;</span> class=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p><strong>配置文件解读：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> &lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;configuration&gt; </span><br><span class="line"></span><br><span class="line"><span class="comment">//CONSOLE ：表示当前的日志信息是可以输出到控制台的。</span></span><br><span class="line">    &lt;appender name=<span class="string">&quot;CONSOLE&quot;</span> class=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;   </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//输出流对象 默认 System.out(黑色) 改为 System.err(红色)</span></span><br><span class="line">        &lt;target&gt;System.out&lt;/target&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;encoder&gt;</span><br><span class="line">        <span class="comment">/*格式化输出：</span></span><br><span class="line"><span class="comment">       %d:表示日期，</span></span><br><span class="line"><span class="comment">       %-5level:级别[DEBUG]、[INFO ]、[TRACE],从左显示5个字符宽度</span></span><br><span class="line"><span class="comment">       %c:取类 Test.class</span></span><br><span class="line"><span class="comment">       %thread:表示线程名(方法名),如[main]</span></span><br><span class="line"><span class="comment">            %msg:日志消息打印的内容</span></span><br><span class="line"><span class="comment">         %n:是换行符</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">            &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%-5level]  %c [%thread] : %msg%n&lt;/pattern&gt;</span><br><span class="line">        &lt;/encoder&gt;</span><br><span class="line">    &lt;/appender&gt;</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------------------------------------------------------ </span><br><span class="line">             </span><br><span class="line"><span class="comment">//File是输出的方向通向文件的 </span></span><br><span class="line">    &lt;appender name=<span class="string">&quot;FILE&quot;</span> class=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span><br><span class="line">        &lt;encoder&gt;</span><br><span class="line">            &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;<span class="number">36</span>&#125; - %msg%n&lt;/pattern&gt;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//utf-8的编码形式   </span></span><br><span class="line">        &lt;charset&gt;utf-<span class="number">8</span>&lt;/charset&gt;</span><br><span class="line">        &lt;/encoder&gt;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//日志输出路径</span></span><br><span class="line">        &lt;file&gt;C:/code/itheima-data.log&lt;/file&gt;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">//指定日志文件拆分和压缩规则</span></span><br><span class="line">        &lt;rollingPolicy</span><br><span class="line">                class=<span class="string">&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy&quot;</span>&gt;</span><br><span class="line">                    </span><br><span class="line">            <span class="comment">//通过指定压缩文件名称，来确定分割文件方式</span></span><br><span class="line">            &lt;fileNamePattern&gt;C:/code/itheima-data2-%d&#123;yyyy-MMdd&#125;.log%i.gz&lt;/fileNamePattern&gt; </span><br><span class="line">                </span><br><span class="line">            <span class="comment">//文件拆分大小</span></span><br><span class="line">            &lt;maxFileSize&gt;1MB&lt;/maxFileSize&gt;</span><br><span class="line">        &lt;/rollingPolicy&gt;</span><br><span class="line">    &lt;/appender&gt;</span><br></pre></td></tr></table></figure><h4 id="1-6Logback配置详解-日志级别设置"><a href="#1-6Logback配置详解-日志级别设置" class="headerlink" title="1.6Logback配置详解-日志级别设置"></a>1.6Logback配置详解-日志级别设置</h4><p>如果系统上线后只想记录一些错误的日志信息或者不想记录日志了，怎么办？</p><p><strong>可以通过设置日志的输出级别来控制哪些日志信息输出或者不输出。</strong></p><p><strong>日志级别</strong></p><ul><li><p>级别程度依次是：TRACE&lt; DEBUG&lt; INFO&lt;WARN&lt;ERROR ; 默认级别是debug（忽略大小写），对应其方法。</p></li><li><p>作用：用于控制系统中哪些日志级别是可以输出的，只输出级别不低于设定级别的日志信息。</p></li><li><p>ALL  和 OFF分别是打开全部日志信息，及关闭全部日志信息。</p></li></ul><p><strong>具体在<root level="INFO">标签的level属性中设置日志级别</strong>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;root level=“INFO<span class="string">&quot;&gt;</span></span><br><span class="line"><span class="string">&lt;appender-ref ref=&quot;</span>CONSOLE<span class="string">&quot;/&gt;</span></span><br><span class="line"><span class="string">&lt;appender-ref ref=&quot;</span>FILE<span class="string">&quot; /&gt;</span></span><br><span class="line"><span class="string">&lt;/root&gt;</span></span><br></pre></td></tr></table></figure><p><strong>配置文件解读：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">------------------------------------------------------------------------------------------------------------ </span><br><span class="line"><span class="comment">/*    level:用来设置打印级别，大小写无关：TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR(错误日志) ,</span></span><br><span class="line"><span class="comment">ALL 和 OFF分别是打开全部日志和关闭全部日志 , 默认debug</span></span><br><span class="line"><span class="comment">    只会打印此级别及以上级别的日志</span></span><br><span class="line"><span class="comment">      root:可以包含零个或多个&lt;appender-ref&gt;元素，标识这个输出位置将会被本日志级别控制。                              */</span></span><br><span class="line">    &lt;root level=<span class="string">&quot;ALL&quot;</span>&gt;</span><br><span class="line">        &lt;appender-ref ref=<span class="string">&quot;CONSOLE&quot;</span>/&gt;  <span class="comment">//控制台开关</span></span><br><span class="line">        &lt;appender-ref ref=<span class="string">&quot;FILE&quot;</span> /&gt;   <span class="comment">//文件开关</span></span><br><span class="line">    &lt;/root&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><h3 id="2-阶段项目实战"><a href="#2-阶段项目实战" class="headerlink" title="2.阶段项目实战"></a>2.阶段项目实战</h3><p>•电影购票系统简介、项目功能演示</p><p>•日志框架搭建、系统角色分析</p><p>•首页设计、登录、商家界面、用户界面实现</p><p>•商家-详情页设计、影片上架、退出</p><p>•商家-影片下架、影片修改</p><p>•用户-展示全部影片</p><p>•用户-购票功能</p><p>•用户-评分功能</p><p>•用户-评分降序展示(学生作业)</p><p>•用户-根据片名查询全部影片信息（学生作业）</p>]]></content>
      
      
      
        <tags>
            
            <tag> java,面向对象进阶,日志框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>day16 - 不可变集合、Stream、异常、日志框架</title>
      <link href="/post/342bf346.html"/>
      <url>/post/342bf346.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-创建不可变集合"><a href="#1-创建不可变集合" class="headerlink" title="1.创建不可变集合"></a>1.创建不可变集合</h3><p><strong>什么是不可变集合？</strong></p><ul><li><p>不可变集合，就是<strong>不可被修改的集合</strong>。</p></li><li><p>l定义完成后<strong>不可以修改，或者添加、删除</strong>。</p></li><li><p>集合的数据项在创建的时候提供，并且在整个生命周期中都不可改变。否则报错。</p></li></ul><p><strong>为什么要创建不可变集合？</strong></p><ul><li><p>如果某个数据不能被修改，把它防御性地拷贝到不可变集合中是个很好的实践。</p></li><li><p>或者当集合对象被不可信的库调用时，不可变形式是安全的。</p></li></ul><p><strong>如何创建不可变集合？</strong></p><ul><li>在List、Set、Map接口中，都存在of方法，可以创建一个不可变的集合。</li></ul><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>static  <E> List<E> of(E…elements)</td><td>创建一个具有指定元素的List集合对象</td></tr><tr><td>static  <E> Set<E> of(E…elements)</td><td>创建一个具有指定元素的Set集合对象</td></tr><tr><td>static &lt;K  , V&gt;  Map&lt;K，V&gt; of(E…elements)</td><td>创建一个具有指定元素的Map集合对象</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//List集合</span></span><br><span class="line">       List&lt;Double&gt; liets = List.of(<span class="number">150.2</span>,<span class="number">598.4</span>);</span><br><span class="line">       <span class="comment">//liets.add(585.3); //不可添加</span></span><br><span class="line">       System.out.println(liets);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//Set集合</span></span><br><span class="line">       Set&lt;String&gt; sets = Set.of(<span class="string">&quot;Java&quot;</span>,<span class="string">&quot;javaSE&quot;</span>);</span><br><span class="line">       <span class="comment">//sets.add(&quot;Java1&quot;); //不可添加</span></span><br><span class="line">       System.out.println(sets);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//Map集合</span></span><br><span class="line">       Map&lt;String,Integer&gt; maps = Map.of(<span class="string">&quot;Java&quot;</span>,<span class="number">100</span>);</span><br><span class="line">       <span class="comment">//maps.put(&quot;C语言&quot;,100); //不可添加</span></span><br><span class="line">       System.out.println(maps);</span><br></pre></td></tr></table></figure><h3 id="2-Stream流"><a href="#2-Stream流" class="headerlink" title="2.Stream流"></a>2.Stream流</h3><h4 id="2-1Stream流的概述"><a href="#2-1Stream流的概述" class="headerlink" title="2.1Stream流的概述"></a>2.1Stream流的概述</h4><p><strong>什么是Stream流？</strong></p><ul><li><p>在Java 8中，得益于Lambda所带来的函数式编程， 引入了一个全新的Stream流概念。</p></li><li><p><strong>目的：用于简化集合和数组操作的API。</strong></p></li></ul><p><strong>Stream流思想</strong></p><p><strong>Stream流式思想的核心：</strong></p><p>1.先得到集合或者数组的Stream流（就是一根传送带）</p><p>2.把元素放上去</p><p>3.然后就用这个Stream流简化的API来方便的操作元素。</p><p><strong>体验Stream流的作用</strong></p><p>需求：</p><p>按照下面的要求完成集合的创建和遍历</p><ul><li><p>创建一个集合，存储多个字符串元素</p></li><li><p>把集合中所有以”张”开头的元素存储到一个新的集合</p></li><li><p>把”张”开头的集合中的长度为3的元素存储到一个新的集合</p></li><li><p>遍历上一步得到的集合中的元素输出。</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建集合</span></span><br><span class="line">List&lt;String&gt; names = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(names,<span class="string">&quot;雷柏&quot;</span>,<span class="string">&quot;帕克&quot;</span>,<span class="string">&quot;凯萨文&quot;</span>,<span class="string">&quot;凯撒&quot;</span>,<span class="string">&quot;迪奥&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">//创建kailist集合，储存以&quot;凯&quot;开头的元素</span></span><br><span class="line"><span class="comment">//        List&lt;String&gt; kailist = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">//        for (String name : names)&#123;</span></span><br><span class="line"><span class="comment">//            if (name.startsWith(&quot;凯&quot;))&#123;</span></span><br><span class="line"><span class="comment">//                kailist.add(name);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        System.out.println(kailist);</span></span><br><span class="line">          <span class="comment">//创建kaithree集合，储存&quot;张&quot;开头的集合中的长度为3的元素</span></span><br><span class="line"><span class="comment">//        List&lt;String&gt; kaithree = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">//        for (String name : kailist) &#123;</span></span><br><span class="line"><span class="comment">//            if (name.length() == 3)&#123;</span></span><br><span class="line"><span class="comment">//                kaithree.add(name);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        System.out.println(kaithree);</span></span><br><span class="line"><span class="comment">//总结：操作繁琐</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用Stream流</span></span><br><span class="line">        names.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;凯&quot;</span>)).filter(s -&gt; s.length() == <span class="number">3</span>).forEach(s -&gt; System.out.println(s));  <span class="comment">//凯萨文</span></span><br><span class="line"><span class="comment">//总结：迅捷高效</span></span><br></pre></td></tr></table></figure><h4 id="2-2Stream流的获取"><a href="#2-2Stream流的获取" class="headerlink" title="2.2Stream流的获取"></a>2.2Stream流的获取</h4><p><strong>Stream流的三类方法</strong></p><ul><li><p><strong>获取Stream流</strong></p><ul><li>创建一条流水线，并把数据放到流水线上准备进行操作</li></ul></li><li><p><strong>中间方法</strong></p><ul><li>流水线上的操作。一次操作完毕之后，还可以继续进行其他操作。</li></ul></li><li><p><strong>终结方法</strong></p><ul><li>一个Stream流只能有一个终结方法，是流水线上的最后一个操作</li></ul></li></ul><p><strong>Stream操作集合或者数组的第一步是先得到Stream流，然后才能使用流的功能。</strong></p><p><strong>【集合】获取Stream流的方式</strong></p><ul><li>可以使用Collection接口中的默认方法stream()生成流</li></ul><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>default  Stream<E> stream()</td><td>获取当前集合对象的Stream流</td></tr></tbody></table><p> <strong>【数组】获取Stream流的方式</strong></p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>public  static <T>  Stream<T>  stream(T[]  array)  &#x2F;&#x2F;Arrays.stream()</td><td>获取当前数组的Stream流</td></tr><tr><td>public  static<T>  Stream<T>  of(T…  values)  &#x2F;&#x2F;Stream.of()</td><td>获取当前数组&#x2F;可变数据的Stream流</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Collection集合获取Stream流</span></span><br><span class="line">Collection&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Stream&lt;String&gt; s = list.stream();</span><br><span class="line"></span><br><span class="line"><span class="comment">//Map集合获取Stream流</span></span><br><span class="line">Map&lt;String, Integer&gt; maps = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//键流</span></span><br><span class="line">Stream&lt;String&gt; mapsStream = maps.keySet().stream();</span><br><span class="line"><span class="comment">//值流</span></span><br><span class="line">Stream&lt;Integer&gt; valuesStream = maps.values().stream();</span><br><span class="line"><span class="comment">//键值对流</span></span><br><span class="line">Stream&lt;Map.Entry&lt;String,Integer&gt;&gt; kAndv = maps.entrySet().stream();</span><br><span class="line"></span><br><span class="line"><span class="comment">//集合集合获取Stream流</span></span><br><span class="line">String[] names = &#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>&#125;; <span class="comment">//首先获取集合对象</span></span><br><span class="line">Stream&lt;String&gt; Arr = Arrays.stream(names); <span class="comment">//方法一</span></span><br><span class="line">Stream&lt;String&gt; Arr = Stream.of(names);  <span class="comment">//方法二</span></span><br></pre></td></tr></table></figure><h4 id="2-3Stream流的常用API"><a href="#2-3Stream流的常用API" class="headerlink" title="2.3Stream流的常用API"></a>2.3Stream流的常用API</h4><p><strong>Stream流的常用API(中间操作方法)</strong></p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>Stream<T>  <strong>filter</strong>(Predicate&lt;?  super  T&gt;  predicate)</td><td>用于对流中的数据进行<strong>过滤。</strong></td></tr><tr><td>Stream<T>  <strong>limit</strong>(long maxSize)</td><td>获取前几个元素</td></tr><tr><td>Stream<T>  <strong>skip</strong>(long n)</td><td>跳过前几个元素</td></tr><tr><td>Stream<T>  <strong>distinct</strong>()</td><td><strong>去除流中重复的元素</strong>。依赖(hashCode和equals方法)</td></tr><tr><td>static  <T> Stream<T> <strong>concat</strong>(Stream  a, Stream b)</td><td><strong>合并a和b</strong>两个流为一个流</td></tr></tbody></table><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//forEach:逐个遍历</span></span><br><span class="line"><span class="comment">//count:统计个数</span></span><br><span class="line"><span class="comment">//filter:过滤元素</span></span><br><span class="line"><span class="comment">//limit:取前几个元素</span></span><br><span class="line"><span class="comment">//skip:跳过前几个</span></span><br><span class="line"><span class="comment">//map:加工方法</span></span><br><span class="line"><span class="comment">//concat:合并流</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;张无忌&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;雷柏&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;帕克&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;凯萨文&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;凯撒&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;迪奥&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取姓凯的元素</span></span><br><span class="line">        list.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;凯&quot;</span>)).forEach(s -&gt; System.out.println(s)); <span class="comment">//凯萨文 凯撒</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//count:统计姓凯的个数</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> list.stream().filter(s -&gt; s.length() ==<span class="number">3</span>).count();</span><br><span class="line">        System.out.println(size); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//limit:取前1个姓凯的元素</span></span><br><span class="line">        list.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;凯&quot;</span>)).limit(<span class="number">1</span>).forEach(s -&gt; System.out.println(s)); <span class="comment">//凯萨文</span></span><br><span class="line">        <span class="comment">//list.stream().filter(s -&gt; s.startsWith(&quot;凯&quot;)).limit(1).forEach(System.out::println); // 两个参数相同是可简化</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//skip:跳过前1个姓凯的元素</span></span><br><span class="line">        list.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;凯&quot;</span>)).skip(<span class="number">1</span>).forEach(System.out::println);  <span class="comment">//凯撒</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//map:加工方法</span></span><br><span class="line">        list.stream().map(s -&gt; <span class="string">&quot;中国的&quot;</span> + s).forEach(s -&gt; System.out.println(s)); <span class="comment">//中国的xx</span></span><br><span class="line">        <span class="comment">//需求：把所有名称 都加工成一个学生对象</span></span><br><span class="line">        <span class="comment">//1.创建一个学生类</span></span><br><span class="line">        <span class="comment">//2.使用Stream的map加工方法</span></span><br><span class="line">        list.stream().map(s -&gt; <span class="keyword">new</span> <span class="title class_">Student</span>).forEach(s -&gt; System.out.println(s));</span><br><span class="line">        <span class="comment">//list.stream().map(Student::new).forEach(s -&gt; System.out.println(s)); //构造器引用  //方法引用</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//concat:合并流</span></span><br><span class="line">        Stream&lt;String&gt; s1 = list.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;凯&quot;</span>));</span><br><span class="line">        Stream&lt;String&gt; s2 = Stream.of(<span class="string">&quot;java&quot;</span>,<span class="string">&quot;java1&quot;</span>);</span><br><span class="line">        Stream&lt;String&gt; s3 = Stream.concat(s1 , s2);</span><br><span class="line">        s3.forEach(s -&gt; System.out.println(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li><p><strong><em>中间方法</em>，也称为非终结方法，调用完成后返回新的Stream流可以继续使用，支持链式编程</strong>。</p></li><li><p><strong>在Stream流中无法直接修改集合、数组中的数据。</strong></p></li></ul><p><strong>Stream流的常见终结操作方法</strong></p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>void  forEach(Consumer  action)</td><td>对此流的每个元素执行遍历操作</td></tr><tr><td>long count()</td><td>返回此流中的元素数</td></tr></tbody></table><p><strong>注意：<em>终结操作方法</em>，调用完成后流就无法继续使用了，原因是不会返回Stream了。</strong></p><h4 id="2-4Stream流的综合应用"><a href="#2-4Stream流的综合应用" class="headerlink" title="2.4Stream流的综合应用"></a>2.4Stream流的综合应用</h4><p><strong>案例标题</strong></p><p>需求：</p><p>某个公司的开发部门，分为开发一部和二部，现在需要进行年中数据结算。</p><p>分析：</p><p>①：员工信息至少包含了(名称、性别、工资、奖金、处罚记录)</p><p>②：开发一部有4个员工、开发二部有5名员工</p><p>③：分别筛选出2个部门的最高工资的员工信息，封装成优秀员工对象Topperformer</p><p>④：分别统计出2个部门的平均月收入，要求去掉最高和最低工资。</p><p>⑤：统计2个开发部门整体的平均工资，去掉最低和最高工资的平均值。</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建公司员工对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span> sex;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> salary;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> bonus;</span><br><span class="line">    <span class="keyword">private</span> String punish;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String name, <span class="type">char</span> sex, <span class="type">double</span> salary, <span class="type">double</span> bonus, String punish)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">        <span class="built_in">this</span>.salary = salary;</span><br><span class="line">        <span class="built_in">this</span>.bonus = bonus;</span><br><span class="line">        <span class="built_in">this</span>.punish = punish;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">getSex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSex</span><span class="params">(<span class="type">char</span> sex)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getSalary</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSalary</span><span class="params">(<span class="type">double</span> salary)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getBonus</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bonus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBonus</span><span class="params">(<span class="type">double</span> bonus)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bonus = bonus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPunish</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> punish;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPunish</span><span class="params">(String punish)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.punish = punish;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建公司优秀员工对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Topperformer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> money;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Topperformer</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Topperformer</span><span class="params">(String name, <span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getMoney</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMoney</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Topperformer&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, money=&quot;</span> + money +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义静态变量，储存剩余员工的工资总和(静态变量可以共享)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> allmoney; <span class="comment">//一个部门去除最高工资和最低工资的总和</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> allmoney2; <span class="comment">//两个部门去除最高工资和最低工资的总和</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注意：使用get()取出对象</span></span><br><span class="line"></span><br><span class="line">        List&lt;Employee&gt; one = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        one.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;猪八戒&quot;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="number">30000</span>, <span class="number">25000</span>, <span class="literal">null</span>));</span><br><span class="line">        one.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;孙悟空&quot;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="number">25000</span>, <span class="number">1000</span>, <span class="string">&quot;顶撞上司&quot;</span>));</span><br><span class="line">        one.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;沙僧&quot;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="number">20000</span>, <span class="number">20000</span>, <span class="literal">null</span>));</span><br><span class="line">        one.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;小白龙&quot;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="number">20000</span>, <span class="number">25000</span>, <span class="literal">null</span>));</span><br><span class="line"></span><br><span class="line">        List&lt;Employee&gt; two = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        two.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;武松&quot;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="number">15000</span>, <span class="number">9000</span>, <span class="literal">null</span>));</span><br><span class="line">        two.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;李逵&quot;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="number">20000</span>, <span class="number">10000</span>, <span class="literal">null</span>));</span><br><span class="line">        two.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;西门庆&quot;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="number">50000</span>, <span class="number">100000</span>, <span class="string">&quot;被打&quot;</span>));</span><br><span class="line">        two.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;潘金莲&quot;</span>, <span class="string">&#x27;女&#x27;</span>, <span class="number">3500</span>, <span class="number">1000</span>, <span class="string">&quot;被打&quot;</span>));</span><br><span class="line">        two.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;武大郎&quot;</span>, <span class="string">&#x27;女&#x27;</span>, <span class="number">20000</span>, <span class="number">0</span>, <span class="string">&quot;下毒&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.开发一部最高工资的员工</span></span><br><span class="line">        <span class="comment">//指定大小规则，对每个对象进行比较</span></span><br><span class="line"><span class="comment">//        Employee e = one.stream().max((e1 , e2) -&gt; Double.compare(e1.getSalary() + e1.getBonus(), e2.getSalary() + e2.getBonus())).get();</span></span><br><span class="line"><span class="comment">//        System.out.println(e);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//加工方法，将最佳员工加工成一个对象</span></span><br><span class="line">        <span class="type">Topperformer</span> <span class="variable">t</span> <span class="operator">=</span> one.stream().max((e1, e2) -&gt; Double.compare(e1.getSalary() + e1.getBonus(), e2.getSalary() + e2.getBonus()))</span><br><span class="line">                .map(e -&gt; <span class="keyword">new</span> <span class="title class_">Topperformer</span>(e.getName(), e.getSalary() + e.getBonus())).get();</span><br><span class="line">        System.out.println(t);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.统计平均工资：去除最高工资和最低工资</span></span><br><span class="line">        <span class="comment">//开发一部</span></span><br><span class="line">        one.stream().sorted((e1, e2) -&gt; Double.compare(e1.getSalary() + e1.getBonus(), e2.getSalary() + e2.getBonus()))</span><br><span class="line">                .skip(<span class="number">1</span>).limit(one.size() - <span class="number">2</span>).forEach(e -&gt; &#123;</span><br><span class="line">                    <span class="comment">//求综合：剩余员工的工资总和</span></span><br><span class="line">                    allmoney += (e.getSalary() + e.getBonus());</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;开发一部的平均工资是：&quot;</span> + allmoney / (one.size() - <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.合并两个集合流，在统计</span></span><br><span class="line">        Stream&lt;Employee&gt; s1 = one.stream();</span><br><span class="line">        Stream&lt;Employee&gt; s2 = two.stream();</span><br><span class="line">        Stream&lt;Employee&gt; s3 = Stream.concat(s1 , s2);</span><br><span class="line">        s3.sorted((e1, e2) -&gt; Double.compare(e1.getSalary() + e1.getBonus(), e2.getSalary() + e2.getBonus()))</span><br><span class="line">                .skip(<span class="number">1</span>).limit(one.size() + two.size() - <span class="number">2</span>).forEach(e -&gt; &#123;</span><br><span class="line">                    <span class="comment">//求总和：剩余员工的工资总和</span></span><br><span class="line">                    allmoney2 += (e.getSalary() + e.getBonus());</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//可以使用BigDecimal解决精度</span></span><br><span class="line">        System.out.println(<span class="string">&quot;开发部的平均工资是：&quot;</span> + allmoney2 / (one.size() + two.size() - <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-5收集Stream流"><a href="#2-5收集Stream流" class="headerlink" title="2.5收集Stream流"></a>2.5收集Stream流</h4><p><strong>Stream流的收集操作</strong></p><ul><li><p><strong>收集Stream流的含义</strong>：<strong>就是把Stream流操作后的结果数据转回到集合或者数组中去。</strong></p></li><li><p>Stream流：方便操作集合&#x2F;数组的<strong>手段。</strong></p></li><li><p>集合&#x2F;数组：才是开发中的<strong>目的</strong>。</p></li></ul><p><strong>Stream流的收集方法</strong></p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>R collect(Collector collector)</td><td>开始收集Stream流，指定收集器</td></tr></tbody></table><p><strong>Collectors工具类提供了具体的收集方式</strong></p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>public static <T> Collector toList()</td><td>把元素收集到List集合中</td></tr><tr><td>public static <T> Collector toSet()</td><td>把元素收集到Set集合中</td></tr><tr><td>public static Collector toMap(Function keyMapper  , Function valueMapper)</td><td>把元素收集到Map集合中</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="string">&quot;张无忌&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;雷柏&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;帕克&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;凯萨文&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;凯撒&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;迪奥&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//注意：流只能使用一次</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//收集到List集合</span></span><br><span class="line">    Stream&lt;String&gt; s1 = list.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;凯&quot;</span>));</span><br><span class="line">    List&lt;String&gt; kai1 = s1.collect(Collectors.toList());</span><br><span class="line">    System.out.println(kai1);  <span class="comment">//[凯萨文, 凯撒]</span></span><br><span class="line">    <span class="comment">//toList();JDK16可以使用，是不可变集合</span></span><br><span class="line">    List&lt;String&gt; list1 = s1.toList();</span><br><span class="line">    System.out.println(list1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//收集到Set集合</span></span><br><span class="line">    Stream&lt;String&gt; s2 = list.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;凯&quot;</span>));</span><br><span class="line">    Set&lt;String&gt; kai2 = s2.collect(Collectors.toSet());</span><br><span class="line">    System.out.println(kai2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//收集到数组中</span></span><br><span class="line">    Stream&lt;String&gt; s3 = list.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;凯&quot;</span>));</span><br><span class="line">    Object[] arrs1 = s3.toArray(); <span class="comment">//储存任意类型</span></span><br><span class="line">    System.out.println(Arrays.toString(arrs1));</span><br><span class="line"></span><br><span class="line">    String[] arrs2 = s3.toArray(s -&gt; <span class="keyword">new</span> <span class="title class_">String</span>[s]); <span class="comment">//储存String类型</span></span><br><span class="line">    <span class="comment">//String[] arrs2 = s3.toArray(String[s]::new); //简化</span></span><br><span class="line">    System.out.println(Arrays.toString(arrs2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-异常处理"><a href="#3-异常处理" class="headerlink" title="3.异常处理"></a>3.异常处理</h3><h4 id="3-1异常概述、体系"><a href="#3-1异常概述、体系" class="headerlink" title="3.1异常概述、体系"></a>3.1异常概述、体系</h4><p><strong>什么是异常？</strong></p><ul><li><p>异常是程序在“编译”或者“执行”的过程中可能出现的问题，<strong>注意：</strong>语法错误不算在异常体系中。 </p></li><li><p>比如:数组索引越界、空指针异常、 日期格式化异常，等…</p></li></ul><p><strong>为什么要学习异常?</strong></p><ul><li>异常一旦出现了，如果没有提前处理，程序就会退出JVM虚拟机而终止.</li><li>研究异常并且避免异常，然后提前处理异常，体现的是程序的安全, 健壮性。</li></ul><p><strong>异常体系</strong></p><ol><li><strong>Throwable类：</strong> Throwable是Java异常体系的根类，它有两个主要的子类，即Error和Exception。</li><li><strong>Error类：</strong> Error表示系统级别的错误，通常是由于虚拟机运行环境出现了严重问题导致的，例如内存溢出（OutOfMemoryError）、线程死锁等。程序一般无法捕获或处理Error，因为它们通常表示无法恢复的问题。</li><li><strong>Exception类：</strong> Exception是可以被程序捕获和处理的异常类型。Exception分为两类，分别是运行时异常（RuntimeException及其子类）和编译时异常（其他Exception及其子类）。<ul><li><strong>运行时异常（RuntimeException）：</strong> 运行时异常是指在程序运行过程中可能会出现，但不是必然出现的异常，如空指针异常（NullPointerException）、数组下标越界异常（ArrayIndexOutOfBoundsException）、算术异常（ArithmeticException）等。这些异常可以通过编写良好的代码和检查来避免，但在程序运行时可能仍然会发生。</li><li><strong>编译时异常：</strong> 编译时异常是指在编写代码时必须处理的异常，否则代码无法通过编译。这些异常主要是IOException及其子类、SQLException等。处理编译时异常通常需要使用try-catch块或者在方法上声明throws子句来传递异常。</li></ul></li></ol><p><strong>Error：</strong></p><ul><li>系统级别问题、JVM退出等，代码无法控制。</li></ul><p><strong>Exception</strong>：java.lang包下，称为异常类，它表示程序本身可以处理的问题</p><ul><li><p><strong>RuntimeException及其子类</strong>：<strong>运行时异常</strong>，编译阶段不会报错。 (空指针异常，数组索引越界异常) </p></li><li><p><strong>除RuntimeException之外所有的异常</strong>：<strong>编译时异常</strong>，编译期必须处理的，否则程序不能通过编译。 (日期格式化异常)。</p></li></ul><p><strong>编译时异常和运行时异常</strong></p><ol><li><strong>编译时异常（Checked Exception）</strong>： 编译时异常是在编译阶段由编译器强制检查的异常。如果一个方法可能会引发编译时异常，那么该方法的调用者必须在代码中显式处理这些异常，以确保程序在运行时不会出现未处理的异常情况。通常，编译时异常是派生自Exception类（但不是RuntimeException类）的异常。</li><li><strong>运行时异常（Unchecked Exception）</strong>： 运行时异常是在运行时阶段才会被检测到的异常，通常由程序的逻辑错误或bug引起。与编译时异常不同，调用者不需要在代码中显式地处理运行时异常，但仍然可以选择捕获并处理它们。运行时异常通常是派生自RuntimeException类的异常。</li></ol><h4 id="3-2常见运行时异常"><a href="#3-2常见运行时异常" class="headerlink" title="3.2常见运行时异常"></a>3.2常见运行时异常</h4><p><strong>运行时异常</strong></p><ul><li>**直接继承自RuntimeException或者其子类</li><li>编译阶段不会报错，运行时可能出现的错误</li></ul><p><strong>运行时异常示例</strong></p><ul><li><p>数组索引越界异常: ArrayIndexOutOfBoundsException</p></li><li><p>空指针异常 : NullPointerException，直接输出没有问题，但是调用空指针的变量的功能就会报错。</p></li><li><p>数学操作异常：ArithmeticException</p></li><li><p>类型转换异常：ClassCastException</p></li><li><p>数字转换异常： NumberFormatException</p></li></ul><p><strong>运行时异常：一般是程序员业务没有考虑好或者是编程逻辑不严谨引起的程序错误，自己的水平有问题！</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">         <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">         <span class="comment">//1.数组索引越界异常</span></span><br><span class="line"><span class="comment">//        System.out.println(arr[3]);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.空指针异常</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="comment">//        System.out.println(name.length()); //运行出错，程序终止</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.类型转换异常</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="number">23</span>;</span><br><span class="line"><span class="comment">//        String s = (String) o;  //运行出错，程序终止</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.数学操作异常</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">10</span> / <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.数字转化异常</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">num</span> <span class="operator">=</span> <span class="string">&quot;23aabbcc&quot;</span>;</span><br><span class="line"><span class="comment">//        Integer it = Integer.valueOf(num);</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-3常见编译时异常"><a href="#3-3常见编译时异常" class="headerlink" title="3.3常见编译时异常"></a>3.3常见编译时异常</h4><p><strong>编译时异常</strong></p><ul><li><strong>继承自Exception的异常或者其子类</strong></li><li>编译阶就报错，必须处理，否则代码不通过。</li></ul><p><strong>编译时异常的作用是什么：</strong></p><ul><li><p>是担心程序员的技术不行，在编译阶段就爆出一个错误, <strong>目的在于提醒不要出错!</strong></p></li><li><p>编译时异常是可遇不可求。遇到了就遇到了呗。</p></li></ul><p><strong>编译时异常示例</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> <span class="string">&quot;2015-01-12 10:23:21&quot;</span>;</span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"><span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> sdf.parse(date);  <span class="comment">//日期解析异常：ParseException</span></span><br><span class="line">System.out.println(d);</span><br></pre></td></tr></table></figure><h4 id="3-4异常的默认处理流程"><a href="#3-4异常的默认处理流程" class="headerlink" title="3.4异常的默认处理流程"></a>3.4异常的默认处理流程</h4><p><strong>默认异常处理机制</strong></p><ul><li><strong>默认的异常处理机制并不好，一旦真的出现异常，程序立即死亡！</strong></li></ul><p>①默认会在出现异常的代码那里自动的创建一个异常对象：ArithmeticException。</p><p>②异常会从方法中出现的点这里抛出给调用者，调用者最终抛出给JVM虚拟机。</p><p>③虚拟机接收到异常对象后，先在控制台直接输出异常栈信息数据。</p><p>④直接从当前执行的异常点干掉当前程序。</p><p>⑤后续代码没有机会执行了，因为程序已经死亡。</p><h4 id="3-5可干涉的处理机制"><a href="#3-5可干涉的处理机制" class="headerlink" title="3.5可干涉的处理机制"></a>3.5可干涉的处理机制</h4><p>编译时异常是编译阶段就出错的，所以必须处理，否则代码根本无法通过</p><p><strong>编译时异常的处理形式有三种：</strong></p><ul><li><p>出现异常直接抛出去给调用者，调用者也继续抛出去。</p></li><li><p>出现异常自己捕获处理，不麻烦别人。</p></li><li><p>前两者结合，出现异常直接抛出去给调用者，调用者捕获处理。</p></li></ul><h5 id="3-1编译时异常的处理机制"><a href="#3-1编译时异常的处理机制" class="headerlink" title="3..1编译时异常的处理机制"></a>3..1编译时异常的处理机制</h5><p><strong>异常处理方式1 —— throws</strong></p><ul><li><p>throws：用在方法上，可以将方法内部出现的异常抛出去给本方法的调用者处理。</p></li><li><p>这种方式并不好，发生异常的方法自己不处理异常，如果异常最终抛出去给虚拟机将引起程序死亡。</p></li></ul><p><strong>抛出异常格式：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方法 <span class="keyword">throws</span> 异常<span class="number">1</span> ，异常<span class="number">2</span> ，异常<span class="number">3</span> ..&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>规范做法</strong>： </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方法 <span class="keyword">throws</span> Exception&#123;  <span class="comment">//代表可以抛出一切异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>异常处理方式2—— try…catch…</strong></p><ul><li><p>监视捕获异常，用在方法内部，可以将方法内部出现的异常直接捕获处理。</p></li><li><p>这种方式还可以，发生异常的方法自己独立完成异常的处理，程序可以继续往下执行。</p></li></ul><p><strong>格式：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">// 监视可能出现异常的代码！</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span> 变量)&#123;</span><br><span class="line"><span class="comment">// 处理异常</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(异常类型<span class="number">2</span> 变量)&#123;</span><br><span class="line"><span class="comment">// 处理异常</span></span><br><span class="line">&#125;...</span><br></pre></td></tr></table></figure><p><strong>建议格式：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">// 可能出现异常的代码！</span></span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;  <span class="comment">//Exception可以捕获处理一切异常类型！</span></span><br><span class="line">e.printStackTrace(); <span class="comment">// 直接打印异常栈信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**异常处理方式3 **—— <strong>前两者结合</strong></p><ul><li><p>方法直接将异通过throws抛出去给调用者</p></li><li><p>调用者收到异常后直接捕获处理。</p></li></ul><p><strong>异常处理的总结</strong></p><ul><li><p><strong>在开发中按照规范来说第三种方式是最好的：底层的异常抛出去给最外层，最外层集中捕获处理。</strong></p></li><li><p><strong>实际应用中，只要代码能够编译通过，并且功能能完成，那么每一种异常处理方式似乎也都是可以的。</strong></p></li></ul><h5 id="3-5-2运行时异常的处理机制"><a href="#3-5-2运行时异常的处理机制" class="headerlink" title="3.5.2运行时异常的处理机制"></a>3.5.2运行时异常的处理机制</h5><p><strong>运行时异常的处理形式</strong></p><ul><li><p>运行时异常编译阶段不会出错，是运行时才可能出错的，所以编译阶段不处理也可以。</p></li><li><p>按照规范建议还是处理：建议在最外层调用处集中捕获处理即可。</p></li></ul><h4 id="3-6异常处理使代码更稳健的案例"><a href="#3-6异常处理使代码更稳健的案例" class="headerlink" title="3.6异常处理使代码更稳健的案例"></a>3.6异常处理使代码更稳健的案例</h4><p><strong>需求</strong></p><p>键盘录入一个合理的价格为止（必须是数值，值必须大于0）。</p><p><strong>分析</strong></p><p>定义一个死循环，让用户不断的输入价格。</p><h4 id="3-7自定义异常"><a href="#3-7自定义异常" class="headerlink" title="3.7自定义异常"></a>3.7自定义异常</h4><p><strong>自定义异常的必要？</strong></p><ul><li><p>Java无法为这个世界上全部的问题提供异常类。</p></li><li><p>如果企业想通过异常的方式来管理自己的某个业务问题，就需要自定义异常类了。</p></li></ul><p><strong>自定义异常的好处：</strong></p><ul><li><p>可以使用异常的机制管理业务问题，如提醒程序员注意。</p></li><li><p>同时一旦出现bug，可以用异常的形式清晰的指出出错的地方。</p></li></ul><p><strong>自定义异常的分类</strong></p><p><strong>1、自定义编译时异常</strong>    </p><ul><li><p>定义一个异常类继承Exception.</p></li><li><p>重写构造器。</p></li><li><p>在出现异常的地方用throw new 自定义对象抛出，</p></li></ul><p><strong>作用</strong>：编译时异常是编译阶段就报错，提醒更加强烈，一定需要处理！！</p><p><strong>2、自定义运行时异常</strong></p><ul><li><p>定义一个异常类继承RuntimeException.</p></li><li><p>重写构造器。</p></li><li><p>在出现异常的地方用throw new 自定义对象抛出!</p></li></ul><p><strong>作用：</strong>提醒不强烈，编译阶段不报错！！运行时才可能出现！！</p><p>需求：</p><p>创建一个编译异常，判断年龄合法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一步.自定义的编译异常</span></span><br><span class="line"><span class="comment">//1.继承Exception</span></span><br><span class="line"><span class="comment">//2.重写构造器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ItheimaAgeIlleagalException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ItheimaAgeIlleagalException</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ItheimaAgeIlleagalException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);  <span class="comment">//message异常提醒</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第二步</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            checkAge(-<span class="number">35</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ItheimaAgeIlleagalException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//年龄合法的判断方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkAge</span><span class="params">(<span class="type">int</span> age)</span> <span class="keyword">throws</span> ItheimaAgeIlleagalException &#123;</span><br><span class="line">        <span class="keyword">if</span> (age &lt; <span class="number">0</span> || age &gt;<span class="number">200</span>)&#123;</span><br><span class="line">            <span class="comment">//抛出去一个异常对象给调用者</span></span><br><span class="line">            <span class="comment">//throo: 在方法内部直接创建一个异常对象，并从此抛出</span></span><br><span class="line">            <span class="comment">//throos: 用在方法申明上的，抛出方法内部异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ItheimaAgeIlleagalException</span>(age + <span class="string">&quot; is illeagal!&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;年龄合法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> java,面向对象进阶,不可变集合,Stream,异常,日志框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>day15 - 集合</title>
      <link href="/post/4e9f6bc.html"/>
      <url>/post/4e9f6bc.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-Set系列集合"><a href="#1-Set系列集合" class="headerlink" title="1.Set系列集合"></a>1.Set系列集合</h3><h4 id="1-1Set系列集系概述"><a href="#1-1Set系列集系概述" class="headerlink" title="1.1Set系列集系概述"></a>1.1Set系列集系概述</h4><p><strong>Set系列集合特点</strong></p><ul><li><p>无序：存取顺序不一致(只能无序一次)</p></li><li><p>不重复：可以去除重复</p></li><li><p>无索引：没有带索引的方法，所以不能使用普通for循环遍历，也不能通过索引来获取元素。</p></li></ul><p><strong>Set集合 实现类特点</strong></p><ul><li>HashSet : 无序、不重复、无索引。<ul><li>LinkedHashSet：<strong>有序</strong>、不重复、无索引。</li></ul></li><li>TreeSet：<strong>可排序</strong>、不重复、无索引。</li></ul><p><strong>Set集合的功能上基本上与Collection的API一致。</strong></p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//看看Set系列集合的特点： HashSet LinkedHashSet TreeSet</span></span><br><span class="line"><span class="comment">//经典代码写法</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//无序 不重复 无索引</span></span><br><span class="line">    Set&lt;String&gt; sets = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(); </span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 有序 不重复 无索引</span></span><br><span class="line">    Set&lt;String&gt; sets = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(); </span><br><span class="line"></span><br><span class="line"> <span class="comment">// 可排序 不重复 无索引</span></span><br><span class="line">    Set&lt;String&gt; sets = newTreeSet&lt;&gt;(); </span><br></pre></td></tr></table></figure><h4 id="1-2HashSet实现类-无序的底层原理：哈希表"><a href="#1-2HashSet实现类-无序的底层原理：哈希表" class="headerlink" title="1.2HashSet实现类  无序的底层原理：哈希表"></a>1.2HashSet实现类  无序的底层原理：哈希表</h4><p><strong>HashSet底层原理</strong></p><ul><li><p>HashSet集合底层采取<strong>哈希表</strong>存储的数据。</p></li><li><p>哈希表是一种对于增删改查数据性能都较好的结构。</p></li></ul><p><strong>哈希表的组成</strong></p><ul><li><p>JDK8之前的，底层使用<strong>数组+链表</strong>组成</p></li><li><p>JDK8开始后，底层采用<strong>数组+链表+红黑树</strong>组成。</p></li></ul><p>在了解哈希表之前需要先理解哈希值的概念</p><p><strong>哈希值</strong></p><ul><li>是JDK根据对象的<strong>地址</strong>，按照某种规则算出来的int类型的<strong>数值</strong>。</li></ul><p><strong>Object类的API</strong></p><ul><li>public int <strong>hashCode</strong>()：<strong>返回对象的哈希值</strong></li></ul><p><strong>对象的哈希值特点</strong></p><ul><li><p>同一个对象多次调用hashCode()方法返回的哈希值是相同的</p></li><li><p>默认情况下，不同对象的哈希值是不同的。</p></li></ul><p><strong>HashSet1.7版本原理解析：数组 + 链表 +（结合哈希算法）</strong></p><p><img src="C:\Users\廖永森\AppData\Roaming\Typora\typora-user-images\image-20220203172311069.png" alt="image-20220203172311069"></p><ul><li><p>①创建一个默认长度16的数组，数组名table</p></li><li><p>②根据元素的哈<strong>希值跟数组的长度求余</strong>计算出应存入的位置（哈希算法）</p></li><li><p>③判断当前位置是否为null，如果是null直接存入</p></li><li><p>④如果位置不为null，表示有元素，则调用equals方法比较</p></li><li><p>⑤如果一样，则不存，如果不一样，则存入数组，</p><ul><li><p>JDK 7新元素占老元素位置，指向老元素</p></li><li><p>JDK 8中新元素挂在老元素下面</p></li></ul></li><li><p>当数组存满到16\0.75&#x3D;12时，就自动扩容，每次扩容原先的两倍</p></li></ul><p><strong>结论：哈希表是一种对于增删改查数据性能都较好的结构。</strong></p><p><strong>JDK1.8版本开始HashSet原理解析</strong></p><ul><li><p>底层结构：哈希表（<strong>数组、链表、红黑树的结合体</strong>）</p></li><li><p>当挂在元素下面的数据过多时，查询性能降低，从JDK8开始后，当链表长度超过<strong>8</strong>的时候，自动转换为红黑树。</p></li></ul><p><img src="C:\Users\廖永森\AppData\Roaming\Typora\typora-user-images\image-20220203172738241.png" alt="image-20220203172738241"></p><p><img src="C:\Users\廖永森\AppData\Roaming\Typora\typora-user-images\image-20220203172802501.png" alt="image-20220203172802501"></p><p><strong>结论：JDK8开始后，哈希表对于红黑树的引入进一步提高了操作数据的性能。</strong></p><h4 id="1-3HashSet元素去重复的底层原理"><a href="#1-3HashSet元素去重复的底层原理" class="headerlink" title="1.3HashSet元素去重复的底层原理"></a>1.3HashSet元素去重复的底层原理</h4><p><strong>HashSet去重复原理解析</strong></p><p>①创建一个默认长度16的数组，数组名table</p><p>②根据元素的<strong>哈希值</strong>跟<strong>数组的长度求余</strong>计算出应存入的位置<strong>（哈希算法）</strong></p><p>③判断当前位置是否为null，如果是null直接存入</p><p>④如果位置不为null，表示有元素，则调用equals方法比较</p><p>⑤如果一样，则不存，如果不一样，则存入数组</p><p><strong>结论：如果希望Set集合认为2个内容一样的对象是重复的</strong></p><p>​            <strong>必须重写对象的hashCode()和equals()方法</strong></p><p><strong>案例：</strong></p><p>Set集合去重复</p><p><strong>需求：</strong></p><p>创建一个存储学生对象的集合，存储多个学生对象，使用程序实现在控制台遍历该集合，要求：学生对象的成员变量值相同，我们就认为是同一个对象</p><p><strong>分析</strong></p><p>①定义学生类，创建HashSet集合对象, 创建学生对象</p><p>②把学生添加到集合</p><p><strong>③在学生类中重写两个方法，hashCode()和equals()，自动生成即可</strong></p><p>④遍历集合(增强for)</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.定义学生类，重写hashCode()和equals()方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Set集合去重复原因：先判断哈希值算出来的存储位置是否相同 再判断    equals</span></span><br><span class="line">        Set&lt;Student&gt; sets = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;无恙&quot;</span>, <span class="number">20</span>, <span class="string">&#x27;男&#x27;</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;无恙&quot;</span>, <span class="number">20</span>, <span class="string">&#x27;男&#x27;</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;周雄&quot;</span>, <span class="number">21</span>, <span class="string">&#x27;男&#x27;</span>);</span><br><span class="line">        </span><br><span class="line">        sets.add(s1);</span><br><span class="line">        sets.add(s2);</span><br><span class="line">        sets.add(s3);</span><br><span class="line"></span><br><span class="line">        System.out.println(sets);</span><br></pre></td></tr></table></figure><h4 id="1-4实现类：LinkedHashSet"><a href="#1-4实现类：LinkedHashSet" class="headerlink" title="1.4实现类：LinkedHashSet"></a>1.4实现类：LinkedHashSet</h4><p><strong>LinkedHashSet集合概述和特点</strong></p><ul><li><p><strong>有序</strong>、不重复、无索引。</p></li><li><p>这里的有序指的是保证存储和取出的元素顺序一致</p></li><li><p><strong>原理</strong>：底层数据结构是依然<strong>哈希表</strong>，只是每个元素又额外的多了一个<strong>双链表</strong>的机制记录存储的顺序。</p></li></ul><p><img src="C:\Users\廖永森\AppData\Roaming\Typora\typora-user-images\image-20220203175655815.png" alt="image-20220203175655815"></p><h4 id="1-5实现类：TreeSet"><a href="#1-5实现类：TreeSet" class="headerlink" title="1.5实现类：TreeSet"></a>1.5实现类：TreeSet</h4><p><strong>TreeSet集合概述和特点</strong></p><ul><li><p>不重复、无索引、可排序</p></li><li><p>可排序：按照<strong>元素的大小</strong>(如果是字符，按照首字母的ASCII排序)默认升序（由小到大）排序。</p></li><li><p>TreeSet集合底层是基于<strong>红黑树的数据结构</strong>实现排序的，增删改查性能都较好。</p></li></ul><p><strong>注意：TreeSet集合是一定要排序的，默认升序，可以将元素按照指定的规则进行排序。</strong></p><p><strong>TreeSet集合默认的规则</strong></p><ul><li><p>对于数值类型：Integer , Double，官方默认按照大小进行升序排序。</p></li><li><p>对于字符串类型：默认按照首字符的编号升序排序。</p></li><li><p>对于自定义类型如Student对象，TreeSet无法直接排序。</p></li></ul><p><strong>结论：想要使用<em>TreeSet存储自定义类型</em>，需要制定排序规则</strong></p><p><strong>自定义排序规则</strong></p><ul><li>TreeSet集合存储对象的的时候有<strong>2种方式</strong>可以设计自定义比较规则</li></ul><p><strong>方式一</strong></p><ul><li>让自定义的类（如学生类）<strong>实现Comparable接口   重写里面的compareTo方法</strong>来定制比较规则。</li></ul><p><strong>方式二</strong></p><ul><li><strong>TreeSet集合有参数构造器</strong>，可以设置Comparator接口对应的<strong>比较器对象</strong>，来定制比较规则。</li></ul><p><strong>两种方式中，关于返回值的规则：</strong></p><ul><li><p>如果认为第一个元素大于第二个元素返回正整数即可。</p></li><li><p>如果认为第一个元素小于第二个元素返回负整数即可。</p></li><li><p>如果认为第一个元素等于第二个元素返回0即可，此时Treeset集合只会保留一个元素，认为两者重复。</p></li></ul><p><strong>注意：如果<em>TreeSet</em>集合存储的对象有实现比较规则，集合也自带比较器，默认使用集合自带的比较器排序。</strong></p><p><strong>案例：</strong></p><p>TreeSet对象排序练习题</p><p><strong>需求：</strong></p><p>键盘录入3个学生信息(姓名,语文成绩,数学成绩,英语成绩),按照总分从高到低输出到控制台</p><p><strong>分析</strong></p><p>①定义学生类</p><p>②创建TreeSet集合对象，通过比较器排序进行排序</p><p>③创建学生对象</p><p>④把学生对象添加到集合</p><p>⑤遍历集合</p><p><strong>代码：</strong></p><p>方式一：实现Comparable接口，重写方法定义规则</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.创建Apple类并实现接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Apple</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Apple&gt;&#123;  <span class="comment">//实现Comparable接口 ---&gt; implements Comparable</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> price;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> weight;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Apple</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Apple</span><span class="params">(String name, String color, <span class="type">double</span> price, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getColor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setColor</span><span class="params">(String color)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getPrice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPrice</span><span class="params">(<span class="type">double</span> price)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getWeight</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWeight</span><span class="params">(<span class="type">int</span> weight)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Apple&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, color=&#x27;&quot;</span> + color + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, price=&quot;</span> + price +</span><br><span class="line">                <span class="string">&quot;, weight=&quot;</span> + weight +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">//2.方法重写</span></span><br><span class="line"><span class="comment">//  自定义比较规则  o1.compareTo(o2)</span></span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Apple o)</span> &#123;</span><br><span class="line">        <span class="comment">// 按照重量进行比较的</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 去除重量重复的元素</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.weight - o.weight ; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保留重量重复的元素</span></span><br><span class="line">        <span class="comment">// return this.weight - o.weight &gt;= 0 ? 1 : -1; </span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>方式二：集合自带比较器对象，来定制比较规则</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建Apple类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Apple</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> price;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> weight;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Apple</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Apple</span><span class="params">(String name, String color, <span class="type">double</span> price, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getColor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setColor</span><span class="params">(String color)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getPrice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPrice</span><span class="params">(<span class="type">double</span> price)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getWeight</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWeight</span><span class="params">(<span class="type">int</span> weight)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Apple&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, color=&#x27;&quot;</span> + color + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, price=&quot;</span> + price +</span><br><span class="line">                <span class="string">&quot;, weight=&quot;</span> + weight +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2.创建比较器对象</span></span><br><span class="line">Set&lt;Apple&gt; apples = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Apple&gt;() &#123;  <span class="comment">//***直接创建比较器对象***</span></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Apple o1, Apple o2)</span> &#123;</span><br><span class="line">      <span class="comment">// return o1.getWeight() - o2.getWeight(); // 升序 </span></span><br><span class="line">      <span class="comment">// return o2.getWeight() - o1.getWeight(); // 降序</span></span><br><span class="line">          </span><br><span class="line">      <span class="comment">// 注意：浮点型建议直接使用Double.compare进行比较</span></span><br><span class="line">      <span class="comment">// return Double.compare(o1.getPrice(), o2.getPrice()); // 升序</span></span><br><span class="line">      <span class="comment">// return Double.compare(o2.getPrice() , o1.getPrice()); // 降序</span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;);</span><br><span class="line">      <span class="comment">//简化</span></span><br><span class="line">      Set&lt;Apple&gt; apples = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(( o1,  o2) -&gt;  Double.compare(o2.getPrice() , o1.getPrice())  );</span><br><span class="line">      </span><br><span class="line">  apples.add(<span class="keyword">new</span> <span class="title class_">Apple</span>(<span class="string">&quot;红富士&quot;</span>, <span class="string">&quot;红色&quot;</span>, <span class="number">9.9</span>, <span class="number">500</span>));</span><br><span class="line">      apples.add(<span class="keyword">new</span> <span class="title class_">Apple</span>(<span class="string">&quot;青苹果&quot;</span>, <span class="string">&quot;绿色&quot;</span>, <span class="number">15.9</span>, <span class="number">300</span>));</span><br><span class="line">      apples.add(<span class="keyword">new</span> <span class="title class_">Apple</span>(<span class="string">&quot;绿苹果&quot;</span>, <span class="string">&quot;青色&quot;</span>, <span class="number">29.9</span>, <span class="number">400</span>));</span><br><span class="line">      apples.add(<span class="keyword">new</span> <span class="title class_">Apple</span>(<span class="string">&quot;黄苹果&quot;</span>, <span class="string">&quot;黄色&quot;</span>, <span class="number">9.8</span>, <span class="number">500</span>));</span><br><span class="line">      System.out.println(apples);</span><br></pre></td></tr></table></figure><h3 id="2-Collection体系的特点、使用场景总结"><a href="#2-Collection体系的特点、使用场景总结" class="headerlink" title="2.Collection体系的特点、使用场景总结"></a>2.Collection体系的特点、使用场景总结</h3><p>1.如果希望元素可以重复，又有索引，索引查询要快？</p><ul><li><strong>用ArrayList集合，基于数组的。（用的最多）</strong></li></ul><p>2.如果希望元素可以重复，又有索引，增删首尾操作快？</p><ul><li>用LinkedList集合，基于链表的。</li></ul><p>3.如果希望增删改查都快，但是元素不重复、无序、无索引。</p><ul><li>用HashSet集合，基于哈希表的。</li></ul><p>4.如果希望增删改查都快，但是元素不重复、有序、无索引。</p><ul><li>用LinkedHashSet集合，基于哈希表和双链表。</li></ul><p>5.如果要对对象进行排序。</p><ul><li>用TreeSet集合，基于红黑树。后续也可以用List集合实现排序。</li></ul><h3 id="3-补充知识：可变参数"><a href="#3-补充知识：可变参数" class="headerlink" title="3.补充知识：可变参数"></a>3.补充知识：可变参数</h3><p>假如需要定义一个方法求和，该方法可以灵活的完成如下需求：</p><ul><li><p>计算1个数据的和。</p></li><li><p>计算2个数据的和。</p></li><li><p>计算3个数据的和。</p></li><li><p>计算n个数据的和，甚至可以支持不接收参数进行调用。</p></li></ul><p><strong>可变参数</strong></p><ul><li><p>可变参数用在形参中可以接收多个数据。</p></li><li><p>可变参数的格式：数据类型…参数名称</p></li></ul><p><strong>可变参数的作用</strong></p><ul><li><p>传输参数非常灵活，方便。<strong>可以不传输参数，可以传输1个或者多个</strong>，也可以传输一个数组</p></li><li><p><strong>可变参数在方法内部本质上就是一个数组。</strong></p></li></ul><p><strong>可变参数的注意事项：</strong></p><ul><li><p><strong>1.一个形参列表(方法)中可变参数只能有一个</strong></p></li><li><p><strong>2.可变参数必须放在形参列表的最后面</strong></p></li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：可变参数。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    可变参数的格式：数据类型...参数名称</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    可变参数的作用：</span></span><br><span class="line"><span class="comment">         传输参数非常灵活，方便。</span></span><br><span class="line"><span class="comment">         可以不传输参数。</span></span><br><span class="line"><span class="comment">         可以传输一个参数。</span></span><br><span class="line"><span class="comment">         可以传输多个参数。</span></span><br><span class="line"><span class="comment">         可以传输一个数组。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         1.一个形参列表中可变参数只能有一个！！</span></span><br><span class="line"><span class="comment">         2.可变参数必须放在形参列表的最后面！！</span></span><br><span class="line"><span class="comment">     小结：</span></span><br><span class="line"><span class="comment">        记住。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        sum(); <span class="comment">// 1、不传参数</span></span><br><span class="line">        sum(<span class="number">10</span>); <span class="comment">// 2、可以传输一个参数</span></span><br><span class="line">        sum(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>); <span class="comment">// 3、可以传输多个参数</span></span><br><span class="line">        sum(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;); <span class="comment">//4、可以传输一个数组</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">       注意：一个形参列表中只能有一个可变参数,可变参数必须放在形参列表的最后面</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sum</span><span class="params">( <span class="type">int</span>...nums )</span>&#123;</span><br><span class="line">        <span class="comment">// 注意：可变参数在方法内部其实就是一个数组。 nums</span></span><br><span class="line">        System.out.println(<span class="string">&quot;元素个数：&quot;</span> + nums.length);</span><br><span class="line">        System.out.println(<span class="string">&quot;元素内容：&quot;</span> + Arrays.toString(nums));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-补充知识：集合工具类Collections"><a href="#4-补充知识：集合工具类Collections" class="headerlink" title="4.补充知识：集合工具类Collections"></a>4.补充知识：集合工具类Collections</h3><p><strong>Collections集合工具类</strong></p><ul><li><p>java.utils.Collections:是集合工具类</p></li><li><p><strong>作用：Collections并不属于集合，是用来操作集合的工具类。</strong></p></li><li><p>通过<strong>List集合</strong>有序特征  弥补的部分方法</p></li></ul><p><strong>Collections常用的API</strong></p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>public static <T> boolean  <strong>addAll</strong>(Collection&lt;? super T&gt; c, T… elements)</td><td>给集合对象<strong>批量添加元素</strong></td></tr><tr><td>public static void <strong>shuffle</strong>(List&lt;?&gt; list)</td><td><strong>打乱List集合元素的顺序</strong></td></tr></tbody></table><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：Collections工具类的使用。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Collections有几个常用的API:</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">将集合中元素按照指定规则排序。</span></span><br><span class="line"><span class="comment">- public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; c)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; names = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//names.add(&quot;楚留香&quot;);</span></span><br><span class="line">        <span class="comment">//names.add(&quot;胡铁花&quot;);</span></span><br><span class="line">        <span class="comment">//names.add(&quot;张无忌&quot;);</span></span><br><span class="line">        <span class="comment">//names.add(&quot;陆小凤&quot;);</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//1.给集合对象批量添加元素！</span></span><br><span class="line">        Collections.addAll(names, <span class="string">&quot;楚留香&quot;</span>,<span class="string">&quot;胡铁花&quot;</span>, <span class="string">&quot;张无忌&quot;</span>,<span class="string">&quot;陆小凤&quot;</span>);</span><br><span class="line">        System.out.println(names);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.public static void shuffle(List&lt;?&gt; list) :打乱集合顺序。</span></span><br><span class="line">        Collections.shuffle(names);</span><br><span class="line">        System.out.println(names);</span><br></pre></td></tr></table></figure><p><strong>排序方式1：默认排序</strong></p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>public static <T> void <strong>sort</strong>(List<T> list)</td><td>将集合中元素按照<strong>默认规则排序</strong></td></tr></tbody></table><p>注意：本方式不可以直接对自定义类型的List集合排序，除非自定义类型实现了比较规则Comparable接口。</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//public static &lt;T&gt; void sort(List&lt;T&gt; list)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将集合中元素按照默认规则排序。(排值特性的元素)</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(list, <span class="number">12</span>, <span class="number">23</span>, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        System.out.println(list);</span><br></pre></td></tr></table></figure><p><strong>排序方式2：自定义类型排序</strong></p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>public static <T> void <strong>sort</strong>(List<T> list，Comparator&lt;? super T&gt; c)</td><td>将集合中元素<strong>按照指定规则排序</strong></td></tr></tbody></table><p><strong>排自定义类型</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法一</span></span><br><span class="line"><span class="comment">//定义Apple类，实现Comparable接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Apple</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Apple&gt;&#123;</span><br><span class="line">    <span class="comment">//自定义类，内容略</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法重写</span></span><br><span class="line">    <span class="comment">//类自定义比较规则  o1.compareTo(o2)  </span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Apple o)</span> &#123;</span><br><span class="line">        <span class="comment">// 按照重量进行比较的</span></span><br><span class="line">        <span class="comment">// List集存储相同大小的元素 会保留！(List可重复)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.weight - o.weight ;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">//主函数  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Apple&gt; apples = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); </span><br><span class="line">        apples.add(<span class="keyword">new</span> <span class="title class_">Apple</span>(<span class="string">&quot;红富士&quot;</span>, <span class="string">&quot;红色&quot;</span>, <span class="number">9.9</span>, <span class="number">500</span>));</span><br><span class="line">        apples.add(<span class="keyword">new</span> <span class="title class_">Apple</span>(<span class="string">&quot;青苹果&quot;</span>, <span class="string">&quot;绿色&quot;</span>, <span class="number">15.9</span>, <span class="number">300</span>));</span><br><span class="line">        apples.add(<span class="keyword">new</span> <span class="title class_">Apple</span>(<span class="string">&quot;绿苹果&quot;</span>, <span class="string">&quot;青色&quot;</span>, <span class="number">29.9</span>, <span class="number">400</span>));</span><br><span class="line">        apples.add(<span class="keyword">new</span> <span class="title class_">Apple</span>(<span class="string">&quot;黄苹果&quot;</span>, <span class="string">&quot;黄色&quot;</span>, <span class="number">9.8</span>, <span class="number">500</span>));</span><br><span class="line"></span><br><span class="line">        Collections.sort(apples); <span class="comment">//Apple类已经重写了比较规则</span></span><br><span class="line">        System.out.println(apples); <span class="comment">//内容可以重复！</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法二</span></span><br><span class="line"><span class="comment">//sort方法自带比较器对象</span></span><br><span class="line"><span class="comment">//定义类Apple，不需要接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">Collections.sort(apples, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Apple&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Apple o1, Apple o2)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> Double.compare(o1.getPrice() , o2.getPrice()); <span class="comment">// 按照价格排序！！</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//简化</span></span><br><span class="line"><span class="comment">//Collections.sort(apples, (o1 , o2) -&gt; Double.compare(o1.getPrice() , o2.getPrice()) );</span></span><br><span class="line">        </span><br><span class="line">    apples.add(<span class="keyword">new</span> <span class="title class_">Apple</span>(<span class="string">&quot;红富士&quot;</span>, <span class="string">&quot;红色&quot;</span>, <span class="number">9.9</span>, <span class="number">500</span>));</span><br><span class="line">    apples.add(<span class="keyword">new</span> <span class="title class_">Apple</span>(<span class="string">&quot;青苹果&quot;</span>, <span class="string">&quot;绿色&quot;</span>, <span class="number">15.9</span>, <span class="number">300</span>));</span><br><span class="line">    apples.add(<span class="keyword">new</span> <span class="title class_">Apple</span>(<span class="string">&quot;绿苹果&quot;</span>, <span class="string">&quot;青色&quot;</span>, <span class="number">29.9</span>, <span class="number">400</span>));</span><br><span class="line">    apples.add(<span class="keyword">new</span> <span class="title class_">Apple</span>(<span class="string">&quot;黄苹果&quot;</span>, <span class="string">&quot;黄色&quot;</span>, <span class="number">9.8</span>, <span class="number">500</span>));</span><br><span class="line">    System.out.println(apples);</span><br></pre></td></tr></table></figure><h3 id="5-Collection体系的综合案例"><a href="#5-Collection体系的综合案例" class="headerlink" title="5.Collection体系的综合案例"></a>5.Collection体系的综合案例</h3><h4 id="斗地主游戏"><a href="#斗地主游戏" class="headerlink" title="斗地主游戏"></a>斗地主游戏</h4><p><strong>需求：</strong><br> 在启动游戏房间的时候，应该提前准备好54张牌，完成洗牌、发牌、牌排序、逻辑。</p><p><strong>分析：</strong></p><p>①：当系统启动的同时需要准备好数据的时候，就可以用静态代码块了。</p><p>②：洗牌就是打乱牌的顺序。</p><p>③：定义三个玩家、依次发出51张牌</p><p>④：给玩家的牌进行排序(拓展)</p><p>⑤：输出每个玩家的牌数据。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个Card类，储存牌类</span></span><br><span class="line"><span class="comment">//index  牌的真正大小</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Card</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String size;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> index; <span class="comment">// 牌的真正大小</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Card</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Card</span><span class="params">(String size, String color, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.size = size;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">        <span class="built_in">this</span>.index = index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSize</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSize</span><span class="params">(String size)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.size = size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getColor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setColor</span><span class="params">(String color)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getIndex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.index = index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size + color;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：斗地主游戏的案例开发。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    业务需求分析:</span></span><br><span class="line"><span class="comment">        斗地主的做牌, 洗牌, 发牌, 排序（拓展知识）, 看牌。</span></span><br><span class="line"><span class="comment">        业务: 总共有54张牌。</span></span><br><span class="line"><span class="comment">        点数: &quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;10&quot;,&quot;J&quot;,&quot;Q&quot;,&quot;K&quot;,&quot;A&quot;,&quot;2&quot;</span></span><br><span class="line"><span class="comment">        花色: &quot;♠&quot;, &quot;♥&quot;, &quot;♣&quot;, &quot;♦&quot;</span></span><br><span class="line"><span class="comment">        大小王: &quot;👲&quot; , &quot;🃏&quot;</span></span><br><span class="line"><span class="comment">        点数分别要组合4种花色，大小王各一张。</span></span><br><span class="line"><span class="comment">        斗地主：发出51张牌，剩下3张作为底牌。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    功能：</span></span><br><span class="line"><span class="comment">        1.做牌。</span></span><br><span class="line"><span class="comment">        2.洗牌。</span></span><br><span class="line"><span class="comment">        3.定义3个玩家</span></span><br><span class="line"><span class="comment">        4.发牌。</span></span><br><span class="line"><span class="comment">        5.排序（拓展，了解，作业）</span></span><br><span class="line"><span class="comment">        6.看牌</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GameDemo</span> &#123;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//1、定义一个静态的集合存储54张牌对象</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Card&gt; allCards = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">//2、做牌：定义静态代码块初始化牌数据</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 3、定义点数：个数确定，类型确定，使用数组</span></span><br><span class="line">        String[] sizes = &#123;<span class="string">&quot;3&quot;</span>,<span class="string">&quot;4&quot;</span>,<span class="string">&quot;5&quot;</span>,<span class="string">&quot;6&quot;</span>,<span class="string">&quot;7&quot;</span>,<span class="string">&quot;8&quot;</span>,<span class="string">&quot;9&quot;</span>,<span class="string">&quot;10&quot;</span>,<span class="string">&quot;J&quot;</span>,<span class="string">&quot;Q&quot;</span>,<span class="string">&quot;K&quot;</span>,<span class="string">&quot;A&quot;</span>,<span class="string">&quot;2&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">// 4、定义花色：个数确定，类型确定，使用数组</span></span><br><span class="line">        String[] colors = &#123;<span class="string">&quot;♠&quot;</span>, <span class="string">&quot;♥&quot;</span>, <span class="string">&quot;♣&quot;</span>, <span class="string">&quot;♦&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">// 5、组合点数和花色</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 记录牌的大小，计算机可识别的大小</span></span><br><span class="line">        <span class="keyword">for</span> (String size : sizes) &#123;</span><br><span class="line">            index++;  <span class="comment">//给每一个点数赋值</span></span><br><span class="line">            <span class="keyword">for</span> (String color : colors) &#123;</span><br><span class="line">                <span class="comment">// 6、封装成一个牌对象。</span></span><br><span class="line">                <span class="type">Card</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Card</span>(size, color, index);</span><br><span class="line">                <span class="comment">// 7、存入到集合容器中去</span></span><br><span class="line">                allCards.add(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 8 大小王存入到集合对象中去 &quot;👲&quot; , &quot;🃏&quot;</span></span><br><span class="line">        <span class="type">Card</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Card</span>(<span class="string">&quot;&quot;</span> ,  <span class="string">&quot;🃏&quot;</span>, ++index); <span class="comment">//++index给大小王赋值</span></span><br><span class="line">        <span class="type">Card</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Card</span>(<span class="string">&quot;&quot;</span> ,  <span class="string">&quot;👲&quot;</span>,++index);</span><br><span class="line">        Collections.addAll(allCards , c1 , c2);</span><br><span class="line">        System.out.println(<span class="string">&quot;新牌：&quot;</span> + allCards);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;   </span><br><span class="line"><span class="comment">// 9、洗牌</span></span><br><span class="line">        Collections.shuffle(allCards);</span><br><span class="line">        System.out.println(<span class="string">&quot;洗牌后：&quot;</span> + allCards);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 10、发牌（定义三个玩家，每个玩家的牌也是一个集合容器）</span></span><br><span class="line">        List&lt;Card&gt; linhuchong = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Card&gt; jiumozhi = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Card&gt; renyingying = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 11、开始发牌（从牌集合中发出51张牌给三个玩家，剩余3张作为底牌）</span></span><br><span class="line">        <span class="comment">// allCards = [🃏, A♠, 5♥, 2♠, 2♣, Q♣, 👲, Q♠ ...</span></span><br><span class="line">        <span class="comment">//    i         0   1   2   3   4   5   6   7       索引 % 3 </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; allCards.size() - <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="type">Card</span> <span class="variable">c</span> <span class="operator">=</span> allCards.get(i); <span class="comment">// 先拿到当前牌对象</span></span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                linhuchong.add(c); <span class="comment">// 请阿冲接牌</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i % <span class="number">3</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                jiumozhi.add(c);  <span class="comment">// 请阿鸠</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i % <span class="number">3</span> == <span class="number">2</span>)&#123;</span><br><span class="line">                renyingying.add(c); <span class="comment">// 请盈盈接牌</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 12、拿到最后三张底牌(把最后三张牌截取成一个子集合)</span></span><br><span class="line">        List&lt;Card&gt; lastThreeCards = allCards.subList(allCards.size() - <span class="number">3</span> , allCards.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 13、给玩家的牌排序 调用sortCards方法（从大到小）</span></span><br><span class="line">        sortCards(linhuchong);   </span><br><span class="line">        sortCards(jiumozhi);</span><br><span class="line">        sortCards(renyingying);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 14、输出玩家的牌：</span></span><br><span class="line">        System.out.println(<span class="string">&quot;啊冲：&quot;</span> + linhuchong);</span><br><span class="line">        System.out.println(<span class="string">&quot;啊鸠：&quot;</span> + jiumozhi);</span><br><span class="line">        System.out.println(<span class="string">&quot;盈盈：&quot;</span> + renyingying);</span><br><span class="line">        System.out.println(<span class="string">&quot;三张底牌：&quot;</span> + lastThreeCards);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义方法，给牌排序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sortCards</span><span class="params">(List&lt;Card&gt; cards)</span> &#123; </span><br><span class="line">        <span class="comment">// cards = [J♥, A♦, 3♥, 🃏, 5♦, Q♥, 2♥</span></span><br><span class="line">        Collections.sort(cards, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Card&gt;() &#123;   <span class="comment">//使用比较器对象</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Card o1, Card o2)</span> &#123;</span><br><span class="line">                <span class="comment">// 知道牌的大小，才可以指定规则，index是牌的真正大小</span></span><br><span class="line">                <span class="keyword">return</span> o2.getIndex() - o1.getIndex();  <span class="comment">//降序</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//代码简化</span></span><br><span class="line">        <span class="comment">// ollections.sort(cards,(o1 , o2) -&gt;o2.getIndex() - o1.getIndex());</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-Map集合体系"><a href="#6-Map集合体系" class="headerlink" title="6.Map集合体系"></a>6.Map集合体系</h3><h4 id="6-1Map集合的概述"><a href="#6-1Map集合的概述" class="headerlink" title="6.1Map集合的概述"></a>6.1Map集合的概述</h4><p><strong>Map集合概述和使用</strong></p><ul><li><p>Map集合是一种双列集合，<strong>每个元素包含两个数据</strong>。</p></li><li><p>Map集合的每个元素的格式：<strong>key&#x3D;value</strong>(键值对元素)。</p></li><li><p>Map集合也被称为“<strong>键值对集合</strong>”。</p></li></ul><p><strong>Map集合整体格式：</strong></p><ul><li><p>Collection集合的格式: [元素1,元素2,元素3..]</p></li><li><p>Map集合的完整格式：{key1&#x3D;value1 , key2&#x3D;value2 , key3&#x3D;value3 , …}</p></li></ul><p><strong>Map集合的使用场景之一：购物车系统</strong></p><p><strong>分析</strong></p><ul><li><p>购物车提供的四个商品和购买的数量在后台需要容器存储。</p></li><li><p>每个商品对象都一一对应一个购买数量。</p></li><li><p>把商品对象看成是Map集合的建，购买数量看成Map集合的值。</p></li></ul><p><strong>{商品1&#x3D;2  ,  商品2&#x3D;3 ，商品3 &#x3D; 2  , 商品4&#x3D; 3}</strong></p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1、创建一个Map集合对象</span></span><br><span class="line"><span class="comment">// Map&lt;String, Integer&gt; maps = new HashMap&lt;&gt;();//一行经典代码</span></span><br><span class="line">        Map&lt;String, Integer&gt; maps = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">        maps.put(<span class="string">&quot;鸿星尔克&quot;</span>, <span class="number">3</span>);</span><br><span class="line">        maps.put(<span class="string">&quot;Java&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        maps.put(<span class="string">&quot;枸杞&quot;</span>, <span class="number">100</span>);</span><br><span class="line">        maps.put(<span class="string">&quot;Java&quot;</span>, <span class="number">100</span>); <span class="comment">// 覆盖前面的数据</span></span><br><span class="line">        maps.put(<span class="literal">null</span>, <span class="literal">null</span>);  <span class="comment">// 可以添加null</span></span><br><span class="line">        System.out.println(maps);</span><br></pre></td></tr></table></figure><h4 id="6-2Map集合体系特点"><a href="#6-2Map集合体系特点" class="headerlink" title="6.2Map集合体系特点"></a>6.2Map集合体系特点</h4><p><strong>Map集合体系</strong></p><p><img src="C:\Users\廖永森\AppData\Roaming\Typora\typora-user-images\image-20220204162909691.png" alt="image-20220204162909691"></p><p><strong>Map集合体系特点</strong></p><ul><li><p>Map集合的特点都是由<strong>键决定</strong>的。</p></li><li><p>Map集合的<strong>键是无序，不重复的，无索引的</strong>，<strong>值不做要求</strong>（可以重复）。</p></li><li><p><strong>Map集合后面重复的键对应的值会覆盖前面重复键的值。</strong></p></li><li><p>Map集合的键值对都可以为null。</p></li></ul><p><strong>Map集合实现类特点</strong></p><ul><li><p>HashMap:元素按照键是<strong>无序</strong>，不重复，无索引，值不做要求。（与Map体系一致）</p></li><li><p>LinkedHashMap:元素按照键是<strong>有序</strong>，不重复，无索引，值不做要求。</p></li><li><p>TreeMap：元素按照建是<strong>排序</strong>，不重复，无索引的，值不做要求。</p></li></ul><h4 id="6-3Map集合常用API"><a href="#6-3Map集合常用API" class="headerlink" title="6.3Map集合常用API"></a>6.3Map集合常用API</h4><p><strong>Map集合</strong> </p><ul><li>Map是双列集合的祖宗接口，它的功能是全部双列集合都可以继承使用的。</li></ul><p><strong>Map  API如下:</strong></p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>V  **put(**K key,V value)</td><td>添加元素</td></tr><tr><td>V  <strong>remove</strong>(Object key)</td><td>根据键删除键值对元素</td></tr><tr><td>void  <strong>clear</strong>()</td><td>移除所有的键值对元素</td></tr><tr><td>boolean <strong>containsKey</strong>(Object key)</td><td>判断集合是否包含指定的键</td></tr><tr><td>boolean <strong>containsValue</strong>(Object value)</td><td>判断集合是否包含指定的值</td></tr><tr><td>boolean <strong>isEmpty</strong>()</td><td>判断集合是否为空</td></tr><tr><td>int  <strong>size</strong>()</td><td>集合的长度，也就是集合中键值对的个数</td></tr></tbody></table><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：Map集合的常用API(重点中的重点)</span></span><br><span class="line"><span class="comment">     - public V put(K key, V value):  把指定的键与指定的值添加到Map集合中。</span></span><br><span class="line"><span class="comment">     - public V remove(Object key): 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。</span></span><br><span class="line"><span class="comment">     - public V get(Object key) 根据指定的键，在Map集合中获取对应的值。</span></span><br><span class="line"><span class="comment">     - public Set&lt;K&gt; keySet(): 获取Map集合中所有的键，存储到Set集合中。</span></span><br><span class="line"><span class="comment">     - public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet(): 获取到Map集合中所有的键值对对象的集合(Set集合)。</span></span><br><span class="line"><span class="comment">     - public boolean containKey(Object key):判断该集合中是否有此键。</span></span><br><span class="line"><span class="comment">     - public boolean containValue(Object value):判断该集合中是否有此值。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.添加元素: 无序，不重复，无索引。</span></span><br><span class="line">        Map&lt;String , Integer&gt; maps = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        maps.put(<span class="string">&quot;iphoneX&quot;</span>,<span class="number">10</span>);</span><br><span class="line">        maps.put(<span class="string">&quot;娃娃&quot;</span>,<span class="number">20</span>);</span><br><span class="line">        maps.put(<span class="string">&quot;iphoneX&quot;</span>,<span class="number">100</span>);<span class="comment">//  Map集合后面重复的键对应的元素会覆盖前面重复的整个元素！</span></span><br><span class="line">        maps.put(<span class="string">&quot;huawei&quot;</span>,<span class="number">100</span>);</span><br><span class="line">        maps.put(<span class="string">&quot;生活用品&quot;</span>,<span class="number">10</span>);</span><br><span class="line">        maps.put(<span class="string">&quot;手表&quot;</span>,<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// &#123;huawei=100, 手表=10, 生活用品=10, iphoneX=100, 娃娃=20&#125;</span></span><br><span class="line">        System.out.println(maps);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.清空集合</span></span><br><span class="line"><span class="comment">//        maps.clear();</span></span><br><span class="line"><span class="comment">//        System.out.println(maps);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.判断集合是否为空，为空返回true ,反之！</span></span><br><span class="line">        System.out.println(maps.isEmpty());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.根据键获取对应值:public V get(Object key)</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">key</span> <span class="operator">=</span> maps.get(<span class="string">&quot;huawei&quot;</span>);</span><br><span class="line">        System.out.println(key);</span><br><span class="line">        System.out.println(maps.get(<span class="string">&quot;生活用品&quot;</span>)); <span class="comment">// 10</span></span><br><span class="line">        System.out.println(maps.get(<span class="string">&quot;生活用品2&quot;</span>)); <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.根据键删除整个元素。(删除键会返回键的值)</span></span><br><span class="line">        System.out.println(maps.remove(<span class="string">&quot;iphoneX&quot;</span>));  <span class="comment">//100</span></span><br><span class="line">        System.out.println(maps);  <span class="comment">//// &#123;huawei=100, 手表=10, 生活用品=10, 娃娃=20&#125; </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.判断是否包含某个键 ，包含返回true ,反之</span></span><br><span class="line">        System.out.println(maps.containsKey(<span class="string">&quot;娃娃&quot;</span>));  <span class="comment">// true</span></span><br><span class="line">        System.out.println(maps.containsKey(<span class="string">&quot;娃娃2&quot;</span>));  <span class="comment">// false</span></span><br><span class="line">        System.out.println(maps.containsKey(<span class="string">&quot;iphoneX&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7.判断是否包含某个值。</span></span><br><span class="line">        System.out.println(maps.containsValue(<span class="number">100</span>));  <span class="comment">// ture</span></span><br><span class="line">        System.out.println(maps.containsValue(<span class="number">10</span>));   <span class="comment">// ture</span></span><br><span class="line">        System.out.println(maps.containsValue(<span class="number">22</span>));   <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// &#123;huawei=100, 手表=10, 生活用品=10, 娃娃=20&#125;</span></span><br><span class="line">        <span class="comment">// 8.获取全部键的集合：public Set&lt;K&gt; keySet()  </span></span><br><span class="line">           <span class="comment">//Set也是不重复的，所以使用Set集合</span></span><br><span class="line">        Set&lt;String&gt; keys = maps.keySet();  </span><br><span class="line">        System.out.println(keys); <span class="comment">// [huawei, 手表, 生活用品, 娃娃]</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;------------------------------&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 9.获取全部值的集合：Collection&lt;V&gt; values();</span></span><br><span class="line">           <span class="comment">//值不需要考虑重复的问题，所以用Collection集合</span></span><br><span class="line">        Collection&lt;Integer&gt; values = maps.values();</span><br><span class="line">        System.out.println(values); <span class="comment">// [100, 10, 10, 20]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 10.集合的大小</span></span><br><span class="line">        System.out.println(maps.size()); <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 11.合并其他Map集合。(拓展)</span></span><br><span class="line">        Map&lt;String , Integer&gt; map1 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map1.put(<span class="string">&quot;java1&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        map1.put(<span class="string">&quot;java2&quot;</span>, <span class="number">100</span>);</span><br><span class="line">        Map&lt;String , Integer&gt; map2 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map2.put(<span class="string">&quot;java2&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        map2.put(<span class="string">&quot;java3&quot;</span>, <span class="number">100</span>);</span><br><span class="line">        map1.putAll(map2); <span class="comment">// 把集合map2的元素拷贝一份到map1中去</span></span><br><span class="line">        System.out.println(map1); </span><br><span class="line">        System.out.println(map2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-4Map集合的遍历"><a href="#6-4Map集合的遍历" class="headerlink" title="6.4Map集合的遍历"></a>6.4Map集合的遍历</h4><p><strong>Map集合的遍历方式有：3种。</strong></p><ul><li><p>方式一：键找值的方式遍历：先获取Map集合全部的键，再根据遍历键找值。</p></li><li><p>方式二：键值对的方式遍历，把“键值对“看成一个整体，难度较大。</p></li><li><p>方式三：JDK 1.8开始之后的新技术：Lambda表达式。（暂时了解）</p></li></ul><h5 id="6-4-1方式一：键找值"><a href="#6-4-1方式一：键找值" class="headerlink" title="6.4.1方式一：键找值"></a>6.4.1方式一：键找值</h5><p><strong>键找值流程</strong></p><p><img src="C:\Users\廖永森\AppData\Roaming\Typora\typora-user-images\image-20220204164759590.png" alt="image-20220204164759590"></p><ul><li><p>先获取Map集合的全部键的Set集合。</p></li><li><p>遍历键的Set集合，然后通过键提取对应值。</p></li></ul><p><strong>键找值涉及到的API:</strong></p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>Set<K>  keySet()</td><td>获取所有键的集合</td></tr><tr><td>V  get(Object key)</td><td>根据键获取值</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：Map集合的遍历方式一：键找值</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">        1.先获取Map集合的全部键的Set集合。</span></span><br><span class="line"><span class="comment">        2.遍历键的Set集合，然后通过键找值。</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">    小结：</span></span><br><span class="line"><span class="comment">        代码简单，需要记住!</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;String , Integer&gt; maps = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 添加元素: 无序，不重复，无索引。</span></span><br><span class="line">        maps.put(<span class="string">&quot;娃娃&quot;</span>,<span class="number">30</span>);</span><br><span class="line">        maps.put(<span class="string">&quot;iphoneX&quot;</span>,<span class="number">100</span>);</span><br><span class="line">        maps.put(<span class="string">&quot;huawei&quot;</span>,<span class="number">1000</span>);</span><br><span class="line">        maps.put(<span class="string">&quot;生活用品&quot;</span>,<span class="number">10</span>);</span><br><span class="line">        maps.put(<span class="string">&quot;手表&quot;</span>,<span class="number">10</span>);</span><br><span class="line">        System.out.println(maps);</span><br><span class="line">        <span class="comment">// maps = &#123;huawei=1000, 手表=10, 生活用品=10, iphoneX=100, 娃娃=30&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、键找值：第一步：keySet方法拿到集合的全部键</span></span><br><span class="line">        Set&lt;String&gt; keys = maps.keySet();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2、第二步：遍历每个键，根据键提取值</span></span><br><span class="line">        <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> maps.get(key);  </span><br><span class="line">            System.out.println(key + <span class="string">&quot;===&gt;&quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="6-4-2方式二：键值对"><a href="#6-4-2方式二：键值对" class="headerlink" title="6.4.2方式二：键值对"></a>6.4.2方式二：键值对</h5><ul><li><p>先把Map集合转换成Set集合，Set集合中每个元素都是键值对实体类型了。</p></li><li><p>遍历Set集合，然后提取键以及提取值。</p></li></ul><p><strong>键值对涉及到的API:</strong></p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</td><td>获取所有键值对对象的集合</td></tr><tr><td>K getKey()</td><td>获得键</td></tr><tr><td>V getValue()</td><td>获取值</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">目标：Map集合的遍历方式二：键值对</span></span><br><span class="line"><span class="comment">    1.先把Map集合转换成Set集合，Set集合中每个元素都是键值对实体类型了。</span></span><br><span class="line"><span class="comment">     2.遍历Set集合，然后提取键以及提取值。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">目标集合 maps = &#123;huawei = 1000, 手表 = 10, 生活用品 = 10 , phoneX = 100 , 娃娃 = 30&#125;</span></span><br><span class="line"><span class="comment">                👇</span></span><br><span class="line"><span class="comment">            使用foreach遍历map集合.发现Map集合的键值对元素直接是没有类型的。所以不可以直接foreach遍历集合。</span></span><br><span class="line"><span class="comment">                👇</span></span><br><span class="line"><span class="comment">            可以通过调用Map的方法 entrySet把Map集合转换成Set集合形式(键值对为整体)  maps.entrySet();</span></span><br><span class="line"><span class="comment">                👇  </span></span><br><span class="line"><span class="comment">            Set&lt;Map.Entry&lt;String,Integer&gt;&gt; entries =  maps.entrySet();</span></span><br><span class="line"><span class="comment">             [(huawei=1000), (手表=10), (生活用品=10), (iphoneX=100), (娃娃=30)]       </span></span><br><span class="line"><span class="comment">                👇</span></span><br><span class="line"><span class="comment">            此时可以使用foreach遍历</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;String , Integer&gt; maps = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 添加元素: 无序，不重复，无索引。</span></span><br><span class="line">        maps.put(<span class="string">&quot;娃娃&quot;</span>,<span class="number">30</span>);</span><br><span class="line">        maps.put(<span class="string">&quot;iphoneX&quot;</span>,<span class="number">100</span>);</span><br><span class="line">        maps.put(<span class="string">&quot;huawei&quot;</span>,<span class="number">1000</span>);</span><br><span class="line">        maps.put(<span class="string">&quot;生活用品&quot;</span>,<span class="number">10</span>);</span><br><span class="line">        maps.put(<span class="string">&quot;手表&quot;</span>,<span class="number">10</span>);</span><br><span class="line">        System.out.println(maps);</span><br><span class="line">        <span class="comment">// maps = &#123;huawei=1000, 手表=10, 生活用品=10, iphoneX=100, 娃娃=30&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、把Map集合转换成Set集合</span></span><br><span class="line">        Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entries = maps.entrySet();  <span class="comment">//maps.entrySet() V快捷键补全</span></span><br><span class="line">        <span class="comment">// 2、开始遍历</span></span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;String, Integer&gt; entry : entries)&#123;  <span class="comment">// maps.entrySet() 快捷键补全</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">            System.out.println(key + <span class="string">&quot;====&gt;&quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="6-4-3方式三：lambda表达式"><a href="#6-4-3方式三：lambda表达式" class="headerlink" title="6.4.3方式三：lambda表达式"></a>6.4.3方式三：lambda表达式</h5><ul><li>得益于JDK 8开始的新技术Lambda表达式，提供了一种更简单、更直接的遍历集合的方式。</li></ul><p><strong>Map结合Lambda遍历的API</strong></p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>default void <strong>forEach</strong>(BiConsumer&lt;?  super  K,  ? super  V&gt;  action)</td><td>结合lambda遍历Map集合</td></tr></tbody></table><p><strong>流程</strong></p><p><img src="C:\Users\廖永森\AppData\Roaming\Typora\typora-user-images\image-20220204170016594.png" alt="image-20220204170016594"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：Map集合的遍历方式。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    c.JDK 1.8开始之后的新技术：Lambda表达式。（暂时了解）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapDemo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;String , Integer&gt; maps = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 1.添加元素: 无序，不重复，无索引。</span></span><br><span class="line">        maps.put(<span class="string">&quot;娃娃&quot;</span>,<span class="number">30</span>);</span><br><span class="line">        maps.put(<span class="string">&quot;iphoneX&quot;</span>,<span class="number">100</span>);</span><br><span class="line">        maps.put(<span class="string">&quot;huawei&quot;</span>,<span class="number">1000</span>);</span><br><span class="line">        maps.put(<span class="string">&quot;生活用品&quot;</span>,<span class="number">10</span>);</span><br><span class="line">        maps.put(<span class="string">&quot;手表&quot;</span>,<span class="number">10</span>);</span><br><span class="line">        System.out.println(maps);</span><br><span class="line"><span class="comment">//  maps = &#123;huawei=1000, 手表=10, 生活用品=10, iphoneX=100, 娃娃=30&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        maps.forEach(new BiConsumer&lt;String, Integer&gt;() &#123;     // maps.forEach(new Bi...) 快捷键补全</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public void accept(String key, Integer value) &#123;</span></span><br><span class="line"><span class="comment">//                System.out.println(key + &quot;---&gt;&quot; + value);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//简化</span></span><br><span class="line">        maps.forEach((k, v) -&gt; &#123;</span><br><span class="line">                System.out.println(k + <span class="string">&quot;---&gt;&quot;</span> + v);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-5Map集合案例"><a href="#6-5Map集合案例" class="headerlink" title="6.5Map集合案例"></a>6.5Map集合案例</h4><p>统计投票人数</p><p><strong>需求</strong></p><p>某个班级80名学生，现在需要组成秋游活动，班长提供了四个景点依次是（A、B、C、D）,每个学生只能选择一个景点，请统计出最终哪个景点想去的人数最多。</p><p><strong>分析</strong></p><ul><li><p>将80个学生选择的数据拿到程序中去。</p></li><li><p>定义Map集合用于存储最终统计的结果。</p></li><li><p>遍历80个学生选择的数据，看Map集合中是否存在，不存在存入“数据&#x3D;1“，存在则其对应值+1,</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   需求：统计投票人数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">         <span class="comment">// 1、把80个学生选择的数据拿进来。</span></span><br><span class="line">        String[] selects = &#123;<span class="string">&quot;A&quot;</span> , <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>&#125;;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">80</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> r.nextInt(<span class="number">0</span>,<span class="number">4</span>);</span><br><span class="line">            sb.append(selects[index]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sb);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、定义一个Map集合记录最终统计的结果： A=30 B=20 C=20 D=10  键是景点 值是选择的数量</span></span><br><span class="line">        Map&lt;Character, Integer&gt; infos = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、遍历80个学生选择的数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sb.length(); i++) &#123;</span><br><span class="line">            <span class="comment">// 4、提取当前选择景点字符</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> sb.charAt(i);</span><br><span class="line">            <span class="comment">// 5、判断Map集合中是否存在这个键</span></span><br><span class="line">            <span class="keyword">if</span>(infos.containsKey(ch))&#123;  <span class="comment">//集合infos中存在ch</span></span><br><span class="line">                 <span class="comment">// 让其值 + 1</span></span><br><span class="line">                infos.put(ch , infos.get(ch) + <span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123; <span class="comment">//集合infos中不存在ch   </span></span><br><span class="line">                <span class="comment">// 说明此景点是第一次被选</span></span><br><span class="line">                infos.put(ch , <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、输出集合</span></span><br><span class="line">        System.out.println(infos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-6Map集合的实现类HashMap"><a href="#6-6Map集合的实现类HashMap" class="headerlink" title="6.6Map集合的实现类HashMap"></a>6.6Map集合的实现类HashMap</h4><p><img src="C:\Users\廖永森\AppData\Roaming\Typora\typora-user-images\image-20220205125149183.png" alt="image-20220205125149183"></p><p><strong>HashMap的特点</strong></p><ul><li><p>HashMap是Map里面的一个实现类。<strong>特点都是由键决定的：无序、不重复、无索引</strong></p></li><li><p>依赖<strong>hashCode</strong>方法和<strong>equals</strong>方法保证<strong>键</strong>的唯一。</p><p>如果<strong>键</strong>要存储的是<strong>自定义对象</strong>，需要重写hashCode和equals方法。</p></li><li><p>HashMap跟HashSet底层原理是一模一样的，都是<strong>哈希表结构</strong>，只是HashMap的每个元素包含两个值而已。</p></li><li><p>没有额外需要学习的特有方法，直接使用Map里面的方法就可以了。</p></li></ul><p><strong>实际上：Set系列集合的底层就是Map实现的，只是Set集合中的元素只要键数据，不要值数据而已。</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//底层</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span> &#123;</span><br><span class="line">map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>案例：</strong></p><p><strong>HashMap集合存储自定义对象并遍历</strong></p><p><strong>需求：</strong></p><p>创建一个HashMap集合，键是学生对象(Student)，值是籍贯(String)。存储三个键值对元素，并遍历</p><p><strong>思路：</strong></p><p>①定义学生类</p><p>②创建HashMap集合对象</p><p>③创建学生对象</p><p>④把学生添加到集合</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Map集合是根据键去除重复元素</span></span><br><span class="line">        Map&lt;Student, String&gt; maps = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;无恙&quot;</span>, <span class="number">20</span>, <span class="string">&#x27;男&#x27;</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;无恙&quot;</span>, <span class="number">20</span>, <span class="string">&#x27;男&#x27;</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;周雄&quot;</span>, <span class="number">21</span>, <span class="string">&#x27;男&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        maps.put(s1, <span class="string">&quot;北京&quot;</span>);</span><br><span class="line">        maps.put(s2, <span class="string">&quot;上海&quot;</span>);</span><br><span class="line">        maps.put(s3, <span class="string">&quot;广州&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(maps); <span class="comment">//学生信息是键，地址是值</span></span><br></pre></td></tr></table></figure><h4 id="6-7Map集合的实现类LinkedHashMap"><a href="#6-7Map集合的实现类LinkedHashMap" class="headerlink" title="6.7Map集合的实现类LinkedHashMap"></a>6.7Map集合的实现类LinkedHashMap</h4><p><strong>LinkedHashMap集合概述和特点</strong></p><ul><li><p><strong>由键决定：有序、不重复、无索引。</strong></p></li><li><p>这里的有序指的是<strong>保证存储和取出的元素顺序一致</strong></p></li><li><p><strong>原理</strong>：底层数据结构是依然<strong>哈希表</strong>，只是每个键值对元素又额外的多了一个<strong>双链表</strong>的机制记录存储的顺序。</p></li></ul><p><img src="C:\Users\廖永森\AppData\Roaming\Typora\typora-user-images\image-20220205125949298.png" alt="image-20220205125949298"></p><h4 id="6-8Map集合的实现类TreeMap"><a href="#6-8Map集合的实现类TreeMap" class="headerlink" title="6.8Map集合的实现类TreeMap"></a>6.8Map集合的实现类TreeMap</h4><p><strong>TreeMap集合概述和特点</strong></p><ul><li><p><strong>由键决定特性：可排序、不重复、无索引</strong></p></li><li><p>可排序：按照键数据的大小默认升序（有小到大）排序。<strong>只能对键排序。</strong></p></li><li><p><strong>注意：TreeMap集合是一定要排序的，可以默认排序，也可以将键按照指定的规则进行排序</strong></p></li><li><p>TreeMap跟TreeSet一样底层原理是一样的(基于红黑树)。</p></li></ul><p><strong>TreeMap集合自定义排序规则有2种</strong></p><ul><li><p>类实现Comparable接口，重写比较规则。</p></li><li><p>集合自定义Comparator比较器对象，重写比较规则。</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Comparator比较器对象</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// TreeMap集合自带排序。  可排序 不重复（只要大小规则一样就认为重复）  无索引</span></span><br><span class="line">Map&lt;Apple, String&gt; maps2 = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Apple&gt;() &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Apple o1, Apple o2)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> Double.compare(o2.getPrice() , o1.getPrice()); <span class="comment">// 按照价格降序排序！</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">   maps2.put(<span class="keyword">new</span> <span class="title class_">Apple</span>(<span class="string">&quot;红富士&quot;</span>, <span class="string">&quot;红色&quot;</span>, <span class="number">9.9</span>, <span class="number">500</span>), <span class="string">&quot;山东&quot;</span> );</span><br><span class="line">   maps2.put(<span class="keyword">new</span> <span class="title class_">Apple</span>(<span class="string">&quot;青苹果&quot;</span>, <span class="string">&quot;绿色&quot;</span>, <span class="number">15.9</span>, <span class="number">300</span>), <span class="string">&quot;广州&quot;</span>);</span><br><span class="line">   maps2.put(<span class="keyword">new</span> <span class="title class_">Apple</span>(<span class="string">&quot;绿苹果&quot;</span>, <span class="string">&quot;青色&quot;</span>, <span class="number">29.9</span>, <span class="number">400</span>), <span class="string">&quot;江西&quot;</span>);</span><br><span class="line">   maps2.put(<span class="keyword">new</span> <span class="title class_">Apple</span>(<span class="string">&quot;黄苹果&quot;</span>, <span class="string">&quot;黄色&quot;</span>, <span class="number">9.8</span>, <span class="number">500</span>), <span class="string">&quot;湖北&quot;</span>);</span><br><span class="line"></span><br><span class="line">   System.out.println(maps2);</span><br></pre></td></tr></table></figure><h3 id="7-补充知识：集合的嵌套"><a href="#7-补充知识：集合的嵌套" class="headerlink" title="7.补充知识：集合的嵌套"></a>7.补充知识：集合的嵌套</h3><p><strong>Map集合案例</strong></p><p>统计投票人数</p><p><strong>需求</strong></p><ul><li>某个班级多名学生，现在需要组成秋游活动，班长提供了四个景点依次是（A、B、C、D）,每个学生可以选择多个景点，请统计出最终哪个景点想去的人数最多。</li></ul><p><strong>分析</strong></p><ul><li><p>将80个学生选择的数据拿到程序中去，需要记住每个学生选择的情况。</p></li><li><p>定义Map集合用于存储最终统计的结果。</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   需求：统计投票人数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapTest4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、要求程序记录每个学生选择的情况。</span></span><br><span class="line">        <span class="comment">// 使用一个Map集合存储。</span></span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; data = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、把学生选择的数据存入进去。</span></span><br><span class="line">        List&lt;String&gt; selects = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(selects, <span class="string">&quot;A&quot;</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">        data.put(<span class="string">&quot;罗勇&quot;</span>, selects);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; selects1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(selects1, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span> , <span class="string">&quot;D&quot;</span>);</span><br><span class="line">        data.put(<span class="string">&quot;胡涛&quot;</span>, selects1);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; selects2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(selects2 , <span class="string">&quot;A&quot;</span>,  <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span> , <span class="string">&quot;D&quot;</span>);</span><br><span class="line">        data.put(<span class="string">&quot;刘军&quot;</span>, selects2);</span><br><span class="line"></span><br><span class="line">        System.out.println(data);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、统计每个景点选择的人数。</span></span><br><span class="line">        <span class="comment">//  &lt;ABCD选项，出现的次数&gt;</span></span><br><span class="line">        Map&lt;String, Integer&gt; infos = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(); <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、提取所有人选择的景点的信息。</span></span><br><span class="line">         <span class="comment">// 提取data的值 --&gt; &lt;List&lt;String&gt;</span></span><br><span class="line">        Collection&lt;List&lt;String&gt;&gt; values = data.values();</span><br><span class="line">        System.out.println(values);</span><br><span class="line">        <span class="comment">// values = [[A, B, C, D], [B, C, D], [A, C]]</span></span><br><span class="line">        <span class="comment">//              value</span></span><br><span class="line">        <span class="comment">//            s</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (List&lt;String&gt; value : values) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String s : value) &#123;</span><br><span class="line">                <span class="comment">// 有没有包含这个景点</span></span><br><span class="line">                <span class="keyword">if</span>(infos.containsKey(s))&#123;</span><br><span class="line">                    infos.put(s, infos.get(s) + <span class="number">1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    infos.put(s , <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(infos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> java,面向对象进阶,Set,Collections,Map,集合嵌套 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>day14 - 集合</title>
      <link href="/post/eb2b9d82.html"/>
      <url>/post/eb2b9d82.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-集合的概述"><a href="#1-集合的概述" class="headerlink" title="1.集合的概述"></a>1.集合的概述</h3><p>集合和数组都是容器。</p><p><strong>数组的特点</strong></p><ul><li><p>数组定义完成并启动后，<strong>类型确定、长度固定</strong>。</p></li><li><p>适合元素的个数和类型确定的业务场景，不适合做需要增删数据操作。</p></li></ul><p>1、数组和集合的元素存储的个数问题。</p><ul><li><p><strong>数组</strong>定义后类型确定，长度固定</p></li><li><p><strong>集合</strong>类型可以不固定，大小是可变的。</p></li></ul><p>2、数组和集合存储元素的类型问题。</p><ul><li><p><strong>数组</strong>可以存储基本类型和引用类型的数据。</p></li><li><p><strong>集合</strong>只能存储引用数据类型的数据。</p></li></ul><p>3、数组和集合适合的场景</p><ul><li><p><strong>数组</strong>适合做数据个数和类型确定的场景。</p></li><li><p><strong>集合</strong>适合做数据个数不确定，且要做增删元素的场景。</p></li></ul><h3 id="2-集合的体系特点"><a href="#2-集合的体系特点" class="headerlink" title="2.集合的体系特点"></a>2.集合的体系特点</h3><p><strong>集合的代表</strong></p><ul><li><strong>Collection接口。</strong></li></ul><p><strong>集合类体系结构</strong></p><ul><li><p>Collection单列集合，每个元素（数据）只包含一个值。</p></li><li><p>Map双列集合，每个元素包含两个值（键值对）。</p></li><li><p><strong>注意：前期先掌握Collection集合体系的使用。</strong></p></li></ul><p><strong>Collection集合体系</strong></p><ol><li><strong>Collection 接口</strong>：<code>Collection</code> 接口是所有集合类的根接口，它定义了基本的集合操作，如添加、删除、遍历等。<code>Collection</code> 接口又分为以下几种常见的子接口和实现类：<ul><li><code>List</code>：有序的集合，允许重复元素。常见的实现类有 <code>ArrayList</code>、<code>LinkedList</code> 和 <code>Vector</code>。</li><li><code>Set</code>：不允许重复元素的集合。常见的实现类有 <code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code>。</li><li><code>Queue</code>：队列集合，支持在一端插入元素，在另一端删除元素。常见的实现类有 <code>LinkedList</code> 和 <code>PriorityQueue</code>。</li></ul></li><li><strong>Map 接口</strong>：<code>Map</code> 接口用于存储键-值对，每个键映射到一个值。<code>Map</code> 接口提供了以键为索引进行访问的功能。常见的实现类有：<ul><li><code>HashMap</code>：基于哈希表实现，无序。</li><li><code>LinkedHashMap</code>：基于链表和哈希表实现，保持插入顺序。</li><li><code>TreeMap</code>：基于红黑树实现，按照键的自然顺序或自定义顺序排序。</li><li><code>Hashtable</code>：类似于 <code>HashMap</code>，但是线程安全（不推荐使用，因为性能相对较差）。</li></ul></li></ol><p><strong>Collection集合特点</strong></p><ul><li><p><strong>List系列集合</strong>：添加的元素是有序、可重复、有索引。</p><ul><li>ArrayList、LinekdList ：<strong>有序、可重复、有索引。</strong></li></ul></li><li><p><strong>Set系列集合</strong>：添加的元素是无序、不重复、无索引。</p><ul><li>HashSet: 无序、不重复、无索引；LinkedHashSet: <strong>有序、不重复、无索引。</strong></li><li>TreeSet：<strong>按照大小默认升序排序、不重复、无索引。</strong></li></ul></li></ul><p><strong>集合对于泛型的支持</strong></p><ul><li>集合都是支持泛型的，可以在编译阶段约束集合只能操作某种数据类型</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection&lt;String&gt; lists = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">Collection&lt;String&gt; lists = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); </span><br><span class="line"><span class="comment">// JDK 1.7开始后面的泛型类型申明可以省略不写</span></span><br></pre></td></tr></table></figure><p><strong>注意：集合和泛型都只能支持引用数据类型，不支持基本数据类型，所以集合中存储的元素都认为是对象。</strong></p><h3 id="3-Collection的常用API"><a href="#3-Collection的常用API" class="headerlink" title="3.Collection的常用API"></a>3.Collection的常用API</h3><p><strong>Collection集合</strong> </p><ul><li>Collection是单列集合的祖宗接口，它的功能是全部单列集合都可以继承使用的。</li></ul><p><strong>Collection API如下:</strong></p><table><thead><tr><th>方法名称</th><th align="left">说明</th></tr></thead><tbody><tr><td>public  boolean add(E e)</td><td align="left">把给定的对象添加到当前集合中</td></tr><tr><td>public  void clear()</td><td align="left">清空集合中所有的元素</td></tr><tr><td>public  boolean remove(E e)</td><td align="left">把给定的对象在当前集合中删除</td></tr><tr><td>public  boolean contains(Object obj)</td><td align="left">判断当前集合中是否包含给定的对象(使用<strong>多态Collection和Set系列</strong>创建对象,不支持索引)</td></tr><tr><td>public  boolean isEmpty()</td><td align="left">判断当前集合是否为空</td></tr><tr><td>public  int size()</td><td align="left">返回集合中元素的个数。</td></tr><tr><td>public  Object[] toArray()</td><td align="left">把集合中的元素，存储到数组中  (需要使用Object[]  类来接，否则报错)</td></tr></tbody></table><h3 id="4-集合的遍历方式"><a href="#4-集合的遍历方式" class="headerlink" title="4.集合的遍历方式"></a>4.集合的遍历方式</h3><h4 id="4-1迭代器"><a href="#4-1迭代器" class="headerlink" title="4.1迭代器"></a>4.1迭代器</h4><p><strong>迭代器遍历概述</strong></p><ul><li><p>遍历就是一个一个的把容器中的元素访问一遍。 </p></li><li><p>迭代器在Java中的代表是<strong>Iterator</strong>，迭代器是集合的专用遍历方式。</p><p>*Iterator<E> iterator()*：得到迭代器对象</p></li></ul><p><strong>Collection集合获取迭代器</strong></p><table><thead><tr><th align="left">方法名称</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><strong>Iterator<E></strong>  <strong>iterator()</strong></td><td align="left">返回集合中的迭代器对象，该迭代器对象默认指向当前集合的0索引</td></tr></tbody></table><p><strong>Iterator中的常用方法</strong></p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>boolean <strong>hasNext</strong>()</td><td>询问当前位置是否有元素存在，存在返回true(循环继续),不存在返回false(循环结束)</td></tr><tr><td>E  <strong>next</strong>()</td><td>获取当前位置的元素，并同时将迭代器对象移向下一个位置，注意防止取出越界。</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;String&gt; it = lists.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;  <span class="comment">//使用hasNext判断是否有元素存在，循环遍历</span></span><br><span class="line"><span class="type">String</span> <span class="variable">ele</span> <span class="operator">=</span> it.next();</span><br><span class="line">System.out.println(ele);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代器如果取元素越界会出现什么问题</p><ul><li><strong>会出现NoSuchElementException异常。</strong></li></ul><h4 id="4-2foreach-增强for循环"><a href="#4-2foreach-增强for循环" class="headerlink" title="4.2foreach&#x2F;增强for循环"></a>4.2foreach&#x2F;增强for循环</h4><p><strong>增强fo循环</strong></p><p>for(<strong>元素数据类型</strong> <strong>变量名</strong> : <strong>数组或者Collection集合对象</strong>) {</p><p>​     &#x2F;&#x2F;在此处使用变量即可，该变量就是元素</p><p>}</p><ul><li>增强for循环：既可以<strong>遍历集合</strong>也可以<strong>遍历数组</strong>。（ Iterator 迭代器 ，只能遍历集合）</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span>(String ele : list) &#123;</span><br><span class="line">System.out.println(ele);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>快捷键：变量名.for回车</p><p><strong>修改第三方变量的值不会影响到集合中的元素</strong></p><h4 id="4-3lambda表达式"><a href="#4-3lambda表达式" class="headerlink" title="4.3lambda表达式"></a>4.3lambda表达式</h4><p><strong>Lambda表达式遍历集合</strong></p><ul><li>得益于JDK 8开始的新技术Lambda表达式，提供了一种更简单、更直接的遍历集合的方式。</li></ul><p><strong>Collection结合Lambda遍历的API</strong></p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>default void <strong>forEach</strong>(Consumer&lt;? super T&gt; action):</td><td>结合lambda遍历集合</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection&lt;String&gt; lists = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">...</span><br><span class="line">lists.forEach(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span> &#123;</span><br><span class="line">System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//简化</span></span><br><span class="line">   lists.forEach(s -&gt; &#123;</span><br><span class="line">       System.out.println(s);</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//简化</span></span><br><span class="line">lists.forEach(s -&gt; System.out.println(s));</span><br><span class="line"></span><br><span class="line"><span class="comment">//再简化</span></span><br><span class="line">lists.forEach(System.out::println);</span><br></pre></td></tr></table></figure><h3 id="5-集合存储自定义类型的对象"><a href="#5-集合存储自定义类型的对象" class="headerlink" title="5.集合存储自定义类型的对象"></a>5.集合存储自定义类型的对象</h3><p><strong>案例：</strong></p><p>影片信息在程序中的表示</p><p><strong>需求</strong></p><ul><li>某影院系统需要在后台存储上述三部电影，然后依次展示出来。</li></ul><p><strong>分析</strong></p><p>①：定义一个电影类，定义一个集合存储电影对象。</p><p>②：创建3个电影对象，封装相关数据，把3个对象存入到集合中去。</p><p>③：遍历集合中的3个对象，输出相关信息。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1、定义一个电影类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、定义一个集合对象存储3部电影对象</span></span><br><span class="line">        Collection&lt;Movie&gt; movies = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        movies.add(<span class="keyword">new</span> <span class="title class_">Movie</span>(<span class="string">&quot;《你好，李焕英》&quot;</span>, <span class="number">9.5</span>, <span class="string">&quot;张小斐,贾玲,沈腾,陈赫&quot;</span>));</span><br><span class="line">        movies.add(<span class="keyword">new</span> <span class="title class_">Movie</span>(<span class="string">&quot;《唐人街探案》&quot;</span>, <span class="number">8.5</span>, <span class="string">&quot;王宝强,刘昊然&quot;</span>));</span><br><span class="line">        movies.add(<span class="keyword">new</span> <span class="title class_">Movie</span>(<span class="string">&quot;《刺杀小说家》&quot;</span>,<span class="number">8.6</span>, <span class="string">&quot;雷佳音,杨幂&quot;</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(movies);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、遍历集合容器中的每个电影对象</span></span><br><span class="line">        <span class="keyword">for</span> (Movie movie : movies) &#123;  <span class="comment">//增强for</span></span><br><span class="line">            System.out.println(<span class="string">&quot;片名：&quot;</span> + movie.getName());</span><br><span class="line">            System.out.println(<span class="string">&quot;得分：&quot;</span> + movie.getScore());</span><br><span class="line">            System.out.println(<span class="string">&quot;主演：&quot;</span> + movie.getActor());</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><strong>集合中存储的是元素的什么信息?</strong></p><ul><li><strong>集合中存储的是元素对象的地址。</strong></li></ul><h3 id="6-常见数据结构"><a href="#6-常见数据结构" class="headerlink" title="6.常见数据结构"></a>6.常见数据结构</h3><h4 id="6-1数据结构概述、栈、队列"><a href="#6-1数据结构概述、栈、队列" class="headerlink" title="6.1数据结构概述、栈、队列,"></a>6.1数据结构概述、栈、队列,</h4><p><strong>数据结构概述</strong></p><ul><li><p>数据结构是计算机底层存储、组织数据的方式。是指数据相互之间是以什么方式排列在一起的。</p></li><li><p>通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率</p></li></ul><p><strong>常见的数据结构</strong></p><ul><li><p>栈</p></li><li><p>队列</p></li><li><p>数组</p></li><li><p>链表</p></li><li><p>二叉树</p></li><li><p>二叉查找树</p></li><li><p>平衡二叉树</p></li><li><p>红黑树</p></li><li><p>……</p></li></ul><p><strong>栈数据结构的执行特点</strong></p><ul><li>后进先出，先进后出</li></ul><p><strong>数据进入栈模型的过程称为：压&#x2F;进栈</strong></p><p><strong>数据离开栈模型的过程称为：弹&#x2F;出栈</strong></p><p><strong>常见数据结构之队列</strong></p><ul><li>先进先出，后进后出</li></ul><p><strong>数据从后端进入队列模型的过程称为：入队列</strong></p><p><strong>数据从前端离开队列模型的过程称为：出队列</strong></p><p><strong>常见数据结构之数组</strong></p><ul><li><p><strong>查询速度快：</strong>查询数据通过地址值和索引定位，查询任意数据耗时相同<strong>。</strong>（元素在内存中是连续存储的）</p></li><li><p><strong>删除效率低：</strong>要将原始数据删除，同时后面每个数据前移。</p></li><li><p><strong>添加效率极低：</strong>添加位置后的每个数据后移，再添加元素。</p></li></ul><h4 id="6-3链表"><a href="#6-3链表" class="headerlink" title="6.3链表"></a>6.3链表</h4><p><strong>链表的特点</strong></p><ul><li>链表中的元素是在内存中不连续存储的，每个元素节点包含数据值和下一个元素的地址。</li></ul><p><strong>链表的特点</strong></p><ul><li><p>链表中的元素是<strong>游离存储</strong>的，每个元素节点包含<strong>数据值和下一个元素的地址</strong>。</p></li><li><p><strong>链表查询慢</strong>，无论查询哪个数据都要从头开始找。</p></li><li><p><strong>链表增删相对快</strong></p></li><li><p><strong>链表查询首位元素极快</strong></p></li></ul><p><strong>链表是一种增删快的模型(对比数组）</strong></p><p><strong>链表是一种查询慢的模型(对比数组）</strong></p><p><strong>链表的种类</strong></p><ol><li><strong>单向链表（Singly Linked List）</strong>：在单向链表中，每个元素包含一个值和一个指向下一个元素的指针。链表的第一个元素称为头节点，最后一个元素的指针为空。这种链表只能从头节点开始遍历，每个元素只能访问下一个元素。</li><li><strong>双向链表（Doubly Linked List）</strong>：在双向链表中，每个元素包含一个值、一个指向下一个元素的指针和一个指向前一个元素的指针。这种链表可以从头节点或尾节点开始遍历，每个元素都可以访问前一个和下一个元素。</li><li><strong>循环链表（Circular Linked List）</strong>：循环链表是一种特殊类型的链表，最后一个元素的指针指向头节点，形成一个循环。这种链表可以通过任何元素开始遍历，可以在某个方向上一直遍历下去。</li><li><strong>双向循环链表（Doubly Circular Linked List）</strong>：结合了双向链表和循环链表的特性，每个元素包含一个指向前一个元素和一个指向下一个元素的指针，而最后一个元素的指针指向头节点。</li><li><strong>跳表（Skip List）</strong>：跳表是一种允许快速查找的数据结构，它是基于多层链表的结构，每一层都是一个有序链表，而最底层的链表包含所有元素。跳表的设计允许快速地进行元素查找和插入操作，类似于平衡树的操作效率。</li></ol><h4 id="6-4二叉树、-二叉查找树"><a href="#6-4二叉树、-二叉查找树" class="headerlink" title="6.4二叉树、 二叉查找树"></a>6.4二叉树、 二叉查找树</h4><p><strong>二叉树概述</strong></p><ol><li><strong>根节点和子节点</strong>：二叉树的顶部节点称为根节点。每个节点可以有零、一个或两个子节点。节点的子节点分为左子节点和右子节点，这两个子节点的相对顺序是重要的。</li><li><strong>节点关系</strong>：对于一个节点，它的子节点是通过指针或引用与之相连的。节点与其子节点的连接关系定义了树的结构。</li><li><strong>深度和高度</strong>：节点的深度是指从根节点到该节点的路径长度，根节点的深度为0。二叉树的高度是树中从根节点到最远叶子节点的最长路径的长度。</li><li><strong>叶子节点</strong>：叶子节点是指没有子节点的节点，也称为终端节点。它们位于树的末端。</li><li><strong>满二叉树</strong>：在满二叉树中，除了叶子节点，每个节点都有两个子节点。每一层都被完全填满。</li><li><strong>完全二叉树</strong>：完全二叉树是指除了最后一层外，其他层都被完全填满，而且最后一层的节点靠左排列。</li><li><strong>二叉搜索树（BST）</strong>：二叉搜索树是一种特殊的二叉树，其中每个节点的值大于其左子树中的所有节点的值，小于其右子树中的所有节点的值。这种特性使得在BST中进行搜索、插入和删除操作的效率较高。</li><li><strong>平衡二叉树（AVL树）</strong>：平衡二叉树是一种特殊的BST，它保持了左子树和右子树的高度差不超过1，从而保证了树的高度较低，提高了各种操作的效率。</li><li><strong>二叉树的遍历</strong>：遍历是指按照一定顺序访问树中的所有节点。常见的二叉树遍历方式有前序遍历（根-左-右）、中序遍历（左-根-右）、后序遍历（左-右-根）和层序遍历（逐层遍历节点）。</li></ol><p><strong>二叉树的特点</strong></p><ul><li><p><strong>只能有一个根节点</strong>，每个节点最多支持2个直接子节点。</p></li><li><p><strong>节点的度：</strong> 节点拥有的子树的个数，二叉树的度不大于2 叶子节点 度为0的节点，也称之为终端结点。</p></li><li><p><strong>高度：</strong>叶子结点的高度为1，叶子结点的父节点高度为2，以此类推，根节点的高度最高。</p></li><li><p><strong>层：</strong>根节点在第一层，以此类推</p></li><li><p><strong>兄弟节点 ：</strong>拥有共同父节点的节点互称为兄弟节点</p></li></ul><p><strong>二叉查找树又称二叉排序树或者二叉搜索树</strong></p><p><strong>特点：</strong></p><ul><li><p>1，每一个节点上最多有两个子节点</p></li><li><p>2，左子树上所有节点的值都小于根节点的值</p></li><li><p>3，右子树上所有节点的值都大于根节点的值</p></li></ul><p><strong>目的：提高检索数据的性能</strong>。</p><p><strong>二叉树查找树添节点:</strong></p><p><strong>规则：</strong> <strong>小的存左边</strong> <strong>大的存右边</strong> <strong>一样的不存</strong></p><h4 id="6-5平衡二叉树"><a href="#6-5平衡二叉树" class="headerlink" title="6.5平衡二叉树"></a>6.5平衡二叉树</h4><p><strong>问题：二叉树查找出现瘸子现象，导致查询的性能与单链表一样，查询速度变慢！</strong></p><p><strong>数据结构–平衡二叉树</strong></p><ul><li>平衡二叉树是在满足查找二叉树的大小规则下，让树尽可能矮小，以此提高查数据的性能。</li></ul><p><strong>平衡二叉树的要求</strong></p><ul><li>任意节点的左右两个子树的高度差不超过1，任意节点的左右两个子树都是一颗平衡二叉树</li></ul><p><strong>平衡二叉树在添加元素后可能导致不平衡</strong></p><ul><li>基本策略是进行<strong>左旋</strong>，或者<strong>右旋</strong>保证平衡。</li></ul><p><strong>平衡二叉树旋转的四种情况</strong></p><ul><li><p>左左</p><p> 当根节点左子树的左子树有节点插入，导致二叉树不平衡（右旋）</p></li><li><p>左右</p><p>当根节点左子树的右子树有节点插入，导致二叉树不平衡</p><p><strong>仅仅做一个右旋还是不行</strong></p><p><strong>第二层及以上先左旋，整体再右旋</strong></p></li><li><p>右右</p><p> 当根节点右子树的右子树有节点插入，导致二叉树不平衡</p></li><li><p>右左</p><p>当根节点右子树的左子树有节点插入，导致二叉树不平衡</p><p><strong>仅仅做一个左旋还是不行</strong></p><p><strong>第二层及以上先右旋，整体再左旋</strong></p></li></ul><h4 id="6-6红黑树"><a href="#6-6红黑树" class="headerlink" title="6.6红黑树"></a>6.6红黑树</h4><p><strong>红黑树概述</strong></p><ul><li><p>红黑树是一种自平衡的二叉查找树，是计算机科学中用到的一种数据结构。</p></li><li><p>1972年出现，当时被称之为平衡二叉B树。1978年被修改为如今的”红黑树”。</p></li><li><p>每一个节点可以是红或者黑；<strong>红黑树不是通过高度平衡的</strong>，它的平衡是通过“红黑规则”进行实现的。</p></li></ul><p><strong>红黑规则</strong></p><ul><li><p>每一个节点或是红色的，或者是黑色的，<strong>根节点必须是黑色。</strong></p></li><li><p>如果某一个节点是红色，那么它的子节点必须是黑色(<strong>不能出现两个红色节点相连的情况</strong>)。</p></li><li><p><strong>对每一个节点，从该节点到其所有后代叶节点的简单路径上，均包含相同数目的黑色节点。</strong></p></li></ul><p><strong>添加节点</strong></p><ul><li><p>添加的节点的颜色，可以是红色的，也可以是黑色的。</p></li><li><p>如果一个节点没有子节点或者父节点，则该节点相应的指针属性值为Nil，这些Nil视为叶节点，每个叶节点(Nil)是黑色的；</p></li><li><p><strong>默认用红色效率高。</strong></p></li></ul><p><strong>红黑树增删改查的性能都很好</strong></p><h3 id="7-List系列集合"><a href="#7-List系列集合" class="headerlink" title="7.List系列集合"></a>7.List系列集合</h3><h4 id="7-1List集合特点、特有API"><a href="#7-1List集合特点、特有API" class="headerlink" title="7.1List集合特点、特有API"></a>7.1List集合特点、特有API</h4><p><strong>Collection集合体系</strong></p><ol><li><strong>Collection 接口</strong>：<code>Collection</code> 接口是所有集合类的根接口，它定义了基本的集合操作，如添加、删除、遍历等。<code>Collection</code> 接口又分为以下几种常见的子接口和实现类：<ul><li><code>List</code>：有序的集合，允许重复元素。常见的实现类有 <code>ArrayList</code>、<code>LinkedList</code> 和 <code>Vector</code>。</li><li><code>Set</code>：不允许重复元素的集合。常见的实现类有 <code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code>。</li><li><code>Queue</code>：队列集合，支持在一端插入元素，在另一端删除元素。常见的实现类有 <code>LinkedList</code> 和 <code>PriorityQueue</code>。</li></ul></li><li><strong>Map 接口</strong>：<code>Map</code> 接口用于存储键-值对，每个键映射到一个值。<code>Map</code> 接口提供了以键为索引进行访问的功能。常见的实现类有：<ul><li><code>HashMap</code>：基于哈希表实现，无序。</li><li><code>LinkedHashMap</code>：基于链表和哈希表实现，保持插入顺序。</li><li><code>TreeMap</code>：基于红黑树实现，按照键的自然顺序或自定义顺序排序。</li><li><code>Hashtable</code>：类似于 <code>HashMap</code>，但是线程安全（不推荐使用，因为性能相对较差）。</li></ul></li></ol><p><strong>List系列集合特点</strong></p><ul><li><p>ArrayList、LinekdList ：有序，可重复，有索引。</p></li><li><p>有序：存储和取出的元素顺序一致</p></li><li><p>有索引：可以通过索引操作元素</p></li><li><p>可重复：存储的元素可以重复</p></li></ul><p><strong>List集合特有方法</strong></p><ul><li>List集合因为支持索引，所以多了很多索引操作的独特api，其他Collection的功能List也都继承了。</li></ul><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>void add(int  index,E element)</td><td>在此集合中的指定位置插入指定的元素</td></tr><tr><td>E remove(int  index)</td><td>删除指定索引处的元素，返回被删除的元素</td></tr><tr><td>E set(int index,E  element)</td><td>修改指定索引处的元素，返回被修改的元素</td></tr><tr><td>E get(int  index)</td><td>返回指定索引处的元素</td></tr><tr><td>indexOf</td><td>去集合中取已知元素的索引</td></tr></tbody></table><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.创建一个ArrayList集合对象：</span></span><br><span class="line">       <span class="comment">// List:有序，可重复，有索引的。</span></span><br><span class="line">       ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 一行经典代码！</span></span><br><span class="line">       list.add(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">       list.add(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">       list.add(<span class="string">&quot;HTML&quot;</span>);</span><br><span class="line">       list.add(<span class="string">&quot;HTML&quot;</span>);</span><br><span class="line">       list.add(<span class="string">&quot;MySQL&quot;</span>);</span><br><span class="line">       list.add(<span class="string">&quot;MySQL&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 2.在某个索引位置插入元素。</span></span><br><span class="line">       list.add(<span class="number">2</span>, <span class="string">&quot;黑马&quot;</span>);</span><br><span class="line">       System.out.println(list);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 3.根据索引删除元素,返回被删除元素</span></span><br><span class="line">       System.out.println(list.remove(<span class="number">1</span>));</span><br><span class="line">       System.out.println(list);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 4.根据索引获取元素:public E get(int index):返回集合中指定位置的元素。</span></span><br><span class="line">       System.out.println(list.get(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 5.修改索引位置处的元素: public E set(int index, E element)</span></span><br><span class="line">       System.out.println(list.set(<span class="number">1</span>, <span class="string">&quot;传智教育&quot;</span>));</span><br><span class="line">       System.out.println(list);</span><br></pre></td></tr></table></figure><p><strong>List的实现类的底层原理</strong></p><ul><li><p>ArrayList底层是基于数组实现的，根据查询元素快，增删相对慢。</p></li><li><p>LinkedList底层基于双链表实现的，查询元素慢，增删首尾元素是非常快的。</p></li></ul><h4 id="7-2List集合的遍历方式小结"><a href="#7-2List集合的遍历方式小结" class="headerlink" title="7.2List集合的遍历方式小结"></a>7.2List集合的遍历方式小结</h4><p><strong>List集合的遍历方式有4种</strong></p><ul><li><p>①迭代器 </p></li><li><p>②增强for循环</p></li><li><p>③Lambda表达式</p></li><li><p>④for循环（因为List集合存在索引）</p></li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    拓展：List系列集合的遍历方式有：4种。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    List系列集合多了索引，所以多了一种按照索引遍历集合的for循环。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    List遍历方式：</span></span><br><span class="line"><span class="comment">        （1）for循环。(独有的，因为List有索引)。</span></span><br><span class="line"><span class="comment">        （2）迭代器。</span></span><br><span class="line"><span class="comment">        （3）foreach。</span></span><br><span class="line"><span class="comment">        （4）JDK 1.8新技术Lambda表达式,(JDK 1.8新技术)。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; lists = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        lists.add(<span class="string">&quot;java1&quot;</span>);</span><br><span class="line">        lists.add(<span class="string">&quot;java2&quot;</span>);</span><br><span class="line">        lists.add(<span class="string">&quot;java3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** （1）for循环。 */</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lists.size(); i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">ele</span> <span class="operator">=</span> lists.get(i);</span><br><span class="line">            System.out.println(ele);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/** （2）迭代器。 */</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------&quot;</span>);</span><br><span class="line">        Iterator&lt;String&gt; it = lists.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">ele</span> <span class="operator">=</span> it.next();</span><br><span class="line">            System.out.println(ele);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** （3）foreach */</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String ele : lists) &#123;</span><br><span class="line">            System.out.println(ele);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** （4）JDK 1.8开始之后的Lambda表达式  */</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------&quot;</span>);</span><br><span class="line">        lists.forEach(s -&gt; &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><h4 id="7-3ArrayList集合的底层原理"><a href="#7-3ArrayList集合的底层原理" class="headerlink" title="7.3ArrayList集合的底层原理"></a>7.3ArrayList集合的底层原理</h4><p><strong>ArrayList集合底层原理</strong></p><ul><li><p>ArrayList底层是基于数组实现的：根据索引定位元素快，增删需要做元素的移位操作。</p></li><li><p>第一次创建集合并添加第一个元素的时候，在底层创建一个默认长度为10的数组。</p></li></ul><p><strong>List集合存储的元素要超过容量怎么办？</strong></p><ul><li>会以自身长度的1.5倍扩容</li></ul><h4 id="7-4LinkedList集合的底层原理"><a href="#7-4LinkedList集合的底层原理" class="headerlink" title="7.4LinkedList集合的底层原理"></a>7.4LinkedList集合的底层原理</h4><p><strong>LinkedList的特点</strong></p><ul><li>底层数据结构是<strong>双链表</strong>，<strong>查询慢</strong>，<strong>首尾操作的速度是极快的</strong>，所以多了很多首尾操作的特有API。</li></ul><p><strong>LinkedList集合的特有功能</strong></p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>public  void <strong>addFirst</strong>(E e)栈结构:或push</td><td>在该列表开头插入指定的元素(入栈)</td></tr><tr><td>public  void <strong>addLast</strong>(E e)</td><td>将指定的元素追加到此列表的末尾(入队)</td></tr><tr><td>public  E <strong>getFirst</strong>()</td><td>返回此列表中的第一个元素</td></tr><tr><td>public  E <strong>getLast</strong>()</td><td>返回此列表中的最后一个元素</td></tr><tr><td>public  E <strong>removeFirst</strong>()  栈结构:或pop</td><td>从此列表中删除并返回第一个元素(出栈，出队)</td></tr><tr><td>public  E <strong>removeLast</strong>()</td><td>从此列表中删除并返回最后一个元素</td></tr></tbody></table><p>(栈结构:先进后出）  (队列结构:先进先出）</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// LinkedList可以完成队列结构，和栈结构 （双链表）</span></span><br><span class="line">        <span class="comment">// 1、做一个队列：</span></span><br><span class="line">        LinkedList&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 入队</span></span><br><span class="line">        queue.addLast(<span class="string">&quot;1号&quot;</span>);</span><br><span class="line">        queue.addLast(<span class="string">&quot;2号&quot;</span>);</span><br><span class="line">        queue.addLast(<span class="string">&quot;3号&quot;</span>);</span><br><span class="line">        System.out.println(queue);</span><br><span class="line">        <span class="comment">// 出队</span></span><br><span class="line">        <span class="comment">// System.out.println(queue.getFirst());</span></span><br><span class="line">        System.out.println(queue.removeFirst());</span><br><span class="line">        System.out.println(queue.removeFirst());</span><br><span class="line">        System.out.println(queue);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、做一个栈</span></span><br><span class="line">        LinkedList&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 入栈 压栈 (push)</span></span><br><span class="line">        stack.push(<span class="string">&quot;第1颗子弹&quot;</span>);</span><br><span class="line">        stack.push(<span class="string">&quot;第2颗子弹&quot;</span>);</span><br><span class="line">        stack.push(<span class="string">&quot;第3颗子弹&quot;</span>);</span><br><span class="line">        stack.push(<span class="string">&quot;第4颗子弹&quot;</span>);</span><br><span class="line">        System.out.println(stack);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 出栈  弹栈 pop</span></span><br><span class="line">        System.out.println(stack.pop());</span><br><span class="line">        System.out.println(stack.pop());</span><br><span class="line">        System.out.println(stack.pop());</span><br><span class="line">        System.out.println(stack);</span><br></pre></td></tr></table></figure><h3 id="8-补充知识：集合的并发修改异常问题"><a href="#8-补充知识：集合的并发修改异常问题" class="headerlink" title="8.补充知识：集合的并发修改异常问题"></a>8.补充知识：集合的并发修改异常问题</h3><p><strong>从集合中的一批元素中找出某些数据并删除，如何操作？是否存在问题呢 ？</strong></p><ul><li>当我们从集合中<strong>找出某个元素并删除</strong>的时候可能出现一种<strong>并发修改异常</strong>问题。</li></ul><p><strong>哪些遍历存在问题？</strong></p><ul><li><p><strong>迭代器</strong>遍历集合且直接用集合删除元素的时候可能出现。</p></li><li><p><strong>增强for循环</strong>遍历集合且直接用集合删除元素的时候可能出现。</p></li></ul><p><strong>哪种遍历且删除元素不出问题</strong></p><ul><li><p><strong>迭代器</strong>遍历集合但是用迭代器自己的删除方法操作可以解决。</p></li><li><p><strong>普通for循环</strong>遍历并删除元素不会存在这个问题。</p></li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：研究集合遍历并删除元素可能出现的：并发修改异常问题。</span></span><br><span class="line"><span class="comment">    需求：删除全部的Java信息。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、准备数据</span></span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;黑马&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;赵敏&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;赵敏&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;素素&quot;</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="comment">// [黑马, Java, Java, 赵敏, 赵敏, 素素]</span></span><br><span class="line">        <span class="comment">//        it</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// a、迭代器遍历删除</span></span><br><span class="line">       Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line"><span class="comment">//       while (it.hasNext())&#123;</span></span><br><span class="line"><span class="comment">//         String ele = it.next();</span></span><br><span class="line"><span class="comment">//         if(&quot;Java&quot;.equals(ele))&#123; //判断是否是Java    </span></span><br><span class="line"><span class="comment">//           list.remove(ele); //删除Java,集合删除会出毛病</span></span><br><span class="line"><span class="comment">//           it.remove(); // 删除迭代器所在位置的元素值（没毛病）</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        System.out.println(list);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// b、foreach遍历删除 (会出现问题，这种无法解决的，foreach不能边遍历边删除，会出bug)</span></span><br><span class="line"><span class="comment">//        for (String s : list) &#123;</span></span><br><span class="line"><span class="comment">//            if(&quot;Java&quot;.equals(s))&#123;</span></span><br><span class="line"><span class="comment">//                list.remove(s);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// c、lambda表达式(会出现问题，这种无法解决的，Lambda遍历不能边遍历边删除，会出bug)</span></span><br><span class="line"><span class="comment">//        list.forEach(s -&gt; &#123;</span></span><br><span class="line"><span class="comment">//            if(&quot;Java&quot;.equals(s))&#123;</span></span><br><span class="line"><span class="comment">//                list.remove(s);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// d、for循环(边遍历边删除集合没毛病，但是必须从后面开始遍历删除才不会出现漏掉应该删除的元素)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> list.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span> ; i--) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">ele</span> <span class="operator">=</span> list.get(i);</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;Java&quot;</span>.equals(ele))&#123;</span><br><span class="line">                list.remove(ele);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="9-补充知识：泛型深入"><a href="#9-补充知识：泛型深入" class="headerlink" title="9.补充知识：泛型深入"></a>9.补充知识：泛型深入</h3><h4 id="9-1泛型的概述和优势"><a href="#9-1泛型的概述和优势" class="headerlink" title="9.1泛型的概述和优势"></a>9.1泛型的概述和优势</h4><p><strong>泛型概述</strong></p><ul><li><p>泛型：是JDK5中引入的特性，可以在编译阶段约束操作的数据类型，并进行检查。</p></li><li><p>泛型的格式：&lt;数据类型&gt;; </p></li><li><p>集合体系的全部接口和实现类都是支持泛型的使用的;</p></li><li><p>注意：<strong>泛型只能支持引用数据类型。</strong></p></li></ul><p><strong>泛型的好处：</strong></p><ul><li><p>统一数据类型。</p></li><li><p>把运行时期的问题提前到了编译期间，避免了强制类型转换可能出现的异常，因为编译阶段类型就能确定下来。</p></li></ul><p><strong>泛型可以在很多地方进行定义:</strong></p><p> 类后面             ——————&gt;   泛型类</p><p> 方法申明上     ——————&gt;   泛型方法</p><p> 接口后面         ——————&gt;   泛型接口</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：泛型的概述。</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    泛型就是一个标签：&lt;数据类型&gt;</span></span><br><span class="line"><span class="comment">    泛型可以在编译阶段约束只能操作某种数据类型。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    注意：</span></span><br><span class="line"><span class="comment">        JDK 1.7开始之后后面的泛型申明可以省略不写</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//添加String类型元素</span></span><br><span class="line"> List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;中国&quot;</span>);</span><br><span class="line">        <span class="comment">// list.add(23); //报错</span></span><br><span class="line">        <span class="comment">//list1.add(23.3); //报错</span></span><br><span class="line">        <span class="comment">//list1.add(false); //报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//添加任意类型的元素</span></span><br><span class="line">        List&lt;Object&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;中国&quot;</span>);</span><br><span class="line">list2.add(<span class="number">23</span>);</span><br><span class="line">        list2.add(<span class="number">23.3</span>);</span><br></pre></td></tr></table></figure><h4 id="9-2自定义泛型类"><a href="#9-2自定义泛型类" class="headerlink" title="9.2自定义泛型类"></a>9.2自定义泛型类</h4><p><strong>泛型类的概述</strong></p><ul><li><p>定义类时同时定义了泛型的类就是泛型类。</p></li><li><p>泛型类的格式：修饰符 class 类名&lt;泛型变量&gt;{ }</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">范例：<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyArrayList</span>&lt;T&gt; &#123;  &#125;</span><br></pre></td></tr></table></figure><ul><li><p>此处泛型变量<strong>T</strong>可以随便写为任意标识，常见的如<strong>E、T、K、V</strong>等。</p></li><li><p><strong>作用</strong>：编译阶段可以指定数据类型，类似于集合的作用。</p></li></ul><p><strong>泛型类的核心思想：</strong></p><ul><li>把出现泛型变量的地方全部替换成传输的真实数据类型。</li></ul><p><strong>泛型类的作用</strong></p><ul><li>编译阶段约定操作的数据的类型，类似于集合的作用。</li></ul><p><strong>课程案例导学</strong></p><ul><li>模拟ArrayList集合自定义一个MyArrayList泛型类,完成添加和删除功能的泛型设计即可。</li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 需求：模拟ArrayList定义一个MyArrayList ，关注泛型设计</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义一个MyArrayList泛型类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyArrayList</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">ArrayList</span> <span class="variable">lists</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e)</span>&#123;</span><br><span class="line">        lists.add(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(E e)</span>&#123;</span><br><span class="line">        lists.remove(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lists.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用MyArrayList泛型类创建对象</span></span><br><span class="line">MyArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">MyArrayList</span>&lt;&gt;();</span><br><span class="line">MyArrayList&lt;Integer&gt; list2 = <span class="keyword">new</span> <span class="title class_">MyArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><h4 id="9-3自定义泛型方法"><a href="#9-3自定义泛型方法" class="headerlink" title="9.3自定义泛型方法"></a>9.3自定义泛型方法</h4><p><strong>泛型方法的概述</strong></p><ul><li><p>定义方法时同时定义了泛型的方法就是泛型方法。</p></li><li><p>泛型方法的格式：修饰符 &lt;泛型变量&gt; 方法返回值 方法名称(形参列表){}</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">范例： <span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(T t)</span> &#123;  &#125;</span><br></pre></td></tr></table></figure><ul><li><strong>作用</strong>：方法中可以使用泛型接收一切实际类型的参数，方法更具备通用性。</li></ul><p><strong>泛型方法的核心思想：</strong></p><ul><li>把出现泛型变量的地方全部替换成传输的真实数据类型。</li></ul><p><strong>课程案例导学</strong></p><ul><li>给你任何一个类型的数组，都能返回它的内容。也就是实现Arrays.toString(数组)的功能！</li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：自定义泛型方法。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    定义了泛型的方法就是泛型方法。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    注意：方法定义了是什么泛型变量，后面就只能用什么泛型变量。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    小结：</span></span><br><span class="line"><span class="comment">        泛型方法可以让方法更灵活的接收数据，可以做通用技术！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//需求：给你任何一个类型的数组，都能返回它的内容。Arrays.toString(数组)的功能！</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] names = &#123;<span class="string">&quot;小璐&quot;</span>, <span class="string">&quot;蓉容&quot;</span>, <span class="string">&quot;小何&quot;</span>&#125;;</span><br><span class="line">        printArray(names);</span><br><span class="line"></span><br><span class="line">        Integer[] ages = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line">        printArray(ages);</span><br><span class="line">      </span><br><span class="line">        String[]  names2 = getArr(names);</span><br><span class="line">        Integer[] ages2 = getArr(ages);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自定义泛型方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] getArr(T[] arr)&#123; <span class="comment">//T[]为定义时万能类型标记</span></span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">(T[] arr)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;[&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">                sb.append(arr[i]).append(i == arr.length - <span class="number">1</span> ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;, &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">            System.out.println(sb);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(arr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-4自定义泛型接口"><a href="#9-4自定义泛型接口" class="headerlink" title="9.4自定义泛型接口"></a>9.4自定义泛型接口</h4><p><strong>泛型接口的概述</strong></p><ul><li><p>使用了泛型定义的接口就是泛型接口。</p></li><li><p>泛型接口的格式：修饰符 interface 接口名称&lt;泛型变量&gt;{}</p></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">范例： public interface Data&lt;E&gt;&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>作用：泛型接口可以约束实现类，实现类可以在实现接口的时候传入自己操作的数据类型这样重写的方法都将是针对于该类型的操作。</strong></li></ul><p><strong>泛型接口的核心思想：</strong></p><ul><li>实现类可以在实现接口的时候传入自己操作的数据类型，这样重写的方法都将是针对于该类型的操作。</li></ul><p><strong>课程案例导学</strong></p><ul><li>教务系统，提供一个接口可约束一定要完成数据（学生，老师）的增删改查操作</li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义学生类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义泛型接口类Data，给出抽象方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Data</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(E e)</span>;</span><br><span class="line">    E <span class="title function_">queryById</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现类StudentData 继承 泛型接口类Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentData</span> <span class="keyword">implements</span> <span class="title class_">Data</span>&lt;Student&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Student student)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Student student)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Student <span class="title function_">queryById</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-5泛型通配符、上下限"><a href="#9-5泛型通配符、上下限" class="headerlink" title="9.5泛型通配符、上下限"></a>9.5泛型通配符、上下限</h4><p><strong>通配</strong>  <strong>?</strong></p><ul><li><p><strong>?</strong> 可以在<strong>使用</strong>泛型的时候代表一切类型。</p></li><li><p><strong>E T K V</strong> 是在<strong>定义</strong>泛型的时候使用的。</p></li></ul><p><strong>注意：</strong></p><ul><li>虽然BMW和BENZ都继承了Car但是ArrayList<BMW>和ArrayList<BENZ>与ArrayList<Car>没有关系的！!</li></ul><p><strong>泛型的上下限：</strong></p><ul><li><p>? <strong>extends</strong> <strong>Car</strong>      必须是Car或者其子类  泛型上限</p></li><li><p>? <strong>super</strong> <strong>Car</strong>          必须是Car或者其父类  泛型下限</p></li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：泛型通配符。?</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    注意：</span></span><br><span class="line"><span class="comment">        虽然BMW和BENZ都继承了Car</span></span><br><span class="line"><span class="comment">        但是ArrayList&lt;BMW&gt;和ArrayList&lt;BENZ&gt;与ArrayList&lt;Car&gt;没有关系的！!</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    小结：</span></span><br><span class="line"><span class="comment">        通配符：？</span></span><br><span class="line"><span class="comment">        ？可以在“使用泛型”的时候代表一切类型。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">//需求：开发一个极品飞车的游戏，所有的汽车都能一起参与比赛。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;BMW&gt; bmws = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        bmws.add(<span class="keyword">new</span> <span class="title class_">BMW</span>());</span><br><span class="line">        bmws.add(<span class="keyword">new</span> <span class="title class_">BMW</span>());</span><br><span class="line">        bmws.add(<span class="keyword">new</span> <span class="title class_">BMW</span>());</span><br><span class="line">        go(bmws);</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;BENZ&gt; benzs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        benzs.add(<span class="keyword">new</span> <span class="title class_">BENZ</span>());</span><br><span class="line">        benzs.add(<span class="keyword">new</span> <span class="title class_">BENZ</span>());</span><br><span class="line">        benzs.add(<span class="keyword">new</span> <span class="title class_">BENZ</span>());</span><br><span class="line">        go(benzs);</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Dog&gt; dogs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dogs.add(<span class="keyword">new</span> <span class="title class_">Dog</span>());</span><br><span class="line">        dogs.add(<span class="keyword">new</span> <span class="title class_">Dog</span>());</span><br><span class="line">        dogs.add(<span class="keyword">new</span> <span class="title class_">Dog</span>());</span><br><span class="line">        <span class="comment">// go(dogs); //没有继承父类Car，会报错</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">       所有车比赛</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">(ArrayList&lt;? extends Car&gt; cars)</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BENZ</span> <span class="keyword">extends</span> <span class="title class_">Car</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BMW</span> <span class="keyword">extends</span> <span class="title class_">Car</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> java,面向对象进阶,Collection,数据结构,List,泛型深入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>day13 - 常用API、正则表达式、Lambda、算法</title>
      <link href="/post/19124d20.html"/>
      <url>/post/19124d20.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-日期与时间（old）"><a href="#1-日期与时间（old）" class="headerlink" title="1.日期与时间（old）"></a><strong>1</strong>.日期与时间（old）</h3><h4 id="1-1Date"><a href="#1-1Date" class="headerlink" title="1.1Date"></a>1.1Date</h4><p><strong>Date 类概述</strong></p><ul><li>Date类代表当前所在系统的日期时间信息。</li></ul><p><strong>Date的构造器</strong></p><table><thead><tr><th align="center">名称</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><strong>public Date()</strong></td><td align="center"><strong>创建一个Date对象，代表的是系统当前此刻日期时间。</strong></td></tr><tr><td align="center"><strong>public Date(long time)</strong></td><td align="center"><strong>把时间毫秒值转换成Date日期对象。</strong></td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1、创建一个Date类的对象：代表系统此刻日期时间对象</span></span><br><span class="line">       <span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">       System.out.println(d);</span><br></pre></td></tr></table></figure><p><strong>Date的常用方法</strong></p><table><thead><tr><th align="center">名称</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><strong>public long getTime()</strong></td><td align="center"><strong>返回从1970年1月1日   00:00:00走到此刻的总的毫秒数</strong></td></tr><tr><td align="center"><strong>public void setTime(long time)</strong></td><td align="center"><strong>设置日期对象的时间为当前时间毫秒值对应的时间</strong></td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2、获取时间毫秒值</span></span><br><span class="line"> <span class="comment">//方法一:getTime</span></span><br><span class="line">          <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> d.getTime();</span><br><span class="line">          System.out.println(time);</span><br><span class="line">      </span><br><span class="line"> <span class="comment">//方法二:System</span></span><br><span class="line">          <span class="type">long</span> <span class="variable">time1</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">          System.out.println(time1);</span><br></pre></td></tr></table></figure><p><strong>案例：</strong></p><ul><li>请计算出当前时间往后走1小时121秒之后的时间是多少。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1、得到当前时间</span></span><br><span class="line">   <span class="type">Date</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">   System.out.println(d1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、当前时间往后走 1小时  121s</span></span><br><span class="line">   <span class="type">long</span> <span class="variable">time2</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">   time2 += (<span class="number">60</span> * <span class="number">60</span> + <span class="number">121</span>) * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、把时间毫秒值转换成对应的日期对象。</span></span><br><span class="line">   <span class="type">Date</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(time2);</span><br><span class="line">   System.out.println(d2);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//或使用setTime</span></span><br><span class="line">   <span class="comment">//Date d3 = new Date();</span></span><br><span class="line">   <span class="comment">//d3.setTime(time2);</span></span><br><span class="line">   <span class="comment">//System.out.println(d3);</span></span><br></pre></td></tr></table></figure><h4 id="1-2SimpleDateFormat-时间格式化"><a href="#1-2SimpleDateFormat-时间格式化" class="headerlink" title="1.2SimpleDateFormat(时间格式化)"></a>1.2SimpleDateFormat(时间格式化)</h4><h5 id="1-2-1SimpleDateFormat类作用"><a href="#1-2-1SimpleDateFormat类作用" class="headerlink" title="1.2.1SimpleDateFormat类作用"></a><strong>1.2.1SimpleDateFormat类作用</strong></h5><p><strong>格式化：</strong></p><p> Date对象             —————&gt;    2099年11月11日 11:11:</p><p> 时间毫秒值          —————&gt;    2099年11月11日 11:11:</p><p><strong>构造器</strong></p><table><thead><tr><th align="center">构造器</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><strong>public SimpleDateFormat(String pattern)</strong></td><td align="center"><strong>构造一个SimpleDateFormat，使用指定的格式</strong></td></tr></tbody></table><p><strong>格式化方法(日期格式、时间毫秒值通用)</strong></p><table><thead><tr><th align="left">格式化方法</th><th>说明</th></tr></thead><tbody><tr><td align="left">public final String format(Date date)</td><td><strong>将日期格式化成日期&#x2F;时间字符串</strong></td></tr><tr><td align="left">public final Stringformat(Object time)</td><td><strong>将时间毫秒值格式化成日期&#x2F;时间字符串</strong></td></tr></tbody></table><ul><li><p>y 年                                  </p></li><li><p>M 月                                   </p></li><li><p>d 日</p></li><li><p>H 时</p></li><li><p>m 分</p></li><li><p>s 秒</p></li></ul><p>2020-11-11 13:27:06    ——–&gt; yyyy-MM-dd HH:mm:ss </p><p> 2020年11月11日 13时27分06秒 周* 上&#x2F;下午 ——–&gt; </p><p>yyyy年MM月dd日 HH时mm分ss秒 EEE a</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    SimpleDateFormat简单日期格式化类的使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//目标一:格式化时间</span></span><br><span class="line">        <span class="comment">// 1、日期对象</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        System.out.println(d);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、格式化这个日期对象 (指定最终格式化的形式)</span></span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy年MM月dd日 HH:mm:ss EEE a&quot;</span>);</span><br><span class="line">        <span class="comment">// 3、开始格式化日期对象成为喜欢的字符串形式</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> sdf.format(d);  </span><br><span class="line">        System.out.println(rs);   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//目标二：格式化时间毫秒值</span></span><br><span class="line"><span class="comment">// 需求：请问121秒后的时间是多少</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">time1</span> <span class="operator">=</span> System.currentTimeMillis() + <span class="number">121</span> * <span class="number">1000</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">rs2</span> <span class="operator">=</span> sdf.format(time1);</span><br><span class="line">        System.out.println(rs2);</span><br></pre></td></tr></table></figure><h5 id="1-2-2parse-解析字符串时间，成为日期对象"><a href="#1-2-2parse-解析字符串时间，成为日期对象" class="headerlink" title="1.2.2parse:解析字符串时间，成为日期对象"></a><strong>1.2.2parse:解析字符串时间，成为日期对象</strong></h5><table><thead><tr><th>解析方法</th><th>说明</th></tr></thead><tbody><tr><td>public Date <strong>parse(String source)</strong></td><td>从给定字符串的开始解析文本以生成日期</td></tr></tbody></table><p><strong>解析字符串时间成为日期对象：</strong></p><p> 2011-11-11 11:11:22  -&gt;  计算机可识别的Date日期对象</p><p><strong>案例</strong></p><ul><li>请计算出 2021年08月06日11点11分11秒，往后走2天14小时49分06秒后的时间是多少。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 目标: 学会使用SimpleDateFormat解析字符串时间成为日期对象。</span></span><br><span class="line"><span class="comment">// 有一个时间 2021年08月06日 11:11:11 往后 2天 14小时 49分 06秒后的时间是多少。</span></span><br><span class="line"><span class="comment">// 1、把字符串时间拿到程序中来</span></span><br><span class="line"><span class="type">String</span> <span class="variable">dateStr</span> <span class="operator">=</span> <span class="string">&quot;2021年08月06日 11:11:11&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、把字符串时间解析成日期对象（本节的重点）: </span></span><br><span class="line"><span class="comment">//    形式必须与被解析时间的形式完全一样，否则运行时解析报错！</span></span><br><span class="line">   <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy年MM月dd日 HH:mm:ss&quot;</span>);    <span class="comment">//创建SimpleDateFormat</span></span><br><span class="line">   <span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> sdf.parse(dateStr); <span class="comment">//使用parse方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、往后走2天 14小时 49分 06秒</span></span><br><span class="line">   <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> d.getTime() + (<span class="number">2L</span>*<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span> + <span class="number">14</span>*<span class="number">60</span>*<span class="number">60</span> + <span class="number">49</span>*<span class="number">60</span> + <span class="number">6</span>) * <span class="number">1000</span>;  <span class="comment">//计算时间毫秒值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4、格式化这个时间毫秒值就是结果</span></span><br><span class="line">   System.out.println(sdf.format(time));<span class="comment">//使用format方法</span></span><br></pre></td></tr></table></figure><p><strong>案例：秒杀活动</strong></p><p><strong>需求</strong></p><ul><li><p>某购物网站举办秒杀活动，开始时间和结束时间如左图所示，当前活动结束后，系统记录到2位用户的付款时间分别如下：</p></li><li><ul><li>小贾下单并付款的时间为：2020年11月11日 0:03:47</li><li>小皮下单并付款的时间为：2020年11月11日 0:10:11</li></ul></li><li><p>规则：顾客的付款时间必须在秒杀时间之内，请判断出两位顾客是否秒杀成功。</p></li></ul><p><strong>分析</strong></p><ul><li><p>把4个字符串形式的时间解析成日期对象。</p></li><li><p>判断小贾和小皮的时间是否在秒杀时间范围之内，并给出相应的提示。</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 1、创建开始和结束时间</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">startTime</span> <span class="operator">=</span> <span class="string">&quot;2021-11-11 00:00:00&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">endTime</span> <span class="operator">=</span> <span class="string">&quot;2021-11-11 00:10:00&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、创建小贾和小皮下单时间</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">xiaoJia</span> <span class="operator">=</span>  <span class="string">&quot;2021-11-11 00:03:47&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">xiaoPi</span> <span class="operator">=</span>  <span class="string">&quot;2021-11-11 00:10:11&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、使用parse方法，解析所有时间</span></span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">d1</span> <span class="operator">=</span> sdf.parse(startTime);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">d2</span> <span class="operator">=</span> sdf.parse(endTime);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">d3</span> <span class="operator">=</span> sdf.parse(xiaoJia);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">d4</span> <span class="operator">=</span> sdf.parse(xiaoPi);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4、使用after(在...之后)和before(在...之前)判断</span></span><br><span class="line">        <span class="keyword">if</span>(d3.after(d1) &amp;&amp; d3.before(d2))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;小贾秒杀成功，可以发货了！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;小贾秒杀失败！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(d4.after(d1) &amp;&amp; d4.before(d2))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;小皮秒杀成功，可以发货了！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;小皮秒杀失败！&quot;</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h4 id="1-3Calendar-日历"><a href="#1-3Calendar-日历" class="headerlink" title="1.3Calendar(日历)"></a>1.3Calendar(日历)</h4><p><strong>Calendar概述</strong></p><ul><li><p>Calendar代表了系统此刻日期对应的日历对象。</p></li><li><p>Calendar是一个<strong>抽象类</strong>，<strong>不能直接创建对象</strong>。</p></li></ul><p><strong>Calendar日历类创建日历对象的方法：</strong></p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td><strong>public  static Calendar getInstance()</strong></td><td><strong>获取当前日历对象</strong></td></tr></tbody></table><p><strong>Calendar常用方法</strong></p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public int get(int field)</td><td>取日期中的某个字段信息。</td></tr><tr><td>public void set(int field,int value)</td><td>修改日历的某个字段信息。</td></tr><tr><td>public void add(int field,int amount)</td><td>为某个字段增加&#x2F;减少指定的值</td></tr><tr><td>public final Date getTime()</td><td>拿到此刻日期对象。</td></tr><tr><td>public long getTimeInMillis()</td><td>拿到此刻时间毫秒值</td></tr></tbody></table><p><strong>注意：calendar是可变日期对象，一旦修改后其对象本身表示的时间将产生变化。</strong></p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 1、拿到系统此刻日历对象</span></span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">cal</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        System.out.println(cal);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、获取日历的信息:public int get(int field)：</span></span><br><span class="line">取日期中的某个字段信息。</span><br><span class="line">        <span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> cal.get(Calendar.YEAR);</span><br><span class="line">        System.out.println(year);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">mm</span> <span class="operator">=</span> cal.get(Calendar.MONTH) + <span class="number">1</span>;</span><br><span class="line">        System.out.println(mm);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">days</span> <span class="operator">=</span> cal.get(Calendar.DAY_OF_YEAR) ;</span><br><span class="line">        System.out.println(days);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、public void set(int field,int value)：</span></span><br><span class="line"><span class="comment">//修改日历的某个字段信息。(很少使用)</span></span><br><span class="line"><span class="comment">// cal.set(Calendar.HOUR , 12);</span></span><br><span class="line"><span class="comment">// System.out.println(cal);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.public void add(int field,int amount)：为某个字段增加/减少指定的值</span></span><br><span class="line"><span class="comment">// 请问64天后是什么时间</span></span><br><span class="line">        cal.add(Calendar.DAY_OF_YEAR , <span class="number">64</span>);</span><br><span class="line">        <span class="comment">//请问59分钟后是什么时间</span></span><br><span class="line">        cal.add(Calendar.MINUTE , <span class="number">59</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  5.public final Date getTime(): 拿到此刻日期对象。</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> cal.getTime();</span><br><span class="line">        System.out.println(d);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  6.public long getTimeInMillis(): 拿到此刻时间毫秒值</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> cal.getTimeInMillis();</span><br><span class="line">        System.out.println(time);</span><br></pre></td></tr></table></figure><h3 id="2-JDK8新增日期类（new）"><a href="#2-JDK8新增日期类（new）" class="headerlink" title="2.JDK8新增日期类（new）"></a>2.JDK8新增日期类（new）</h3><h4 id="2-1概述"><a href="#2-1概述" class="headerlink" title="2.1概述"></a>2.1概述</h4><ul><li><p>从Java 8开始，java.time包提供了新的日期和时间API，主要涉及的类型有：</p><p>​                                <strong>LocalDate</strong>：不包含具体时间的日期。</p><p>​                            <strong>LocalTime</strong>：不含日期的时间。</p><p>​                            <strong>LocalDateTime</strong>：包含了日期及时间。</p></li></ul><p><strong>JDK8新增日期类</strong>   <strong>Instant</strong>：代表的是时间戳。</p><p>  ​                                 <strong>DateTimeFormatter</strong> 用于做时间的格式化和解析的</p><p>  ​                                 <strong>Duration</strong>:用于计算两个“时间”间隔</p><p>  ​                                 <strong>Period</strong>:用于计算两个“日期”间隔</p><ul><li><p>新增的API严格区分了<strong>时刻、本地日期、本地时间</strong>，并且，对日期和时间进行运算更加方便。</p></li><li><p>其次，新API的类型几乎全部是<strong>不变类型</strong>（和String的使用类似），可以放心使用不必担心被修改。</p></li></ul><h4 id="2-2LocalDate、LocalTime、LocalDateTime"><a href="#2-2LocalDate、LocalTime、LocalDateTime" class="headerlink" title="2.2LocalDate、LocalTime、LocalDateTime"></a>2.2LocalDate、LocalTime、LocalDateTime</h4><ul><li><p>他们 分别表示日期，时间，日期时间对象，他们的类的实例是不可变的对象。</p></li><li><p><strong>他们三者构建对象和API都是通用的</strong>。</p></li></ul><p><strong>构建对象的方式如下：</strong></p><table><thead><tr><th align="left">方法名</th><th align="center">说明</th><th align="left"></th></tr></thead><tbody><tr><td align="left">public static Xxxx now();</td><td align="center">静态方法，根据当前时间创建对象</td><td align="left">LocaDate localDate &#x3D; LocalDate.now();     LocalTime llocalTime &#x3D; LocalTime.<em>now</em>();     LocalDateTime localDateTime &#x3D; LocalDateTime.<em>now</em>();</td></tr><tr><td align="left">public static Xxxx of(…);</td><td align="center">静态方法，指定日期&#x2F;时间创建对象</td><td align="left">LocalDate  localDate1 &#x3D;  LocalDate.<em>of</em>(2099  ,  11,11);                                                           LocalTime  localTime1 &#x3D;  LocalTime.<em>of</em>(11, 11, 11);                             LocalDateTime  localDateTime1 &#x3D;  LocalDateTime.<em>of</em>(2020, 10, 6, 13, 23, 43);</td></tr></tbody></table><p><strong>LocalDate、LocalTime、LocalDateTime获取信息的API.</strong></p><table><thead><tr><th align="left">方法名</th><th>说明</th></tr></thead><tbody><tr><td align="left">public int getYear()</td><td>获取年</td></tr><tr><td align="left">public int getMonthValue()</td><td>获取月份（1-12）</td></tr><tr><td align="left">Public int getDayOfMonth()</td><td>获取月中第几天</td></tr><tr><td align="left">Public int getDayOfYear()</td><td>获取年中第几天</td></tr><tr><td align="left">Public DayOfWeek getDayOfWeek()</td><td>获取星期</td></tr></tbody></table><p><strong>转换相关的API</strong></p><p>*<strong>LocalDateTime 包括了</strong> <em><strong>LocalDate和LocalTime</strong></em></p><p><strong>LocalDateTime的转换API</strong></p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td><strong>public LocalDate toLocalDate()</strong></td><td><strong>转换成一个LocalDate对象</strong></td></tr><tr><td><strong>public LocalTime toLocalTime()</strong></td><td><strong>转换成一个LocalTime对象</strong></td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取当前时间对象</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">ld</span> <span class="operator">=</span> nowDateTime.toLocalDate();</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用toLocalTime方法，将nowDateTime转换成LocalTime</span></span><br><span class="line"><span class="type">LocalTime</span> <span class="variable">lt</span> <span class="operator">=</span> nowDateTime.toLocalTime();</span><br><span class="line">System.out.println(lt.getHour());<span class="comment">//获取小时</span></span><br><span class="line">System.out.println(lt.getMinute());<span class="comment">//获取分钟</span></span><br><span class="line">System.out.println(lt.getSecond());<span class="comment">//获取秒</span></span><br></pre></td></tr></table></figure><p><strong>修改相关的API</strong></p><ul><li><p>LocalDateTime 综合了 LocalDate 和 LocalTime 里面的方法，所以下面只用 LocalDate 和 LocalTime 来举例。</p></li><li><p>这些方法返回的是一个新的实例引用，因为LocalDateTime 、LocalDate 、LocalTime 都是不可变的。</p></li></ul><table><thead><tr><th align="left">方法名</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">plusDays                       plusWeeks               plusMonths                  plusYears</td><td align="left">向当前 LocalDate 对象添加几天、 几周、几个月、几年</td></tr><tr><td align="left">minusDays                minusWeeks         minusMonths           minusYears</td><td align="left">从当前 LocalDate 对象减去几天、 几周、几个月、几年</td></tr><tr><td align="left">withDayOfMonth withDayOfYear          withMonth                      withYear</td><td align="left">将月份天数、年份天数、月份、年 份 修 改 为 指 定 的 值 并 返 回 新  的 LocalDate 对象</td></tr><tr><td align="left">isBefore                             isAfter</td><td align="left">比较两个 LocalDate</td></tr></tbody></table><p><strong>修改相关的API代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当前时间</span></span><br><span class="line"><span class="type">LocalTime</span> <span class="variable">nowTime</span> <span class="operator">=</span> LocalTime.now();</span><br><span class="line">System.out.println(nowTime);</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.plus方法</span></span><br><span class="line">System.out.println(nowTime.plusHours(<span class="number">1</span>));<span class="comment">//一小时后</span></span><br><span class="line">System.out.println(nowTime.plusMinutes(<span class="number">1</span>));<span class="comment">//一分钟后</span></span><br><span class="line">System.out.println(nowTime.plusSeconds(<span class="number">1</span>));<span class="comment">//一秒后</span></span><br><span class="line">System.out.println(nowTime.plusNanos(<span class="number">1</span>));<span class="comment">//一纳秒后</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.minus方法</span></span><br><span class="line">System.out.println(nowTime.minusHours(<span class="number">1</span>));<span class="comment">//一小时前</span></span><br><span class="line">System.out.println(nowTime.minusMinutes(<span class="number">1</span>));<span class="comment">//一分钟前</span></span><br><span class="line">System.out.println(nowTime.minusSeconds(<span class="number">1</span>));<span class="comment">//一秒前</span></span><br><span class="line">System.out.println(nowTime.minusNanos(<span class="number">1</span>));<span class="comment">//一纳秒前</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">birDate</span> <span class="operator">=</span> LocalDate.of(<span class="number">1996</span>, <span class="number">8</span>, <span class="number">5</span>);<span class="comment">//生日日期对象</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">nowDate1</span> <span class="operator">=</span> LocalDate.now();<span class="comment">//当前日期对象</span></span><br><span class="line"></span><br><span class="line"><span class="type">MonthDay</span> <span class="variable">birMd</span> <span class="operator">=</span> MonthDay.of(birDate.getMonthValue(), birDate.getDayOfMonth());<span class="comment">//获取生日日期对象中的月 日</span></span><br><span class="line"><span class="type">MonthDay</span> <span class="variable">nowMd</span> <span class="operator">=</span> MonthDay.from(nowDate1);<span class="comment">//使用MonthDay方法获取当前日期对象中的月 日</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;今天是你的生日吗？&quot;</span>+birMd.equals(nowMd));</span><br><span class="line"><span class="comment">//今天是你的生日吗？ false</span></span><br></pre></td></tr></table></figure><p><strong>LocalData代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1、获取本地日期对象。</span></span><br><span class="line">        <span class="comment">//今天的日期：</span></span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">nowDate</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">        System.out.println(<span class="string">&quot;今天的日期：&quot;</span> + nowDate);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取年</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> nowDate.getYear();</span><br><span class="line">        System.out.println(<span class="string">&quot;year：&quot;</span> + year);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取月</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> nowDate.getMonthValue();</span><br><span class="line">        System.out.println(<span class="string">&quot;month：&quot;</span> + month);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取日</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> nowDate.getDayOfMonth();</span><br><span class="line">        System.out.println(<span class="string">&quot;day：&quot;</span> + day);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当年的第几天</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">dayOfYear</span> <span class="operator">=</span> nowDate.getDayOfYear();</span><br><span class="line">        System.out.println(<span class="string">&quot;dayOfYear：&quot;</span> + dayOfYear);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//星期</span></span><br><span class="line">        System.out.println(nowDate.getDayOfWeek());</span><br><span class="line">           System.out.println(nowDate.getDayOfWeek().getValue());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//月份</span></span><br><span class="line">        System.out.println(nowDate.getMonth());<span class="comment">//AUGUST</span></span><br><span class="line">        System.out.println(nowDate.getMonth().getValue());<span class="comment">//8</span></span><br><span class="line"></span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">bt</span> <span class="operator">=</span> LocalDate.of(<span class="number">1991</span>, <span class="number">11</span>, <span class="number">11</span>);</span><br><span class="line">        System.out.println(bt);<span class="comment">//直接传入对应的年月日</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//相对上面只是把月换成了枚举</span></span><br><span class="line">System.out.println(LocalDate.of(<span class="number">1991</span>, Month.NOVEMBER, <span class="number">11</span>));</span><br></pre></td></tr></table></figure><p><strong>LocalTime</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1、获取本地时间对象。</span></span><br><span class="line">        <span class="type">LocalTime</span> <span class="variable">nowTime</span> <span class="operator">=</span> LocalTime.now();</span><br><span class="line">        System.out.println(<span class="string">&quot;今天的时间：&quot;</span> + nowTime);<span class="comment">//今天的时间：</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">hour</span> <span class="operator">=</span> nowTime.getHour();<span class="comment">//时</span></span><br><span class="line">        System.out.println(<span class="string">&quot;hour：&quot;</span> + hour);<span class="comment">//hour：</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">minute</span> <span class="operator">=</span> nowTime.getMinute();<span class="comment">//分</span></span><br><span class="line">        System.out.println(<span class="string">&quot;minute：&quot;</span> + minute);<span class="comment">//minute：</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">second</span> <span class="operator">=</span> nowTime.getSecond();<span class="comment">//秒</span></span><br><span class="line">        System.out.println(<span class="string">&quot;second：&quot;</span> + second);<span class="comment">//second：</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">nano</span> <span class="operator">=</span> nowTime.getNano();<span class="comment">//纳秒</span></span><br><span class="line">        System.out.println(<span class="string">&quot;nano：&quot;</span> + nano);<span class="comment">//nano：</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建Time</span></span><br><span class="line">        System.out.println(LocalTime.of(<span class="number">8</span>, <span class="number">20</span>));<span class="comment">//时分</span></span><br><span class="line">        System.out.println(LocalTime.of(<span class="number">8</span>, <span class="number">20</span>, <span class="number">30</span>));<span class="comment">//时分秒</span></span><br><span class="line">        System.out.println(LocalTime.of(<span class="number">8</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">150</span>));</span><br><span class="line">        <span class="comment">//时分秒纳秒       </span></span><br></pre></td></tr></table></figure><p><strong>LocalDataTime代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 日期 时间</span></span><br><span class="line">        <span class="comment">//创建现在日期 时间</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">nowDateTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        System.out.println(<span class="string">&quot;今天是：&quot;</span> + nowDateTime);<span class="comment">//今天是：</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(nowDateTime.getYear());<span class="comment">//获取年</span></span><br><span class="line">        System.out.println(nowDateTime.getMonthValue());<span class="comment">//月</span></span><br><span class="line">        System.out.println(nowDateTime.getDayOfMonth());<span class="comment">//日</span></span><br><span class="line">        System.out.println(nowDateTime.getHour());<span class="comment">//时</span></span><br><span class="line">        System.out.println(nowDateTime.getMinute());<span class="comment">//分</span></span><br><span class="line">        System.out.println(nowDateTime.getSecond());<span class="comment">//秒</span></span><br><span class="line">        System.out.println(nowDateTime.getNano());<span class="comment">//纳秒</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//日：当年的第几天</span></span><br><span class="line">System.out.println(<span class="string">&quot;dayOfYear：&quot;</span> + nowDateTime.getDayOfYear());<span class="comment">//dayOfYear：249</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//星期</span></span><br><span class="line"><span class="comment">//THURSDAY </span></span><br><span class="line">System.out.println(nowDateTime.getDayOfWeek());</span><br><span class="line"><span class="comment">//4</span></span><br><span class="line">System.out.println(nowDateTime.getDayOfWeek().getValue());</span><br><span class="line"></span><br><span class="line"><span class="comment">//月份</span></span><br><span class="line"><span class="comment">//SEPTEMBER   </span></span><br><span class="line">System.out.println(nowDateTime.getMonth()); </span><br><span class="line"><span class="comment">//9</span></span><br><span class="line">System.out.println(nowDateTime.getMonth().getValue());</span><br></pre></td></tr></table></figure><h4 id="2-3Instant（时间戳，了解）"><a href="#2-3Instant（时间戳，了解）" class="headerlink" title="2.3Instant（时间戳，了解）"></a>2.3Instant（时间戳，了解）</h4><p><strong>Instant时间戳</strong></p><ul><li>JDK8获取时间戳特别简单，且功能更丰富。Instant类由一个静态的工厂方法now()可以返回当前时间戳。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Instant</span> <span class="variable">instant</span> <span class="operator">=</span> Instant.now();</span><br><span class="line">System.out.println(<span class="string">&quot;当前时间戳是：&quot;</span> + instant);</span><br><span class="line"></span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> Date.from(instant);</span><br><span class="line">System.out.println(<span class="string">&quot;当前时间戳是：&quot;</span> + date);</span><br><span class="line"></span><br><span class="line">instant = date.toInstant();</span><br><span class="line">System.out.println(instant);</span><br></pre></td></tr></table></figure><ul><li><p><strong>时间戳是包含日期和时间的</strong>，与java.util.Date很类似，事实上Instant就是类似JDK8 以前的Date。</p></li><li><p><strong>Instant和Date这两个类可以进行转换。</strong></p></li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1、得到一个Instant时间戳对象</span></span><br><span class="line"><span class="type">Instant</span> <span class="variable">instant</span> <span class="operator">=</span> Instant.now();</span><br><span class="line">System.out.println(instant);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、系统此刻的时间戳&gt;&gt;&gt;转换为此刻的时间对象</span></span><br><span class="line"><span class="type">Instant</span> <span class="variable">instant1</span> <span class="operator">=</span> Instant.now();      </span><br><span class="line">System.out.println(instant1.atZone(ZoneId.systemDefault()));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、如何去返回Date对象</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> Date.from(instant);</span><br><span class="line">System.out.println(date);</span><br><span class="line"></span><br><span class="line"><span class="type">Instant</span> <span class="variable">i2</span> <span class="operator">=</span> date.toInstant();</span><br><span class="line">System.out.println(i2);</span><br></pre></td></tr></table></figure><h4 id="2-4DateTimeFormatter（日期时间格式化）"><a href="#2-4DateTimeFormatter（日期时间格式化）" class="headerlink" title="2.4DateTimeFormatter（日期时间格式化）"></a>2.4DateTimeFormatter（日期时间格式化）</h4><ul><li><p>在JDK8中，引入了一个全新的日期与时间格式器DateTimeFormatter。</p></li><li><p>正反都能调用format方法。</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取当前日期时间</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">ldt</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">System.out.println(ldt);<span class="comment">//2021-03-01T15:09:17.444190900</span></span><br><span class="line"></span><br><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">dtf</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">ldtStr</span> <span class="operator">=</span> ldt.format(dtf);</span><br><span class="line">System.out.println(ldtStr);<span class="comment">//2021-03-01 15:09:17</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">ldtStr1</span> <span class="operator">=</span> dtf.format(ldt);</span><br><span class="line">System.out.println(ldtStr1);<span class="comment">//2021-03-01 15:09:17</span></span><br></pre></td></tr></table></figure><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一:解析本地此刻 </span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">ldt</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">System.out.println(ldt);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 解析/格式化器&gt;&gt;&gt;DateTimeFormatter</span></span><br><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">dtf</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss EEE a&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//格式化方法&gt;&gt;&gt;format</span></span><br><span class="line">/ 正向格式化</span><br><span class="line">System.out.println(dtf.format(ldt));</span><br><span class="line">/ 逆向格式化</span><br><span class="line">System.out.println(ldt.format(dtf));</span><br><span class="line">————————————————————————————————————————————————————————————</span><br><span class="line"><span class="comment">// 二:解析字符串时间</span></span><br><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">dtf1</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"><span class="comment">// parse方法，解析当前字符串时间成为本地日期时间对象</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">ldt1</span> <span class="operator">=</span> LocalDateTime.parse(<span class="string">&quot;2019-11-11 11:11:11&quot;</span> ,  dtf1);</span><br><span class="line">System.out.println(ldt1);</span><br></pre></td></tr></table></figure><h4 id="2-5Duration-Period（计算时间-日期间隔）"><a href="#2-5Duration-Period（计算时间-日期间隔）" class="headerlink" title="2.5Duration&#x2F;Period（计算时间&#x2F;日期间隔）"></a>2.5Duration&#x2F;Period（计算时间&#x2F;日期间隔）</h4><p><strong>Duration</strong></p><ul><li><p>在Java8中，我们可以使用以下类来计算<strong>时间间隔</strong>差异：java.time.Duration</p></li><li><p>提供了使用基于时间的值测量时间量的方法。</p></li><li><p>用于 <strong>LocalDateTime</strong> 之间的比较。也可用于 <strong>Instant</strong> 之间的比较。</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 本地日期时间对象。</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">today</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">System.out.println(today);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出生的日期时间对象</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">birthDate</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">1990</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">50</span>,<span class="number">30</span>);</span><br><span class="line">System.out.println(birthDate);</span><br><span class="line"></span><br><span class="line"><span class="type">Duration</span> <span class="variable">duration</span> <span class="operator">=</span> Duration.between(birthDate, today);<span class="comment">//第二个参数减第一个参数</span></span><br><span class="line">System.out.println(duration.toDays());<span class="comment">//两个时间差的天数</span></span><br><span class="line">System.out.println(duration.toHours());<span class="comment">//两个时间差的小时数System.out.println(duration.toMinutes());//两个时间差的分钟数System.out.println(duration.toMillis());//两个时间差的毫秒数System.out.println(duration.toNanos());//两个时间差的纳秒数</span></span><br></pre></td></tr></table></figure><p><strong>Period</strong></p><ul><li><p>在Java8中，我们可以使用以下类来计算<strong>日期间隔</strong>差异：java.time.Period</p></li><li><p>主要是 **Period 类方法 getYears()，getMonths() 和 getDays() **来计算,只能精确到年月日。</p></li><li><p>用于 <strong>LocalDate</strong> 之间的比较。</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LocalDate</span> <span class="variable">today</span> <span class="operator">=</span> LocalDate.now();<span class="comment">//获取当前日期对象</span></span><br><span class="line">System.out.println(today);        <span class="comment">// 2021-03-01</span></span><br><span class="line"></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">birthDate</span> <span class="operator">=</span> LocalDate.of(<span class="number">1995</span>, <span class="number">1</span>, <span class="number">11</span>);</span><br><span class="line">System.out.println(birthDate);    <span class="comment">// 1995-01-11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//调用Period.between方法</span></span><br><span class="line"><span class="type">Period</span> <span class="variable">period</span> <span class="operator">=</span> Period.between(birthDate, today);</span><br><span class="line"><span class="comment">//第二个参数减第一个参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//比较日期间隔</span></span><br><span class="line">System.out.printf(<span class="string">&quot;年龄 : %d 年 %d 月 %d 日&quot;</span>, </span><br><span class="line">period.getYears(), period.getMonths(), period.getDays());</span><br></pre></td></tr></table></figure><h4 id="2-6ChronoUnit（计算时间日期间隔-更全面）"><a href="#2-6ChronoUnit（计算时间日期间隔-更全面）" class="headerlink" title="2.6ChronoUnit（计算时间日期间隔&gt;&gt;&gt;更全面）"></a>2.6ChronoUnit（计算时间日期间隔&gt;&gt;&gt;更全面）</h4><p><strong>java.time.temporal.ChronoUnit</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 本地日期时间对象：此刻的</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">today</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">System.out.println(today);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生日时间</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">birthDate</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">1990</span>,<span class="number">10</span>,<span class="number">1</span>,</span><br><span class="line"><span class="number">10</span>,<span class="number">50</span>,<span class="number">59</span>);</span><br><span class="line">System.out.println(birthDate);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;相差的年数：&quot;</span> + ChronoUnit.YEARS.between(birthDate, today));</span><br><span class="line">System.out.println(<span class="string">&quot;相差的月数：&quot;</span> + ChronoUnit.MONTHS.between(birthDate, today));</span><br><span class="line">System.out.println(<span class="string">&quot;相差的周数：&quot;</span> + ChronoUnit.WEEKS.between(birthDate, today));</span><br><span class="line">System.out.println(<span class="string">&quot;相差的天数：&quot;</span> + ChronoUnit.DAYS.between(birthDate, today));</span><br><span class="line">System.out.println(<span class="string">&quot;相差的时数：&quot;</span> + ChronoUnit.HOURS.between(birthDate, today));</span><br><span class="line">System.out.println(<span class="string">&quot;相差的分数：&quot;</span> + ChronoUnit.MINUTES.between(birthDate, today));</span><br><span class="line">System.out.println(<span class="string">&quot;相差的秒数：&quot;</span> + ChronoUnit.SECONDS.between(birthDate, today));</span><br><span class="line">System.out.println(<span class="string">&quot;相差的毫秒数：&quot;</span> + ChronoUnit.MILLIS.between(birthDate, today));</span><br><span class="line">System.out.println(<span class="string">&quot;相差的微秒数：&quot;</span> + ChronoUnit.MICROS.between(birthDate, today));</span><br><span class="line">System.out.println(<span class="string">&quot;相差的纳秒数：&quot;</span> + ChronoUnit.NANOS.between(birthDate, today));</span><br><span class="line">System.out.println(<span class="string">&quot;相差的半天数：&quot;</span> + ChronoUnit.HALF_DAYS.between(birthDate, today));</span><br><span class="line">System.out.println(<span class="string">&quot;相差的十年数：&quot;</span> + ChronoUnit.DECADES.between(birthDate, today));</span><br><span class="line">System.out.println(<span class="string">&quot;相差的世纪（百年）数：&quot;</span> + ChronoUnit.CENTURIES.between(birthDate, today));</span><br><span class="line">System.out.println(<span class="string">&quot;相差的千年数：&quot;</span> + ChronoUnit.MILLENNIA.between(birthDate, today));</span><br><span class="line">System.out.println(<span class="string">&quot;相差的纪元数：&quot;</span> + ChronoUnit.ERAS.between(birthDate, today));</span><br></pre></td></tr></table></figure><h3 id="3-包装类（-引用数据类型-）"><a href="#3-包装类（-引用数据类型-）" class="headerlink" title="3.包装类（ 引用数据类型  ）"></a>3.包装类（ 引用数据类型  ）</h3><ul><li>其实就是8种基本数据类型对应的引用类型。</li></ul><table><thead><tr><th align="center">基本数据类型</th><th align="center">引用数据类型</th></tr></thead><tbody><tr><td align="center"><strong>byte</strong></td><td align="center"><strong>Byte</strong></td></tr><tr><td align="center"><strong>short</strong></td><td align="center"><strong>Short</strong></td></tr><tr><td align="center"><strong>int</strong></td><td align="center"><strong>Integer</strong></td></tr><tr><td align="center"><strong>long</strong></td><td align="center"><strong>Long</strong></td></tr><tr><td align="center"><strong>char</strong></td><td align="center"><strong>Character</strong></td></tr><tr><td align="center"><strong>float</strong></td><td align="center"><strong>Float</strong></td></tr><tr><td align="center"><strong>double</strong></td><td align="center"><strong>Double</strong></td></tr><tr><td align="center"><strong>boolean</strong></td><td align="center"><strong>Boolean</strong></td></tr></tbody></table><p><strong>为什么提供包装类？</strong></p><ul><li><p>Java为了实现一切皆对象，为<strong>8种基本类型提供了对应的引用类型</strong>。</p></li><li><p>后面的<strong>集合和泛型其实也只能支持包装类型</strong>，不支持基本数据类型。</p></li></ul><p><strong>自动装箱</strong>：基本类型的数据和变量可以直接赋值给包装类型的变量。</p><p><strong>自动拆箱：</strong>包装类型的变量可以直接赋值给基本数据类型的变量。</p><p><strong>包装类的特有功能</strong></p><ul><li><p>包装类的变量的默认值可以是null，容错率更高。</p></li><li><p>可以把基本类型的数据转换成字符串类型(用处不大)</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1、包装类可以把基本类型的数据转换成字符串形式。（没啥用）</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">23</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">i2</span> <span class="operator">=</span> i1.toString();</span><br><span class="line">        System.out.println(i2 + <span class="number">1</span>);  <span class="comment">//231</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">23</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">i2</span> <span class="operator">=</span> Integer.toString(i1);</span><br><span class="line">        System.out.println(i2 + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以直接+字符串得到字符串类型 (更常用)</span></span><br><span class="line"><span class="type">String</span> <span class="variable">rs2</span> <span class="operator">=</span> i3 + <span class="string">&quot;&quot;</span>;</span><br><span class="line">System.out.println(rs2 + <span class="number">1</span>);</span><br></pre></td></tr></table></figure><ul><li>可以把字符串类型的数值转换成真实的数据类型<strong>（真的很有用）</strong></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2、可以把字符串类型的数值转换成真实的数据类型（实用）</span></span><br><span class="line"><span class="comment">//转换成整数</span></span><br><span class="line"><span class="type">String</span> <span class="variable">number1</span> <span class="operator">=</span> <span class="string">&quot;23&quot;</span>;</span><br><span class="line"><span class="comment">// int age = Integer.parseInt(number1);</span></span><br><span class="line"><span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> Integer.valueOf(number1); <span class="comment">//valueOf方法更常用</span></span><br><span class="line">System.out.println(age + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//转换成小数</span></span><br><span class="line"><span class="type">String</span> <span class="variable">number2</span> <span class="operator">=</span> <span class="string">&quot;99.9&quot;</span>;</span><br><span class="line"><span class="comment">//double score = Double.parseDouble(number2);</span></span><br><span class="line"><span class="type">double</span> <span class="variable">score</span> <span class="operator">=</span> Double.valueOf(number2);<span class="comment">//valueOf方法更常用</span></span><br><span class="line">System.out.println(score + <span class="number">0.1</span>);</span><br></pre></td></tr></table></figure><h3 id="4-正则表达式"><a href="#4-正则表达式" class="headerlink" title="4.正则表达式"></a>4.正则表达式</h3><h4 id="4-1正则表达式概述、初体验"><a href="#4-1正则表达式概述、初体验" class="headerlink" title="4.1正则表达式概述、初体验"></a>4.1正则表达式概述、初体验</h4><p><strong>正则表示</strong></p><ul><li>正则表达式可以用一些规定的字符来制定规则，并用来校验数据格式的合法性。</li></ul><p><strong>正则表达式初体验</strong></p><ul><li><p>需求：假如现在要求校验一个qq号码是否正确，6位及20位之内，必须全部是数字 。</p></li><li><p>先使用目前所学知识完成校验需求；然后体验一下正则表达式检验。</p></li></ul><h4 id="4-2正则表达式的匹配规则"><a href="#4-2正则表达式的匹配规则" class="headerlink" title="4.2正则表达式的匹配规则"></a>4.2正则表达式的匹配规则</h4><p><strong>字符串对象提供了匹配正则表达式的方法】</strong>【String】</p><p>​public boolean matches(<a href="file:///D:/course/%E5%9F%BA%E7%A1%80%E9%98%B6%E6%AE%B5/API%E6%96%87%E6%A1%A3/docs/api/java.base/java/lang/String.html">String</a> regex): 判断是否匹配正则表达式</p><p>​匹配返回true，不匹配返回false。</p><p><strong>字符类(默认匹配一个字符)</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[abc]       只能是a, b, 或c</span><br><span class="line">[^abc]       除了a, b, c之外的任何字符</span><br><span class="line">[a-zA-Z]                a到z A到Z，包括（范围）</span><br><span class="line">[a-d[m-p]]       a到d，或m通过p：（[a-dm-p]联合）</span><br><span class="line">[a-z&amp;&amp;[def]]        d, e, 或f(交集)</span><br><span class="line">[a-z&amp;&amp;[^bc]]        a到z，除了b和c：（[ad-z]减法）</span><br><span class="line">[a-z&amp;&amp;[^m-p]]           a到z，除了m到p：（[a-lq-z]减法）</span><br></pre></td></tr></table></figure><p><strong>预定义的字符类(默认匹配一个字符)</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.任何字符</span><br><span class="line">\d一个数字： [<span class="number">0</span>-<span class="number">9</span>]</span><br><span class="line">\D非数字： [^<span class="number">0</span>-<span class="number">9</span>]</span><br><span class="line">\s一个空白字符： [ \t\n\x0B\f\r]</span><br><span class="line">\S非空白字符： [^\s]</span><br><span class="line">\w[a-zA-Z_0-<span class="number">9</span>] 英文、数字、下划线</span><br><span class="line">\W [^\w] 一个非单词字符</span><br></pre></td></tr></table></figure><p><strong>贪婪的量词（配合匹配多个字符）</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">X?X , 一次或根本不</span><br><span class="line">X*X，零次或多次</span><br><span class="line">X+X , 一次或多次</span><br><span class="line">X&#123;n&#125;X，正好n次</span><br><span class="line">X&#123;n, &#125;X，至少n次</span><br><span class="line">X&#123;n,m&#125;X，至少n但不超过m次</span><br></pre></td></tr></table></figure><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//只能是 a  b  c  正则匹配只能校验单个字符。</span></span><br><span class="line">System.out.println(<span class="string">&quot;a&quot;</span>.matches(<span class="string">&quot;[abc]&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">System.out.println(<span class="string">&quot;z&quot;</span>.matches(<span class="string">&quot;[abc]&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不能出现a  b  c</span></span><br><span class="line">System.out.println(<span class="string">&quot;a&quot;</span>.matches(<span class="string">&quot;[^abc]&quot;</span>)); <span class="comment">// false</span></span><br><span class="line">System.out.println(<span class="string">&quot;z&quot;</span>.matches(<span class="string">&quot;[^abc]&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;a&quot;</span>.matches(<span class="string">&quot;\\d&quot;</span>)); <span class="comment">// false</span></span><br><span class="line">System.out.println(<span class="string">&quot;3&quot;</span>.matches(<span class="string">&quot;\\d&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">System.out.println(<span class="string">&quot;333&quot;</span>.matches(<span class="string">&quot;\\d&quot;</span>)); <span class="comment">// false</span></span><br><span class="line">System.out.println(<span class="string">&quot;z&quot;</span>.matches(<span class="string">&quot;\\w&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">System.out.println(<span class="string">&quot;2&quot;</span>.matches(<span class="string">&quot;\\w&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">System.out.println(<span class="string">&quot;21&quot;</span>.matches(<span class="string">&quot;\\w&quot;</span>)); <span class="comment">// false</span></span><br><span class="line">System.out.println(<span class="string">&quot;你&quot;</span>.matches(<span class="string">&quot;\\w&quot;</span>)); <span class="comment">//false</span></span><br><span class="line">System.out.println(<span class="string">&quot;你&quot;</span>.matches(<span class="string">&quot;\\W&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="comment">// 校验密码</span></span><br><span class="line"><span class="comment">// 必须是数字 字母 下划线 至少 6位</span></span><br><span class="line">System.out.println(<span class="string">&quot;2442fsfsf&quot;</span>.matches(<span class="string">&quot;\\w&#123;6,&#125;&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;244f&quot;</span>.matches(<span class="string">&quot;\\w&#123;6,&#125;&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证码 必须是数字和字符  必须是4位</span></span><br><span class="line">System.out.println(<span class="string">&quot;23dF&quot;</span>.matches(<span class="string">&quot;[a-zA-Z0-9]&#123;4&#125;&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;23_F&quot;</span>.matches(<span class="string">&quot;[a-zA-Z0-9]&#123;4&#125;&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;23dF&quot;</span>.matches(<span class="string">&quot;[\\w&amp;&amp;[^_]]&#123;4&#125;&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;23_F&quot;</span>.matches(<span class="string">&quot;[\\w&amp;&amp;[^_]]&#123;4&#125;&quot;</span>));</span><br></pre></td></tr></table></figure><h4 id="4-3正则表达式的常见案例"><a href="#4-3正则表达式的常见案例" class="headerlink" title="4.3正则表达式的常见案例"></a>4.3正则表达式的常见案例</h4><p><strong>请使用正则表达式完成如下需求:</strong></p><p><strong>需求</strong></p><ul><li><p>①请编写程序模拟用户输入手机号码、验证格式正确，并给出提示，直到格式输入正确为止。</p></li><li><p>②请编写程序模拟用户输入邮箱号码、验证格式正确，并给出提示，直到格式输入正确为止。</p></li><li><p>③请编写程序模拟用户输入电话号码、验证格式正确，并给出提示，直到格式输入正确为止。</p></li></ul><p><strong>分析</strong></p><ul><li>定义方法，接收用户输入的数据，使用正则表达式完成检验，并给出提示。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 目标：校验 手机号码 邮箱  电话号码</span></span><br><span class="line"><span class="comment">// checkPhone();</span></span><br><span class="line"><span class="comment">// checkEmail();</span></span><br><span class="line"><span class="comment">// checkTel();</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkTel</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请您输入您的电话号码：&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">tel</span> <span class="operator">=</span> sc.next();</span><br><span class="line">            <span class="comment">// 判断邮箱格式是否正确   027-3572457  0273572457</span></span><br><span class="line">            <span class="keyword">if</span>(tel.matches(<span class="string">&quot;0\\d&#123;2,6&#125;-?\\d&#123;5,20&#125;&quot;</span>))&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;格式正确，注册完成！&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;格式有误！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkEmail</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请您输入您的注册邮箱：&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">email</span> <span class="operator">=</span> sc.next();</span><br><span class="line">            <span class="comment">// 判断邮箱格式是否正确   3268847878@qq.com</span></span><br><span class="line">            <span class="comment">// 判断邮箱格式是否正确   3268847dsda878@163.com</span></span><br><span class="line">            <span class="comment">// 判断邮箱格式是否正确   3268847dsda878@pci.com.cn</span></span><br><span class="line">            <span class="keyword">if</span>(email.matches(<span class="string">&quot;\\w&#123;1,30&#125;@[a-zA-Z0-9]&#123;2,20&#125;(\\.[a-zA-Z0-9]&#123;2,20&#125;)&#123;1,2&#125;&quot;</span>))&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;邮箱格式正确，注册完成！&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;格式有误！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkPhone</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请您输入您的注册手机号码：&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> sc.next();</span><br><span class="line">            <span class="comment">// 判断手机号码的格式是否正确</span></span><br><span class="line">            <span class="keyword">if</span>(phone.matches(<span class="string">&quot;1[3-9]\\d&#123;9&#125;&quot;</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;手机号码格式正确，注册完成！&quot;</span>);</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;格式有误！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="4-4正则表达式在方法中的应用"><a href="#4-4正则表达式在方法中的应用" class="headerlink" title="4.4正则表达式在方法中的应用"></a>4.4正则表达式在方法中的应用</h4><p><strong>正则表达式在字符串方法中的使用</strong></p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public String replaceAll(String regex,String newStr)</td><td>按照正则表达式匹配的内容进行替换</td></tr><tr><td>public String[] split(String regex)：</td><td>按照正则表达式匹配的内容进行分割字符串，反回一个字符串数组。</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：正则表达式在方法中的应用。</span></span><br><span class="line"><span class="comment">        public String[] split(String regex)：</span></span><br><span class="line"><span class="comment">            -- 按照正则表达式匹配的内容进行分割字符串，反回一个字符串数组。</span></span><br><span class="line"><span class="comment">        public String replaceAll(String regex,String newStr)</span></span><br><span class="line"><span class="comment">            -- 按照正则表达式匹配的内容进行替换</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">      <span class="type">String</span> <span class="variable">names</span> <span class="operator">=</span> <span class="string">&quot;小路dhdfhdf342蓉儿43fdffdfbjdfaf小何&quot;</span>;</span><br><span class="line"></span><br><span class="line">      String[] arrs = names.split(<span class="string">&quot;\\w+&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arrs.length; i++) &#123;</span><br><span class="line">          System.out.println(arrs[i]); </span><br><span class="line">      &#125; <span class="comment">//小路 </span></span><br><span class="line"><span class="comment">//蓉儿 </span></span><br><span class="line">    <span class="comment">//小何</span></span><br><span class="line"></span><br><span class="line">      <span class="type">String</span> <span class="variable">names2</span> <span class="operator">=</span> names.replaceAll(<span class="string">&quot;\\w+&quot;</span>, <span class="string">&quot;  &quot;</span>);</span><br><span class="line">      System.out.println(names2);  <span class="comment">//小路  蓉儿  小何</span></span><br></pre></td></tr></table></figure><h4 id="4-5正则表达式爬取信息"><a href="#4-5正则表达式爬取信息" class="headerlink" title="4.5正则表达式爬取信息"></a>4.5正则表达式爬取信息</h4><p><strong>正则表达式支持爬取信息</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    拓展：正则表达式爬取信息中的内容。(了解)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="string">&quot;来黑马程序学习Java,电话020-43422424，或者联系邮箱&quot;</span> +</span><br><span class="line">            <span class="string">&quot;itcast@itcast.cn,电话18762832633，0203232323&quot;</span> +</span><br><span class="line">            <span class="string">&quot;邮箱bozai@itcast.cn，400-100-3233 ，4001003232&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需求：从上面的内容中爬取出 电话号码和邮箱。</span></span><br><span class="line"><span class="comment">// 1、定义爬取规则，字符串形式</span></span><br><span class="line"><span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;(\\w&#123;1,30&#125;@[a-zA-Z0-9]&#123;2,20&#125;(\\.[a-zA-Z0-9]&#123;2,20&#125;)&#123;1,2&#125;)|(1[3-9]\\d&#123;9&#125;)&quot;</span> +</span><br><span class="line"><span class="string">&quot;|(0\\d&#123;2,6&#125;-?\\d&#123;5,20&#125;)|(400?\\d&#123;3,9&#125;-?\\d&#123;3,9&#125;)&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、把这个爬取规则编译成匹配对象。</span></span><br><span class="line"><span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(regex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、得到一个内容匹配器对象</span></span><br><span class="line"><span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(rs);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4、开始找了</span></span><br><span class="line"><span class="keyword">while</span> (matcher.find()) &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">rs1</span> <span class="operator">=</span> matcher.group();</span><br><span class="line">System.out.println(rs1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//金额判断</span></span><br><span class="line"> <span class="keyword">if</span> (num.matches(<span class="string">&quot;([0]?|[1-9]&#123;1,&#125;\\d*)(\\.?[0-9]&#123;1,2&#125;)&quot;</span>) </span><br></pre></td></tr></table></figure><h3 id="5-Arrays类-数组操作"><a href="#5-Arrays类-数组操作" class="headerlink" title="5.Arrays类(数组操作)"></a>5.Arrays类(数组操作)</h3><h4 id="5-1Arrays类概述，常用功能演示"><a href="#5-1Arrays类概述，常用功能演示" class="headerlink" title="5.1Arrays类概述，常用功能演示"></a>5.1Arrays类概述，常用功能演示</h4><p><strong>Arrays类概述</strong></p><ul><li><strong>数组操作</strong>工具类，专门用于操作数组元素的。</li></ul><p><strong>Arrays类的常用API</strong></p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public static <a href="mk:@MSITStore:C:\course\API文档\jdk-9_google.CHM::/java/lang/String.html">String</a> <strong>toString</strong>(类型[] a)</td><td>返回<strong>数组的内容</strong>（字符串形式）</td></tr><tr><td>public  static void <strong>sort</strong>(类型[] a)</td><td>对数组进行<strong>默认升序排序</strong></td></tr><tr><td>public  static <T> void <strong>sort</strong>(类型[] a, <a href="mk:@MSITStore:C:\course\API文档\jdk-9_google.CHM::/java/util/Comparator.html">Comparator</a>&lt;?  super T&gt; c)</td><td>使用比较器对象<strong>自定义排序</strong></td></tr><tr><td>public  static int <strong>binarySearch</strong>(int[] a,  int key)</td><td><strong>二分搜索</strong>数组中的数据，存在返回索引，不存在返回-1 （前提数组必须排好序才支持，否则出bug）</td></tr></tbody></table><p><strong>Arrays类<em>toString</em>(数组)和<em>binarySearch</em>二分搜索</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 目标：学会使用Arrays类的常用API ,并理解其原理</span></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">10</span>, <span class="number">2</span>, <span class="number">55</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">100</span>&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、返回数组内容的 toString(数组)</span></span><br><span class="line">        <span class="comment">//String rs = Arrays.toString(arr);//String接</span></span><br><span class="line">        <span class="comment">//System.out.println(rs);</span></span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(arr));<span class="comment">//直接输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、二分搜索技术（前提数组必须排好序才支持，否则出bug）</span></span><br><span class="line">        <span class="comment">// 排序的API(默认自动对数组元素进行升序排序)</span></span><br><span class="line">        Arrays.sort(arr); </span><br><span class="line">  </span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Arrays.binarySearch(arr, <span class="number">55</span>);<span class="comment">//检索字符55</span></span><br><span class="line">        System.out.println(index);<span class="comment">//返回索引</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回不存在元素索引的规律： - （应该插入的位置索引 + 1）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index2</span> <span class="operator">=</span> Arrays.binarySearch(arr, <span class="number">22</span>);</span><br><span class="line">        System.out.println(index2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：数组如果没有排好序，可能会找不到存在的元素，从而出现bug!!</span></span><br><span class="line">        <span class="type">int</span>[] arr2 = &#123;<span class="number">12</span>, <span class="number">36</span>, <span class="number">34</span>, <span class="number">25</span> , <span class="number">13</span>,  <span class="number">24</span>,  <span class="number">234</span>, <span class="number">100</span>&#125;;</span><br><span class="line">        System.out.println(Arrays.binarySearch(arr2 , <span class="number">36</span>));</span><br></pre></td></tr></table></figure><h4 id="5-2Arrays类对于Comparator比较器的支持"><a href="#5-2Arrays类对于Comparator比较器的支持" class="headerlink" title="5.2Arrays类对于Comparator比较器的支持"></a>5.2Arrays类对于Comparator比较器的支持</h4><p><strong>Arrays类的排序方法</strong></p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public  static void sort(类型[] a)</td><td>对数组进行<strong>默认升序排序</strong></td></tr><tr><td>public  static <T> void sort(类型[] a, <a href="mk:@MSITStore:C:\course\API文档\jdk-9_google.CHM::/java/util/Comparator.html">Comparator</a>&lt;?  super T&gt; c)</td><td>使用比较器对象<strong>自定义排序</strong></td></tr></tbody></table><p><strong>自定义排序规则</strong></p><p><strong>设置Comparator接口对应的比较器对象，来定制比较规则。</strong></p><p>如果认为左边数据 大于 右边数据 返回正整数    </p><p>如果认为左边数据 小于 右边数据 返回负整数    </p><p>如果认为左边数据 等于 右边数据 返回0             </p><p>o1 – o2 升序        o2 –o1降序        o1 &#x3D; o2 不变</p><p><strong>注意：比较浮点类型只能调用Double.compare</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 目标：自定义数组的排序规则：Comparator比较器对象。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、排序的API(默认自动对数组元素进行升序排序)</span></span><br><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">34</span>, <span class="number">12</span>, <span class="number">42</span>, <span class="number">23</span>&#125;;</span><br><span class="line">        Arrays.sort(arr); <span class="comment">//先调用方法，传入数组</span></span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、需求：降序排序！(自定义比较器对象，**只能支持引用类型的排序！！)</span></span><br><span class="line"> Integer[] arr = &#123;<span class="number">34</span>, <span class="number">12</span>, <span class="number">42</span>, <span class="number">23</span>&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">参数一：被排序的数组 必须是引用类型的元素</span></span><br><span class="line"><span class="comment">参数二：匿名内部类对象，代表了一个比较器对象。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        Arrays.sort(ages1, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">            <span class="comment">// 指定比较规则,if判断代码冗余</span></span><br><span class="line">            <span class="comment">//    if(o1 &gt; o2)&#123;</span></span><br><span class="line">            <span class="comment">//        return 1;</span></span><br><span class="line">            <span class="comment">//    &#125;else if(o1 &lt; o2)&#123;</span></span><br><span class="line">            <span class="comment">//        return -1;</span></span><br><span class="line">            <span class="comment">//      &#125;</span></span><br><span class="line">              <span class="comment">//一般直接return  </span></span><br><span class="line">                  <span class="keyword">return</span> o1 - o2; <span class="comment">// 默认升序</span></span><br><span class="line">                  <span class="comment">//或</span></span><br><span class="line">                  <span class="keyword">return</span> o2 - o1; <span class="comment">//  降序</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p><strong>案例：</strong></p><ul><li>已知一个Student类</li><li>类中已定义姓名name,年龄age,身高height，并提供有参无参构造器，set、get方法</li><li>使用Comparator自定义排序实现功能</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Student[] students = <span class="keyword">new</span> <span class="title class_">Student</span>[<span class="number">3</span>];</span><br><span class="line">students[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;吴磊&quot;</span>,<span class="number">23</span> , <span class="number">175.5</span>);</span><br><span class="line">students[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;谢鑫&quot;</span>,<span class="number">18</span> , <span class="number">185.5</span>);</span><br><span class="line">students[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;王亮&quot;</span>,<span class="number">20</span> , <span class="number">195.5</span>);</span><br><span class="line">System.out.println(Arrays.toString(students));<span class="comment">//可打印确认</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Arrays.sort(students);//直接运行奔溃,原因:自定义对象不支持默认排序</span></span><br><span class="line">Arrays.sort(students, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1, Student o2)</span> &#123;</span><br><span class="line"><span class="comment">// 自己指定比较规则</span></span><br><span class="line">  <span class="comment">//按照年龄</span></span><br><span class="line">  <span class="comment">// return o1.getAge() - o2.getAge();// 按照年龄升序排序！</span></span><br><span class="line">  <span class="comment">// return o2.getAge() - o1.getAge();// 按照年龄降序排序！</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//按照身高 上述方法只能返回int类型，由于身高为double类型</span></span><br><span class="line">  <span class="comment">// return Double.compare(o1.getHeight(), o2.getHeight());   // 比较浮点型 升序</span></span><br><span class="line">  <span class="comment">// return Double.compare(o2.getHeight(), o1.getHeight()); </span></span><br><span class="line">  <span class="comment">// 比较浮点型 降序</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">     System.out.println(Arrays.toString(students));</span><br></pre></td></tr></table></figure><h3 id="6-常见算法"><a href="#6-常见算法" class="headerlink" title="6.常见算法"></a>6.常见算法</h3><h4 id="6-1冒泡排序"><a href="#6-1冒泡排序" class="headerlink" title="6.1冒泡排序"></a>6.1冒泡排序</h4><p><strong>冒泡排序的思想</strong></p><ul><li>每次从数组中找出最大值放在数组的后面去。</li></ul><p><strong>实现冒泡排序的关键步骤分析</strong></p><ul><li><p>确定总共需要做几轮： 数组的长度-1.</p></li><li><p>每轮比较几次:</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">i(轮数)   次数      <span class="comment">//次数规律:  数组的长度 - i</span></span><br><span class="line"><span class="number">1</span>          <span class="number">3</span></span><br><span class="line"><span class="number">2</span>          <span class="number">2</span></span><br><span class="line"><span class="number">3</span>          <span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>当前位置大于后一个位置则交换数据</li></ul><h4 id="6-2选择排序"><a href="#6-2选择排序" class="headerlink" title="6.2选择排序"></a>6.2选择排序</h4><p><strong>选择排序的思想</strong></p><ul><li><p>每轮选择当前位置，开始找出后面的较小值与该位置交换</p><p>(每一轮第一个元素与他后面的每一个元素比较)</p></li></ul><p><strong>选择排序的关键</strong></p><ul><li><p>确定总共需要选择几轮： 数组的长度-1.</p></li><li><p>控制每轮从以前位置为基准，与后面元素选择几次。</p></li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：学会使用选择排序的方法对数组进行排序。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        <span class="comment">// 1、定义数组</span></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        <span class="comment">//           0  1  2  3</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、定义一个循环控制选择几轮： arr.length - 1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// i = 0   j =  1  2  3</span></span><br><span class="line">            <span class="comment">// i = 1   j =  2  3</span></span><br><span class="line">            <span class="comment">// i = 2   j =  3</span></span><br><span class="line">            <span class="comment">// 3、定义内部循环，控制选择几次</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="comment">// 当前位：arr[i]</span></span><br><span class="line">                <span class="comment">// 如果有比当前位数据更小的，则交换</span></span><br><span class="line">                <span class="keyword">if</span>(arr[i] &gt; arr[j]) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">                    arr[i] = arr[j];</span><br><span class="line">                    arr[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br></pre></td></tr></table></figure><h4 id="6-3二分查找"><a href="#6-3二分查找" class="headerlink" title="6.3二分查找"></a>6.3二分查找</h4><p><strong>二分查找</strong></p><ul><li>二分查询性能好，二分查找的前提是必须是排好序的数据。</li><li>二分查找相当于每次去掉一半的查找范围</li><li><strong>结论：二分查找正常的检索条件应该是  开始位置min &lt;&#x3D;  结束位置max</strong></li></ul><p><strong>min</strong>和<strong>max</strong>表示查找的范围</p><p>数组的二分查找的实现步骤是什么样的?</p><ul><li><p><strong>定义变量记录左边和右边位置。</strong></p></li><li><p>使用<strong>while循环控制查询</strong>（条件是左边位置&lt;&#x3D;右边位置）</p></li><li><p>循环内部<strong>获取中间元素索引</strong></p></li><li><p>判断当前要找的元素如果<strong>大于中间元素，左边位置 &#x3D; 中间索引+1</strong></p></li><li><p>判断当前要找的元素如果<strong>小于中间元素，右边位置 &#x3D;  中间索引-1</strong></p></li><li><p>判断当前要找的元素如果<strong>等于中间元素，返回当前中间元素索引。</strong></p></li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：理解二分搜索的原理并实现。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、定义数组</span></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">10</span>, <span class="number">14</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">28</span>, <span class="number">30</span>, <span class="number">35</span>, <span class="number">88</span>, <span class="number">100</span>&#125;;</span><br><span class="line">     </span><br><span class="line">        System.out.println(binarySearch(arr , <span class="number">35</span>));</span><br><span class="line">        System.out.println(binarySearch(arr , <span class="number">350</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 二分查找算法的方法实现</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr  排序的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data 要找的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  索引，如果元素不存在，直接返回-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> data)</span>&#123;</span><br><span class="line">        <span class="comment">// 1、定义左边位置  和 右边位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、开始循环，折半查询。</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">            <span class="comment">// 取中间索引</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">middleIndex</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 3、判断当前中间位置的元素和要找的元素的大小情况</span></span><br><span class="line">            <span class="keyword">if</span>(data &gt; arr[middleIndex]) &#123;</span><br><span class="line">                <span class="comment">// 往右边找，左位置更新为 = 中间索引+1</span></span><br><span class="line">                left = middleIndex + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(data &lt; arr[middleIndex]) &#123;</span><br><span class="line">                <span class="comment">// 往左边找，右边位置 = 中间索引 - 1</span></span><br><span class="line">                right = middleIndex - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> middleIndex;  <span class="comment">//左右索引相等，返回本索引</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// left &gt; right查无此元素</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="7-Lambda表达式"><a href="#7-Lambda表达式" class="headerlink" title="7.Lambda表达式"></a>7.Lambda表达式</h3><h4 id="7-1Lambda概述"><a href="#7-1Lambda概述" class="headerlink" title="7.1Lambda概述"></a>7.1Lambda概述</h4><p><strong>Lambda概述</strong></p><ul><li><p>Lambda表达式是JDK 8开始后的一种新语法形式。</p></li><li><p><strong>作用：简化匿名内部类的代码写法。</strong></p></li></ul><p><strong>Lambda表达式的简化格式</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(匿名内部类被重写方法的形参列表) -&gt; &#123;</span><br><span class="line">被重写方法的方法体代码。</span><br><span class="line">&#125;</span><br><span class="line">注：-&gt; 是语法形式，无实际含义</span><br></pre></td></tr></table></figure><p><strong>注意：Lambda表达式只能简化【函数式接口】的匿名内部类的写法形式</strong></p><p><strong>什么是函数式接口？</strong></p><ul><li>首先必须是<strong>【接口】</strong>、其次<strong>【接口中有且仅有一个抽象方法】</strong>的形式</li></ul><h4 id="7-2Lambda实战-简化常见函数式接口"><a href="#7-2Lambda实战-简化常见函数式接口" class="headerlink" title="7.2Lambda实战-简化常见函数式接口"></a>7.2Lambda实战-简化常见函数式接口</h4><p><strong>Lambda表达式简化Comparator接口的匿名形式</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">Integer[] ages = &#123;<span class="number">66</span>, <span class="number">33</span>, <span class="number">22</span>, <span class="number">55</span>, <span class="number">88</span>&#125;;</span><br><span class="line">Arrays.sort(ages, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;()&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> o2 - o1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;内容:&quot;</span> + Arrays.toString(ages));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//简化后结果</span></span><br><span class="line"></span><br><span class="line">Arrays.sort(ages, (Integer o1, Integer o2) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> o2 - o1;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>注意：通常我们见到的函数式接口上都有一个*@FunctionalInterface*注解，标记该接口必须是满足函数式接口。</strong></p><p><strong>Lambda表达式简化按钮监听器ActionListener的匿名内部类形式</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">JButton</span> <span class="variable">btn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;登录&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给登录按钮绑定点击事件监听器</span></span><br><span class="line">btn.addActionListener(<span class="keyword">new</span> <span class="title class_">ActionListener</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent e)</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;登录一下~~~&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//简化后结果</span></span><br><span class="line"></span><br><span class="line">btn.addActionListener( (ActionEvent e) -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;登录一下~~~&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>做法：</strong>去掉new的对象、重写的方法名以及括号，加上箭头，其余保留</p><h4 id="7-3Lambda表达式的省略规则（进一步省略）"><a href="#7-3Lambda表达式的省略规则（进一步省略）" class="headerlink" title="7.3Lambda表达式的省略规则（进一步省略）"></a>7.3Lambda表达式的省略规则（进一步省略）</h4><p><strong>Lambda表达式的省略写法（进一步在Lambda表达式的基础上继续简化）</strong></p><ul><li><p><strong>参数类型可以省略不写。</strong></p></li><li><p>如果<strong>只有一个参数</strong>，参数类型可以省略，同时()也可以省略。</p></li><li><p>如果Lambda表达式的<strong>方法体代码只有一行代码</strong>。可以省略大括号不写,同时要省略大括号里面的”;”</p></li><li><p>如果Lambda表达式的<strong>方法体代码只有一行代码</strong>。可以省略大括号不写。此时，如果这行代码是return语句，必须省略return不写，同时也必须省略大括号里面的”;”不写</p></li></ul><p><strong>代码:</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] ages1 = &#123;<span class="number">34</span>, <span class="number">12</span>, <span class="number">42</span>, <span class="number">23</span>&#125;;</span><br><span class="line">      </span><br><span class="line">Arrays.sort(ages1, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> o2 - o1; <span class="comment">//  降序</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//简化</span></span><br><span class="line">Arrays.sort(ages1, (Integer o1, Integer o2) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> o2 - o1; <span class="comment">//  降序</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//再简化</span></span><br><span class="line">Arrays.sort(ages1, ( o1,  o2) -&gt; &#123;</span><br><span class="line"><span class="keyword">return</span> o2 - o1; <span class="comment">//  降序</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//最简</span></span><br><span class="line">Arrays.sort(ages1, ( o1,  o2 ) -&gt;  o2 - o1 );</span><br><span class="line"></span><br><span class="line">System.out.println(Arrays.toString(ages1));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">JFrame</span> <span class="variable">win</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JFrame</span>(<span class="string">&quot;登录界面&quot;</span>);</span><br><span class="line">        <span class="type">JButton</span> <span class="variable">btn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;我是按钮&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//      btn.addActionListener(new ActionListener() &#123;</span></span><br><span class="line"><span class="comment">//          @Override</span></span><br><span class="line"><span class="comment">//          public void actionPerformed(ActionEvent e) &#123;</span></span><br><span class="line"><span class="comment">//              System.out.println(&quot;点我，点我！！&quot;);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//简化</span></span><br><span class="line"><span class="comment">//        btn.addActionListener((ActionEvent e) -&gt; &#123;</span></span><br><span class="line"><span class="comment">//              System.out.println(&quot;点我，点我！！&quot;);</span></span><br><span class="line"><span class="comment">//        &#125;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//再简化</span></span><br><span class="line"><span class="comment">//        btn.addActionListener(( e) -&gt; &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;点我，点我！！&quot;);</span></span><br><span class="line"><span class="comment">//        &#125;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//更简化</span></span><br><span class="line"><span class="comment">//        btn.addActionListener( e -&gt; &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;点我！！&quot;);</span></span><br><span class="line"><span class="comment">//        &#125;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//最简</span></span><br><span class="line">btn.addActionListener( e -&gt; System.out.println(<span class="string">&quot;点我！！&quot;</span>) );</span><br><span class="line"></span><br><span class="line">        win.add(btn);</span><br><span class="line">        win.setSize(<span class="number">400</span>, <span class="number">300</span>);</span><br><span class="line">        win.setVisible(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> java,面向对象进阶,常用API,正则表达式,Lambda,算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>day12 - 多态、内部类、常用API</title>
      <link href="/post/1d32812b.html"/>
      <url>/post/1d32812b.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-面向对象三大特征之三：多态"><a href="#1-面向对象三大特征之三：多态" class="headerlink" title="1.面向对象三大特征之三：多态"></a>1.面向对象三大特征之三：多态</h3><h4 id="1-1多态的概述，多态的形式"><a href="#1-1多态的概述，多态的形式" class="headerlink" title="1.1多态的概述，多态的形式"></a>1.1多态的概述，多态的形式</h4><p><strong>什么是多态？</strong></p><ul><li>同类型的对象，执行同一个行为，会表现出不同的行为特征。</li></ul><p><strong>多态的常见形式</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">父类类型 对象名称 = <span class="keyword">new</span> 子类构造器;</span><br><span class="line">接口     对象名称 = <span class="keyword">new</span> 实现类构造器;</span><br></pre></td></tr></table></figure><p><strong>多态中成员访问特点</strong></p><ul><li><p>方法调用：编译看左边，运行看右边。</p></li><li><p>变量调用：编译看左边，运行也看左边。（<strong>多态侧重行为多态</strong>）</p></li></ul><p><strong>多态的前提</strong></p><ul><li><strong>有继承&#x2F;实现关系；有父类引用指向子类对象；有方法重写。</strong></li></ul><h4 id="1-2多态的优势"><a href="#1-2多态的优势" class="headerlink" title="1.2多态的优势"></a>1.2多态的优势</h4><p> <strong>优势</strong></p><ul><li>在多态形式下，右边对象可以实现解耦合，便于扩展和维护。(方便于更换对象)</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">a.run(); <span class="comment">// 后续业务行为随对象而变，后续代码无需修改</span></span><br></pre></td></tr></table></figure><ul><li>定义方法的时候，使用父类型作为参数，该方法就可以接收这父类的一切子类对象，体现出多态的扩展性与便利。</li></ul><p><strong>多态下会产生的一个问题:</strong></p><ul><li>多态下不能使用子类的独有功能</li></ul><h4 id="1-3多态下引用数据类型的类型转换-实现调用子类独有功能"><a href="#1-3多态下引用数据类型的类型转换-实现调用子类独有功能" class="headerlink" title="1.3多态下引用数据类型的类型转换(实现调用子类独有功能)"></a>1.3多态下引用数据类型的类型转换(实现调用子类独有功能)</h4><p><strong>自动类型转换(从子到父—&gt;小转大)：</strong>子类对象赋值给父类类型的变量指向。</p><p><strong>强制类型转换(从父到子—&gt;大转小)</strong></p><ul><li><p>此时必须进行强制类型转换：子类 对象变量 &#x3D;  (子类)父类类型的变量</p></li><li><p>作用：可以解决多态下的劣势，可以<strong>实现调用子类独有的功能</strong>。</p></li><li><p>注意： 如果<strong>转型后的类型和对象真实类型不是同一种类型</strong>，那么在转换的时候就会出现<strong>ClassCastException</strong>。</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tortoise</span>(); <span class="comment">//new一个乌龟对象</span></span><br><span class="line"><span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> (Dog)t; <span class="comment">//将乌龟对象 强转为 狗对象</span></span><br><span class="line"><span class="comment">// 此时出现异常 ClassCastException</span></span><br></pre></td></tr></table></figure><p><strong>Java建议强转转换前使用【instanceof】判断当前对象的真实类型，再进行强制转换</strong></p><p><strong>变量名 <em>instanceof</em> 真实类型</strong></p><p>判断关键字左边的变量指向的对象的真实类型，是否是右边的类型或者是其子类类型，是则返回true，反之。</p><p><strong>强制类型转换:可以实现调用子类独有功能的</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意：多态下直接强制类型转换，可能出现类型转换异常</span></span><br><span class="line"><span class="comment">// 规定：有继承或者实现关系的2个类型就可以强制类型转换，运行时可能出现问题。</span></span><br><span class="line"><span class="comment">// Tortoise t1 = (Tortoise) a;</span></span><br><span class="line"><span class="comment">// 建议强制转换前，先判断变量指向对象的真实类型，再强制类型转换。</span></span><br><span class="line"><span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(a <span class="keyword">instanceof</span> Tortoise)&#123;   <span class="comment">//false</span></span><br><span class="line">     <span class="type">Tortoise</span> <span class="variable">t</span> <span class="operator">=</span> (Tortoise) a;</span><br><span class="line">     t.layEggs();   </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a <span class="keyword">instanceof</span> Dog)&#123;  <span class="comment">//true</span></span><br><span class="line">     <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> (Dog) a;</span><br><span class="line">     d.lookDoor();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-4多态的综合案例"><a href="#1-4多态的综合案例" class="headerlink" title="1.4多态的综合案例"></a>1.4多态的综合案例</h4><p><strong>多态综合案例</strong></p><p><strong>需求：</strong></p><ul><li><p>使用面向对象编程模拟：设计一个电脑对象，可以安装2个USB设备</p></li><li><p>鼠标：被安装时可以完成接入、调用点击功能、拔出功能。</p></li><li><p>键盘：被安装时可以完成接入、调用打字功能、拔出功能。</p></li></ul><p><strong>分析</strong></p><p>①定义一个USB的接口（申明USB设备的规范必须是：可以接入和拔出）。</p><p>②提供2个USB实现类代表鼠标和键盘，让其实现USB接口，并分别定义独有功能。</p><p>③创建电脑对象，创建2个USB实现类对象，分别安装到电脑中并触发功能的执行。</p><h3 id="2-内部类"><a href="#2-内部类" class="headerlink" title="2.内部类"></a>2.内部类</h3><h4 id="2-1内部类概述"><a href="#2-1内部类概述" class="headerlink" title="2.1内部类概述"></a>2.1内部类概述</h4><p><strong>内部类</strong></p><ul><li>内部类就是定义在一个类里面的类，里面的类可以理解成（寄生），外部类可以理解成（宿主）。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">People</span>&#123;</span><br><span class="line"><span class="comment">// 内部类  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Heart</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>内部类的使用场景、作用</strong></p><ul><li><p>当一个事物的内部，还有一个部分需要一个完整的结构进行描述，而这个内部的完整的结构又只为外部事物提供服务，那么整个内部的完整结构可以选择使用内部类来设计。</p></li><li><p>内部类通常可以方便访问外部类的成员，包括私有的成员。</p></li><li><p>内部类提供了更好的封装性，内部类本身就可以用private protectecd等修饰，封装性可以做更多控制。</p></li></ul><h4 id="2-2内部类之一：静态内部类-了解"><a href="#2-2内部类之一：静态内部类-了解" class="headerlink" title="2.2内部类之一：静态内部类[了解]"></a>2.2内部类之一：静态内部类[了解]</h4><p><strong>什么是静态内部类？</strong></p><ul><li><p>有static修饰，属于外部类本身。</p></li><li><p>它的特点和使用与普通类是完全一样的，类有的成分它都有，只是位置在别人里面而已。</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line"><span class="comment">// 静态成员内部类      </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>静态内部类创建对象的格式：</strong>  </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//格式：外部类名.内部类名 对象名 = new 外部类名.内部类构造器;</span></span><br><span class="line"><span class="comment">//范例：Outer.Inner in =  new Outer.Inner();</span></span><br></pre></td></tr></table></figure><p><strong>静态内部类的访问拓展：</strong> </p><p>1、静态内部类中是否可以直接访问外部类的静态成员？ </p><ul><li><strong>可以，外部类的静态成员只有一份可以被共享访问。</strong></li></ul><p>2、静态内部类中是否可以直接访问外部类的实例成员？ </p><ul><li><strong>不可以的，外部类的实例成员必须用外部类对象访问。</strong></li></ul><h4 id="2-3内部类之二：成员内部类-了解"><a href="#2-3内部类之二：成员内部类-了解" class="headerlink" title="2.3内部类之二：成员内部类[了解]"></a>2.3内部类之二：成员内部类[了解]</h4><p><strong>什么是成员内部类？</strong></p><ul><li><p>无static修饰，属于外部类的对象。</p></li><li><p>JDK16之前，成员内部类中不能定义静态成员，JDK 16开始也可以定义静态成员了。</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line"><span class="comment">// 成员内部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>成员内部类创建对象的格式：</strong>  </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//格式:外部类名.内部类名 对象名 = new 外部类构造器.new 内部类构造器();</span></span><br><span class="line"><span class="comment">//范例:Outer.Inner in =  new Outer().new  Inner();</span></span><br></pre></td></tr></table></figure><p><strong>成员内部类-面试题</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">heartbeat</span> <span class="operator">=</span> <span class="number">150</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Heart</span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">heartbeat</span> <span class="operator">=</span> <span class="number">110</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">heartbeat</span> <span class="operator">=</span> <span class="number">78</span>;</span><br><span class="line">System.out.println(??); <span class="comment">// 78  </span></span><br><span class="line">System.out.println(??); <span class="comment">// 110 </span></span><br><span class="line">System.out.println(??); <span class="comment">// 150</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：在成员内部类中访问所在外部类对象 ，格式：外部类名.this。</strong></p><p><strong>成员内部类的访问拓展：</strong> </p><p>1、成员内部类中是否可以直接访问外部类的静态成员？ </p><ul><li><strong>可以，外部类的静态成员只有一份可以被共享访问。</strong></li></ul><p>2、成员内部类的实例方法中是否可以直接访问外部类的实例成员？ </p><ul><li><strong>可以的，因为必须先有外部类对象，才能有成员内部类对象，所以可以直接访问外部类对象的实例成员。</strong></li></ul><h4 id="2-4内部类之三：局部内部类-了解"><a href="#2-4内部类之三：局部内部类-了解" class="headerlink" title="2.4内部类之三：局部内部类[了解]"></a>2.4内部类之三：局部内部类[了解]</h4><p><strong>局部内部类 （鸡肋语法，了解即可）</strong></p><ul><li><p>局部内部类放在方法、代码块、构造器等执行体中。</p></li><li><p>局部内部类的类文件名为： 外部类$N内部类.class。</p></li></ul><h4 id="2-5内部类之四：匿名内部类概述-重点"><a href="#2-5内部类之四：匿名内部类概述-重点" class="headerlink" title="2.5内部类之四：匿名内部类概述[重点]"></a>2.5内部类之四：匿名内部类概述[重点]</h4><p><strong>匿名内部类：</strong></p><ul><li><p>本质上是一个没有名字的局部内部类，定义在方法中、代码块中、等。</p></li><li><p><strong>作用</strong>：方便创建子类对象，最终目的为了简化代码编写。</p></li></ul><p><strong>格式：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">new</span> 类|抽象类名|或者接口名() &#123;   </span><br><span class="line"> 重写方法;</span><br><span class="line"> &#125;;   <span class="comment">//分号</span></span><br><span class="line"></span><br><span class="line"><span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>() &#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">a. run();</span><br></pre></td></tr></table></figure><p><strong>特点总结：</strong></p><ul><li><p>匿名内部类是一个<strong>没有名字的内部类</strong>。</p></li><li><p>匿名内部类写出来就会<strong>产生一个匿名内部类的对象</strong>。</p></li><li><p>匿名内部类的对象类型相当于是当前<strong>new的那个的类型的子类类型</strong>。</p></li></ul><h4 id="2-6匿名内部类常见使用形式"><a href="#2-6匿名内部类常见使用形式" class="headerlink" title="2.6匿名内部类常见使用形式"></a>2.6匿名内部类常见使用形式</h4><p><strong>匿名内部类在开发中的使用形式了解</strong></p><ul><li>某个学校需要让老师，学生，运动员一起参加游泳比赛</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*游泳接口*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Swimming</span> &#123;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 测试类*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JumppingDemo</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//需求：goSwimming方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义一个方法让所有角色进来一起比赛</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">goSwimming</span><span class="params">(Swimming swimming)</span> &#123;        swimming.swim();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>匿名内部类可以作为方法的实际参数进行传输。</strong></p><h4 id="2-7匿名内部类真实使用场景演示"><a href="#2-7匿名内部类真实使用场景演示" class="headerlink" title="2.7匿名内部类真实使用场景演示"></a>2.7匿名内部类真实使用场景演示</h4><p><strong>匿名内部类在开发中的真实使用场景演示</strong></p><ul><li>给按钮绑定点击事件</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  为按钮绑定点击事件监听器。</span></span><br><span class="line">btn.addActionListener(<span class="keyword">new</span> <span class="title class_">ActionListener</span>() &#123;         `<span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent e)</span> &#123;               System.out.println(<span class="string">&quot;登录一下~~&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//btn.addActionListener(e -&gt; System.out.println(&quot;登录一下~~&quot;));</span></span><br></pre></td></tr></table></figure><p><strong>使用总结:</strong></p><p><strong>开发中不是我们主动去定义匿名内部类的，而是别人需要我们写或者我们可以写的时候才会使用。</strong></p><p><strong>匿名内部类的代码可以实现代码进一步的简化（回扣主题）</strong></p><h3 id="3-常用API"><a href="#3-常用API" class="headerlink" title="3.常用API"></a>3.常用API</h3><p><strong>什么是API?</strong></p><ul><li><p>API(Application Programming interface) 应用程序编程接口。</p></li><li><p><strong>简单来说：就是<em>Java</em>帮我们已经写好的一些方法，我们直接拿过来用就可以了。</strong></p></li></ul><p><strong>Object类的作用：</strong></p><ul><li><p>Object类的方法是一切子类对象都可以直接使用的，所以我们要学习Object类的方法。</p></li><li><p>一个类要么默认继承了Object类，要么间接继承了Object类，Object类是Java中的祖宗类。</p></li></ul><h4 id="3-1Object类的常用方法："><a href="#3-1Object类的常用方法：" class="headerlink" title="3.1Object类的常用方法："></a><strong>3.1Object类的常用方法：</strong></h4><table><thead><tr><th align="center">方法名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><strong>public String toString()</strong></td><td align="center"><strong>默认是返回当前对象在堆内存中的地址信息:类的全限名@内存地址</strong></td></tr><tr><td align="center"><strong>public boolean equals(Object o)</strong></td><td align="center"><strong>默认是比较当前对象与另一个对象的地址是否相同，相同返回true，不同返回false</strong></td></tr></tbody></table><h5 id="3-1-1Object的toString方法："><a href="#3-1-1Object的toString方法：" class="headerlink" title="3.1.1Object的toString方法："></a><strong>3.1.1Object的toString方法：</strong></h5><p><strong>问题引出</strong></p><ul><li><p>开发中直接输出对象，默认输出对象的地址其实是毫无意义的。</p></li><li><p>开发中输出对象变量，更多的时候是希望看到对象的内容数据而不是对象的地址信息。</p></li></ul><p><strong>toString存在的意义</strong></p><ul><li><strong>父类toString()方法存在的意义就是为了被子类重写，以便返回对象的内容信息，而不是地址信息！！</strong></li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//在子类中先进行方法重写,万能快捷键</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, sex=&quot;</span> + sex +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//主函数使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;   </span><br><span class="line">   </span><br><span class="line">   <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;周雄&quot;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="number">19</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// System.out.println(s.toString());//默认可以省略toString</span></span><br><span class="line"></span><br><span class="line">    System.out.println(s); <span class="comment">//按重写方法排版</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-2Object的equals方法："><a href="#3-2Object的equals方法：" class="headerlink" title="3.2Object的equals方法："></a><strong>3.2Object的equals方法：</strong></h5><p><strong>问题思考</strong></p><ul><li>直接比较两个对象的地址是否相同完全可以用“&#x3D;&#x3D;”替代equals。</li></ul><p><strong>equals存在的意义</strong></p><ul><li><strong>父类equals方法存在的意义就是为了被子类重写，以便子类自己来定制比较规则。</strong></li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;周雄&quot;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="number">19</span>);</span><br><span class="line"><span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;周雄&quot;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="number">19</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// equals默认是比较2个对象的地址是否相同。</span></span><br><span class="line">System.out.println(s1.equals(s2)); <span class="comment">//false</span></span><br><span class="line">System.out.println(s1 == s2);      <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//子类重写后会调用子类重写的来比较内容是否相同。</span></span><br><span class="line">System.out.println(s1.equals(s2)); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h4 id="3-2Objects概述"><a href="#3-2Objects概述" class="headerlink" title="3.2Objects概述"></a><strong>3.2Objects概述</strong></h4><ul><li>Objects是一个工具类，提供了一些方法去完成一些功能。</li></ul><p><strong>Objects的常见方法：</strong></p><table><thead><tr><th align="center">方法名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><strong>public  static boolean equals(Object a,  Object b)</strong></td><td align="center"><strong>比较两个对象的，底层会先进行非空判断，从而可以避免空指针异常。再进行equals比较</strong></td></tr><tr><td align="center"><strong>public  static boolean isNull(Object obj)</strong></td><td align="center"><strong>判断变量是否为null  ,为null返回true  ,反之</strong></td></tr></tbody></table><h5 id="3-2-1Objects的equals方法"><a href="#3-2-1Objects的equals方法" class="headerlink" title="3.2.1Objects的equals方法"></a><strong>3.2.1Objects的equals方法</strong></h5><p><strong>官方在进行字符串比较时，没有用字符串对象的的equals方法，而是选择了Objects的equals方法来比较。</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="comment">//官方方法重写</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line"><span class="comment">// 1、判断是否是同一个对象比较，如果是返回true。</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 2、如果o是null返回false  如果o不是学生类型返回false  ...Student !=  ..Pig</span></span><br><span class="line"><span class="keyword">if</span> (o == <span class="literal">null</span> || <span class="built_in">this</span>.getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 3、说明o一定是学生类型而且不为null</span></span><br><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) o;</span><br><span class="line"><span class="keyword">return</span> sex == student.sex &amp;&amp; age == student.age &amp;&amp; Objects.equals(name, student.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>源码分析</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object a, Object b)</span> &#123;    <span class="keyword">return</span> (a == b) || (a != <span class="literal">null</span> &amp;&amp; a.equals(b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用Objects的equals方法在进行对象的比较会更安全。(建议使用)</strong></p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//掌握objects类的常用方法:equals</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s12</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;itheima&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 留下了隐患，可能出现空指针异常。</span></span><br><span class="line"><span class="comment">// System.out.println(s1.equals(s2));   </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 更安全，结果也是对的！推荐使用！</span></span><br><span class="line"><span class="comment">//有对象时，推荐方法重写后使用</span></span><br><span class="line">System.out.println(Objects.equals(s1, s2)); </span><br></pre></td></tr></table></figure><h5 id="3-2-2Objects的isNull方法"><a href="#3-2-2Objects的isNull方法" class="headerlink" title="3.2.2Objects的isNull方法"></a><strong>3.2.2Objects的isNull方法</strong></h5><p><strong>判断是否为空，两种方法效果相同</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;itheima&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(Objects.isNull(s1)); <span class="comment">// true</span></span><br><span class="line">System.out.println(s1 == <span class="literal">null</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">System.out.println(Objects.isNull(s2)); <span class="comment">// false</span></span><br><span class="line">System.out.println(s2 == <span class="literal">null</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h4 id="3-3StringBuilder可变的字符串类概述"><a href="#3-3StringBuilder可变的字符串类概述" class="headerlink" title="3.3StringBuilder可变的字符串类概述"></a><strong>3.3StringBuilder可变的字符串类概述</strong></h4><p><strong>StringBuilder概述</strong></p><ul><li><p>StringBuilder是一个<strong>可变的字符串类</strong>，我们可以把它看成是<strong>一个对象容器</strong>。</p></li><li><p><strong>作用</strong>：<strong>提高字符串的操作效率</strong>，如拼接、修改等。</p></li></ul><p><strong>StringBuilder 构造器</strong></p><table><thead><tr><th align="center">名称</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><strong>public  StringBuilder()</strong></td><td align="center"><strong>创建一个空白的可变的字符串对象，不包含任何内容</strong></td></tr><tr><td align="center"><strong>public  StringBuilder(String str)</strong></td><td align="center"><strong>创建一个指定字符串内容的可变字符串对象</strong></td></tr></tbody></table><p><strong>StringBuilder常用方法</strong></p><table><thead><tr><th align="center">方法名称</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><strong>public StringBuilder append(任意类型)</strong></td><td align="center"><strong>添加数据并返回StringBuilder对象本身</strong></td></tr><tr><td align="center"><strong>public StringBuilder reverse()</strong></td><td align="center"><strong>将对象的内容反转</strong></td></tr><tr><td align="center"><strong>public int length()</strong></td><td align="center"><strong>返回对象内容长度</strong></td></tr><tr><td align="center"><strong>public String toString()</strong></td><td align="center"><strong>通过toString()就可以实现把StringBuilder转换为String</strong></td></tr></tbody></table><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：学会使用StringBuilder操作字符串,</span></span><br><span class="line"><span class="comment">    最终还需要知道它性能好的原因</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(); <span class="comment">// </span></span><br><span class="line">        sb.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">        sb.append(<span class="number">1</span>);</span><br><span class="line">        sb.append(<span class="literal">false</span>);</span><br><span class="line">        sb.append(<span class="number">3.3</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        System.out.println(sb);  <span class="comment">//abc1false3.3abc</span></span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="comment">// 支持链式编程</span></span><br><span class="line">        sb1.append(<span class="string">&quot;a&quot;</span>).append(<span class="string">&quot;b&quot;</span>).append(<span class="string">&quot;c&quot;</span>).append(<span class="string">&quot;我爱你中国&quot;</span>);</span><br><span class="line">        System.out.println(sb1); <span class="comment">//abc我爱你中国</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// reverse()反转</span></span><br><span class="line">        sb1.reverse().append(<span class="string">&quot;110&quot;</span>); </span><br><span class="line">        System.out.println(sb1);  <span class="comment">//abc我爱你中国--&gt;国中你爱我cba</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// length()长度</span></span><br><span class="line">        System.out.println(sb1.length());  <span class="comment">//连接后字符长度</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意：StringBuilder只是拼接字符串的手段：效率好。</span></span><br><span class="line">        <span class="comment">// 最终的目的还是要恢复成String类型，方便传参</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        sb2.append(<span class="string">&quot;123&quot;</span>).append(<span class="string">&quot;456&quot;</span>);  </span><br><span class="line">        <span class="comment">// 恢复成String类型</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> sb2.toString();</span><br><span class="line">        check(rs);</span><br></pre></td></tr></table></figure><p><strong>为什么拼接、反转字符串建议使用StringBuilder?</strong></p><ul><li><p><strong>String</strong> <strong>：内容是不可变的、拼接字符串性能差。</strong></p></li><li><p><strong>StringBuilder：内容是可变的、拼接字符串性能好、代码优雅。</strong></p></li><li><p><strong>定义字符串使用String</strong></p></li><li><p><strong>拼接、修改等操作字符串使用StringBuilder</strong></p></li></ul><p><em><strong>案例:</strong></em></p><p><em><strong>打印整型数组内容</strong></em></p><p><strong>需求：</strong></p><p>设计一个方法用于输出任意整型数组的内容，要求输出成如下格式：</p><p>   “该数组内容为：[11, 22, 33, 44, 55]”</p><p><strong>分析</strong>：</p><p>1、定义一个方法，要求该方法能够接收数组，并输出数组内容。 —&gt; 需要参数吗？需要返回值类型申明吗？</p><p>2、定义一个静态初始化的数组，调用该方法，并传入该数组。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//*需求：</span></span><br><span class="line">设计一个方法用于输出任意整型数组的内容，要求输出成如下格式：</span><br><span class="line">“该数组内容为：[<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>]”</span><br><span class="line"><span class="comment">//分析：</span></span><br><span class="line"><span class="number">1</span>、定义一个方法，要求该方法能够接收数组，并输出数组内容。</span><br><span class="line">    ---&gt; 需要参数吗？需要返回值类型申明吗？</span><br><span class="line"><span class="number">2</span>、定义一个静态初始化的数组，调用该方法，并传入该数组。</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr1 = <span class="literal">null</span>;  <span class="comment">//数组为空</span></span><br><span class="line">        System.out.println(show(arr1));</span><br><span class="line">        <span class="type">int</span>[] arr2 = &#123;<span class="number">10</span>, <span class="number">88</span>, <span class="number">66</span>&#125;; <span class="comment">//数组有值</span></span><br><span class="line">        System.out.println(show(arr2));</span><br><span class="line">        <span class="type">int</span>[] arr3 = &#123;&#125;;    <span class="comment">//数组无任何值</span></span><br><span class="line">        System.out.println(show(arr3));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">show</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr != <span class="literal">null</span>) &#123;   <span class="comment">//判断数组不为空</span></span><br><span class="line">            <span class="comment">//创建StringBuilder 构造器</span></span><br><span class="line">            <span class="type">StringBuffer</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(); </span><br><span class="line">            System.out.print(<span class="string">&quot;[&quot;</span>);</span><br><span class="line">            <span class="comment">//遍历数组中每一个元素</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">                s.append(arr[i]).append(i == arr.length - <span class="number">1</span> ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;,&quot;</span>);  <span class="comment">//判断元素是否为最后一个 </span></span><br><span class="line">            &#125;</span><br><span class="line">            s.append(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">st</span> <span class="operator">=</span> s.toString(); </span><br><span class="line">            <span class="comment">//以方法返回值类型String返回</span></span><br><span class="line">            <span class="keyword">return</span> st;</span><br><span class="line">        &#125; <span class="keyword">else</span>              <span class="comment">//判断数组为空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-4Math类"><a href="#3-4Math类" class="headerlink" title="3.4Math类"></a><strong>3.4Math类</strong></h4><ul><li><p>包含执行基本数字运算的方法，Math类没有提供公开的构造器。</p></li><li><p><strong>如何使用类中的成员呢？</strong>看类的成员是否都是静态的，如果是，通过类名就可以直接调用</p></li></ul><p><strong>Math 类的常用方法：</strong></p><table><thead><tr><th align="center"><strong>方法名</strong></th><th align="center"><strong>说明</strong></th></tr></thead><tbody><tr><td align="center"><strong>public static int abs(int a)</strong></td><td align="center"><strong>获取参数绝对值</strong></td></tr><tr><td align="center"><strong>public static double  ceil(double a)</strong></td><td align="center"><strong>向上取整</strong></td></tr><tr><td align="center"><strong>public static double  floor(double a)</strong></td><td align="center"><strong>向下取整</strong></td></tr><tr><td align="center"><strong>public static int round(float a)</strong></td><td align="center"><strong>四舍五入</strong></td></tr><tr><td align="center"><strong>public static int max(int  a,int b)</strong></td><td align="center"><strong>获取两个int值中的较大值</strong></td></tr><tr><td align="center"><strong>public static double pow(double  a,double b)</strong></td><td align="center"><strong>返回a的b次幂的值</strong></td></tr><tr><td align="center"><strong>public static double random()</strong></td><td align="center"><strong>返回值为double的随机值，范围[0.0,1.0)</strong></td></tr></tbody></table><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：Math类的使用。</span></span><br><span class="line"><span class="comment">    Math用于做数学运算。</span></span><br><span class="line"><span class="comment">    Math类中的方法全部是静态方法，直接用类名调用即可。</span></span><br><span class="line"><span class="comment">    方法：</span></span><br><span class="line"><span class="comment">方法名                                      说明</span></span><br><span class="line"><span class="comment">public static int abs(int a)         获取参数a的绝对值：                                      </span></span><br><span class="line"><span class="comment">public static double ceil(double a)      向上取整       </span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">public static double floor(double a)     向下取整        </span></span><br><span class="line"><span class="comment">         </span></span><br><span class="line"><span class="comment">public static double pow(double a, double b)   获取a的b次幂</span></span><br><span class="line"><span class="comment">         </span></span><br><span class="line"><span class="comment">public static long round(double a)      四舍五入取整</span></span><br><span class="line"><span class="comment">   </span></span><br><span class="line"><span class="comment">小结：</span></span><br><span class="line"><span class="comment">    记住。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MathDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.取绝对值:返回正数</span></span><br><span class="line">        System.out.println(Math.abs(<span class="number">10</span>)); <span class="comment">// 10</span></span><br><span class="line">        System.out.println(Math.abs(-<span class="number">10.3</span>)); <span class="comment">// 10.3</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.向上取整: 5</span></span><br><span class="line">        System.out.println(Math.ceil(<span class="number">4.00000001</span>)); <span class="comment">// 5.0</span></span><br><span class="line">        System.out.println(Math.ceil(<span class="number">4.0</span>)); <span class="comment">// 4.0</span></span><br><span class="line">        <span class="comment">// 3.向下取整：4</span></span><br><span class="line">        System.out.println(Math.floor(<span class="number">4.99999999</span>)); <span class="comment">// 4.0</span></span><br><span class="line">        System.out.println(Math.floor(<span class="number">4.0</span>)); <span class="comment">// 4.0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.求指数次方</span></span><br><span class="line">        System.out.println(Math.pow(<span class="number">2</span> , <span class="number">3</span>)); <span class="comment">// 2^3 = 8.0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 5.四舍五入 10</span></span><br><span class="line">        System.out.println(Math.round(<span class="number">4.49999</span>)); <span class="comment">// 4</span></span><br><span class="line">        System.out.println(Math.round(<span class="number">4.500001</span>)); <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.随机数[0~1) （包前不包后）</span></span><br><span class="line">        System.out.println(Math.random());  <span class="comment">// 0.0 - 1.0 </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拓展： 3 - 9 之间的随机数  （0 - 6） + 3</span></span><br><span class="line">        <span class="comment">//  [0 - 6] + 3</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span>  (<span class="type">int</span>)(Math.random() * <span class="number">7</span>) + <span class="number">3</span>;</span><br><span class="line">        System.out.println(data);</span><br></pre></td></tr></table></figure><h4 id="3-5System-工具类概述"><a href="#3-5System-工具类概述" class="headerlink" title="3.5System 工具类概述"></a><strong>3.5System 工具类概述</strong></h4><ul><li>System也是一个工具类，代表了当前系统，提供了一些与系统相关的方法。</li></ul><p><strong>System 类的常用方法</strong></p><table><thead><tr><th align="center">方法名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><strong>public  static void exit(int status)</strong></td><td align="center"><strong>终止当前运行的 Java 虚拟机，非零表示异常终止</strong></td></tr><tr><td align="center"><strong>public  static long currentTimeMillis()</strong></td><td align="center"><strong>返回当前系统的时间毫秒值形式</strong></td></tr><tr><td align="center"><strong>public  static void arraycopy(数据源数组, 起始索引, 目的地数组, 起始索引, 拷贝个数)</strong></td><td align="center"><strong>数组拷贝</strong></td></tr></tbody></table><p><strong>时间毫秒值</strong></p><ul><li><p>计算机认为时间是有起点的，起始时间： 1970年1月1日 00:00:00</p></li><li><p>时间毫秒值：指的是从1970年1月1日   00:00:00走到此刻的总的毫秒数，应该是很大的。 1s &#x3D; 1000ms。</p></li><li><p><strong>原因：</strong></p><p>​    1969年8月，贝尔实验室的程序员肯汤普逊利用妻儿离开一个月的机会，开始着手创造一个全新的革命性的操作系统，他使用B编译语言在老旧的PDP-7机器上开发出了Unix的一个版本。</p><p>随后，汤普逊和同事丹尼斯里奇改进了B语言，开发出了C语言，重写了UNIX。</p><p> <strong>1970年1月1日 算C语言的生日</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">System.out.println(time);<span class="comment">//1575465416955</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;程序开始。。。&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// System.exit(0); // JVM终止！ 0是有程序员正常终止，非0位非正常终止</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;程序结束。。。。&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2、计算机认为时间有起源：返回1970-1-1 00：00：00 走到此刻的总的毫秒值：时间毫秒值。</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(time);  <span class="comment">//截至到目前时间毫秒</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 功能：进行时间的计算：性能分析</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis(); <span class="comment">//运行前时间</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;输出：&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();  <span class="comment">//运行结束时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">upTime</span> <span class="operator">=</span> (endTime - startTime)/<span class="number">1000.0</span>;  <span class="comment">//时间差</span></span><br><span class="line">        System.out.println(upTime+ <span class="string">&quot;s&quot;</span>); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、做数组拷贝（了解）</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         arraycopy(Object src,  int  srcPos,</span></span><br><span class="line"><span class="comment">         Object dest, int destPos,</span></span><br><span class="line"><span class="comment">         int length)</span></span><br><span class="line"><span class="comment">         参数一：被拷贝的数组</span></span><br><span class="line"><span class="comment">         参数二：从哪个索引位置开始拷贝</span></span><br><span class="line"><span class="comment">         参数三：复制的目标数组</span></span><br><span class="line"><span class="comment">         参数四：粘贴位置</span></span><br><span class="line"><span class="comment">         参数五：拷贝元素的个数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">int</span>[] arr1 = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>, <span class="number">70</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] arr2 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">6</span>]; <span class="comment">// [0, 0, 0, 0, 0, 0] ==&gt;  [0, 0, 40, 50, 60, 0]</span></span><br><span class="line">        System.arraycopy(arr1, <span class="number">3</span>, arr2, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr2));</span><br></pre></td></tr></table></figure><h4 id="3-6BigDecimal作用"><a href="#3-6BigDecimal作用" class="headerlink" title="3.6BigDecimal作用"></a>3.6<strong>BigDecimal作用</strong></h4><ul><li>用于解决浮点型运算精度失真的问题</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">// 浮点型运算的时候直接+  * / 可能会出现数据失真（精度问题）。  System.out.println(0.09 + 0.01);  //0.09999999999999</span></span><br><span class="line">System.out.println(<span class="number">1.0</span> - <span class="number">0.32</span>);   <span class="comment">//0.67999999999999</span></span><br><span class="line">System.out.println(<span class="number">1.015</span> * <span class="number">100</span>);  <span class="comment">//101.499999999999</span></span><br><span class="line">System.out.println(<span class="number">1.301</span> / <span class="number">100</span>);  <span class="comment">//0.01300999999999</span></span><br><span class="line">System.out.println(<span class="string">&quot;-------------------------&quot;</span>);</span><br><span class="line"><span class="type">double</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0.1</span> + <span class="number">0.2</span>;             <span class="comment">//0.30000000000004</span></span><br><span class="line">System.out.println(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用步骤</strong></p><ul><li><strong>创建对象BigDecimal封装浮点型数据（最好的方式是调用方法）</strong></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> BigDecimal <span class="title function_">valueOf</span><span class="params">(<span class="type">double</span> val)</span>:   </span><br><span class="line"><span class="comment">//包装浮点数成为BigDecimal对象。</span></span><br></pre></td></tr></table></figure><p><strong>BigDecima常用API</strong></p><table><thead><tr><th align="center"><strong>方法名</strong></th><th align="left"><strong>说明</strong></th></tr></thead><tbody><tr><td align="center"><strong>public BigDecimal add(BigDecimal b)</strong></td><td align="left"><strong>加法</strong></td></tr><tr><td align="center"><strong>public BigDecimal subtract(BigDecimal b)</strong></td><td align="left"><strong>减法</strong></td></tr><tr><td align="center"><strong>public BigDecimal multiply(BigDecimal b)</strong></td><td align="left"><strong>乘法</strong></td></tr><tr><td align="center"><strong>public BigDecimal divide(BigDecimal b)</strong></td><td align="left"><strong>除法</strong></td></tr><tr><td align="center"><strong>public BigDecimal divide (另一个BigDecimal对象，精确几位，舍入模式)</strong></td><td align="left"><strong>除法</strong></td></tr></tbody></table><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0.1</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0.2</span>;</span><br><span class="line"><span class="comment">// 包装浮点型数据成为大数据对象 BigDeciaml</span></span><br><span class="line">     <span class="type">BigDecimal</span> <span class="variable">a1</span> <span class="operator">=</span> BigDecimal.valueOf(a);</span><br><span class="line">     <span class="type">BigDecimal</span> <span class="variable">b1</span> <span class="operator">=</span> BigDecimal.valueOf(b);</span><br><span class="line">        </span><br><span class="line">     <span class="type">BigDecimal</span> <span class="variable">c1</span> <span class="operator">=</span> a1.add(b1);<span class="comment">//加</span></span><br><span class="line">   <span class="comment">//BigDecimal c1 = a1.subtract(b1);//减</span></span><br><span class="line">   <span class="comment">//BigDecimal c1 = a1.multiply(b1);//乘</span></span><br><span class="line">   <span class="comment">//BigDecimal c1 = a1.divide(b1);//除</span></span><br><span class="line">        </span><br><span class="line">    System.out.println(c1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目的：以double类型传出去</span></span><br><span class="line">   <span class="type">double</span> <span class="variable">rs</span> <span class="operator">=</span> c1.doubleValue(); <span class="comment">//转换位double类型</span></span><br><span class="line">   System.out.println(rs);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意事项：BigDecimal是一定要精度运算的</span></span><br><span class="line">   <span class="type">BigDecimal</span> <span class="variable">a11</span> <span class="operator">=</span> BigDecimal.valueOf(<span class="number">10.0</span>);</span><br><span class="line">   <span class="type">BigDecimal</span> <span class="variable">b11</span> <span class="operator">=</span> BigDecimal.valueOf(<span class="number">3.0</span>);</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">   参数一：除数 </span></span><br><span class="line"><span class="comment">   参数二：保留小数位数  </span></span><br><span class="line"><span class="comment">   参数三：舍入模式</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"> <span class="type">BigDecimal</span> <span class="variable">c11</span> <span class="operator">=</span> a11.divide(b11, <span class="number">2</span>, RoundingMode.HALF_UP); </span><br><span class="line"> System.out.println(c11);  <span class="comment">// 3.33</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> java,面向对象进阶,多态,内部类,常用API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>day11 - 包、权限修饰符、final、常量、枚举、抽象类、接口</title>
      <link href="/post/383d7cb7.html"/>
      <url>/post/383d7cb7.html</url>
      
        <content type="html"><![CDATA[<h2 id="day12-面向对象进阶"><a href="#day12-面向对象进阶" class="headerlink" title="day12.面向对象进阶"></a>day12.面向对象进阶</h2><hr><hr><h3 id="1-包"><a href="#1-包" class="headerlink" title="1.包"></a>1.包</h3><p><strong>什么是包？</strong></p><ul><li><p>包是用来分门别类的管理各种不同类的，类似于文件夹、建包利于程序的管理和维护。</p></li><li><p>建包的语法格式：package 公司域名倒写.技术名称。报名建议全部英文小写，且具备意义</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itcase.javabean;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>建包语句必须在第一行，一般IDEA工具会帮助创建</li></ul><p><strong>导包</strong> </p><ul><li><p>相同包下的类可以直接访问，不同包下的类必须导包,才可以使用！导包格式：<strong>import</strong> <strong>包名.类名;</strong></p></li><li><p>假如一个类中需要用到不同类，而这个两个类的名称是一样的，那么默认只能导入一个类，另一个类要带包名访问。</p></li></ul><hr><hr><h3 id="2-权限修饰符"><a href="#2-权限修饰符" class="headerlink" title="2.权限修饰符"></a>2.权限修饰符</h3><p><strong>什么是权限修饰符？</strong></p><ul><li><p>权限修饰符：是用来控制一个成员能够被访问的范围的。</p></li><li><p>可以修饰成员变量，方法，构造器，内部类，不同权限修饰符修饰的成员能够被访问的范围将受到限制。</p></li></ul><p><strong>权限修饰符的分类和具体作用范围：</strong></p><ul><li><p>权限修饰符：有四种作用范围由小到大</p><p>（private -&gt; 缺省 -&gt; protected - &gt; public ）</p><table><thead><tr><th><strong>修饰符</strong></th><th align="center">同一 个类中</th><th align="center">同一个包中其他类</th><th align="center">不同包下的子类</th><th align="center">不同包下的无关类</th></tr></thead><tbody><tr><td>private</td><td align="center">√</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td>缺省</td><td align="center">√</td><td align="center">√</td><td align="center"></td><td align="center"></td></tr><tr><td>protected</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center"></td></tr><tr><td>public</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr></tbody></table></li></ul><p><strong>学完权限修饰符需要具备如下能力</strong></p><ul><li><p>能够识别别人定义的成员的访问权限。</p></li><li><p>自己定义成员（方法，成员变量，构造器等）一般满足如下要求：</p><ul><li>成员变量一般私有。</li><li>方法一般公开。</li><li>如果该成员只希望本类访问，使用private修饰。</li><li>如果该成员只希望本类，同一个包下的其他类和子类访问，使用protected修饰。</li></ul></li></ul><hr><hr><h3 id="3-final"><a href="#3-final" class="headerlink" title="3.final"></a>3.final</h3><hr><h4 id="3-1final的作用"><a href="#3-1final的作用" class="headerlink" title="3.1final的作用"></a>3.1final的作用</h4><ul><li><p>final 关键字是最终的意思，可以修饰（方法，变量，类）</p></li><li><p>修饰方法：表明该方法是最终方法，不能被重写。</p></li><li><p>修饰变量：表示该变量第一次赋值后，不能再次被赋值(有且仅能被赋值一次)。</p></li><li><p>修饰类：表明该类是最终类，不能被继承。</p></li></ul><hr><h4 id="3-2-final修饰变量的注意"><a href="#3-2-final修饰变量的注意" class="headerlink" title="3.2 final修饰变量的注意"></a>3.2 final修饰变量的注意</h4><ul><li><p>final修饰的变量是基本类型：那么变量存储的<strong>数据值</strong>不能发生改变。</p></li><li><p>final修饰的变量是引用类型：那么变量存储的<strong>地址值</strong>不能发生改变，但是地址指向的对象内容是可以发生变化的。</p></li></ul><hr><hr><h3 id="4-常量"><a href="#4-常量" class="headerlink" title="4.常量"></a>4.常量</h3><hr><h4 id="4-1常量概述和基本作用"><a href="#4-1常量概述和基本作用" class="headerlink" title="4.1常量概述和基本作用"></a>4.1常量概述和基本作用</h4><p><strong>常量</strong> </p><ul><li><p>常量是使用了public static final修饰的成员变量，必须有初始化值，而且执行的过程中其值不能被改变。</p></li><li><p>常量的作用和好处：可以用于做系统的配置信息，方便程序的维护，同时也能提高可读</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Constant</span> &#123;    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SCHOOL_NAME</span>  <span class="operator">=</span> “传智教育<span class="string">&quot;;   public static final String LOGIN_NAME  = “admin&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PASS_WORD</span>  <span class="operator">=</span> “<span class="number">123456</span><span class="string">&quot;;</span></span><br><span class="line"><span class="string">&#125; </span></span><br></pre></td></tr></table></figure><p><strong>建议：</strong>常量命名规范：英文单词全部大写，多个单词下划线连接起来。</p><p><strong>常量的执行原理</strong></p><ul><li><p>在编译阶段会进行“宏替换”，把使用常量的地方全部替换成真实的字面量。</p></li><li><p>这样做的好处是让使用常量的程序的执行性能与直接使用字面量是一样的。</p></li></ul><hr><h4 id="4-2常量做信息标志和分类"><a href="#4-2常量做信息标志和分类" class="headerlink" title="4.2常量做信息标志和分类"></a>4.2常量做信息标志和分类</h4><p><strong>案例说明：</strong></p><ul><li>现在开发的超级玛丽游戏需要接收用户输入的四个方向的信号（上下左右），以便控制玛丽移动的方向。</li></ul><p><strong>选择常量做信息标志和分类：</strong></p><ul><li>代码可读性好，实现了软编码形式。</li></ul><hr><hr><h3 id="5-枚举"><a href="#5-枚举" class="headerlink" title="5.枚举"></a>5.枚举</h3><hr><h4 id="5-1枚举的概述"><a href="#5-1枚举的概述" class="headerlink" title="5.1枚举的概述"></a>5.1枚举的概述</h4><p><strong>枚举的概述</strong></p><ul><li>枚举是Java中的一种特殊类型</li></ul><p><strong>枚举的作用：</strong></p><ul><li>是为了做信息的标志和信息的分类</li></ul><p><strong>定义枚举类的格式:</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 <span class="keyword">enum</span> 枚举名称&#123;</span><br><span class="line">            第一行都是罗列枚举类实例的名称。</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Season</span>&#123;    </span><br><span class="line">SPRING , SUMMER , AUTUMN , WINTER;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>枚举的特征：</strong></p><ul><li><p>枚举类都是继承了枚举类型：java.lang.Enum</p></li><li><p>枚举都是最终类，不可以被继承。</p></li><li><p>构造器都是私有的，枚举对外不能创建对象。</p></li><li><p>枚举类的第一行默认都是罗列枚举对象的名称的。</p></li><li><p>枚举类相当于是多例模式。</p></li></ul><hr><h4 id="5-2枚举的使用场景演示"><a href="#5-2枚举的使用场景演示" class="headerlink" title="5.2枚举的使用场景演示"></a>5.2枚举的使用场景演示</h4><p><strong>案例说明：</strong></p><ul><li>现在开发的超级玛丽游戏需要接收用户输入的四个方向的信号（上下左右），以便控制玛丽移动的方向。</li></ul><p><strong>选择常量做信息标志和分类：</strong></p><ul><li>虽然可以实现可读性，但是入参值不受约束，代码相对不够严谨。</li></ul><p><strong>枚举做信息标志和分类：</strong></p><ul><li>代码可读性好，入参约束严谨，代码优雅，是最好的信息分类技术！建议使用!</li></ul><hr><hr><h3 id="6-抽象类"><a href="#6-抽象类" class="headerlink" title="6.抽象类"></a>6.抽象类</h3><hr><h4 id="6-1抽象类概述"><a href="#6-1抽象类概述" class="headerlink" title="6.1抽象类概述"></a>6.1抽象类概述</h4><p><strong>抽象类</strong></p><ul><li>在Java中<strong>abstract</strong>是抽象的意思，如果一个类中的<strong>已知有某个方法</strong>，但是<strong>方法的具体实现不能确定</strong>，就可以申明成<strong>abstract</strong>修饰的抽象方法（不能写方法体了），这个类必须用abstract修饰，被称为抽象类。（只能修饰方法、类）</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 <span class="keyword">abstract</span> 返回值类型 方法名称(形参列表);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 <span class="keyword">abstract</span> class 类名&#123;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>抽象的使用总结与注意事项</strong></p><ul><li><p>抽象类可以理解成类的不完整设计图，是用来被子类继承的。</p></li><li><p>一个类如果<strong>继承了抽象类</strong>，那么这个类<strong>必须重写完抽象类的全部抽象方法</strong>，否则这个类也<strong>必须定义成抽象类</strong>。</p></li></ul><hr><h4 id="6-2抽象类的案例"><a href="#6-2抽象类的案例" class="headerlink" title="6.2抽象类的案例"></a>6.2抽象类的案例</h4><p><strong>系统需求</strong></p><ul><li><p>某加油站推出了2种支付卡，一种是预存10000的<strong>金卡</strong>，后续加油享受<strong>8折优惠</strong>，另一种是预存5000的<strong>银卡</strong> ,后续加油享受<strong>8.5折优惠</strong>。</p></li><li><p>请分别实现2种卡片进入收银系统后的逻辑，卡片需要包含主人<strong>名称，余额，支付功能。</strong></p></li></ul><p><strong>分析实现</strong></p><ul><li><p>创建一张卡片父类：定义属性包括主人名称、余额、支付功能（具体实现交给子类）</p></li><li><p>创建一张白金卡类：重写支付功能，按照原价的8折计算输出。</p></li><li><p>创建一张银卡类：重写支付功能，按照原价的8.5折计算输出。</p></li></ul><hr><h4 id="6-3抽象类的特征、注意事项"><a href="#6-3抽象类的特征、注意事项" class="headerlink" title="6.3抽象类的特征、注意事项"></a>6.3抽象类的特征、注意事项</h4><p><strong>特征和注意事项</strong></p><ul><li><p><strong>有得有失</strong>: 得到了抽象方法，失去了创建对象的能力。</p></li><li><p><strong>抽象类为什么不能创建对象？</strong></p></li><li><ul><li><p>类有的成员（成员变量、方法、构造器）抽象类都具备</p></li><li><p>抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类（只能修饰方法、类）</p></li><li><p>一个类继承了抽象类必须重写完抽象类的全部抽象方法，否则这个类也必须定义成抽象类。</p></li><li><p>不能用abstract修饰变量、代码块、构造器。</p></li></ul></li></ul><hr><h4 id="6-4abstract和final是什么关系？"><a href="#6-4abstract和final是什么关系？" class="headerlink" title="6.4abstract和final是什么关系？"></a>6.4abstract和final是什么关系？</h4><p><strong>互斥关系</strong></p><ul><li><p><strong>abstract</strong>定义的<strong>抽象类</strong>作为模板让<strong>子类继承</strong>，<strong>final</strong>定义的<strong>类不能被继承</strong>。</p></li><li><p><strong>抽象方法</strong>定义通用<strong>方法</strong>让<strong>子类重写</strong>，<strong>final</strong>定义的<strong>方法</strong>子类<strong>不能重写</strong>。</p></li></ul><hr><h4 id="6-4抽象类的应用知识：模板方法模式"><a href="#6-4抽象类的应用知识：模板方法模式" class="headerlink" title="6.4抽象类的应用知识：模板方法模式"></a>6.4抽象类的应用知识：模板方法模式</h4><p><strong>什么时候使用模板方法模式</strong></p><p><strong>使用场景说明</strong>：当系统中出现同一个功能多处在开发，而该功能中大部分代码是一样的，只有其中部分可能不同的时候。</p><p><strong>模板方法模式实现步骤</strong></p><ul><li><p>把功能定义成一个所谓的模板方法，放在抽象类中，模板方法中只定义通用且能确定的代码。</p></li><li><p>模板方法中不能决定的功能定义成抽象方法让具体子类去实现。</p></li></ul><p><strong>案例：银行利息结算系统</strong></p><p><strong>需求：</strong></p><ul><li><p>某软件公司要为某银行的业务支撑系统开发一个利息结算系统，账户有活期和定期账户两种，</p></li><li><p>活期是0.35%，定期是 1.75%，定期如果满10万额外给予3%的收益。</p></li><li><p>结算利息要先进行用户名、密码验证，验证失败直接提示，登录成功进行结算</p></li></ul><p><strong>分析：</strong></p><p>活期————登录验证</p><p>​                       计算利息…</p><p>定期————输出利息</p><p><strong>银行利息结算系统实现</strong></p><p><strong>需求：</strong></p><ul><li><p>活期是0.35%，定期是 1.75%，定期如果满10万额外给予3%的收益。</p></li><li><p>结算利息要先进行用户名、密码验证，验证失败直接提示，登录成功进行结算</p></li></ul><p><strong>分析：</strong></p><p>①：创建一个抽象的账户类Account作为父类模板，提供属性（卡号，余额）</p><p>②：在父类Account中提供一个模板方法实现登录验证，利息结算、利息输出。</p><p>③：具体的利息结算定义成抽象方法，交给子类实现。</p><p>④：定义活期账户类，让子类重写实现具体的结算方法</p><p>⑤：定义定期账户类，让子类重写实现具体的结算方法</p><p>⑥：创建账户对象，完成相关功能。</p><p><strong>模板方法我们是建议使用final修饰的，这样会更专业，那么为什么呢？</strong></p><p>答：模板方法是给子类直接使用的，不是让子类重写的，</p><p>一旦子类重写了模板方法就失效了。</p><hr><hr><h3 id="7-接口"><a href="#7-接口" class="headerlink" title="7.接口"></a>7.接口</h3><hr><h4 id="7-1接口概述、特点"><a href="#7-1接口概述、特点" class="headerlink" title="7.1接口概述、特点"></a>7.1接口概述、特点</h4><p><strong>接口的定义与特点</strong></p><p>接口的格式如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">接口用关键字interface来定义</span><br><span class="line"><span class="keyword">public</span> interface 接口名 &#123;</span><br><span class="line">       <span class="comment">// 常量</span></span><br><span class="line">       <span class="comment">// 抽象方法</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><ul><li><p>JDK8之前接口中只能是<strong>抽象方法</strong>和<strong>常量</strong>，没有其他成分了。</p></li><li><p><strong>接口不能实例化</strong>。</p></li><li><p>接口中的成员都是<strong>public修饰</strong>的，写不写都是，因为规范的目的是为了公开化。</p></li></ul><hr><h4 id="7-2接口的基本使用：被实现"><a href="#7-2接口的基本使用：被实现" class="headerlink" title="7.2接口的基本使用：被实现"></a>7.2接口的基本使用：被实现</h4><p><strong>接口的用法</strong>：</p><ul><li><p>接口是用来被类实现（<strong>implements</strong>）的，<strong>实现接口的类称为实现类</strong>。实现类可以理解成所谓的<strong>子类</strong>。(接口也具有继承关系)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 class 实现类 implements 接口<span class="number">1</span>, 接口<span class="number">2</span>, 接口<span class="number">3</span> , ... &#123;</span><br><span class="line">&#125;</span><br><span class="line">实现的关键字：implements</span><br></pre></td></tr></table></figure></li><li><p>从上面可以看出，接口可以被类单实现，也可以被类多实现。</p></li></ul><p><strong>接口实现的注意事项：</strong></p><ul><li><strong>一个类实现接口，必须重写完全部接口的全部抽象方法，否则这个类需要定义成抽象类。</strong></li></ul><hr><h4 id="7-3接口与接口的关系：多继承"><a href="#7-3接口与接口的关系：多继承" class="headerlink" title="7.3接口与接口的关系：多继承"></a>7.3接口与接口的关系：多继承</h4><p><strong>基本小结</strong></p><ul><li><p>类和类的关系：单继承。</p></li><li><p>类和接口的关系：多实现。</p></li><li><p>接口和接口的关系：多继承，一个接口可以同时继承多个接口。</p></li></ul><p><strong>接口多继承的作用</strong></p><ul><li>规范合并，整合多个接口为同一个接口，便于子类实现。</li></ul><hr><h4 id="7-4JDK8开始接口新增方法"><a href="#7-4JDK8开始接口新增方法" class="headerlink" title="7.4JDK8开始接口新增方法"></a>7.4JDK8开始接口新增方法</h4><p><strong>第一种：默认方法</strong>  (实例方法)</p><ul><li><p>类似之前写的普通实例方法：<strong>必须用default修饰</strong></p></li><li><p>默认会public修饰。需要用接口的实现类的对象来调用</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(默认<span class="keyword">public</span>) <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123; </span><br><span class="line">System.out.println(<span class="string">&quot;--开始跑--&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">等同于普通实例方法，但是在接口里面必须用<span class="keyword">default</span>修饰，风格~~</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123; </span><br><span class="line">System.out.println(<span class="string">&quot;--开始跑--&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第二种：静态方法</strong></p><ul><li>默认会public修饰，<strong>必须static修饰。</strong></li></ul><p><strong>注意：接静态方法必须用本身的接口名来调用</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(默认<span class="keyword">public</span>) <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">inAddr</span><span class="params">()</span>&#123;  </span><br><span class="line">System.out.println(<span class="string">&quot;我们都在黑马培训中心快乐的学习Java!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第三种：私有方法</strong></p><ul><li><p>就是私有的实例方法:，<strong>必须使用private修饰</strong>，从<strong>JDK 1.9才开始有的</strong>。</p></li><li><p>只能在<strong>本类中被其他的默认方法</strong>或者<strong>私有方法</strong>访问。</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(默认<span class="keyword">public</span>) <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">()</span>&#123;    </span><br><span class="line">System.out.println(<span class="string">&quot;--准备--&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="7-5使用接口的注意事项"><a href="#7-5使用接口的注意事项" class="headerlink" title="7.5使用接口的注意事项"></a>7.5使用接口的注意事项</h4><p><strong>接口的注意事项</strong></p><ol><li>接口不能创建对象</li><li>一个类实现多个接口，多个接口中有同样的静态方法不冲突。</li><li>一个类继承了父类，同时又实现了接口，父类中和接口中有同名方法，默认用父类的。</li><li>一个类实现了多个接口，多个接口中存在同名的默认方法，不冲突，这个类重写该方法即可。</li><li>一个接口继承多个接口，是没有问题的，如果多个接口中存在规范冲突则不能多继承。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> java,面向对象进阶,包,权限修饰符,final,常量,枚举,抽象类,接口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>day10 - static、继承、单例、代码块</title>
      <link href="/post/b149836c.html"/>
      <url>/post/b149836c.html</url>
      
        <content type="html"><![CDATA[<h3 id="day11-面向对象进阶"><a href="#day11-面向对象进阶" class="headerlink" title="day11.面向对象进阶"></a>day11.面向对象进阶</h3><h3 id="1-静态关键字：static"><a href="#1-静态关键字：static" class="headerlink" title="1.静态关键字：static"></a>1.静态关键字：static</h3><h4 id="1-1static的作用、修饰成员变量的用法"><a href="#1-1static的作用、修饰成员变量的用法" class="headerlink" title="1.1static的作用、修饰成员变量的用法"></a>1.1static的作用、修饰成员变量的用法</h4><p><strong>static关键字的作用</strong></p><ul><li><p>static是静态的意思，可以修饰成员变量和成员方法。</p></li><li><p>static修饰成员变量表示该成员变量只在内存中只存储一份，可以被共享访问、修改。</p></li></ul><p><strong>成员变量可以分为2类</strong></p><ul><li><p>静态成员变量（有static修饰，属于类，内存中加载一次）: 常表示如在线人数信息、等需要被共享的信息，可以被共享访问。</p></li><li><p>实例成员变量（无static修饰，存在于每个对象中）：常表示姓名name、年龄age、等属于每个对象的信息。</p></li></ul><h4 id="1-2static修饰成员变量的内存原理"><a href="#1-2static修饰成员变量的内存原理" class="headerlink" title="1.2static修饰成员变量的内存原理"></a>1.2static修饰成员变量的内存原理</h4><h4 id="1-3static修饰成员方法的基本用法"><a href="#1-3static修饰成员方法的基本用法" class="headerlink" title="1.3static修饰成员方法的基本用法"></a>1.3static修饰成员方法的基本用法</h4><p><strong>成员方法的分类：</strong></p><ul><li><p>静态成员方法（有static修饰，属于类），建议用类名访问，也可以用对象访问。</p><p><strong>类名.静态成员方法。</strong></p><p><strong>对象.静态成员方法。（不推荐）</strong></p></li><li><p>实例成员方法（无static修饰，属于对象），只能用对象触发访问。</p><p><strong>对象.实例成员方法。</strong></p></li></ul><p><strong>使用场景</strong></p><ul><li><p>表示对象自己的行为的，且方法中需要访问实例成员的，则该方法必须申明成实例方法。</p></li><li><p>如果该方法是以执行一个共用功能为目的，则可以申明成静态方法。</p></li></ul><p><strong>定义员工类的实例</strong></p><p>需求：请完成一个标准实体类的设计，并提供如下要求实现。</p><p>①：某公司的员工信息系统中，需要定义一个公司的员工类Employee，包含如下信息（name, age , 所在部门名称dept ） , 定义一个静态的成员变量company记录公司的名称。</p><p>②：需要在Employee类中定义一个方法showInfos()，用于输出当前员工对象的信息。如name, age ，dept 以及公司名称company的信息。</p><p>③：需要在Employee类中定义定义一个通用的静态方法compareByAge，用于传输两个员工对象的年龄进入，并返回比较较大的年龄，例如：2个人中的最大年龄是:45岁。</p><h4 id="1-4static修饰成员方法的内存原理"><a href="#1-4static修饰成员方法的内存原理" class="headerlink" title="1.4static修饰成员方法的内存原理"></a>1.4static修饰成员方法的内存原理</h4><h4 id="1-5static实际应用案例：设计工具类"><a href="#1-5static实际应用案例：设计工具类" class="headerlink" title="1.5static实际应用案例：设计工具类"></a>1.5static实际应用案例：设计工具类</h4><p><strong>工具类：</strong></p><ul><li>工具类中定义的都是一些静态方法，每个方法都是以完成一个共用的功能为目的。</li></ul><p><strong>现状问题分析：</strong></p><ul><li>如果登录和注册等多处地方都存在验证码逻辑，就会导致同一个功能多处开发，会出现代码重复度过高。</li></ul><p><strong>工具类的好处</strong></p><ul><li>一是调用方便，二是提高了代码复用（一次编写，处处可用）</li></ul><p><strong>为什么工具类中的方法不用实例方法做？</strong></p><ul><li>实例方法需要创建对象调用，此时用对象只是为了调用方法，这样只会浪费内存。</li></ul><p><strong>工具类的定义注意</strong></p><ul><li><p>建议将<strong>工具类的构造器进行私有，工具类无需创建对象</strong>。</p></li><li><p>里面都是静态方法，直接用类名访问即可。</p></li></ul><h4 id="1-6static的注意事项总结-面试热点"><a href="#1-6static的注意事项总结-面试热点" class="headerlink" title="1.6static的注意事项总结[面试热点]"></a>1.6static的注意事项总结[面试热点]</h4><p><strong>static访问注意实现：</strong></p><ul><li><p>静态方法只能访问静态的成员，不可以直接访问实例成员。</p></li><li><p>实例方法可以访问静态的成员，也可以访问实例成员。</p></li><li><p>静态方法中是不可以出现this关键字的。</p></li></ul><hr><hr><h3 id="2-static应用知识：代码块"><a href="#2-static应用知识：代码块" class="headerlink" title="2.static应用知识：代码块"></a>2.static应用知识：代码块</h3><h4 id="2-1代码块的分类、作用"><a href="#2-1代码块的分类、作用" class="headerlink" title="2.1代码块的分类、作用"></a>2.1代码块的分类、作用</h4><p><strong>代码块概述</strong></p><ul><li><p>代码块是类的5大成分之一（成员变量、构造器，方法，代码块，内部类），定义在类中方法外。</p></li><li><p>在Java类下，使用 { } 括起来的代码被称为代码块 。</p></li></ul><p><strong>代码块分为</strong></p><ul><li><p><strong>静态代码块</strong>:</p><ul><li><strong>格式</strong>：static{}</li><li><strong>特点</strong>：需要通过static关键字修饰，随着类的加载而加载，并且自动触发、只执行一次</li><li><strong>使用场景</strong>：在类加载的时候做一些静态数据初始化的操作，以便后续使用。</li></ul></li><li><p><strong>构造代码块</strong>（<strong>了解，用的少</strong>）：</p><ul><li><strong>格式</strong>：{}</li><li><strong>特点</strong>：每次创建对象，调用构造器执行时，都会执行该代码块中的代码，并且在构造器执行前执行</li><li><strong>使用场景</strong>：初始化实例资源。</li></ul></li></ul><h4 id="2-2静态代码块的应用案例"><a href="#2-2静态代码块的应用案例" class="headerlink" title="2.2静态代码块的应用案例"></a>2.2静态代码块的应用案例</h4><p><strong>斗地主游戏</strong></p><p><strong>需求：</strong><br> 在启动游戏房间的时候，应该提前准备好54张牌，后续才可以直接使用这些牌数据。</p><p><strong>分析：</strong></p><p>①该房间只需要一副牌。</p><p>②定义一个静态的ArrayList集合存储54张牌对象，静态的集合只会加载一份。</p><p>③在启动游戏房间前，应该将54张牌初始化好</p><p>④当系统启动的同时需要准备好54张牌数据，此时可以用静态代码块完成。</p><hr><hr><h3 id="3-static应用知识：单例"><a href="#3-static应用知识：单例" class="headerlink" title="3.static应用知识：单例"></a>3.static应用知识：单例</h3><h4 id="3-1设计模式、单例模式介绍、饿汉单例模式"><a href="#3-1设计模式、单例模式介绍、饿汉单例模式" class="headerlink" title="3.1设计模式、单例模式介绍、饿汉单例模式"></a>3.1设计模式、单例模式介绍、饿汉单例模式</h4><p><strong>什么是设计模式（Design pattern）</strong></p><ul><li><p>开发中经常遇到一些问题，一个问题通常有n种解法的，但其中肯定有一种解法是最优的，这个最优的解法被人总结出来了，称之为设计模式。</p></li><li><p>设计模式有20多种，对应20多种软件开发中会遇到的问题，学设计模式主要是学2点：</p><ul><li>第一：这种模式用来解决什么问题。</li><li>第二：遇到这种问题了，该模式是怎么写的，他是如何解决这个问题的。</li></ul></li></ul><p><strong>单例模式</strong></p><ul><li><p>可以保证系统中，应用该模式的这个类永远只有一个实例，即一个类永远只能创建一个对象。</p></li><li><p>例如任务管理器对象我们只需要一个就可以解决问题了，这样可以节省内存空间。</p></li></ul><p><strong>单例的实现方式很多</strong></p><ul><li><p>饿汉单例模式。</p></li><li><p>懒汉单例模式。</p></li><li><p>…</p></li></ul><p><strong>饿汉单例设计模式</strong></p><ul><li>在用类获取对象的时候，对象已经提前为你创建好了。</li></ul><p><strong>设计步骤：</strong></p><ul><li><p>定义一个类，把构造器私有。</p></li><li><p>定义一个静态变量存储一个对象。</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** a、定义一个单例类 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleInstance</span> &#123;    </span><br><span class="line"><span class="comment">/** c.定义一个静态变量存储一个对象即可 :属于类，与类一起加载一次 */</span>  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">SingleInstance</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleInstance</span> ();    </span><br><span class="line"></span><br><span class="line"><span class="comment">/** b.单例必须私有构造器*/</span>   </span><br><span class="line"><span class="keyword">private</span> <span class="title function_">SingleInstance</span> <span class="params">()</span>&#123;        </span><br><span class="line">System.out.println(<span class="string">&quot;创建了一个对象&quot;</span>);   </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2懒汉单例模式"><a href="#3-2懒汉单例模式" class="headerlink" title="3.2懒汉单例模式"></a>3.2懒汉单例模式</h4><p><strong>懒汉单例设计模式</strong></p><ul><li>在真正需要该对象的时候，才去创建一个对象(延迟加载对象)。</li></ul><p><strong>设计步骤：</strong></p><ul><li><p>定义一个类，把构造器私有。</p></li><li><p>定义一个静态变量存储一个对象。</p></li><li><p>提供一个返回单例对象的方法</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 定义一个单例类 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleInstance</span>&#123;</span><br><span class="line"><span class="comment">/** 定义一个静态变量存储一个对象即可 :属于类，与类一起加载一次 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> SingleInstance instance ; <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 单例必须私有构造器*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">SingleInstance</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 必须提供一个方法返回一个单例对象  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> SingleInstance <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> ...;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><hr><h3 id="4-面向对象三大特征之二：继承"><a href="#4-面向对象三大特征之二：继承" class="headerlink" title="4.面向对象三大特征之二：继承"></a>4.面向对象三大特征之二：继承</h3><h4 id="4-1继承概述、使用继承的好处"><a href="#4-1继承概述、使用继承的好处" class="headerlink" title="4.1继承概述、使用继承的好处"></a>4.1继承概述、使用继承的好处</h4><p><strong>什么是继承？</strong></p><ul><li>Java中提供一个关键字extends，用这个关键字，我们可以让一个类和另一个类建立起父子关系。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">People</span> &#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>Student称为子类（派生类），People称为父类(基类 或超类)。</li></ul><p><strong>使用继承的好处</strong></p><ul><li>当子类继承父类后，就可以直接使用父类公共的属性和方法了。因此，用好这个技术可以很好的我们提高代码的复用性</li></ul><p><strong>继承的格式</strong></p><ul><li><strong>子类 extends父类</strong></li></ul><p><strong>继承后子类的特点</strong></p><ul><li><p><strong>子类 继承父类，子类可以得到父类的属性和行为，子类可以使用。</strong></p></li><li><p><strong>Java中子类更强大</strong></p></li></ul><h4 id="4-2继承的设计规范、内存运行原理"><a href="#4-2继承的设计规范、内存运行原理" class="headerlink" title="4.2继承的设计规范、内存运行原理"></a>4.2继承的设计规范、内存运行原理</h4><p><strong>继承设计规范：</strong></p><ul><li>子类们相同特征（共性属性，共性方法）放在父类中定义</li><li>子类独有的的属性和行为应该定义在子类自己里面。</li></ul><p><strong>为什么？</strong> </p><ul><li>如果子类的独有属性、行为定义在父类中，会导致其它子类也会得到这些属性和行为，这不符合面向对象逻辑。</li></ul><h4 id="4-3继承的特点"><a href="#4-3继承的特点" class="headerlink" title="4.3继承的特点"></a>4.3继承的特点</h4><p><strong>继承的特点</strong></p><p>​①子类可以继承父类的属性和行为，但是子类不能继承父类的构造器。</p><p>​②Java是单继承模式：一个类只能继承一个直接父类。</p><p>​③Java不支持多继承、但是支持多层继承。</p><p>​④Java中所有的类都是Object类的子类。</p><p><strong>1、子类是否可以继承父类的构造器？</strong></p><ul><li>不可以的，子类有自己的构造器，父类构造器用于初始化父类对象。</li></ul><p><strong>2、子类是否可以继承父类的私有成员？</strong></p><ul><li>可以的，只是不能直接访问。</li></ul><p><strong>3、子类是否可以继承父类的静态成员？</strong></p><ul><li><p>有争议的知识点。</p></li><li><p>子类可以直接使用父类的静态成员（共享）</p></li><li><p>但个人认为：子类不能继承父类的静态成员。（共享并非继承）</p></li></ul><p><strong>注意：Java只支持单继承，不支持多继承。</strong></p><ul><li><strong>单继承：子类只能继承一个直接父类</strong></li><li><strong>不支持多继承：子类不能同时继承多个父类</strong></li></ul><p><strong>Java支持多层继承</strong></p><ul><li>子类 A 继承父类 B ，父类B 可以 继承父类 C</li></ul><p><strong>Object特点：</strong></p><ul><li>Java中所有类，要么直接继承了Object , 要么默认继承了Object , 要么间接继承了Object, Object是祖宗类。</li></ul><h4 id="4-4继承后：成员变量、成员方法的访问特点"><a href="#4-4继承后：成员变量、成员方法的访问特点" class="headerlink" title="4.4继承后：成员变量、成员方法的访问特点"></a>4.4继承后：成员变量、成员方法的访问特点</h4><p><strong>在子类方法中访问成员（成员变量、成员方法）满足：就近原则</strong></p><ul><li><p>先子类局部范围找</p></li><li><p>然后子类成员范围找</p></li><li><p>然后父类成员范围找，如果父类范围还没有找到则报错。</p></li></ul><p><strong>如果子父类中，出现了重名的成员，会优先使用子类的，此时如果一定要在子类中使用父类的怎么办？</strong></p><ul><li><p>可以通过super关键字，指定访问父类的成员。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">格式：<span class="built_in">super</span>.父类成员变量/父类成员方法</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-5继承后：方法重写"><a href="#4-5继承后：方法重写" class="headerlink" title="4.5继承后：方法重写"></a>4.5继承后：方法重写</h4><p><strong>什么是方法重写？</strong></p><ul><li>在继承体系中，子类出现了和父类中一模一样的方法声明，我们就称子类这个方法是重写的方法。</li></ul><p><strong>方法重写的应用场景</strong></p><ul><li><p>当子类需要父类的功能，但父类的该功能不完全满足自己的需求时。</p></li><li><p>子类可以重写父类中的方法。</p></li></ul><p><strong>案例演示：</strong></p><ul><li><p>旧手机的功能只能是基本的打电话，发信息</p></li><li><p>新手机的功能需要能够：基本的打电话下支持视频通话。基本的发信息下支持发送语音和图片。</p></li></ul><p><strong>@Override重写注解</strong></p><ul><li><p>@Override是放在重写后的方法上，作为重写是否正确的校验注解。</p></li><li><p>加上该注解后如果重写错误，编译阶段会出现错误提示。</p></li><li><p>建议重写方法都加@Override注解，代码安全，优雅！</p></li></ul><p><strong>方法重写注意事项和要求</strong></p><ul><li><p>重写方法的名称、形参列表必须与被重写方法的名称和参数列表一致。</p></li><li><p>私有方法不能被重写。</p></li><li><p>子类重写父类方法时，访问权限必须大于或者等于父类 </p><p>（暂时了解 ：缺省 &lt; protected &lt; public）</p></li><li><p>子类不能重写父类的静态方法，如果重写会报错的。</p></li></ul><h4 id="4-6继承后：子类构造器的特点"><a href="#4-6继承后：子类构造器的特点" class="headerlink" title="4.6继承后：子类构造器的特点"></a>4.6继承后：子类构造器的特点</h4><p><strong>子类继承父类后构造器的特点：</strong></p><ul><li>子类中所有的构造器默认都会先访问父类中无参的构造器，再执行自己。</li></ul><p><strong>为什么？</strong></p><ul><li><p>子类在初始化的时候，有可能会使用到父类中的数据，如果父类没有完成初始化，子类将无法使用父类的数据。</p></li><li><p>子类初始化之前，一定要调用父类构造器先完成父类数据空间的初始化。</p></li></ul><p><strong>怎么调用父类构造器的？</strong></p><ul><li>子类构造器的第一行语句默认都是：<strong>super()，不写也存在。</strong></li></ul><h4 id="4-7继承后：子类构造器访问父类有参构造器"><a href="#4-7继承后：子类构造器访问父类有参构造器" class="headerlink" title="4.7继承后：子类构造器访问父类有参构造器"></a>4.7继承后：子类构造器访问父类有参构造器</h4><p><strong>super调用父类有参数构造器的作用：</strong></p><ul><li>初始化继承自父类的数据。</li></ul><p><strong>如果父类中没有无参数构造器，只有有参构造器，会出现什么现象呢？</strong></p><ul><li>会报错。因为子类默认是调用父类无参构造器的。</li></ul><p><strong>如何解决？</strong></p><ul><li>子类构造器中可以通过书写 super(…)，手动调用父类的有参数构造器</li></ul><h4 id="4-8this、super使用总结"><a href="#4-8this、super使用总结" class="headerlink" title="4.8this、super使用总结"></a>4.8this、super使用总结</h4><p><strong>this和super详情</strong></p><ul><li><strong>this</strong>：代表本类对象的引用；<strong>super</strong>：代表父类存储空间的标识。</li></ul><table><thead><tr><th align="center">关键字</th><th align="center"><strong>访问成员变量</strong></th><th align="center"><strong>访问成员方法</strong></th><th align="center">访问构造方法</th></tr></thead><tbody><tr><td align="center"><strong>this</strong></td><td align="center">this.成员变量  访问本类成员变量</td><td align="center">this.成员方法(…)  访问本类成员方法</td><td align="center">this(…)  访问本类构器</td></tr><tr><td align="center"><strong>super</strong></td><td align="center">super.成员变量  访问父类成员变量</td><td align="center">super.成员方法(…)  访问父类成员方法</td><td align="center">super(…)  访问父类构造器</td></tr></tbody></table><p><strong>实际上，在以上的总结中，唯独只有this调用本类其他构造器我们是没有接触过的。</strong></p><p><strong>案例需求：</strong></p><ul><li><p>在学员信息登记系统中，后台创建对象封装数据的时候如果用户没有输入学校，则默认使用“黑马培训中心”。</p></li><li><p>如果用户输入了学校则使用用户输入的学校信息。</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;        </span><br><span class="line"><span class="keyword">private</span> String schoolName;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span>&#123;</span><br><span class="line">          <span class="built_in">this</span>(name , “黑马培训中心”);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name , String schoolName )</span>&#123;</span><br><span class="line">          <span class="built_in">this</span>.name = name;</span><br><span class="line">          <span class="built_in">this</span>.schoolName = schoolName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>this(…)和super(…)使用注意点：</strong></p><ul><li><p>子类通过 this (…）去调用本类的其他构造器，本类其他构造器会通过 super 去手动调用父类的构造器，最终还是会调用父类构造器的。</p></li><li><p>注意：this(…) super(…) 都只能放在构造器的第一行，所以二者不能共存在同一个构造器中。</p></li></ul><p>继承后的真实类型</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">instanceof</span></span><br><span class="line"></span><br><span class="line"> <span class="title function_">if</span> <span class="params">(u <span class="keyword">instanceof</span> Customer)</span>&#123;  <span class="comment">//u:父类对象  Customer：子类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> java,面向对象进阶,static，单例，代码块，继承 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>day09 - API</title>
      <link href="/post/bb5ff40.html"/>
      <url>/post/bb5ff40.html</url>
      
        <content type="html"><![CDATA[<h1 id="ATM系统功能实战"><a href="#ATM系统功能实战" class="headerlink" title="ATM系统功能实战"></a>ATM系统功能实战</h1><h2 id="系统准备、首页设计"><a href="#系统准备、首页设计" class="headerlink" title="系统准备、首页设计"></a>系统准备、首页设计</h2><p><strong>系统准备内容分析：</strong></p><p>①每个用户的账户信息都是一个对象，需要提供账户类。</p><p>②需要准备一个容器，用于存储系统全部账户对象信息。</p><p>③首页只需要包含：登录和注册2个功能。</p><p><strong>实现步骤：</strong></p><p>①定义账户类，用于后期创建账户对象封装用户的账户信息。</p><p>②账户类中的信息至少需要包含（卡号、姓名、密码、余额、取现额度）</p><p>③需要准备一个ArrayList的集合，用于存储系统用户的账户对象。</p><p>④定义一个系统启动类ATMSystem需要展示欢迎页包含2个功能：开户功能、登录账户。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String cardId;  <span class="comment">// 卡号</span></span><br><span class="line">    <span class="keyword">private</span> String userName;  <span class="comment">// 客户名称</span></span><br><span class="line">    <span class="keyword">private</span> String passWord;  <span class="comment">// 密码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> money;  <span class="comment">// 余额</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> quotaMoney;  <span class="comment">// 当次取现限额</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">(String cardId, String userName, String passWord, <span class="type">double</span> quotaMoney)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cardId = cardId;</span><br><span class="line">        <span class="built_in">this</span>.userName = userName;</span><br><span class="line">        <span class="built_in">this</span>.passWord = passWord;</span><br><span class="line">        <span class="built_in">this</span>.quotaMoney = quotaMoney;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCardId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cardId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCardId</span><span class="params">(String cardId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cardId = cardId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUserName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserName</span><span class="params">(String userName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPassWord</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> passWord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPassWord</span><span class="params">(String passWord)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.passWord = passWord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getMoney</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMoney</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getQuotaMoney</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> quotaMoney;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setQuotaMoney</span><span class="params">(<span class="type">double</span> quotaMoney)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.quotaMoney = quotaMoney;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ATMSystem</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、准备系统需要的容器对象，用于存储账户对象</span></span><br><span class="line">        ArrayList&lt;Account&gt; accounts = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、准备系统的首页：登录 开户</span></span><br><span class="line">        showMain(accounts);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showMain</span><span class="params">(ArrayList&lt;Account&gt; accounts)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=============欢迎进入首页=================&quot;</span>);</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请您输入您想做的操作：&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;1、登录&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;2、开户&quot;</span>);</span><br><span class="line">            System.out.print(<span class="string">&quot;您可以输入命令了：&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">command</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">            <span class="keyword">switch</span> (command) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    <span class="comment">// 登录</span></span><br><span class="line">                    login(accounts, sc);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    <span class="comment">// 开户</span></span><br><span class="line">                    register(accounts, sc);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;您当前输入的操作命令不被支持！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用户开户功能实现"><a href="#用户开户功能实现" class="headerlink" title="用户开户功能实现"></a>用户开户功能实现</h2><p>开户功能其实就是就是往系统的集合容器中存入一个新的账户对象的信息。</p><p><strong>开户功能实现步骤</strong></p><p>①定义方法完成开户：</p><p>②键盘录入姓名、密码、确认密码（需保证两次密码一致）</p><p>③生成账户卡号，卡号必须由系统自动生成8位数字（必须保证卡号的唯一）</p><p>④创建Account账户类对象用于封装账户信息（姓名、密码、卡号）</p><p>⑤把Account账户类对象存入到集合accounts中去。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户开户功能</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> accounts 账户的集合对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(ArrayList&lt;Account&gt; accounts, Scanner sc)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;===============用户开户功能==============&quot;</span>);</span><br><span class="line">    <span class="comment">// 2、键盘录入 姓名 密码 确认密码</span></span><br><span class="line">    System.out.println(<span class="string">&quot;请您输入开户名称：&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> sc.next();</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请您输入开户密码：&quot;</span>);</span><br><span class="line">        password = sc.next();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;请您输入确认密码：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">okPassword</span> <span class="operator">=</span> sc.next();</span><br><span class="line">        <span class="comment">// 判断两次输入的密码是否一致</span></span><br><span class="line">        <span class="keyword">if</span>(okPassword.equals(password))&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;两次密码必须一致~~~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;请您输入当次限额：&quot;</span>);</span><br><span class="line">    <span class="type">double</span> <span class="variable">quotaMoney</span> <span class="operator">=</span> sc.nextDouble();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、生成账户的卡号，卡号是8位，而且不能与其他账户卡号重复。</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">cardId</span> <span class="operator">=</span> createCardId(accounts);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4、创建一个账户对象封装账户的信息</span></span><br><span class="line">    <span class="comment">//   public Account(String cardId, String userName, String passWord, double money, double quotaMoney)</span></span><br><span class="line">    <span class="type">Account</span> <span class="variable">account</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span>(cardId, name, password,quotaMoney);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5、把账户对象添加到集合中去</span></span><br><span class="line">    accounts.add(account);</span><br><span class="line">    System.out.println(<span class="string">&quot;恭喜您，您开户成功，您的卡号是：&quot;</span> + account.getCardId() +<span class="string">&quot;。请您妥善保管&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">createCardId</span><span class="params">(ArrayList&lt;Account&gt; accounts)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 生成8位随机的数字代表卡号</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">cardId</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            cardId += r.nextInt(<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断卡号是否重复了</span></span><br><span class="line">        <span class="type">Account</span> <span class="variable">acc</span> <span class="operator">=</span> getAccountByCardId(cardId, accounts);</span><br><span class="line">        <span class="keyword">if</span>(acc == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 说明当前卡号没有重复</span></span><br><span class="line">            <span class="keyword">return</span> cardId;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Account <span class="title function_">getAccountByCardId</span><span class="params">(String cardId , ArrayList&lt;Account&gt; accounts)</span>&#123;</span><br><span class="line">    <span class="comment">// 根据卡号查询账户对象</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; accounts.size(); i++) &#123;</span><br><span class="line">        <span class="type">Account</span> <span class="variable">acc</span> <span class="operator">=</span> accounts.get(i);</span><br><span class="line">        <span class="keyword">if</span>(acc.getCardId().equals(cardId))&#123;</span><br><span class="line">            <span class="keyword">return</span> acc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 查无此账户，说明卡号没有重复了！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用户登录功能实现"><a href="#用户登录功能实现" class="headerlink" title="用户登录功能实现"></a>用户登录功能实现</h2><p><strong>分析</strong></p><p>①定义方法：</p><p>②让用户键盘录入卡号，根据卡号查询账户对象。</p><p>③如果没有找到了账户对象，说明卡号不存在，提示继续输入卡号。</p><p>④如果找到了账户对象，说明卡号存在，继续输入密码。</p><p>⑤如果密码不正确，提示继续输入密码</p><p>⑥如果密码正确，提示登陆成功！！</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 完成用户登录</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> accounts</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(ArrayList&lt;Account&gt; accounts, Scanner sc)</span> &#123;</span><br><span class="line">    <span class="comment">// 必须系统中存在账户才可以登录</span></span><br><span class="line">    <span class="keyword">if</span>(accounts.size() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 没有任何账户</span></span><br><span class="line">        System.out.println(<span class="string">&quot;当前系统中无任何账户，您需要先注册！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 直接结束方法的执行！</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、让用户键盘录入卡号，</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请您输入登录的卡号：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">cardId</span> <span class="operator">=</span> sc.next();</span><br><span class="line">        <span class="comment">// 根据卡号查询账户对象。</span></span><br><span class="line">        <span class="type">Account</span> <span class="variable">acc</span> <span class="operator">=</span> getAccountByCardId(cardId , accounts);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、判断账户对象是否存在，存在说明卡号没问题</span></span><br><span class="line">        <span class="keyword">if</span>(acc != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 4、让用户继续输入密码</span></span><br><span class="line">                System.out.println(<span class="string">&quot;请您输入登录的密码：&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> sc.next();</span><br><span class="line">                <span class="comment">// 5、判断密码是否正确</span></span><br><span class="line">                <span class="keyword">if</span>(acc.getPassWord().equals(password))&#123;</span><br><span class="line">                    <span class="comment">// 密码正确，登录成功</span></span><br><span class="line">                    <span class="comment">// 展示系统登录后的操作界面（下节课继续完成的功能！！）</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;恭喜您，&quot;</span> + acc.getUserName() +<span class="string">&quot;先生/女士成功进入系统，您的卡号是：&quot;</span> + acc.getCardId());</span><br><span class="line">                    <span class="comment">// 展示操作页面</span></span><br><span class="line">                    showUserCommand(sc, acc , accounts);</span><br><span class="line">                    <span class="keyword">return</span>; <span class="comment">// 继续结束登录方法</span></span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;您的密码有误，请确认！&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;对不起，不存在该卡号的账户！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用户操作页设计、查询账户、退出账户功能实现"><a href="#用户操作页设计、查询账户、退出账户功能实现" class="headerlink" title="用户操作页设计、查询账户、退出账户功能实现"></a>用户操作页设计、查询账户、退出账户功能实现</h2><p>①用户登录成功后，需要进入用户操作页，退出账户是需要回到首页的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showUserCommand</span><span class="params">(Scanner sc, Account acc , ArrayList&lt;Account&gt; accounts)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;==================用户操作界面===================&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;1、查询账户&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;2、存款&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;3、取款&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;4、转账&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;5、修改密码&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;6、退出&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;7、注销账户&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;请您输入操作命令：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">command</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="keyword">switch</span> (command) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    <span class="comment">// 查询账户</span></span><br><span class="line">                    showAccount(acc);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    <span class="comment">// 存款</span></span><br><span class="line">                    depositMoney(acc, sc);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                    <span class="comment">// 取款</span></span><br><span class="line">                    drawMoney(acc,sc);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                    <span class="comment">// 转账</span></span><br><span class="line">                    transferMoney(accounts, acc , sc);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                    <span class="comment">// 修改密码</span></span><br><span class="line">                    updatePassWord(acc,sc);</span><br><span class="line">                    <span class="keyword">return</span>; <span class="comment">// 结束当前操作的方法</span></span><br><span class="line">                <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                    <span class="comment">// 退出</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;欢迎下次光临！！&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span>; <span class="comment">// 结束当前操作的方法！</span></span><br><span class="line">                <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">                    <span class="comment">// 注销账户</span></span><br><span class="line">                    <span class="comment">// 从当前集合中抹掉当前账户对象即可</span></span><br><span class="line">                    accounts.remove(acc);</span><br><span class="line">                    System.out.println(<span class="string">&quot;销户成功了！！&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span>;<span class="comment">// 结束当前操作的方法！</span></span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;您的命令输入有误~~~&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>②查询就是直接展示当前登录成功的账户对象的信息。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showAccount</span><span class="params">(Account acc)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;==================当前账户详情===================&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;卡号：&quot;</span> + acc.getCardId());</span><br><span class="line">    System.out.println(<span class="string">&quot;姓名：&quot;</span> + acc.getUserName());</span><br><span class="line">    System.out.println(<span class="string">&quot;余额：&quot;</span> + acc.getMoney());</span><br><span class="line">    System.out.println(<span class="string">&quot;当次限额：&quot;</span> + acc.getQuotaMoney());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用户存款功能实现"><a href="#用户存款功能实现" class="headerlink" title="用户存款功能实现"></a>用户存款功能实现</h2><p>①存款就是拿到当前账户对象。</p><p>②然后让用户输入存款的金额。</p><p>③调用账户对象的setMoney方法将账户余额修改成存钱后的余额。</p><p>④存钱后需要查询一下账户信息，确认是否存钱成功了！</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   存钱的</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> acc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">depositMoney</span><span class="params">(Account acc, Scanner sc)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;==================存钱操作===================&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;请您输入存款的金额：&quot;</span>);</span><br><span class="line">    <span class="type">double</span> <span class="variable">money</span> <span class="operator">=</span> sc.nextDouble();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接把金额修改到账户对象的money属性中去</span></span><br><span class="line">    acc.setMoney(acc.getMoney() + money);</span><br><span class="line">    System.out.println(<span class="string">&quot;存款完成！！&quot;</span>);</span><br><span class="line">    showAccount(acc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用户取款功能实现"><a href="#用户取款功能实现" class="headerlink" title="用户取款功能实现"></a>用户取款功能实现</h2><p><strong>取款分析</strong></p><p>①取款需要先判断账户是否有钱。</p><p>②有钱则拿到自己账户对象。</p><p>③然后让用户输入取款金额</p><p>④判断取款金额是否超过了当次限额，以及余额是否足够</p><p>⑤满足要求则调用账户对象的setMoney方法完成金额的修改。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   取款</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> acc</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">drawMoney</span><span class="params">(Account acc, Scanner sc)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;==================取款操作===================&quot;</span>);</span><br><span class="line">    <span class="comment">// 1、判断它的账户是否足够100元</span></span><br><span class="line">    <span class="keyword">if</span>(acc.getMoney() &gt;= <span class="number">100</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请您输入取款的金额：&quot;</span>);</span><br><span class="line">            <span class="type">double</span> <span class="variable">money</span> <span class="operator">=</span> sc.nextDouble();</span><br><span class="line">            <span class="comment">// 2、判断这个金额有没有超过当次限额</span></span><br><span class="line">            <span class="keyword">if</span>(money &gt; acc.getQuotaMoney())&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;您当次取款金额超过每次限额，不要取那么多，每次最多可以取：&quot;</span> + acc.getQuotaMoney());</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 3、判断当前余额是否足够你取钱</span></span><br><span class="line">                <span class="keyword">if</span>(acc.getMoney() &gt;= money)&#123;</span><br><span class="line">                    <span class="comment">// 够钱，可以取钱了</span></span><br><span class="line">                    acc.setMoney(acc.getMoney() - money);</span><br><span class="line">                    System.out.println(<span class="string">&quot;恭喜您，取钱&quot;</span> + money + <span class="string">&quot;成功了！当前账户还剩余：&quot;</span> + acc.getMoney());</span><br><span class="line">                    <span class="keyword">return</span>;<span class="comment">// 取钱后干掉取钱方法</span></span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;余额不足啊！&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;您自己的金额没有超过100元，就别取了~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用户转账功能实现"><a href="#用户转账功能实现" class="headerlink" title="用户转账功能实现"></a>用户转账功能实现</h2><p><strong>分析</strong></p><p>①转账功能需要判断系统中是否有2个账户对象及以上。</p><p>②同时还要判断自己账户是否有钱。</p><p>③接下来需要输入对方卡号，判断对方账户是否存在。</p><p>④对方账户存在还需要认证对方户主的姓氏。</p><p>⑤满足要求则可以把自己账户对象的金额修改到对方账户对象中去。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  转账功能</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> accounts</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> acc</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">transferMoney</span><span class="params">(ArrayList&lt;Account&gt; accounts, Account acc, Scanner sc)</span> &#123;</span><br><span class="line">    <span class="comment">// 1、判断系统中是否有2个账户及以上</span></span><br><span class="line">    <span class="keyword">if</span>(accounts.size() &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;对不起，系统中无其他账户，您不可以转账！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、判断自己的账户对象中是否有钱</span></span><br><span class="line">    <span class="keyword">if</span>(acc.getMoney() == <span class="number">0</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;对不起，您自己都没钱，就别转了~~&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、开始转账逻辑</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请您输入对方账户的卡号：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">cardId</span> <span class="operator">=</span> sc.next();</span><br><span class="line">        <span class="type">Account</span> <span class="variable">account</span> <span class="operator">=</span> getAccountByCardId(cardId , accounts);</span><br><span class="line">        <span class="comment">// 判断这个账户对象是否存在，存在说明对方卡号输入正确</span></span><br><span class="line">        <span class="keyword">if</span>(account != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 判断这个账户对象是否是当前登录的账户自己</span></span><br><span class="line">            <span class="keyword">if</span>(account.getCardId().equals(acc.getCardId()))&#123;</span><br><span class="line">                <span class="comment">// 正在给自己转账</span></span><br><span class="line">                System.out.println(<span class="string">&quot;您不可以为自己转账！&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 确认对方的姓氏</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;*&quot;</span> + account.getUserName().substring(<span class="number">1</span>);</span><br><span class="line">                System.out.print(<span class="string">&quot;请您确认【&quot;</span> + name + <span class="string">&quot;】的姓氏：&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">preName</span> <span class="operator">=</span> sc.next(); <span class="comment">// 王</span></span><br><span class="line">                <span class="comment">// 判断        黑马关之琳</span></span><br><span class="line">                <span class="keyword">if</span>(account.getUserName().startsWith(preName))&#123;</span><br><span class="line">                    <span class="comment">// 真正开始转账了</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;请您输入转账的金额：&quot;</span>);</span><br><span class="line">                    <span class="type">double</span> <span class="variable">money</span> <span class="operator">=</span> sc.nextDouble();</span><br><span class="line">                    <span class="comment">// 判断这个金额是否超过了自己的余额</span></span><br><span class="line">                    <span class="keyword">if</span>(money &gt; acc.getMoney() )&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;对不起，您要转账的金额太多，您最多可以转账多少：&quot;</span> + acc.getMoney());</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 真的可以转了</span></span><br><span class="line">                        acc.setMoney(acc.getMoney() - money);</span><br><span class="line">                        account.setMoney(account.getMoney() + money);</span><br><span class="line">                        System.out.println(<span class="string">&quot;恭喜您，转账成功了，已经为&quot;</span> + account.getUserName() +<span class="string">&quot;转账多少：&quot;</span> + money);</span><br><span class="line">                        showAccount(acc);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;对不起，您认证的信息有误~~~&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;对不起，您输入的转账卡号有问题！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用户密码修改、销户功能实现"><a href="#用户密码修改、销户功能实现" class="headerlink" title="用户密码修改、销户功能实现"></a>用户密码修改、销户功能实现</h2><p><strong>分析</strong></p><p>①修改密码就是把当前对象的密码属性使用set方法进行更新。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">updatePassWord</span><span class="params">(Account acc, Scanner sc)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;===========修改密码=======================&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请您输入正确的密码：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">okPassWord</span> <span class="operator">=</span> sc.next();</span><br><span class="line">        <span class="comment">// 判断密码是否正确</span></span><br><span class="line">        <span class="keyword">if</span>(acc.getPassWord().equals(okPassWord))&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 可以输入新密码</span></span><br><span class="line">                System.out.println(<span class="string">&quot;请您输入新的密码：&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">newPassWord</span> <span class="operator">=</span> sc.next();</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;请您输入确认密码：&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">okNewPassWord</span> <span class="operator">=</span> sc.next();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(newPassWord.equals(okNewPassWord)) &#123;</span><br><span class="line">                    <span class="comment">// 修改账户对象的密码为新密码</span></span><br><span class="line">                    acc.setPassWord(newPassWord);</span><br><span class="line">                    <span class="keyword">return</span>; <span class="comment">// 直接结束掉！！</span></span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;您两次输入的密码不一致~~&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前输入的密码不正确~~~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>②销户是从集合对象中删除当前对象，并回到首页。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">    <span class="comment">// 注销账户</span></span><br><span class="line">    <span class="comment">// 从当前集合中抹掉当前账户对象即可</span></span><br><span class="line">    accounts.remove(acc);</span><br><span class="line">    System.out.println(<span class="string">&quot;销户成功了！！&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;<span class="comment">// 结束当前操作的方法！</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> java,基础语法,ATM系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>day08 - API</title>
      <link href="/post/eaac7003.html"/>
      <url>/post/eaac7003.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-API"><a href="#1-API" class="headerlink" title="1.API"></a>1.API</h2><h3 id="1-1API概述"><a href="#1-1API概述" class="headerlink" title="1.1API概述"></a>1.1API概述</h3><ul><li><p>什么是API</p><p>​API (Application Programming Interface) ：应用程序编程接口</p></li><li><p>java中的API</p><p>​指的就是 JDK 中提供的各种功能的 Java类，这些类将底层的实现封装了起来，我们不需要关心这些类是如何实现的，只需要学习这些类如何使用即可，我们可以通过帮助文档来学习这些API如何使用。</p></li></ul><h3 id="1-2如何使用API帮助文档"><a href="#1-2如何使用API帮助文档" class="headerlink" title="1.2如何使用API帮助文档"></a>1.2如何使用API帮助文档</h3><ul><li><p>打开帮助文档</p></li><li><p>找到索引选项卡中的输入框</p></li><li><p>在输入框中输入Random</p></li><li><p>看类在哪个包下</p></li><li><p>看类的描述</p></li><li><p>看构造方法</p></li><li><p>看成员方法</p></li></ul><h2 id="2-String类"><a href="#2-String类" class="headerlink" title="2.String类"></a>2.String类</h2><h3 id="2-1String类概述"><a href="#2-1String类概述" class="headerlink" title="2.1String类概述"></a>2.1String类概述</h3><p>​String 类代表字符串，Java 程序中的所有字符串文字（例如“abc”）都被实现为此类的实例。也就是说，Java 程序中所有的双引号字符串，都是 String 类的对象。String 类在 java.lang 包下，所以使用的时候不需要导包！</p><h3 id="2-2String类的特点"><a href="#2-2String类的特点" class="headerlink" title="2.2String类的特点"></a>2.2String类的特点</h3><ul><li>字符串不可变，它们的值在创建后不能被更改</li><li>虽然 String 的值是不可变的，但是它们可以被共享</li><li>字符串效果上相当于字符数组( char[] )，但是底层原理是字节数组( byte[] )</li></ul><h3 id="2-3String类的构造方法"><a href="#2-3String类的构造方法" class="headerlink" title="2.3String类的构造方法"></a>2.3String类的构造方法</h3><ul><li><p>常用的构造方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public   String()</td><td>创建一个空白字符串对象，不含有任何内容</td></tr><tr><td>public   String(char[] chs)</td><td>根据字符数组的内容，来创建字符串对象</td></tr><tr><td>public   String(byte[] bys)</td><td>根据字节数组的内容，来创建字符串对象</td></tr><tr><td>String s &#x3D;   “abc”;</td><td>直接赋值的方式创建字符串对象，内容就是abc</td></tr></tbody></table></li><li><p>示例代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//public String()：创建一个空白字符串对象，不含有任何内容</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;s1:&quot;</span> + s1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//public String(char[] chs)：根据字符数组的内容，来创建字符串对象</span></span><br><span class="line">        <span class="type">char</span>[] chs = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(chs);</span><br><span class="line">        System.out.println(<span class="string">&quot;s2:&quot;</span> + s2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//public String(byte[] bys)：根据字节数组的内容，来创建字符串对象</span></span><br><span class="line">        <span class="type">byte</span>[] bys = &#123;<span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>&#125;;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bys);</span><br><span class="line">        System.out.println(<span class="string">&quot;s3:&quot;</span> + s3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//String s = “abc”;直接赋值的方式创建字符串对象，内容就是abc</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;s4:&quot;</span> + s4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-4创建字符串对象两种方式的区别"><a href="#2-4创建字符串对象两种方式的区别" class="headerlink" title="2.4创建字符串对象两种方式的区别"></a>2.4创建字符串对象两种方式的区别</h3><ul><li><p>直接赋值方式创建</p><p>​以 “  ” 方式给出的字符串对象，在字符常量池中储存，而且形同内容指挥在其中储存一份</p></li><li><p>通过构造方法创建</p><p>​通过 new 创建的字符串对象，每 new 一次都会产生一个新对象，放在堆内存中，虽然内容相同，但是地址值不同</p></li></ul><p></p><h3 id="2-5字符串的比较"><a href="#2-5字符串的比较" class="headerlink" title="2.5字符串的比较"></a>2.5字符串的比较</h3><h4 id="2-5-1-号的作用"><a href="#2-5-1-号的作用" class="headerlink" title="2.5.1   &#x3D;&#x3D;号的作用"></a>2.5.1   &#x3D;&#x3D;号的作用</h4><ul><li>比较基本数据类型：比较的是具体的值</li><li>比较引用数据类型：比较的是对象地址值</li><li>所以  &#x3D;&#x3D;  不适合字符串的内容比较</li></ul><h4 id="2-5-2-equals方法的作用"><a href="#2-5-2-equals方法的作用" class="headerlink" title="2.5.2   equals方法的作用"></a>2.5.2   equals方法的作用</h4><ul><li><p>方法介绍   </p><p><strong>equals与equalsIgnoreCase的区别</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object anObject)</span></span><br><span class="line"><span class="comment">//比较两个字符串内容是否相同、区分大小写，多用于密码登录</span></span><br><span class="line"></span><br><span class="line">例：</span><br><span class="line">  <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;itadmin&quot;</span>; <span class="comment">//创建正确用户名</span></span><br><span class="line">  <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;czbk&quot;</span>;    <span class="comment">//创建正确密码</span></span><br><span class="line"></span><br><span class="line">  <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">&quot;请输入密码：&quot;</span>);</span><br><span class="line">  <span class="type">String</span> <span class="variable">pwd</span> <span class="operator">=</span> sc.nextLine(); <span class="comment">//用户输入密码</span></span><br><span class="line">  System.out.println(<span class="string">&quot;请输入密码：&quot;</span>);</span><br><span class="line">  <span class="type">String</span> <span class="variable">pwd</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">   </span><br><span class="line">  <span class="keyword">if</span>(name.equals(username)&amp;&amp;pwd.equals(password)) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">     </span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equalsIgnoreCase</span><span class="params">(String anotherString)</span></span><br><span class="line">    <span class="comment">////比较两个字符串内容是否相同、不区分大小写，多用于验证码</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure></li><li><p>示例代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//构造方法的方式得到对象</span></span><br><span class="line">        <span class="type">char</span>[] chs = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(chs);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(chs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//直接赋值的方式得到对象</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//比较字符串对象地址是否相同</span></span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">        System.out.println(s1 == s3);</span><br><span class="line">        System.out.println(s3 == s4);</span><br><span class="line">        System.out.println(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//比较字符串内容是否相同</span></span><br><span class="line">        System.out.println(s1.equals(s2));</span><br><span class="line">        System.out.println(s1.equals(s3));</span><br><span class="line">        System.out.println(s3.equals(s4));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-6用户登录案例"><a href="#2-6用户登录案例" class="headerlink" title="2.6用户登录案例"></a>2.6用户登录案例</h3><h4 id="2-6-1案例需求"><a href="#2-6-1案例需求" class="headerlink" title="2.6.1案例需求"></a>2.6.1案例需求</h4><p>​已知用户名和密码，请用程序实现模拟用户登录。总共给三次机会，登录之后，给出相应的提示</p><h4 id="2-6-2代码实现"><a href="#2-6-2代码实现" class="headerlink" title="2.6.2代码实现"></a>2.6.2代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    思路：</span></span><br><span class="line"><span class="comment">        1:已知用户名和密码，定义两个字符串表示即可</span></span><br><span class="line"><span class="comment">        2:键盘录入要登录的用户名和密码，用 Scanner 实现</span></span><br><span class="line"><span class="comment">        3:拿键盘录入的用户名、密码和已知的用户名、密码进行比较，给出相应的提示。字符串的内容比较，用equals() 方法实现</span></span><br><span class="line"><span class="comment">        4:用循环实现多次机会，这里的次数明确，采用for循环实现，并在登录成功的时候，使用break结束循环</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTest01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//已知用户名和密码，定义两个字符串表示即可</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;itadmin&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;czbk&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用循环实现多次机会，这里的次数明确，采用for循环实现，并在登录成功的时候，使用break结束循环</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//键盘录入要登录的用户名和密码，用 Scanner 实现</span></span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;请输入用户名：&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;请输入密码：&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">pwd</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//拿键盘录入的用户名、密码和已知的用户名、密码进行比较，给出相应的提示。字符串的内容比较，用equals() 方法实现</span></span><br><span class="line">            <span class="keyword">if</span>(name.equals(username)&amp;&amp;pwd.equals(password)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="number">2</span>-i == <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;你的账户被锁定，请与管理员联系&quot;</span>);</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//2,1,0</span></span><br><span class="line">                    <span class="comment">//i,0,1,2</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;登录失败，你还有&quot;</span> + (<span class="number">2</span> - i) + <span class="string">&quot;次机会&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-7遍历字符串案例"><a href="#2-7遍历字符串案例" class="headerlink" title="2.7遍历字符串案例"></a>2.7遍历字符串案例</h3><h4 id="2-7-1案例需求"><a href="#2-7-1案例需求" class="headerlink" title="2.7.1案例需求"></a>2.7.1案例需求</h4><p>​键盘录入一个字符串，使用程序实现在控制台遍历该字符串</p><h4 id="2-7-2代码实现"><a href="#2-7-2代码实现" class="headerlink" title="2.7.2代码实现"></a>2.7.2代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    思路：</span></span><br><span class="line"><span class="comment">        1:键盘录入一个字符串，用 Scanner 实现</span></span><br><span class="line"><span class="comment">        2:遍历字符串，首先要能够获取到字符串中的每一个字符</span></span><br><span class="line"><span class="comment">            public char charAt(int index)：返回指定索引处的char值，字符串的索引也是从0开始的</span></span><br><span class="line"><span class="comment">        3:遍历字符串，其次要能够获取到字符串的长度</span></span><br><span class="line"><span class="comment">            public int length()：返回此字符串的长度</span></span><br><span class="line"><span class="comment">            数组的长度：数组名.length</span></span><br><span class="line"><span class="comment">            字符串的长度：字符串对象.length()</span></span><br><span class="line"><span class="comment">        4:遍历字符串的通用格式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTest02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//键盘录入一个字符串，用 Scanner 实现</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入一个字符串：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;line.length(); i++) &#123;</span><br><span class="line">            System.out.println(line.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-8统计字符次数案例"><a href="#2-8统计字符次数案例" class="headerlink" title="2.8统计字符次数案例"></a>2.8统计字符次数案例</h3><h4 id="2-8-1案例需求"><a href="#2-8-1案例需求" class="headerlink" title="2.8.1案例需求"></a>2.8.1案例需求</h4><p>​键盘录入一个字符串，统计该字符串中大写字母字符，小写字母字符，数字字符出现的次数(不考虑其他字符)</p><h4 id="2-8-2代码实现"><a href="#2-8-2代码实现" class="headerlink" title="2.8.2代码实现"></a>2.8.2代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  思路：</span></span><br><span class="line"><span class="comment">        1:键盘录入一个字符串，用 Scanner 实现</span></span><br><span class="line"><span class="comment">        2:要统计三种类型的字符个数，需定义三个统计变量，初始值都为0</span></span><br><span class="line"><span class="comment">        3:遍历字符串，得到每一个字符</span></span><br><span class="line"><span class="comment">        4:判断该字符属于哪种类型，然后对应类型的统计变量+1</span></span><br><span class="line"><span class="comment">            假如ch是一个字符，我要判断它属于大写字母，小写字母，还是数字，直接判断该字符是否在对应的范围即可</span></span><br><span class="line"><span class="comment">            大写字母：ch&gt;=&#x27;A&#x27; &amp;&amp; ch&lt;=&#x27;Z&#x27;</span></span><br><span class="line"><span class="comment">            小写字母： ch&gt;=&#x27;a&#x27; &amp;&amp; ch&lt;=&#x27;z&#x27;</span></span><br><span class="line"><span class="comment">            数字： ch&gt;=&#x27;0&#x27; &amp;&amp; ch&lt;=&#x27;9&#x27;</span></span><br><span class="line"><span class="comment">        5:输出三种类型的字符个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTest03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//键盘录入一个字符串，用 Scanner 实现</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入一个字符串：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//要统计三种类型的字符个数，需定义三个统计变量，初始值都为0</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">bigCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">smallCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">numberCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历字符串，得到每一个字符</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;line.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> line.charAt(i);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断该字符属于哪种类型，然后对应类型的统计变量+1</span></span><br><span class="line">            <span class="keyword">if</span>(ch&gt;=<span class="string">&#x27;A&#x27;</span> &amp;&amp; ch&lt;=<span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">                bigCount++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ch&gt;=<span class="string">&#x27;a&#x27;</span> &amp;&amp; ch&lt;=<span class="string">&#x27;z&#x27;</span>) &#123;</span><br><span class="line">                smallCount++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                numberCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出三种类型的字符个数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;大写字母：&quot;</span> + bigCount + <span class="string">&quot;个&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;小写字母：&quot;</span> + smallCount + <span class="string">&quot;个&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;数字：&quot;</span> + numberCount + <span class="string">&quot;个&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-9字符串拼接案例"><a href="#2-9字符串拼接案例" class="headerlink" title="2.9字符串拼接案例"></a>2.9字符串拼接案例</h3><h4 id="2-9-1案例需求"><a href="#2-9-1案例需求" class="headerlink" title="2.9.1案例需求"></a>2.9.1案例需求</h4><p>​定义一个方法，把 int 数组中的数据按照指定的格式拼接成一个字符串返回，调用该方法，</p><p>​并在控制台输出结果。例如，数组为 int[] arr &#x3D; {1,2,3}; ，执行方法后的输出结果为：[1, 2, 3]</p><h4 id="2-9-2代码实现"><a href="#2-9-2代码实现" class="headerlink" title="2.9.2代码实现"></a>2.9.2代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    思路：</span></span><br><span class="line"><span class="comment">        1:定义一个 int 类型的数组，用静态初始化完成数组元素的初始化</span></span><br><span class="line"><span class="comment">        2:定义一个方法，用于把 int 数组中的数据按照指定格式拼接成一个字符串返回。</span></span><br><span class="line"><span class="comment">          返回值类型 String，参数列表 int[] arr</span></span><br><span class="line"><span class="comment">        3:在方法中遍历数组，按照要求进行拼接</span></span><br><span class="line"><span class="comment">        4:调用方法，用一个变量接收结果</span></span><br><span class="line"><span class="comment">        5:输出结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTest04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//定义一个 int 类型的数组，用静态初始化完成数组元素的初始化</span></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用方法，用一个变量接收结果</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> arrayToString(arr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;s:&quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个方法，用于把 int 数组中的数据按照指定格式拼接成一个字符串返回</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        两个明确：</span></span><br><span class="line"><span class="comment">            返回值类型：String</span></span><br><span class="line"><span class="comment">            参数：int[] arr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">arrayToString</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="comment">//在方法中遍历数组，按照要求进行拼接</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        s += <span class="string">&quot;[&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==arr.length-<span class="number">1</span>) &#123;</span><br><span class="line">                s += arr[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                s += arr[i];</span><br><span class="line">                s += <span class="string">&quot;, &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        s += <span class="string">&quot;]&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-10字符串反转案例"><a href="#2-10字符串反转案例" class="headerlink" title="2.10字符串反转案例"></a>2.10字符串反转案例</h3><h4 id="2-10-1案例需求"><a href="#2-10-1案例需求" class="headerlink" title="2.10.1案例需求"></a>2.10.1案例需求</h4><p>​定义一个方法，实现字符串反转。键盘录入一个字符串，调用该方法后，在控制台输出结果</p><p>​例如，键盘录入 abc，输出结果 cba</p><h4 id="2-10-2代码实现"><a href="#2-10-2代码实现" class="headerlink" title="2.10.2代码实现"></a>2.10.2代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    思路：</span></span><br><span class="line"><span class="comment">        1:键盘录入一个字符串，用 Scanner 实现</span></span><br><span class="line"><span class="comment">        2:定义一个方法，实现字符串反转。返回值类型 String，参数 String s</span></span><br><span class="line"><span class="comment">        3:在方法中把字符串倒着遍历，然后把每一个得到的字符拼接成一个字符串并返回</span></span><br><span class="line"><span class="comment">        4:调用方法，用一个变量接收结果</span></span><br><span class="line"><span class="comment">        5:输出结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTest05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//键盘录入一个字符串，用 Scanner 实现</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入一个字符串：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用方法，用一个变量接收结果</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> reverse(line);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;s:&quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个方法，实现字符串反转</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        两个明确：</span></span><br><span class="line"><span class="comment">            返回值类型：String</span></span><br><span class="line"><span class="comment">            参数：String s</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">reverse</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">//在方法中把字符串倒着遍历，然后把每一个得到的字符拼接成一个字符串并返回</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=s.length()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            ss += s.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ss;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-11帮助文档查看String常用方法"><a href="#2-11帮助文档查看String常用方法" class="headerlink" title="2.11帮助文档查看String常用方法"></a>2.11帮助文档查看String常用方法</h3><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public boolean   equals(Object anObject)</td><td>比较字符串的内容，严格区分大小写(用户名和密码)</td></tr><tr><td>public char charAt(int   index)</td><td>返回指定索引处的 char 值</td></tr><tr><td>public int   length()</td><td>返回此字符串的长度</td></tr><tr><td>startsWith</td><td>比较字符串首字符是否一致</td></tr></tbody></table><h2 id="3-ArrayList（集合）"><a href="#3-ArrayList（集合）" class="headerlink" title="3.ArrayList（集合）"></a>3.ArrayList（集合）</h2><h3 id="3-1ArrayList类概述"><a href="#3-1ArrayList类概述" class="headerlink" title="3.1ArrayList类概述"></a>3.1ArrayList类概述</h3><ul><li><p>什么是集合</p><p>​提供一种存储空间可变的存储模型，存储的数据容量可以发生改变</p></li><li><p>ArrayList集合的特点</p><p>​底层是数组实现的，长度可以变化</p></li><li><p>泛型的使用</p><p>​用于约束集合中存储元素的数据类型</p></li></ul><h3 id="3-2ArrayList类常用方法"><a href="#3-2ArrayList类常用方法" class="headerlink" title="3.2ArrayList类常用方法"></a>3.2ArrayList类常用方法</h3><h4 id="3-2-1构造方法"><a href="#3-2-1构造方法" class="headerlink" title="3.2.1构造方法"></a>3.2.1构造方法</h4><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public ArrayList()</td><td>创建一个空的集合对象</td></tr></tbody></table><h4 id="3-2-2成员方法"><a href="#3-2-2成员方法" class="headerlink" title="3.2.2成员方法"></a>3.2.2成员方法</h4><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public boolean   remove(Object o)</td><td>删除指定的元素，返回删除是否成功</td></tr><tr><td>public E   remove(int   index)</td><td>删除指定索引处的元素，返回被删除的元素</td></tr><tr><td>public E   set(int index,E   element)</td><td>修改指定索引处的元素，返回被修改的元素</td></tr><tr><td>public E   get(int   index)</td><td>返回指定索引处的元素</td></tr><tr><td>public int   size()</td><td>返回集合中的元素的个数</td></tr><tr><td>public boolean   add(E e)</td><td>将指定的元素追加到此集合的末尾</td></tr><tr><td>public void   add(int index,E   element)</td><td>在此集合中的指定位置插入指定的元素</td></tr></tbody></table><h4 id="3-2-3泛型概述"><a href="#3-2-3泛型概述" class="headerlink" title="3.2.3泛型概述"></a>3.2.3泛型概述</h4><ul><li><p>ArrayList&lt;引用数据类型&gt;： 其实就是一个泛型类，可以在编译阶段约束集合对象只能操作某种数据类型</p><p>举例：</p></li><li><p>ArrayList<String>:  此集合只能字符串类型的元素</p></li><li><p>ArrayList<Integer>:  此集合只能整形类型的元素</p></li></ul><p><strong>注意:集合中只能存储引用类型，不支持基本数据类型</strong></p><h4 id="3-2-4示例代码"><a href="#3-2-4示例代码" class="headerlink" title="3.2.4示例代码"></a>3.2.4示例代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayListDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建集合</span></span><br><span class="line">        ArrayList&lt;String&gt; array = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        array.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        array.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        array.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//public boolean remove(Object o)：删除指定的元素，返回删除是否成功</span></span><br><span class="line"><span class="comment">//        System.out.println(array.remove(&quot;world&quot;));</span></span><br><span class="line"><span class="comment">//        System.out.println(array.remove(&quot;javaee&quot;));</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//public E remove(int index)：删除指定索引处的元素，返回被删除的元素</span></span><br><span class="line"><span class="comment">//        System.out.println(array.remove(1));</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//IndexOutOfBoundsException</span></span><br><span class="line"><span class="comment">//        System.out.println(array.remove(3));</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//public E set(int index,E element)：修改指定索引处的元素，返回被修改的元素</span></span><br><span class="line"><span class="comment">//        System.out.println(array.set(1,&quot;javaee&quot;));</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//IndexOutOfBoundsException</span></span><br><span class="line"><span class="comment">//        System.out.println(array.set(3,&quot;javaee&quot;));</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//public E get(int index)：返回指定索引处的元素</span></span><br><span class="line"><span class="comment">//        System.out.println(array.get(0));</span></span><br><span class="line"><span class="comment">//        System.out.println(array.get(1));</span></span><br><span class="line"><span class="comment">//        System.out.println(array.get(2));</span></span><br><span class="line">        <span class="comment">//System.out.println(array.get(3)); //？？？？？？ 自己测试</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//public int size()：返回集合中的元素的个数</span></span><br><span class="line">        System.out.println(array.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出集合</span></span><br><span class="line">        System.out.println(<span class="string">&quot;array:&quot;</span> + array);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-3ArrayList存储字符串并遍历"><a href="#3-3ArrayList存储字符串并遍历" class="headerlink" title="3.3ArrayList存储字符串并遍历"></a>3.3ArrayList存储字符串并遍历</h3><h4 id="3-3-1案例需求"><a href="#3-3-1案例需求" class="headerlink" title="3.3.1案例需求"></a>3.3.1案例需求</h4><p>​创建一个存储字符串的集合，存储3个字符串元素，使用程序实现在控制台遍历该集合</p><h4 id="3-3-2代码实现"><a href="#3-3-2代码实现" class="headerlink" title="3.3.2代码实现"></a>3.3.2代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    思路：</span></span><br><span class="line"><span class="comment">   1:创建集合对象</span></span><br><span class="line"><span class="comment">   2:往集合中添加字符串对象</span></span><br><span class="line"><span class="comment">   3:遍历集合（遍历集合的通用格式）</span></span><br><span class="line"><span class="comment">     首先通过get(int index)方法获取到集合中的每一个元素</span></span><br><span class="line"><span class="comment">     其次通过size()方法要能够获取到集合的长度</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayListTest01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//创建集合对象</span></span><br><span class="line">        ArrayList&lt;String&gt; array =</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//往集合中添加字符串对象</span></span><br><span class="line">        array.add(<span class="string">&quot;刘正风&quot;</span>);</span><br><span class="line">        array.add(<span class="string">&quot;左冷禅&quot;</span>);</span><br><span class="line">        array.add(<span class="string">&quot;风清扬&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历集合的通用格式</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;array.size(); i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> array.get(i);</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4ArrayList存储学生对象并遍历"><a href="#3-4ArrayList存储学生对象并遍历" class="headerlink" title="3.4ArrayList存储学生对象并遍历"></a>3.4ArrayList存储学生对象并遍历</h3><h4 id="3-4-1案例需求"><a href="#3-4-1案例需求" class="headerlink" title="3.4.1案例需求"></a>3.4.1案例需求</h4><p>​创建一个存储学生对象的集合，存储3个学生对象，使用程序实现在控制台遍历该集合</p><h4 id="3-4-2代码实现"><a href="#3-4-2代码实现" class="headerlink" title="3.4.2代码实现"></a>3.4.2代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    思路：</span></span><br><span class="line"><span class="comment">        1:定义学生类</span></span><br><span class="line"><span class="comment">        2:创建集合对象</span></span><br><span class="line"><span class="comment">        3:创建学生对象</span></span><br><span class="line"><span class="comment">        4:添加学生对象到集合中</span></span><br><span class="line"><span class="comment">        5:遍历集合，采用通用遍历格式实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayListTest02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建集合对象</span></span><br><span class="line">        ArrayList&lt;Student&gt; array = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建学生对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;林青霞&quot;</span>, <span class="number">30</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;风清扬&quot;</span>, <span class="number">33</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张曼玉&quot;</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加学生对象到集合中</span></span><br><span class="line">        array.add(s1);</span><br><span class="line">        array.add(s2);</span><br><span class="line">        array.add(s3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历集合，采用通用遍历格式实现</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.size(); i++) &#123;</span><br><span class="line">            <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> array.get(i);</span><br><span class="line">            System.out.println(s.getName() + <span class="string">&quot;,&quot;</span> + s.getAge());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5ArrayList存储学生对象并遍历升级版"><a href="#3-5ArrayList存储学生对象并遍历升级版" class="headerlink" title="3.5ArrayList存储学生对象并遍历升级版"></a>3.5ArrayList存储学生对象并遍历升级版</h3><h4 id="3-5-1案例需求"><a href="#3-5-1案例需求" class="headerlink" title="3.5.1案例需求"></a>3.5.1案例需求</h4><p>​创建一个存储学生对象的集合，存储3个学生对象，使用程序实现在控制台遍历该集合</p><p>​        学生的姓名和年龄来自于键盘录入</p><h4 id="3-5-2代码实现"><a href="#3-5-2代码实现" class="headerlink" title="3.5.2代码实现"></a>3.5.2代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    思路：</span></span><br><span class="line"><span class="comment">        1:定义学生类，为了键盘录入数据方便，把学生类中的成员变量都定义为String类型</span></span><br><span class="line"><span class="comment">        2:创建集合对象</span></span><br><span class="line"><span class="comment">        3:键盘录入学生对象所需要的数据</span></span><br><span class="line"><span class="comment">        4:创建学生对象，把键盘录入的数据赋值给学生对象的成员变量</span></span><br><span class="line"><span class="comment">        5:往集合中添加学生对象</span></span><br><span class="line"><span class="comment">        6:遍历集合，采用通用遍历格式实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayListTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建集合对象</span></span><br><span class="line">        ArrayList&lt;Student&gt; array = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Student&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//为了提高代码的复用性，我们用方法来改进程序</span></span><br><span class="line">        addStudent(array);</span><br><span class="line">        addStudent(array);</span><br><span class="line">        addStudent(array);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历集合，采用通用遍历格式实现</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.size(); i++) &#123;</span><br><span class="line">            <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> array.get(i);</span><br><span class="line">            System.out.println(s.getName() + <span class="string">&quot;,&quot;</span> + s.getAge());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        两个明确：</span></span><br><span class="line"><span class="comment">            返回值类型：void</span></span><br><span class="line"><span class="comment">            参数：ArrayList&lt;Student&gt; array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addStudent</span><span class="params">(ArrayList&lt;Student&gt; array)</span> &#123;</span><br><span class="line">        <span class="comment">//键盘录入学生对象所需要的数据</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入学生姓名:&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入学生年龄:&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">age</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建学生对象，把键盘录入的数据赋值给学生对象的成员变量</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        s.setName(name);</span><br><span class="line">        s.setAge(age);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//往集合中添加学生对象</span></span><br><span class="line">        array.add(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> java,基础语法,API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>day07 - 面对对象</title>
      <link href="/post/ca2e86a8.html"/>
      <url>/post/ca2e86a8.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-类和对象"><a href="#1-类和对象" class="headerlink" title="1. 类和对象"></a>1. 类和对象</h2><h3 id="1-1-类和对象的理解"><a href="#1-1-类和对象的理解" class="headerlink" title="1.1 类和对象的理解"></a>1.1 类和对象的理解</h3><p>客观存在的事物皆为对象 ，所以我们也常常说万物皆对象。</p><ul><li>类<ul><li>类的理解<ul><li>类是对现实生活中一类具有共同属性和行为的事物的抽象</li><li>类是对象的数据类型，类是具有相同属性和行为的一组对象的集合</li><li>简单理解：类就是对现实事物的一种描述</li></ul></li><li>类的组成<ul><li>属性：指事物的特征，例如：手机事物（品牌，价格，尺寸）</li><li>行为：指事物能执行的操作，例如：手机事物（打电话，发短信）</li></ul></li></ul></li><li>类和对象的关系<ul><li>类：类是对现实生活中一类具有共同属性和行为的事物的抽象</li><li>对象：是能够看得到摸的着的真实存在的实体</li><li>简单理解：<strong>类是对事物的一种描述，对象则为具体存在的事物</strong></li></ul></li></ul><h3 id="1-2-类的定义"><a href="#1-2-类的定义" class="headerlink" title="1.2 类的定义"></a>1.2 类的定义</h3><p>类的组成是由属性和行为两部分组成</p><ul><li>属性：在类中通过成员变量来体现（类中方法外的变量）</li><li>行为：在类中通过成员方法来体现（和前面的方法相比去掉static关键字即可）</li></ul><p>类的定义步骤：</p><p>①定义类</p><p>②编写类的成员变量</p><p>③编写类的成员方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名 &#123;</span><br><span class="line"><span class="comment">// 成员变量</span></span><br><span class="line">变量<span class="number">1</span>的数据类型 变量<span class="number">1</span>；</span><br><span class="line">变量<span class="number">2</span>的数据类型 变量<span class="number">2</span>;</span><br><span class="line">…</span><br><span class="line"><span class="comment">// 成员方法</span></span><br><span class="line">方法<span class="number">1</span>;</span><br><span class="line">方法<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    手机类：</span></span><br><span class="line"><span class="comment">        类名：</span></span><br><span class="line"><span class="comment">        手机(Phone)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        成员变量：</span></span><br><span class="line"><span class="comment">        品牌(brand)</span></span><br><span class="line"><span class="comment">        价格(price)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        成员方法：</span></span><br><span class="line"><span class="comment">        打电话(call)</span></span><br><span class="line"><span class="comment">        发短信(sendMessage)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="comment">//成员变量</span></span><br><span class="line">    String brand;</span><br><span class="line">    <span class="type">int</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//成员方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打电话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发短信&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1-3-对象的使用"><a href="#1-3-对象的使用" class="headerlink" title="1.3 对象的使用"></a>1.3 对象的使用</h3><ul><li>创建对象的格式：<ul><li>类名 对象名 &#x3D; new 类名();</li></ul></li><li>调用成员的格式：<ul><li>对象名.成员变量</li><li>对象名.成员方法();</li></ul></li><li>示例代码</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    创建对象</span></span><br><span class="line"><span class="comment">        格式：类名 对象名 = new 类名();</span></span><br><span class="line"><span class="comment">        范例：Phone p = new Phone();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    使用对象</span></span><br><span class="line"><span class="comment">        1：使用成员变量</span></span><br><span class="line"><span class="comment">            格式：对象名.变量名</span></span><br><span class="line"><span class="comment">            范例：p.brand</span></span><br><span class="line"><span class="comment">        2：使用成员方法</span></span><br><span class="line"><span class="comment">            格式：对象名.方法名()</span></span><br><span class="line"><span class="comment">            范例：p.call()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhoneDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        <span class="type">Phone</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用成员变量</span></span><br><span class="line">        System.out.println(p.brand);</span><br><span class="line">        System.out.println(p.price);</span><br><span class="line"></span><br><span class="line">        p.brand = <span class="string">&quot;小米&quot;</span>;</span><br><span class="line">        p.price = <span class="number">2999</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(p.brand);</span><br><span class="line">        System.out.println(p.price);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用成员方法</span></span><br><span class="line">        p.call();</span><br><span class="line">        p.sendMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-学生对象-练习"><a href="#1-4-学生对象-练习" class="headerlink" title="1.4 学生对象-练习"></a>1.4 学生对象-练习</h3><ul><li>需求：首先定义一个学生类，然后定义一个学生测试类，在学生测试类中通过对象完成成员变量和成员方法的使用</li><li>分析：<ul><li>成员变量：姓名，年龄…</li><li>成员方法：学习，做作业…</li></ul></li><li>示例代码：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">![<span class="number">1</span>](C:\TeachRes\Java2019\JavaSe01\day07\<span class="number">4</span>-笔记\笔记图片资源包\<span class="number">1.</span>png)<span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="comment">//成员变量</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//成员方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;好好学习，天天向上&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doHomework</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;键盘敲烂，月薪过万&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    学生测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用对象</span></span><br><span class="line">        System.out.println(s.name + <span class="string">&quot;,&quot;</span> + s.age);</span><br><span class="line"></span><br><span class="line">        s.name = <span class="string">&quot;林青霞&quot;</span>;</span><br><span class="line">        s.age = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(s.name + <span class="string">&quot;,&quot;</span> + s.age);</span><br><span class="line"></span><br><span class="line">        s.study();</span><br><span class="line">        s.doHomework();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-对象内存图"><a href="#2-对象内存图" class="headerlink" title="2. 对象内存图"></a>2. 对象内存图</h2><h3 id="2-1-单个对象内存图"><a href="#2-1-单个对象内存图" class="headerlink" title="2.1 单个对象内存图"></a>2.1 单个对象内存图</h3><ul><li>成员变量使用过程</li></ul><p><img src="/images%5C1.png" alt="1"></p><ul><li>成员方法调用过程</li></ul><p><img src="/images%5C2.png" alt="2"></p><h3 id="2-2-多个对象内存图"><a href="#2-2-多个对象内存图" class="headerlink" title="2.2 多个对象内存图"></a>2.2 多个对象内存图</h3><ul><li>成员变量使用过程</li></ul><p><img src="/images%5C3.png" alt="3"></p><ul><li>成员方法调用过程</li></ul><p><img src="/images%5C4.png" alt="4"></p><ul><li><p>总结：</p><p>多个对象在堆内存中，都有不同的内存划分，成员变量存储在各自的内存区域中，成员方法多个对象共用的一份</p></li></ul><h3 id="2-3-多个对象指向相同内存图"><a href="#2-3-多个对象指向相同内存图" class="headerlink" title="2.3 多个对象指向相同内存图"></a>2.3 多个对象指向相同内存图</h3><p><img src="/images%5C4.bmp" alt="4"></p><ul><li><p>总结</p><p>当多个对象的引用指向同一个内存空间（变量所记录的地址值是一样的）</p><p>只要有任何一个对象修改了内存中的数据，随后，无论使用哪一个对象进行数据获取，都是修改后的数据。</p></li></ul><h2 id="3-成员变量和局部变量"><a href="#3-成员变量和局部变量" class="headerlink" title="3. 成员变量和局部变量"></a>3. 成员变量和局部变量</h2><h3 id="3-1-成员变量和局部变量的区别"><a href="#3-1-成员变量和局部变量的区别" class="headerlink" title="3.1 成员变量和局部变量的区别"></a>3.1 成员变量和局部变量的区别</h3><ul><li>类中位置不同：成员变量（类中方法外）局部变量（方法内部或方法声明上）</li><li>内存中位置不同：成员变量（堆内存）局部变量（栈内存）</li><li>生命周期不同：成员变量（随着对象的存在而存在，随着对象的消失而消失）局部变量（随着方法的调用而存在，醉着方法的调用完毕而消失）</li><li>初始化值不同：成员变量（有默认初始化值）局部变量（没有默认初始化值，必须先定义，赋值才能使用）</li></ul><h2 id="4-封装"><a href="#4-封装" class="headerlink" title="4. 封装"></a>4. 封装</h2><h3 id="4-1-private关键字"><a href="#4-1-private关键字" class="headerlink" title="4.1 private关键字"></a>4.1 private关键字</h3><p>private是一个修饰符，可以用来修饰成员（成员变量，成员方法）</p><ul><li><p>被private修饰的成员，只能在本类进行访问，针对private修饰的成员变量，如果需要被其他类使用，提供相应的操作</p><ul><li>提供“get变量名()”方法，用于获取成员变量的值，方法用public修饰</li><li>提供“set变量名(参数)”方法，用于设置成员变量的值，方法用public修饰</li></ul></li><li><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    学生类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="comment">//成员变量</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供get/set方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(a&lt;<span class="number">0</span> || a&gt;<span class="number">120</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;你给的年龄有误&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            age = a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//成员方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;,&quot;</span> + age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    学生测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        <span class="comment">//给成员变量赋值</span></span><br><span class="line">        s.name = <span class="string">&quot;林青霞&quot;</span>;</span><br><span class="line">        s.setAge(<span class="number">30</span>);</span><br><span class="line">        <span class="comment">//调用show方法</span></span><br><span class="line">        s.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-2-private的使用"><a href="#4-2-private的使用" class="headerlink" title="4.2 private的使用"></a>4.2 private的使用</h3><ul><li><p>需求：定义标准的学生类，要求name和age使用private修饰，并提供set和get方法以及便于显示数据的show方法，测试类中创建对象并使用，最终控制台输出  林青霞，30 </p></li><li><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    学生类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="comment">//成员变量</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get/set方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String n)</span> &#123;</span><br><span class="line">        name = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">        age = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;,&quot;</span> + age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    学生测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用set方法给成员变量赋值</span></span><br><span class="line">        s.setName(<span class="string">&quot;林青霞&quot;</span>);</span><br><span class="line">        s.setAge(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">        s.show();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用get方法获取成员变量的值</span></span><br><span class="line">        System.out.println(s.getName() + <span class="string">&quot;---&quot;</span> + s.getAge());</span><br><span class="line">        System.out.println(s.getName() + <span class="string">&quot;,&quot;</span> + s.getAge());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-3-this关键字"><a href="#4-3-this关键字" class="headerlink" title="4.3 this关键字"></a>4.3 this关键字</h3><ul><li>this修饰的变量用于指代成员变量，其主要作用是（区分局部变量和成员变量的重名问题）<ul><li>方法的形参如果与成员变量同名，不带this修饰的变量指的是形参，带this修饰的变量是成员变量</li><li>方法的形参没有与成员变量同名，不带this修饰的变量指的是成员变量</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;,&quot;</span> + age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-this内存原理"><a href="#4-4-this内存原理" class="headerlink" title="4.4 this内存原理"></a>4.4 this内存原理</h3><ul><li><p>this代表当前调用方法的引用，哪个对象（类）调用的方法，this就代表哪一个对象（类）</p></li><li><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        s1.setName(<span class="string">&quot;林青霞&quot;</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        s2.setName(<span class="string">&quot;张曼玉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>图解：</p><p><img src="/images%5C5.png" alt="5"></p><p><img src="/images%5C6.png" alt="6"></p></li></ul><h3 id="4-5-封装思想"><a href="#4-5-封装思想" class="headerlink" title="4.5 封装思想"></a>4.5 封装思想</h3><ol><li>封装概述<br> 是面向对象三大特征之一（封装，继承，多态）<br> 是面向对象编程语言对客观世界的模拟，客观世界里成员变量都是隐藏在对象内部的，外界是无法直接操作的</li><li>封装原则<br> 将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问<br> 成员变量private，提供对应的getXxx()&#x2F;setXxx()方法</li><li>封装好处<br> 通过方法来控制成员变量的操作，提高了代码的安全性<br> 把代码用方法进行封装，提高了代码的复用性</li></ol><h2 id="5-标准JavaBean"><a href="#5-标准JavaBean" class="headerlink" title="5.标准JavaBean"></a>5.标准JavaBean</h2><h3 id="5-1标准JavaBean概述"><a href="#5-1标准JavaBean概述" class="headerlink" title="5.1标准JavaBean概述"></a>5.1标准JavaBean概述</h3><p>​      可以理解为实体类，其对象可以用于在程序中封装数据（例如学生类，汽车类）</p><h3 id="5-2标准JavaBean风格"><a href="#5-2标准JavaBean风格" class="headerlink" title="5.2标准JavaBean风格"></a>5.2标准JavaBean风格</h3><p>  标准JavaBean须满足如下条件要求：</p><p>​<br>​      * 成员变量使用private修饰<br>​<br>​      * 提供每一个成员变量对应提供成套的setXxx()  getXxx()<br>​<br>​      * 必须提供一个无参构造器</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">创建过程</span><br><span class="line"><span class="keyword">package</span> javabean;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.成员变量私有</span></span><br><span class="line"> <span class="keyword">public</span> String  name;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//2.必须提供成套的getter和setter方法暴露成员变量的取值和赋值</span></span><br><span class="line"><span class="comment">//（快捷操作方法：右键 Generate,Gerrer and Setter,shift全选）</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.必须提供一个无参构造器（使用默认的）</span></span><br><span class="line">    <span class="comment">//或手写</span></span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建方法</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意：存在有参构造器时无参构造器消失，此时需要使用无参构造器时需要手动构造"><a href="#注意：存在有参构造器时无参构造器消失，此时需要使用无参构造器时需要手动构造" class="headerlink" title="注意：存在有参构造器时无参构造器消失，此时需要使用无参构造器时需要手动构造"></a><strong>注意：存在有参构造器时无参构造器消失，此时需要使用无参构造器时需要手动构造</strong></h4><h2 id="6-构造方法"><a href="#6-构造方法" class="headerlink" title="6. 构造方法"></a>6. 构造方法</h2><h3 id="6-1-构造方法概述"><a href="#6-1-构造方法概述" class="headerlink" title="6.1 构造方法概述"></a>6.1 构造方法概述</h3><p>构造方法是一种特殊的方法</p><ul><li><p>作用：创建对象   Student stu &#x3D; <strong>new Student();</strong></p></li><li><p>格式：</p><p>public class 类名{</p><p>​        修饰符 类名( 参数 ) {</p><p>​        }</p><p>}</p></li><li><p>功能：主要是完成对象数据的初始化</p></li><li><p>示例代码：</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;无参构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;,&quot;</span> + age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        s.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-构造方法的注意事项"><a href="#6-2-构造方法的注意事项" class="headerlink" title="6.2 构造方法的注意事项"></a>6.2 构造方法的注意事项</h3><ul><li>构造方法的创建</li></ul><p>如果没有定义构造方法，系统将给出一个默认的无参数构造方法<br>如果定义了构造方法，系统将不再提供默认的构造方法</p><ul><li>构造方法的重载</li></ul><p>如果自定义了带参构造方法，还要使用无参数构造方法，就必须再写一个无参数构造方法</p><ul><li>推荐的使用方式</li></ul><p>无论是否使用，都手工书写无参数构造方法</p><ul><li>重要功能！</li></ul><p>可以使用带参构造，为成员变量进行初始化</p><ul><li>示例代码</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    学生类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name,<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;,&quot;</span> + age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        s1.show();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//public Student(String name)</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;林青霞&quot;</span>);</span><br><span class="line">        s2.show();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//public Student(int age)</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">30</span>);</span><br><span class="line">        s3.show();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//public Student(String name,int age)</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;林青霞&quot;</span>,<span class="number">30</span>);</span><br><span class="line">        s4.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-3-标准类制作"><a href="#6-3-标准类制作" class="headerlink" title="6.3 标准类制作"></a>6.3 标准类制作</h3><ul><li>需求：定义标准学生类，要求分别使用空参和有参构造方法创建对象，空参创建的对象通过setXxx赋值，有参创建的对象直接赋值，并通过show方法展示数据。 </li><li>示例代码：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="comment">//成员变量</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//成员方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;,&quot;</span> + age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    创建对象并为其成员变量赋值的两种方式</span></span><br><span class="line"><span class="comment">        1:无参构造方法创建对象后使用setXxx()赋值</span></span><br><span class="line"><span class="comment">        2:使用带参构造方法直接创建带有属性值的对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//无参构造方法创建对象后使用setXxx()赋值</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        s1.setName(<span class="string">&quot;林青霞&quot;</span>);</span><br><span class="line">        s1.setAge(<span class="number">30</span>);</span><br><span class="line">        s1.show();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用带参构造方法直接创建带有属性值的对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;林青霞&quot;</span>,<span class="number">30</span>);</span><br><span class="line">        s2.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> java,基础语法,对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>day06 - Debug</title>
      <link href="/post/cad517f3.html"/>
      <url>/post/cad517f3.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-Debug模式"><a href="#1-Debug模式" class="headerlink" title="1.Debug模式"></a>1.Debug模式</h2><h3 id="1-1什么是Debug模式"><a href="#1-1什么是Debug模式" class="headerlink" title="1.1什么是Debug模式"></a>1.1什么是Debug模式</h3><p>是供程序员使用的程序调试工具，它可以用于查看程序的执行流程，也可以用于追踪程序执行过程来调试程序。</p><h2 id="2-基础练习（参考题目）"><a href="#2-基础练习（参考题目）" class="headerlink" title="2.基础练习（参考题目）"></a>2.基础练习（参考题目）</h2><h3 id="2-1减肥计划if版本"><a href="#2-1减肥计划if版本" class="headerlink" title="2.1减肥计划if版本"></a>2.1减肥计划if版本</h3><h4 id="2-1-1案例需求"><a href="#2-1-1案例需求" class="headerlink" title="2.1.1案例需求"></a>2.1.1案例需求</h4><p>​输入星期数，显示今天的减肥活动<br>​          周一：跑步<br>​          周二：游泳<br>​          周三：慢走<br>​          周四：动感单车<br>​          周五：拳击<br>​          周六：爬山<br>​          周日：好好吃一顿</p><h4 id="2-1-2代码实现"><a href="#2-1-2代码实现" class="headerlink" title="2.1.2代码实现"></a>2.1.2代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    思路：</span></span><br><span class="line"><span class="comment">        1:键盘录入一个星期数，用一个变量接收</span></span><br><span class="line"><span class="comment">        2:对星期数进行判断，这里用 if 语句实现</span></span><br><span class="line"><span class="comment">        3:在对应的语句控制中输出对应的减肥活动</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//键盘录入一个星期数，用一个变量接收</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入一个星期数：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">week</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对星期数进行判断，这里用 if 语句实现</span></span><br><span class="line">        <span class="keyword">if</span> (week &lt; <span class="number">1</span> || week &gt; <span class="number">7</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;你输入的星期数有误&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (week == <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;跑步&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (week == <span class="number">2</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;游泳&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (week == <span class="number">3</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;慢走&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (week == <span class="number">4</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;动感单车&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (week == <span class="number">5</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;拳击&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (week == <span class="number">6</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;爬山&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;好好吃一顿&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2减肥计划switch版本"><a href="#2-2减肥计划switch版本" class="headerlink" title="2.2减肥计划switch版本"></a>2.2减肥计划switch版本</h3><h4 id="2-2-1案例需求"><a href="#2-2-1案例需求" class="headerlink" title="2.2.1案例需求"></a>2.2.1案例需求</h4><p>​输入星期数，显示今天的减肥活动<br>​          周一：跑步<br>​          周二：游泳<br>​          周三：慢走<br>​          周四：动感单车<br>​          周五：拳击<br>​          周六：爬山<br>​          周日：好好吃一顿</p><h4 id="2-2-2代码实现"><a href="#2-2-2代码实现" class="headerlink" title="2.2.2代码实现"></a>2.2.2代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    思路：</span></span><br><span class="line"><span class="comment">        1:键盘录入一个星期数，用一个变量接收</span></span><br><span class="line"><span class="comment">        2:对星期数进行判断，这里用 switch 语句实现</span></span><br><span class="line"><span class="comment">        3:在对应的语句控制中输出对应的减肥活动</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    导包：</span></span><br><span class="line"><span class="comment">        1:手动导包  import java.util.Scanner;</span></span><br><span class="line"><span class="comment">        2:快捷键导包 Alt+Enter</span></span><br><span class="line"><span class="comment">        3:自动导包</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//键盘录入一个星期数，用一个变量接收</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入一个星期数：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">week</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对星期数进行判断，这里用 switch 语句实现</span></span><br><span class="line">        <span class="keyword">switch</span> (week) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;跑步&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;游泳&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;慢走&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;动感单车&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;拳击&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;爬山&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;好好吃一顿&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;你输入的星期数有误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3逢七跳过"><a href="#2-3逢七跳过" class="headerlink" title="2.3逢七跳过"></a>2.3逢七跳过</h3><h4 id="2-3-1案例需求"><a href="#2-3-1案例需求" class="headerlink" title="2.3.1案例需求"></a>2.3.1案例需求</h4><p>​朋友聚会的时候可能会玩一个游戏：逢七过。<br>​        规则是：从任意一个数字开始报数，当你要报的数字包含7或者是7的倍数时都要说：过。<br>​        为了帮助大家更好的玩这个游戏，这里我们直接在控制台打印出1-100之间的满足逢七必过规则的数据。<br>​        这样，大家将来在玩游戏的时候，就知道哪些数据要说：过。</p><h4 id="2-3-2代码实现"><a href="#2-3-2代码实现" class="headerlink" title="2.3.2代码实现"></a>2.3.2代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    思路：</span></span><br><span class="line"><span class="comment">        1:数据在1-100之间，用for循环实现数据的获取</span></span><br><span class="line"><span class="comment">        2:根据规则，用if语句实现数据的判断：要么个位是7，要么十位是7，要么能够被7整除</span></span><br><span class="line"><span class="comment">        3:在控制台输出满足规则的数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//数据在1-100之间，用for循环实现数据的获取</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">1</span>; x&lt;=<span class="number">100</span>; x++) &#123;</span><br><span class="line">            <span class="comment">//根据规则，用if语句实现数据的判断：要么个位是7，要么十位是7，要么能够被7整除</span></span><br><span class="line">            <span class="keyword">if</span>(x%<span class="number">10</span>==<span class="number">7</span> || x/<span class="number">10</span>%<span class="number">10</span>==<span class="number">7</span> || x%<span class="number">7</span>==<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//在控制台输出满足规则的数据</span></span><br><span class="line">                System.out.println(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4不死神兔"><a href="#2-4不死神兔" class="headerlink" title="2.4不死神兔"></a>2.4不死神兔</h3><h4 id="2-4-1案例需求"><a href="#2-4-1案例需求" class="headerlink" title="2.4.1案例需求"></a>2.4.1案例需求</h4><p>​有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第三个月后每个月又生一对兔子，<br>​        假如兔子都不死，问第二十个月的兔子对数为多少？</p><h4 id="2-4-2代码实现"><a href="#2-4-2代码实现" class="headerlink" title="2.4.2代码实现"></a>2.4.2代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   思路：</span></span><br><span class="line"><span class="comment">        1:为了存储多个月的兔子对数，定义一个数组，用动态初始化完成数组元素的初始化，长度为20</span></span><br><span class="line"><span class="comment">        2:因为第1个月，第2个月兔子的对数是已知的，都是1，所以数组的第1个元素，第2个元素值也都是1</span></span><br><span class="line"><span class="comment">        3:用循环实现计算每个月的兔子对数</span></span><br><span class="line"><span class="comment">        4:输出数组中最后一个元素的值，就是第20个月的兔子对数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//为了存储多个月的兔子对数，定义一个数组，用动态初始化完成数组元素的初始化，长度为20</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//因为第1个月，第2个月兔子的对数是已知的，都是1，所以数组的第1个元素，第2个元素值也都是1</span></span><br><span class="line">        arr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        arr[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用循环实现计算每个月的兔子对数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">2</span>; x&lt;arr.length; x++) &#123;</span><br><span class="line">            arr[x] = arr[x-<span class="number">2</span>] + arr[x-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出数组中最后一个元素的值，就是第20个月的兔子对数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;第二十个月兔子的对数是：&quot;</span> + arr[<span class="number">19</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5百钱白鸡"><a href="#2-5百钱白鸡" class="headerlink" title="2.5百钱白鸡"></a>2.5百钱白鸡</h3><h4 id="2-5-1案例需求"><a href="#2-5-1案例需求" class="headerlink" title="2.5.1案例需求"></a>2.5.1案例需求</h4><p>​我国古代数学家张丘建在《算经》一书中提出的数学问题：鸡翁一值钱五，鸡母一值钱三，鸡雏三值钱一。<br>​        百钱买百鸡，问鸡翁、鸡母、鸡雏各几何？</p><h4 id="2-5-2代码实现"><a href="#2-5-2代码实现" class="headerlink" title="2.5.2代码实现"></a>2.5.2代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    思路：</span></span><br><span class="line"><span class="comment">        1:第1层循环，用于表示鸡翁的范围，初始化表达式的变量定义为 x=0，判断条件是x&lt;=20</span></span><br><span class="line"><span class="comment">        2:第2层循环，用于表示鸡母的范围，初始化表达式的变量定义为 y=0，判断条件是y&lt;=33</span></span><br><span class="line"><span class="comment">        3:这个时候，用于表示鸡雏的变量 z = 100 – x – y</span></span><br><span class="line"><span class="comment">        4:判断表达式 z%3==0 和表达式 5*x + 3*y + z/3 = 100 是否同时成立，如果成立，输出对应的 x，y，z 的值，就是对应的鸡翁，鸡母，鸡雏的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//第1层循环，用于表示鸡翁的范围，初始化表达式的变量定义为 x=0，判断条件是x&lt;=20</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>; x&lt;=<span class="number">20</span>; x++) &#123;</span><br><span class="line">            <span class="comment">//第2层循环，用于表示鸡母的范围，初始化表达式的变量定义为 y=0，判断条件是y&lt;=33</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> y=<span class="number">0</span>; y&lt;=<span class="number">33</span>; y++) &#123;</span><br><span class="line">                <span class="comment">//这个时候，用于表示鸡雏的变量 z = 100 – x – y</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">z</span> <span class="operator">=</span> <span class="number">100</span> - x - y;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//判断表达式 z%3==0 和表达式 5*x + 3*y + z/3 = 100 是否同时成立</span></span><br><span class="line">                <span class="keyword">if</span>(z%<span class="number">3</span>==<span class="number">0</span> &amp;&amp; <span class="number">5</span>*x+<span class="number">3</span>*y+z/<span class="number">3</span>==<span class="number">100</span>) &#123;</span><br><span class="line">                    System.out.println(x+<span class="string">&quot;,&quot;</span>+y+<span class="string">&quot;,&quot;</span>+z);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6数组元素求和"><a href="#2-6数组元素求和" class="headerlink" title="2.6数组元素求和"></a>2.6数组元素求和</h3><h4 id="2-6-1案例需求"><a href="#2-6-1案例需求" class="headerlink" title="2.6.1案例需求"></a>2.6.1案例需求</h4><p>​有这样的一个数组，元素是{68,27,95,88,171,996,51,210}。求出该数组中满足要求的元素和，<br>​        要求是：求和的元素个位和十位都不能是7，并且只能是偶数</p><h4 id="2-6-2代码实现"><a href="#2-6-2代码实现" class="headerlink" title="2.6.2代码实现"></a>2.6.2代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   思路：</span></span><br><span class="line"><span class="comment">        1:定义一个数组，用静态初始化完成数组元素的初始化</span></span><br><span class="line"><span class="comment">        2:定义一个求和变量，初始值是0</span></span><br><span class="line"><span class="comment">        3:遍历数组，获取到数组中的每一个元素</span></span><br><span class="line"><span class="comment">        4:判断该元素是否满足条件，如果满足条件就累加</span></span><br><span class="line"><span class="comment">        5:输出求和变量的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test06</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//定义一个数组，用静态初始化完成数组元素的初始化</span></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">68</span>, <span class="number">27</span>, <span class="number">95</span>, <span class="number">88</span>, <span class="number">171</span>, <span class="number">996</span>, <span class="number">51</span>, <span class="number">210</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义一个求和变量，初始值是0</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历数组，获取到数组中的每一个元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>; x&lt;arr.length; x++) &#123;</span><br><span class="line">            <span class="comment">//判断该元素是否满足条件，如果满足条件就累加</span></span><br><span class="line">            <span class="keyword">if</span>(arr[x]%<span class="number">10</span>!=<span class="number">7</span> &amp;&amp; arr[x]/<span class="number">10</span>%<span class="number">10</span>!=<span class="number">7</span> &amp;&amp; arr[x]%<span class="number">2</span>==<span class="number">0</span>) &#123;</span><br><span class="line">                sum += arr[x];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出求和变量的值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;sum:&quot;</span> + sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-7判断两个数组是否相同"><a href="#2-7判断两个数组是否相同" class="headerlink" title="2.7判断两个数组是否相同"></a>2.7判断两个数组是否相同</h3><h4 id="2-7-1案例需求"><a href="#2-7-1案例需求" class="headerlink" title="2.7.1案例需求"></a>2.7.1案例需求</h4><p>​定义一个方法，用于比较两个数组的内容是否相同</p><h4 id="2-7-2代码实现"><a href="#2-7-2代码实现" class="headerlink" title="2.7.2代码实现"></a>2.7.2代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    思路：</span></span><br><span class="line"><span class="comment">        1:定义两个数组，分别使用静态初始化完成数组元素的初始化</span></span><br><span class="line"><span class="comment">        2:定义一个方法，用于比较两个数组的内容是否相同</span></span><br><span class="line"><span class="comment">        3:比较两个数组的内容是否相同，按照下面的步骤实现就可以了</span></span><br><span class="line"><span class="comment">            首先比较数组长度，如果长度不相同，数组内容肯定不相同，返回false</span></span><br><span class="line"><span class="comment">            其次遍历，比较两个数组中的每一个元素，只要有元素不相同，返回false</span></span><br><span class="line"><span class="comment">            最后循环遍历结束后，返回true</span></span><br><span class="line"><span class="comment">        4:调用方法，用变量接收</span></span><br><span class="line"><span class="comment">        5:输出结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test07</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//定义两个数组，分别使用静态初始化完成数组元素的初始化</span></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>&#125;;</span><br><span class="line">        <span class="comment">//int[] arr2 = &#123;11, 22, 33, 44, 55&#125;;</span></span><br><span class="line">        <span class="type">int</span>[] arr2 = &#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用方法，用变量接收</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> compare(arr,arr2);</span><br><span class="line">        <span class="comment">//输出结果</span></span><br><span class="line">        System.out.println(flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个方法，用于比较两个数组的内容是否相同</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        两个明确：</span></span><br><span class="line"><span class="comment">            返回值类型：boolean</span></span><br><span class="line"><span class="comment">            参数：int[] arr, int[] arr2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span>[] arr2)</span> &#123;</span><br><span class="line">        <span class="comment">//首先比较数组长度，如果长度不相同，数组内容肯定不相同，返回false</span></span><br><span class="line">        <span class="keyword">if</span>(arr.length != arr2.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//其次遍历，比较两个数组中的每一个元素，只要有元素不相同，返回false</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>; x&lt;arr.length; x++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[x] != arr2[x]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最后循环遍历结束后，返回true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-8查找元素在数组中出现的索引位置"><a href="#2-8查找元素在数组中出现的索引位置" class="headerlink" title="2.8查找元素在数组中出现的索引位置"></a>2.8查找元素在数组中出现的索引位置</h3><h4 id="2-8-1案例需求"><a href="#2-8-1案例需求" class="headerlink" title="2.8.1案例需求"></a>2.8.1案例需求</h4><p>​已知一个数组 arr &#x3D; {19, 28, 37, 46, 50}; 键盘录入一个数据，查找该数据在数组中的索引。</p><p>​并在控制台输出找到的索引值。如果没有查找到，则输出-1</p><h4 id="2-8-2代码实现"><a href="#2-8-2代码实现" class="headerlink" title="2.8.2代码实现"></a>2.8.2代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    思路：</span></span><br><span class="line"><span class="comment">        1:定义一个数组，用静态初始化完成数组元素的初始化</span></span><br><span class="line"><span class="comment">        2:键盘录入要查找的数据，用一个变量接收</span></span><br><span class="line"><span class="comment">        3:定义一个索引变量，初始值为-1</span></span><br><span class="line"><span class="comment">        4:遍历数组，获取到数组中的每一个元素</span></span><br><span class="line"><span class="comment">        5:拿键盘录入的数据和数组中的每一个元素进行比较，如果值相同，就把该值对应的索引赋值给索引变量,并结束循环</span></span><br><span class="line"><span class="comment">        6:输出索引变量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test08</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//定义一个数组，用静态初始化完成数组元素的初始化</span></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">19</span>, <span class="number">28</span>, <span class="number">37</span>, <span class="number">46</span>, <span class="number">50</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//键盘录入要查找的数据，用一个变量接收</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入要查找的数据：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用方法</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> getIndex(arr, number);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出索引变量</span></span><br><span class="line">        System.out.println(<span class="string">&quot;index: &quot;</span> + index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找指定的数据在数组中的索引</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        两个明确：</span></span><br><span class="line"><span class="comment">            返回值类型：int</span></span><br><span class="line"><span class="comment">            参数：int[] arr, int number</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getIndex</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> number)</span> &#123;</span><br><span class="line">        <span class="comment">//定义一个索引变量，初始值为-1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历数组，获取到数组中的每一个元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>; x&lt;arr.length; x++) &#123;</span><br><span class="line">            <span class="comment">//拿键盘录入的数据和数组中的每一个元素进行比较，如果值相同，就把该值对应的索引赋值给索引变量,并结束循环</span></span><br><span class="line">            <span class="keyword">if</span>(arr[x] == number) &#123;</span><br><span class="line">                index = x;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回索引</span></span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-9数组元素反转"><a href="#2-9数组元素反转" class="headerlink" title="2.9数组元素反转"></a>2.9数组元素反转</h3><h4 id="2-9-1案例需求"><a href="#2-9-1案例需求" class="headerlink" title="2.9.1案例需求"></a>2.9.1案例需求</h4><p>​已知一个数组 arr &#x3D; {19, 28, 37, 46, 50}; 用程序实现把数组中的元素值交换，<br>​        交换后的数组 arr &#x3D; {50, 46, 37, 28, 19}; 并在控制台输出交换后的数组元素。</p><h4 id="2-9-2代码实现"><a href="#2-9-2代码实现" class="headerlink" title="2.9.2代码实现"></a>2.9.2代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    思路：</span></span><br><span class="line"><span class="comment">        1:定义一个数组，用静态初始化完成数组元素的初始化</span></span><br><span class="line"><span class="comment">        2:循环遍历数组，这一次初始化语句定义两个索引变量，判断条件是开始索引小于等于结束索引</span></span><br><span class="line"><span class="comment">        3:变量交换</span></span><br><span class="line"><span class="comment">        4:遍历数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test09</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//定义一个数组，用静态初始化完成数组元素的初始化</span></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">19</span>, <span class="number">28</span>, <span class="number">37</span>, <span class="number">46</span>, <span class="number">50</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用反转的方法</span></span><br><span class="line">        reverse(arr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历数组</span></span><br><span class="line">        printArray(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        两个明确：</span></span><br><span class="line"><span class="comment">            返回值类型：void</span></span><br><span class="line"><span class="comment">            参数：int[] arr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="comment">//循环遍历数组，这一次初始化语句定义两个索引变量，判断条件是开始索引小于等于结束索引</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>, end = arr.length - <span class="number">1</span>; start &lt;= end; start++, end--) &#123;</span><br><span class="line">            <span class="comment">//变量交换</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[start];</span><br><span class="line">            arr[start] = arr[end];</span><br><span class="line">            arr[end] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        两个明确：</span></span><br><span class="line"><span class="comment">            返回值类型：void</span></span><br><span class="line"><span class="comment">            参数：int[] arr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;[&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>; x &lt; arr.length; x++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x == arr.length - <span class="number">1</span>) &#123;</span><br><span class="line">                System.out.print(arr[x]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.print(arr[x] + <span class="string">&quot;, &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-10评委打分"><a href="#2-10评委打分" class="headerlink" title="2.10评委打分"></a>2.10评委打分</h3><h4 id="2-10-1案例需求"><a href="#2-10-1案例需求" class="headerlink" title="2.10.1案例需求"></a>2.10.1案例需求</h4><p>​在编程竞赛中，有6个评委为参赛的选手打分，分数为0-100的整数分。<br>​        选手的最后得分为：去掉一个最高分和一个最低分后 的4个评委平均值 (不考虑小数部分)。</p><h4 id="2-10-2代码实现"><a href="#2-10-2代码实现" class="headerlink" title="2.10.2代码实现"></a>2.10.2代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    思路：</span></span><br><span class="line"><span class="comment">        1:定义一个数组，用动态初始化完成数组元素的初始化，长度为6</span></span><br><span class="line"><span class="comment">        2:键盘录入评委分数</span></span><br><span class="line"><span class="comment">        3:由于是6个评委打分，所以，接收评委分数的操作，用循环改进</span></span><br><span class="line"><span class="comment">        4:定义方法实现获取数组中的最高分(数组最大值)，调用方法</span></span><br><span class="line"><span class="comment">        5:定义方法实现获取数组中的最低分(数组最小值) ，调用方法</span></span><br><span class="line"><span class="comment">        6:定义方法实现获取数组中的所有元素的和(数组元素求和) ，调用方法</span></span><br><span class="line"><span class="comment">        7:按照计算规则进行计算得到平均分</span></span><br><span class="line"><span class="comment">        8:输出平均分</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test10</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//定义一个数组，用动态初始化完成数组元素的初始化，长度为6</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//键盘录入评委分数</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//由于是6个评委打分，所以，接收评委分数的操作，用循环改进</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>; x&lt;arr.length; x++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入第&quot;</span> + (x + <span class="number">1</span>) + <span class="string">&quot;个评委的打分：&quot;</span>);</span><br><span class="line">            arr[x] = sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//printArray(arr);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义方法实现获取数组中的最高分(数组最大值)，调用方法</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> getMax(arr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义方法实现获取数组中的最低分(数组最小值) ，调用方法</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> getMin(arr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义方法实现获取数组中的所有元素的和(数组元素求和) ，调用方法</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> getSum(arr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//按照计算规则进行计算得到平均分</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">avg</span> <span class="operator">=</span> (sum - max - min) / (arr.length - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出平均分</span></span><br><span class="line">        System.out.println(<span class="string">&quot;选手的最终得分是：&quot;</span> + avg);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        两个明确：</span></span><br><span class="line"><span class="comment">            返回值类型：int</span></span><br><span class="line"><span class="comment">            参数：int[] arr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>; x&lt;arr.length; x++) &#123;</span><br><span class="line">            sum += arr[x];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        两个明确：</span></span><br><span class="line"><span class="comment">            返回值类型：int</span></span><br><span class="line"><span class="comment">            参数：int[] arr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">1</span>; x&lt;arr.length; x++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[x] &lt; min) &#123;</span><br><span class="line">                min = arr[x];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        两个明确：</span></span><br><span class="line"><span class="comment">            返回值类型：int</span></span><br><span class="line"><span class="comment">            参数：int[] arr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getMax</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">1</span>; x&lt;arr.length; x++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[x] &gt; max) &#123;</span><br><span class="line">                max = arr[x];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;[&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>; x &lt; arr.length; x++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x == arr.length - <span class="number">1</span>) &#123;</span><br><span class="line">                System.out.print(arr[x]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.print(arr[x] + <span class="string">&quot;, &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> java,基础语法,Debug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>day05 - 方法</title>
      <link href="/post/bb00120e.html"/>
      <url>/post/bb00120e.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-方法概述"><a href="#1-方法概述" class="headerlink" title="1. 方法概述"></a>1. 方法概述</h2><h3 id="1-1-方法的概念（理解）"><a href="#1-1-方法的概念（理解）" class="headerlink" title="1.1 方法的概念（理解）"></a>1.1 方法的概念（理解）</h3><p>​方法（method）是将具有独立功能的代码块组织成为一个整体，使其具有特殊功能的代码集</p><ul><li>注意：<ul><li>方法必须先创建才可以使用，该过程成为方法定义</li><li>方法创建后并不是直接可以运行的，需要手动使用后，才执行，该过程成为方法调用</li></ul></li></ul><h2 id="2-方法的定义和调用"><a href="#2-方法的定义和调用" class="headerlink" title="2. 方法的定义和调用"></a>2. 方法的定义和调用</h2><h3 id="2-1-无参数方法定义和调用（掌握）"><a href="#2-1-无参数方法定义和调用（掌握）" class="headerlink" title="2.1 无参数方法定义和调用（掌握）"></a>2.1 无参数方法定义和调用（掌握）</h3><ul><li><p>定义格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> 方法名 (   ) &#123;</span><br><span class="line"><span class="comment">// 方法体;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>范例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span> <span class="params">(    )</span> &#123;</span><br><span class="line"><span class="comment">// 方法体;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>调用格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方法名();</span><br></pre></td></tr></table></figure></li><li><p>范例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">method();</span><br></pre></td></tr></table></figure></li><li><p>注意：</p><p>​方法必须先定义，后调用，否则程序将报错</p></li></ul><h3 id="2-2-方法调用过程图解（理解）"><a href="#2-2-方法调用过程图解（理解）" class="headerlink" title="2.2 方法调用过程图解（理解）"></a>2.2 方法调用过程图解（理解）</h3><ul><li>总结：每个方法在被调用执行的时候，都会进入栈内存，并且拥有自己独立的内存空间，方法内部代码调用完毕之后，会从栈内存中弹栈消失。</li></ul><h3 id="2-3-无参数方法的练习（应用）"><a href="#2-3-无参数方法的练习（应用）" class="headerlink" title="2.3 无参数方法的练习（应用）"></a>2.3 无参数方法的练习（应用）</h3><ul><li>需求：设计一个方法用于打印两个数中的较大数 </li><li>思路：<ul><li>①定义一个方法，用于打印两个数字中的较大数，例如getMax() </li><li>②方法中定义两个变量，用于保存两个数字 </li><li>③使用分支语句分两种情况对两个数字的大小关系进行处理 </li><li>④在main()方法中调用定义好的方法</li></ul></li><li>代码：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//在main()方法中调用定义好的方法</span></span><br><span class="line">        getMax();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个方法，用于打印两个数字中的较大数，例如getMax()</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getMax</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//方法中定义两个变量，用于保存两个数字</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用分支语句分两种情况对两个数字的大小关系进行处理</span></span><br><span class="line">        <span class="keyword">if</span>(a &gt; b) &#123;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-带参数方法定义和调用"><a href="#3-带参数方法定义和调用" class="headerlink" title="3. 带参数方法定义和调用"></a>3. 带参数方法定义和调用</h2><h3 id="3-1-带参数方法定义和调用（掌握）"><a href="#3-1-带参数方法定义和调用（掌握）" class="headerlink" title="3.1 带参数方法定义和调用（掌握）"></a>3.1 带参数方法定义和调用（掌握）</h3><ul><li><p>定义格式：</p><p>参数：由数据类型和变量名组成 -  数据类型 变量名</p><p>参数范例：int a</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> 方法名 (参数<span class="number">1</span>) &#123;</span><br><span class="line">方法体;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> 方法名 (参数<span class="number">1</span>, 参数<span class="number">2</span>, 参数<span class="number">3.</span>..) &#123;</span><br><span class="line">方法体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>范例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">isEvenNumber</span><span class="params">(<span class="type">int</span> number)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getMax</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>注意：</p><pre><code>  方法定义时，参数中的数据类型与变量名都不能缺少，缺少任意一个程序将报错      方法定义时，多个参数之间使用逗号( ，)分隔</code></pre></li></ul></li><li><p>调用格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方法名(参数)；</span><br><span class="line"></span><br><span class="line">方法名(参数<span class="number">1</span>,参数<span class="number">2</span>);</span><br></pre></td></tr></table></figure></li><li><p>范例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">isEvenNumber(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">getMax(<span class="number">10</span>,<span class="number">20</span>);</span><br></pre></td></tr></table></figure><ul><li>方法调用时，参数的数量与类型必须与方法定义中的设置相匹配，否则程序将报错</li></ul></li></ul><h3 id="3-2-形参和实参（理解）"><a href="#3-2-形参和实参（理解）" class="headerlink" title="3.2 形参和实参（理解）"></a>3.2 形参和实参（理解）</h3><ol><li>形参：方法定义中的参数</li></ol><p>​          等同于变量定义格式，例如：int number</p><ol start="2"><li>实参：方法调用中的参数</li></ol><p>​          等同于使用变量或常量，例如： 10  number</p><h3 id="3-3-带参数方法练习（应用）"><a href="#3-3-带参数方法练习（应用）" class="headerlink" title="3.3 带参数方法练习（应用）"></a>3.3 带参数方法练习（应用）</h3><ul><li>需求：设计一个方法用于打印两个数中的较大数，数据来自于方法参数 }</li><li>思路：<ul><li>①定义一个方法，用于打印两个数字中的较大数，例如getMax() </li><li>②为方法定义两个参数，用于接收两个数字 </li><li>③使用分支语句分两种情况对两个数字的大小关系进行处理 </li><li>④在main()方法中调用定义好的方法（使用常量）</li><li>⑤在main()方法中调用定义好的方法（使用变量）</li></ul></li><li>代码：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//在main()方法中调用定义好的方法（使用常量）</span></span><br><span class="line">        getMax(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">        <span class="comment">//调用方法的时候，人家要几个，你就给几个，人家要什么类型的，你就给什么类型的</span></span><br><span class="line">        <span class="comment">//getMax(30);</span></span><br><span class="line">        <span class="comment">//getMax(10.0,20.0);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//在main()方法中调用定义好的方法（使用变量）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">        getMax(a, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个方法，用于打印两个数字中的较大数，例如getMax()</span></span><br><span class="line">    <span class="comment">//为方法定义两个参数，用于接收两个数字</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getMax</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="comment">//使用分支语句分两种情况对两个数字的大小关系进行处理</span></span><br><span class="line">        <span class="keyword">if</span>(a &gt; b) &#123;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-带返回值方法的定义和调用"><a href="#4-带返回值方法的定义和调用" class="headerlink" title="4. 带返回值方法的定义和调用"></a>4. 带返回值方法的定义和调用</h2><h3 id="4-1-带返回值方法定义和调用（掌握）"><a href="#4-1-带返回值方法定义和调用（掌握）" class="headerlink" title="4.1 带返回值方法定义和调用（掌握）"></a>4.1 带返回值方法定义和调用（掌握）</h3><ul><li><p>定义格式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> 数据类型 方法名 ( 参数 ) &#123; </span><br><span class="line"><span class="keyword">return</span> 数据 ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>范例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isEvenNumber</span><span class="params">( <span class="type">int</span> number )</span> &#123;           </span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getMax</span><span class="params">( <span class="type">int</span> a, <span class="type">int</span> b )</span> &#123;</span><br><span class="line"><span class="keyword">return</span>  <span class="number">100</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意：<ul><li>方法定义时return后面的返回值与方法定义上的数据类型要匹配，否则程序将报错</li></ul></li></ul></li><li><p>调用格式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方法名 ( 参数 ) ;</span><br><span class="line">数据类型 变量名 = 方法名 ( 参数 ) ;</span><br></pre></td></tr></table></figure></li><li><p>范例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">isEvenNumber ( <span class="number">5</span> ) ;</span><br><span class="line"><span class="type">boolean</span>  <span class="variable">flag</span> <span class="operator">=</span>  isEvenNumber ( <span class="number">5</span> ); </span><br></pre></td></tr></table></figure><ul><li>注意：<ul><li>方法的返回值通常会使用变量接收，否则该返回值将无意义</li></ul></li></ul></li></ul><h3 id="4-2-带返回值方法练习（应用）"><a href="#4-2-带返回值方法练习（应用）" class="headerlink" title="4.2 带返回值方法练习（应用）"></a>4.2 带返回值方法练习（应用）</h3><ul><li><p>需求：设计一个方法可以获取两个数的较大值，数据来自于参数</p></li><li><p>思路：</p><ul><li>①定义一个方法，用于获取两个数字中的较大数 </li><li>②使用分支语句分两种情况对两个数字的大小关系进行处理 </li><li>③根据题设分别设置两种情况下对应的返回结果 </li><li>④在main()方法中调用定义好的方法并使用变量保存 </li><li>⑤在main()方法中调用定义好的方法并直接打印结果</li></ul></li><li><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//在main()方法中调用定义好的方法并使用变量保存</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> getMax(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在main()方法中调用定义好的方法并直接打印结果</span></span><br><span class="line">        System.out.println(getMax(<span class="number">10</span>,<span class="number">20</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个方法，用于获取两个数字中的较大数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getMax</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="comment">//使用分支语句分两种情况对两个数字的大小关系进行处理</span></span><br><span class="line">        <span class="comment">//根据题设分别设置两种情况下对应的返回结果</span></span><br><span class="line">        <span class="keyword">if</span>(a &gt; b) &#123;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="5-方法的注意事项"><a href="#5-方法的注意事项" class="headerlink" title="5. 方法的注意事项"></a>5. 方法的注意事项</h2><h3 id="5-1-方法的注意事项（掌握）"><a href="#5-1-方法的注意事项（掌握）" class="headerlink" title="5.1 方法的注意事项（掌握）"></a>5.1 方法的注意事项（掌握）</h3><ul><li><p>方法不能嵌套定义</p><ul><li><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">methodOne</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">methodTwo</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">// 这里会引发编译错误!!!</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>void表示无返回值，可以省略return，也可以单独的书写return，后面不加数据</p><ul><li><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">methodTwo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//return 100; 编译错误，因为没有具体返回值类型</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//System.out.println(100); return语句后面不能跟数据或代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="5-2-方法的通用格式（掌握）"><a href="#5-2-方法的通用格式（掌握）" class="headerlink" title="5.2 方法的通用格式（掌握）"></a>5.2 方法的通用格式（掌握）</h3><ul><li><p>格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> 返回值类型 方法名(参数) &#123;</span><br><span class="line">   方法体; </span><br><span class="line">   <span class="keyword">return</span> 数据 ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>解释：</p><ul><li><p>public static 修饰符，目前先记住这个格式</p><p>   返回值类型方法操作完毕之后返回的数据的数据类型</p><p>​如果方法操作完毕，没有数据返回，这里写void，而且方法体中一般不写return</p><p>   方法名调用方法时候使用的标识</p><p>   参数由数据类型和变量名组成，多个参数之间用逗号隔开</p><p>   方法体完成功能的代码块</p><p>   return如果方法操作完毕，有数据返回，用于把数据返回给调用者</p></li></ul></li><li><p>定义方法时，要做到两个明确</p><ul><li>明确返回值类型：主要是明确方法操作完毕之后是否有数据返回，如果没有，写void；如果有，写对应的数据类型</li><li>明确参数：主要是明确参数的类型和数量</li></ul></li><li><p>调用方法时的注意：</p><ul><li>void类型的方法，直接调用即可</li><li>非void类型的方法，推荐用变量接收调用</li></ul></li></ul><h2 id="6-方法重载"><a href="#6-方法重载" class="headerlink" title="6. 方法重载"></a>6. 方法重载</h2><h3 id="6-1-方法重载（理解）"><a href="#6-1-方法重载（理解）" class="headerlink" title="6.1 方法重载（理解）"></a>6.1 方法重载（理解）</h3><ul><li><p>方法重载概念</p><p>方法重载指同一个类中定义的多个方法之间的关系，满足下列条件的多个方法相互构成重载</p><ul><li>多个方法在同一个类中</li><li>多个方法具有相同的方法名</li><li>多个方法的参数不相同，类型不同或者数量不同</li></ul></li><li><p>注意：</p><ul><li>重载仅对应方法的定义，与方法的调用无关，调用方式参照标准格式</li><li>重载仅针对同一个类中方法的名称与参数进行识别，与返回值无关，换句话说不能通过返回值来判定两个方法是否相互构成重载</li></ul></li><li><p>正确范例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodDemo</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fn</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">    <span class="comment">//方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fn</span><span class="params">(<span class="type">double</span> a)</span> &#123;</span><br><span class="line">    <span class="comment">//方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodDemo</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">float</span> <span class="title function_">fn</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">    <span class="comment">//方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fn</span><span class="params">(<span class="type">int</span> a , <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="comment">//方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>错误范例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodDemo</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fn</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">    <span class="comment">//方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fn</span><span class="params">(<span class="type">int</span> a)</span> &#123; <span class="comment">/*错误原因：重载与返回值无关*/</span></span><br><span class="line">    <span class="comment">//方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fn</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">        <span class="comment">//方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fn</span><span class="params">(<span class="type">double</span> a)</span> &#123; <span class="comment">/*错误原因：这是两个类的两个fn方法*/</span></span><br><span class="line">        <span class="comment">//方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="6-2-方法重载练习（掌握）"><a href="#6-2-方法重载练习（掌握）" class="headerlink" title="6.2 方法重载练习（掌握）"></a>6.2 方法重载练习（掌握）</h3><ul><li><p>需求：使用方法重载的思想，设计比较两个整数是否相同的方法，兼容全整数类型（byte,short,int,long） </p></li><li><p>思路：</p><ul><li>①定义比较两个数字的是否相同的方法compare()方法，参数选择两个int型参数</li><li>②定义对应的重载方法，变更对应的参数类型，参数变更为两个long型参数</li><li>③定义所有的重载方法，两个byte类型与两个short类型参数 </li><li>④完成方法的调用，测试运行结果</li></ul></li><li><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//调用方法</span></span><br><span class="line">        System.out.println(compare(<span class="number">10</span>, <span class="number">20</span>));</span><br><span class="line">        System.out.println(compare((<span class="type">byte</span>) <span class="number">10</span>, (<span class="type">byte</span>) <span class="number">20</span>));</span><br><span class="line">        System.out.println(compare((<span class="type">short</span>) <span class="number">10</span>, (<span class="type">short</span>) <span class="number">20</span>));</span><br><span class="line">        System.out.println(compare(<span class="number">10L</span>, <span class="number">20L</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//int</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;int&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> a == b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//byte</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(<span class="type">byte</span> a, <span class="type">byte</span> b)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;byte&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> a == b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//short</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(<span class="type">short</span> a, <span class="type">short</span> b)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;short&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> a == b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//long</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(<span class="type">long</span> a, <span class="type">long</span> b)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;long&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> a == b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="7-方法的参数传递"><a href="#7-方法的参数传递" class="headerlink" title="7. 方法的参数传递"></a>7. 方法的参数传递</h2><h3 id="7-1-方法参数传递基本类型（理解）"><a href="#7-1-方法参数传递基本类型（理解）" class="headerlink" title="7.1 方法参数传递基本类型（理解）"></a>7.1 方法参数传递基本类型（理解）</h3><ul><li><p>测试代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArgsDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用change方法前：&quot;</span> + number);</span><br><span class="line">        change(number);</span><br><span class="line">        System.out.println(<span class="string">&quot;调用change方法后：&quot;</span> + number);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">        number = <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>结论：</p><ul><li>基本数据类型的参数，形式参数的改变，不影响实际参数</li></ul></li><li><p>结论依据：</p><ul><li>每个方法在栈内存中，都会有独立的栈空间，方法运行结束后就会弹栈消失</li></ul></li></ul><h3 id="7-2-方法参数传递引用类型（理解）"><a href="#7-2-方法参数传递引用类型（理解）" class="headerlink" title="7.2 方法参数传递引用类型（理解）"></a>7.2 方法参数传递引用类型（理解）</h3><ul><li><p>测试代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArgsDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用change方法前：&quot;</span> + arr[<span class="number">1</span>]);</span><br><span class="line">        change(arr);</span><br><span class="line">        System.out.println(<span class="string">&quot;调用change方法后：&quot;</span> + arr[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        arr[<span class="number">1</span>] = <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>结论：</p><ul><li>**对于引用类型的参数，形式参数的改变，影响实际参数的值 **</li></ul></li><li><p>结论依据：</p><ul><li>引用数据类型的传参，传入的是<strong>地址值</strong>，内存中会造成两个引用指向同一个内存的效果，所以即使方法弹栈，堆内存中的数据也已经是改变后的结果</li></ul></li></ul><h3 id="7-3-数组遍历（应用）"><a href="#7-3-数组遍历（应用）" class="headerlink" title="7.3 数组遍历（应用）"></a>7.3 数组遍历（应用）</h3><ul><li><p>需求：设计一个方法用于数组遍历，要求遍历的结果是在一行上的。例如：[11, 22, 33, 44, 55] </p></li><li><p>思路：</p><ul><li><p>①因为要求结果在一行上输出，所以这里需要在学习一个新的输出语句System.out.print(“内容”);</p><p>System.out.println(“内容”); 输出内容并换行</p><p>System.out.print(“内容”); 输出内容不换行</p><p>System.out.println(); 起到换行的作用</p></li><li><p>②定义一个数组，用静态初始化完成数组元素初始化</p></li><li><p>③定义一个方法，用数组遍历通用格式对数组进行遍历</p></li><li><p>④用新的输出语句修改遍历操作</p></li><li><p>⑤调用遍历方法</p></li></ul></li><li><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodTest01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//定义一个数组，用静态初始化完成数组元素初始化</span></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用方法</span></span><br><span class="line">        printArray(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个方法，用数组遍历通用格式对数组进行遍历</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        两个明确：</span></span><br><span class="line"><span class="comment">            返回值类型：void</span></span><br><span class="line"><span class="comment">            参数：int[] arr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;[&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>; x&lt;arr.length; x++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(x == arr.length-<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.print(arr[x]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.print(arr[x]+<span class="string">&quot;, &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="7-4-数组最大值（应用）"><a href="#7-4-数组最大值（应用）" class="headerlink" title="7.4 数组最大值（应用）"></a>7.4 数组最大值（应用）</h3><ul><li><p>需求：设计一个方法用于获取数组中元素的最大值 </p></li><li><p>思路：</p><ul><li>①定义一个数组，用静态初始化完成数组元素初始化</li><li>②定义一个方法，用来获取数组中的最大值，最值的认知和讲解我们在数组中已经讲解过了</li><li>③调用获取最大值方法，用变量接收返回结果</li><li>④把结果输出在控制台</li></ul></li><li><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodTest02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//定义一个数组，用静态初始化完成数组元素初始化</span></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">12</span>, <span class="number">45</span>, <span class="number">98</span>, <span class="number">73</span>, <span class="number">60</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用获取最大值方法，用变量接收返回结果</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> getMax(arr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把结果输出在控制台</span></span><br><span class="line">        System.out.println(<span class="string">&quot;number:&quot;</span> + number);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个方法，用来获取数组中的最大值</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        两个明确：</span></span><br><span class="line"><span class="comment">            返回值类型：int</span></span><br><span class="line"><span class="comment">            参数：int[] arr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getMax</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">1</span>; x&lt;arr.length; x++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[x] &gt; max) &#123;</span><br><span class="line">                max = arr[x];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> java,基础语法,方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>day04 - 数组</title>
      <link href="/post/305c640.html"/>
      <url>/post/305c640.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-数组"><a href="#1-数组" class="headerlink" title="1.数组"></a>1.数组</h2><h3 id="1-1什么是数组【理解】"><a href="#1-1什么是数组【理解】" class="headerlink" title="1.1什么是数组【理解】"></a>1.1什么是数组【理解】</h3><p>​数组就是存储数据长度固定的容器，存储多个数据的数据类型要一致。 </p><h3 id="1-2数组定义格式【记忆】"><a href="#1-2数组定义格式【记忆】" class="headerlink" title="1.2数组定义格式【记忆】"></a>1.2数组定义格式【记忆】</h3><h4 id="1-2-1第一种"><a href="#1-2-1第一种" class="headerlink" title="1.2.1第一种"></a>1.2.1第一种</h4><p>​数据类型[] 数组名</p><p>​示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr;        </span><br><span class="line"><span class="type">double</span>[] arr;      </span><br><span class="line"><span class="type">char</span>[] arr;</span><br></pre></td></tr></table></figure><h4 id="1-2-2第二种"><a href="#1-2-2第二种" class="headerlink" title="1.2.2第二种"></a>1.2.2第二种</h4><p>​数据类型 数组名[]</p><p>​示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[];</span><br><span class="line"><span class="type">double</span> arr[];</span><br><span class="line"><span class="type">char</span> arr[];</span><br></pre></td></tr></table></figure><h3 id="1-3数组动态初始化【应用】"><a href="#1-3数组动态初始化【应用】" class="headerlink" title="1.3数组动态初始化【应用】"></a>1.3数组动态初始化【应用】</h3><h4 id="1-3-1什么是动态初始化"><a href="#1-3-1什么是动态初始化" class="headerlink" title="1.3.1什么是动态初始化"></a>1.3.1什么是动态初始化</h4><p>​数组动态初始化就是只给定数组的长度，由系统给出默认初始化值。</p><h4 id="1-3-2动态初始化格式"><a href="#1-3-2动态初始化格式" class="headerlink" title="1.3.2动态初始化格式"></a>1.3.2动态初始化格式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数据类型[] 数组名 = <span class="keyword">new</span> 数据类型[数组长度];</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br></pre></td></tr></table></figure><h4 id="1-3-3动态初始化格式详解"><a href="#1-3-3动态初始化格式详解" class="headerlink" title="1.3.3动态初始化格式详解"></a>1.3.3动态初始化格式详解</h4><ul><li><p>等号左边：</p><ul><li><p>int:数组的数据类型</p></li><li><p>[]:代表这是一个数组</p></li><li><p>arr:代表数组的名称</p></li></ul></li><li><p>等号右边：</p></li><li><p>new:为数组开辟内存空间</p></li><li><p>int:数组的数据类型</p></li><li><p>[]:代表这是一个数组</p></li><li><p>5:代表数组的长度</p></li></ul><h3 id="1-4数组元素访问【应用】"><a href="#1-4数组元素访问【应用】" class="headerlink" title="1.4数组元素访问【应用】"></a>1.4数组元素访问【应用】</h3><h4 id="1-4-1什么是索引"><a href="#1-4-1什么是索引" class="headerlink" title="1.4.1什么是索引"></a>1.4.1什么是索引</h4><p>​每一个存储到数组的元素，都会自动的拥有一个编号，从0开始。</p><p>​这个自动编号称为数组索引(index)，可以通过数组的索引访问到数组中的元素。 </p><h4 id="1-4-2访问数组元素格式"><a href="#1-4-2访问数组元素格式" class="headerlink" title="1.4.2访问数组元素格式"></a>1.4.2访问数组元素格式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数组名[索引];</span><br></pre></td></tr></table></figure><h4 id="1-4-3示例代码"><a href="#1-4-3示例代码" class="headerlink" title="1.4.3示例代码"></a>1.4.3示例代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出数组名</span></span><br><span class="line">        System.out.println(arr); <span class="comment">//[I@880ec60</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出数组中的元素</span></span><br><span class="line">        System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">        System.out.println(arr[<span class="number">1</span>]);</span><br><span class="line">        System.out.println(arr[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5内存分配【理解】"><a href="#1-5内存分配【理解】" class="headerlink" title="1.5内存分配【理解】"></a>1.5内存分配【理解】</h3><h4 id="1-5-1内存概述"><a href="#1-5-1内存概述" class="headerlink" title="1.5.1内存概述"></a>1.5.1内存概述</h4><p>​内存是计算机中的重要原件，临时存储区域，作用是运行程序。</p><p>​我们编写的程序是存放在硬盘中的，在硬盘中的程序是不会运行的。</p><p>​必须放进内存中才能运行，运行完毕后会清空内存。 </p><p>​Java虚拟机要运行程序，必须要对内存进行空间的分配和管理。 </p><h4 id="1-5-2java中的内存分配"><a href="#1-5-2java中的内存分配" class="headerlink" title="1.5.2java中的内存分配"></a>1.5.2java中的内存分配</h4><ul><li>目前我们只需要记住两个内存，分别是：栈内存和堆内存</li></ul><table><thead><tr><th>区域名称</th><th>作用</th></tr></thead><tbody><tr><td>寄存器</td><td>给CPU使用，和我们开发无关。</td></tr><tr><td>本地方法栈</td><td>JVM在使用操作系统功能的时候使用，和我们开发无关。</td></tr><tr><td>方法区</td><td>存储可以运行的class文件。</td></tr><tr><td>堆内存</td><td>存储对象或者数组，new来创建的，都存储在堆内存。</td></tr><tr><td>方法栈</td><td>方法运行时使用的内存，比如main方法运行，进入方法栈中执行。</td></tr></tbody></table><h3 id="1-6单个数组的内存图【理解】"><a href="#1-6单个数组的内存图【理解】" class="headerlink" title="1.6单个数组的内存图【理解】"></a>1.6单个数组的内存图【理解】</h3><h3 id="1-7多个数组的内存图【理解】"><a href="#1-7多个数组的内存图【理解】" class="headerlink" title="1.7多个数组的内存图【理解】"></a>1.7多个数组的内存图【理解】</h3><h3 id="1-8多个数组指向相同内存图【理解】"><a href="#1-8多个数组指向相同内存图【理解】" class="headerlink" title="1.8多个数组指向相同内存图【理解】"></a>1.8多个数组指向相同内存图【理解】</h3><h3 id="1-9数组静态初始化【应用】"><a href="#1-9数组静态初始化【应用】" class="headerlink" title="1.9数组静态初始化【应用】"></a>1.9数组静态初始化【应用】</h3><h4 id="1-9-1什么是静态初始化"><a href="#1-9-1什么是静态初始化" class="headerlink" title="1.9.1什么是静态初始化"></a>1.9.1什么是静态初始化</h4><p>​在创建数组时，直接将元素确定</p><h4 id="1-9-2静态初始化格式"><a href="#1-9-2静态初始化格式" class="headerlink" title="1.9.2静态初始化格式"></a>1.9.2静态初始化格式</h4><ul><li><p>完整版格式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数据类型[] 数组名 = <span class="keyword">new</span> 数据类型[]&#123;元素<span class="number">1</span>,元素<span class="number">2</span>,...&#125;;</span><br></pre></td></tr></table></figure></li><li><p>简化版格式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数据类型[] 数组名 = &#123;元素<span class="number">1</span>,元素<span class="number">2</span>,...&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="1-9-3示例代码"><a href="#1-9-3示例代码" class="headerlink" title="1.9.3示例代码"></a>1.9.3示例代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//定义数组</span></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出数组名</span></span><br><span class="line">        System.out.println(arr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出数组中的元素</span></span><br><span class="line">        System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">        System.out.println(arr[<span class="number">1</span>]);</span><br><span class="line">        System.out.println(arr[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-10数组操作的两个常见小问题【应用】"><a href="#1-10数组操作的两个常见小问题【应用】" class="headerlink" title="1.10数组操作的两个常见小问题【应用】"></a>1.10数组操作的两个常见小问题【应用】</h3><h4 id="1-10-1索引越界异常"><a href="#1-10-1索引越界异常" class="headerlink" title="1.10.1索引越界异常"></a>1.10.1索引越界异常</h4><ul><li><p>出现原因</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">        System.out.println(arr[<span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组长度为3，索引范围是0~2，但是我们却访问了一个3的索引。</p><p>程序运行后，将会抛出ArrayIndexOutOfBoundsException 数组越界异常。在开发中，数组的越界异常是不能出现的，一旦出现了，就必须要修改我们编写的代码。 </p></li><li><p>解决方案</p><p>将错误的索引修改为正确的索引范围即可！</p></li></ul><h4 id="1-10-2空指针异常"><a href="#1-10-2空指针异常" class="headerlink" title="1.10.2空指针异常"></a>1.10.2空指针异常</h4><ul><li><p>出现原因</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把null赋值给数组</span></span><br><span class="line">        arr = <span class="literal">null</span>;</span><br><span class="line">        System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>arr &#x3D; null 这行代码，意味着变量arr将不会再保存数组的内存地址，也就不允许再操作数组了，因此运行的时候会抛出 NullPointerException 空指针异常。在开发中，数组的越界异常是不能出现的，一旦出现了，就必须要修改我们编写的代码。</p></li><li><p>解决方案</p><p>给数组一个真正的堆内存空间引用即可！</p></li></ul><h3 id="1-11数组遍历【应用】"><a href="#1-11数组遍历【应用】" class="headerlink" title="1.11数组遍历【应用】"></a>1.11数组遍历【应用】</h3><ul><li><p>数组遍历：就是将数组中的每个元素分别获取出来，就是遍历。遍历也是数组操作中的基石。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayTest01</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">System.out.println(arr[<span class="number">1</span>]);</span><br><span class="line">System.out.println(arr[<span class="number">2</span>]);</span><br><span class="line">System.out.println(arr[<span class="number">3</span>]);</span><br><span class="line">System.out.println(arr[<span class="number">4</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码是可以将数组中每个元素全部遍历出来，但是如果数组元素非常多，这种写法肯定不行，因此我们需要改造成循环的写法。数组的索引是 0 到 lenght-1 ，可以作为循环的条件出现。 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayTest01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//定义数组</span></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用通用的遍历格式</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>; x &lt; arr.length; x++) &#123;</span><br><span class="line">            System.out.println(arr[x]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-12数组最值【应用】"><a href="#1-12数组最值【应用】" class="headerlink" title="1.12数组最值【应用】"></a>1.12数组最值【应用】</h3><ul><li><p>最大值获取：从数组的所有元素中找出最大值。</p></li><li><p>实现思路：</p><ul><li>定义变量，保存数组0索引上的元素</li><li>遍历数组，获取出数组中的每个元素</li><li>将遍历到的元素和保存数组0索引上值的变量进行比较</li><li>如果数组元素的值大于了变量的值，变量记录住新的值</li><li>数组循环遍历结束，变量保存的就是数组中的最大值</li></ul></li><li><p>代码实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayTest02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//定义数组</span></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">12</span>, <span class="number">45</span>, <span class="number">98</span>, <span class="number">73</span>, <span class="number">60</span>&#125;;</span><br><span class="line">        <span class="comment">//定义一个变量，用于保存最大值</span></span><br><span class="line">        <span class="comment">//取数组中第一个数据作为变量的初始值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//与数组中剩余的数据逐个比对，每次比对将最大值保存到变量中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">1</span>; x&lt;arr.length; x++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[x] &gt; max) &#123;</span><br><span class="line">                max = arr[x];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//循环结束后打印变量的值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;max:&quot;</span> + max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> java,基础语法,数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>day03 - 循环</title>
      <link href="/post/979f52f0.html"/>
      <url>/post/979f52f0.html</url>
      
        <content type="html"><![CDATA[<h2 id="1、流程控制语句（应用）"><a href="#1、流程控制语句（应用）" class="headerlink" title="1、流程控制语句（应用）"></a>1、流程控制语句（应用）</h2><p>在一个程序执行的过程中，各条语句的执行顺序对程序的结果是有直接影响的。所以，我们必须清楚每条语句的执行流程。而且，很多时候要通过控制语句的执行顺序来实现我们想要的功能。</p><h3 id="1-1-流程控制语句分类"><a href="#1-1-流程控制语句分类" class="headerlink" title="1.1 流程控制语句分类"></a>1.1 流程控制语句分类</h3><p>​顺序结构</p><p>​分支结构(if, switch)</p><p>​循环结构(for, while, do…while)</p><h3 id="1-2-顺序结构"><a href="#1-2-顺序结构" class="headerlink" title="1.2 顺序结构"></a>1.2 顺序结构</h3><p>顺序结构是程序中最简单最基本的流程控制，没有特定的语法结构，按照代码的先后顺序，依次执行，程序中大多数的代码都是这样执行的。</p><h3 id="1-3-分支结构：if语句"><a href="#1-3-分支结构：if语句" class="headerlink" title="1.3 分支结构：if语句"></a>1.3 分支结构：if语句</h3><h4 id="if语句格式1"><a href="#if语句格式1" class="headerlink" title="if语句格式1"></a>if语句格式1</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line"><span class="keyword">if</span> (关系表达式) &#123;</span><br><span class="line">    语句体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行流程：</p><p>①首先计算关系表达式的值</p><p>②如果关系表达式的值为true就执行语句体</p><p>③如果关系表达式的值为false就不执行语句体</p><p>④继续执行后面的语句内容</p><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IfDemo</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;开始&quot;</span>);</span><br><span class="line"><span class="comment">//定义两个变量</span></span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="comment">//需求：判断a和b的值是否相等，如果相等，就在控制台输出：a等于b</span></span><br><span class="line"><span class="keyword">if</span>(a == b) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;a等于b&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//需求：判断a和c的值是否相等，如果相等，就在控制台输出：a等于c</span></span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span>(a == c) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;a等于c&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="if语句格式2"><a href="#if语句格式2" class="headerlink" title="if语句格式2"></a>if语句格式2</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line"><span class="keyword">if</span> (关系表达式) &#123;</span><br><span class="line">    语句体<span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    语句体<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行流程：</p><p>①首先计算关系表达式的值</p><p>②如果关系表达式的值为true就执行语句体1</p><p>③如果关系表达式的值为false就执行语句体2</p><p>④继续执行后面的语句内容</p><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IfDemo02</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;开始&quot;</span>);</span><br><span class="line"><span class="comment">//定义两个变量</span></span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">b = <span class="number">5</span>;</span><br><span class="line"><span class="comment">//需求：判断a是否大于b，如果是，在控制台输出：a的值大于b，否则，在控制台输出：a的值不大于b</span></span><br><span class="line"><span class="keyword">if</span>(a &gt; b) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;a的值大于b&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;a的值不大于b&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>if语句案例：奇偶数</p><p>需求：任意给出一个整数，请用程序实现判断该整数是奇数还是偶数，并在控制台输出该整数是奇数还是偶数。</p><p>分析：</p><p>​①为了体现任意给出一个整数，采用键盘录入一个数据</p><p>​②判断整数是偶数还是奇数要分两种情况进行判断，使用if..else结构</p><p>​③判断是否偶数需要使用取余运算符实现该功能 number % 2 &#x3D;&#x3D; 0</p><p>​④根据判定情况，在控制台输出对应的内容</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IfTest01</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//为了体现任意给出一个整数，采用键盘录入一个数据。(导包，创建对象，接收数据)</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">System.out.println(<span class="string">&quot;请输入一个整数：&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"><span class="comment">//判断整数是偶数还是奇数要分两种情况进行判断，使用if..else结构</span></span><br><span class="line"><span class="comment">//判断是否偶数需要使用取余运算符实现该功能 number % 2 == 0</span></span><br><span class="line"><span class="comment">//根据判定情况，在控制台输出对应的内容</span></span><br><span class="line"><span class="keyword">if</span>(number%<span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">System.out.println(number + <span class="string">&quot;是偶数&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(number + <span class="string">&quot;是奇数&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="if语句格式3"><a href="#if语句格式3" class="headerlink" title="if语句格式3"></a>if语句格式3</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line"><span class="keyword">if</span> (关系表达式<span class="number">1</span>) &#123;</span><br><span class="line">    语句体<span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (关系表达式<span class="number">2</span>) &#123;</span><br><span class="line">    语句体<span class="number">2</span>;</span><br><span class="line">&#125; </span><br><span class="line">…</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    语句体n+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行流程：</p><p>①首先计算关系表达式1的值</p><p>②如果值为true就执行语句体1；如果值为false就计算关系表达式2的值</p><p>③如果值为true就执行语句体2；如果值为false就计算关系表达式3的值</p><p>④…</p><p>⑤如果没有任何关系表达式为true，就执行语句体n+1。</p><p>示例：键盘录入一个星期数(1,2,…7)，输出对应的星期一，星期二，…星期日</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IfDemo03</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;开始&quot;</span>);</span><br><span class="line"><span class="comment">// 需求：键盘录入一个星期数(1,2,...7)，输出对应的星期一，星期二，...星期日</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">System.out.println(<span class="string">&quot;请输入一个星期数(1-7)：&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">week</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"><span class="keyword">if</span>(week == <span class="number">1</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;星期一&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(week == <span class="number">2</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;星期二&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(week == <span class="number">3</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;星期三&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(week == <span class="number">4</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;星期四&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(week == <span class="number">5</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;星期五&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(week == <span class="number">6</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;星期六&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;星期日&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>if语句格式3案例：</p><p>需求：小明快要期末考试了，小明爸爸对他说，会根据他不同的考试成绩，送他不同的礼物，假如你可以控制小明的得分，请用程序实现小明到底该获得什么样的礼物，并在控制台输出。</p><p>分析：</p><p>​①小明的考试成绩未知，可以使用键盘录入的方式获取值</p><p>​②由于奖励种类较多，属于多种判断，采用if…else…if格式实现</p><p>​③为每种判断设置对应的条件</p><p>​④为每种判断设置对应的奖励</p><h3 id="1-4-分支结构：switch语句"><a href="#1-4-分支结构：switch语句" class="headerlink" title="1.4 分支结构：switch语句"></a>1.4 分支结构：switch语句</h3><h5 id="switch语句结构（掌握）"><a href="#switch语句结构（掌握）" class="headerlink" title="switch语句结构（掌握）"></a>switch语句结构（掌握）</h5><ul><li><p>格式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (表达式) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">语句体<span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">语句体<span class="number">2</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">语句体n+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>执行流程：</p><ul><li>首先计算出表达式的值 </li><li>其次，和case依次比较，一旦有对应的值，就会执行相应的语句，在执行的过程中，遇到break就会结 束。 </li><li>最后，如果所有的case都和表达式的值不匹配，就会执行default语句体部分，然后程序结束掉。</li></ul></li></ul><h5 id="switch语句练习-春夏秋冬（应用）"><a href="#switch语句练习-春夏秋冬（应用）" class="headerlink" title="switch语句练习-春夏秋冬（应用）"></a>switch语句练习-春夏秋冬（应用）</h5><ul><li>需求：一年有12个月，分属于春夏秋冬4个季节，键盘录入一个月份，请用程序实现判断该月份属于哪个季节，并输出。 </li><li>运行结果：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">春：3、4、5</span><br><span class="line">夏：6、7、8</span><br><span class="line">秋：9、10、11</span><br><span class="line">冬：1、2、12</span><br></pre></td></tr></table></figure><ul><li>示例代码：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//键盘录入月份数据，使用变量接收</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入一个月份：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="comment">//case穿透</span></span><br><span class="line">        <span class="keyword">switch</span>(month) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;冬季&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;春季&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;夏季&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;秋季&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;你输入的月份有误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意：如果switch中得case，没有对应break的话，则会出现case穿透的现象。</li></ul><h3 id="1-5-循环结构：for循环"><a href="#1-5-循环结构：for循环" class="headerlink" title="1.5 循环结构：for循环"></a>1.5 循环结构：for循环</h3><h4 id="for循环结构（掌握）"><a href="#for循环结构（掌握）" class="headerlink" title="for循环结构（掌握）"></a>for循环结构（掌握）</h4><ul><li><p>循环：</p><p>循环语句可以在满足循环条件的情况下，反复执行某一段代码，这段被重复执行的代码被称为循环体语句，当反复 执行这个循环体时，需要在合适的时候把循环判断条件修改为false，从而结束循环，否则循环将一直执行下去，形 成死循环。 </p></li><li><p>for循环格式：</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (初始化语句;条件判断语句;条件控制语句) &#123;</span><br><span class="line">循环体语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>格式解释：</p><ul><li>初始化语句：  用于表示循环开启时的起始状态，简单说就是循环开始的时候什么样</li><li>条件判断语句：用于表示循环反复执行的条件，简单说就是判断循环是否能一直执行下去</li><li>循环体语句：  用于表示循环反复执行的内容，简单说就是循环反复执行的事情</li><li>条件控制语句：用于表示循环执行中每次变化的内容，简单说就是控制循环是否能执行下去</li></ul></li><li><p>执行流程：</p><p>①执行初始化语句</p><p>②执行条件判断语句，看其结果是true还是false</p><p>​             如果是false，循环结束</p><p>​             如果是true，继续执行</p><p>③执行循环体语句</p><p>④执行条件控制语句</p><p>⑤回到②继续</p></li></ul><h4 id="for循环练习-输出数据（应用）"><a href="#for循环练习-输出数据（应用）" class="headerlink" title="for循环练习-输出数据（应用）"></a>for循环练习-输出数据（应用）</h4><ul><li>需求：在控制台输出1-5和5-1的数据 </li><li>示例代码：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForTest01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//需求：输出数据1-5</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line"><span class="comment">//需求：输出数据5-1</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">5</span>; i&gt;=<span class="number">1</span>; i--) &#123;</span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="for循环练习-求和（应用）"><a href="#for循环练习-求和（应用）" class="headerlink" title="for循环练习-求和（应用）"></a>for循环练习-求和（应用）</h4><ul><li>需求：求1-5之间的数据和，并把求和结果在控制台输出  </li><li>示例代码：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForTest02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//求和的最终结果必须保存起来，需要定义一个变量，用于保存求和的结果，初始值为0</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//从1开始到5结束的数据，使用循环结构完成</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line"><span class="comment">//将反复进行的事情写入循环结构内部</span></span><br><span class="line">             <span class="comment">// 此处反复进行的事情是将数据 i 加到用于保存最终求和的变量 sum 中</span></span><br><span class="line">sum += i;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sum += i;sum = sum + i;</span></span><br><span class="line"><span class="comment">第一次：sum = sum + i = 0 + 1 = 1;</span></span><br><span class="line"><span class="comment">第二次：sum = sum + i = 1 + 2 = 3;</span></span><br><span class="line"><span class="comment">第三次：sum = sum + i = 3 + 3 = 6;</span></span><br><span class="line"><span class="comment">第四次：sum = sum + i = 6 + 4 = 10;</span></span><br><span class="line"><span class="comment">第五次：sum = sum + i = 10 + 5 = 15;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当循环执行完毕时，将最终数据打印出来</span></span><br><span class="line">System.out.println(<span class="string">&quot;1-5之间的数据和是：&quot;</span> + sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>本题要点：<ul><li>今后遇到的需求中，如果带有求和二字，请立即联想到求和变量</li><li>求和变量的定义位置，必须在循环外部，如果在循环内部则计算出的数据将是错误的</li></ul></li></ul><h4 id="for循环练习-求偶数和（应用）"><a href="#for循环练习-求偶数和（应用）" class="headerlink" title="for循环练习-求偶数和（应用）"></a>for循环练习-求偶数和（应用）</h4><ul><li>需求：求1-100之间的偶数和，并把求和结果在控制台输出 }</li><li>示例代码：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForTest03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//求和的最终结果必须保存起来，需要定义一个变量，用于保存求和的结果，初始值为0</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//对1-100的数据求和与1-5的数据求和几乎完全一样，仅仅是结束条件不同</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">100</span>; i++) &#123;</span><br><span class="line"><span class="comment">//对1-100的偶数求和，需要对求和操作添加限制条件，判断是否是偶数</span></span><br><span class="line"><span class="keyword">if</span>(i%<span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">sum += i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当循环执行完毕时，将最终数据打印出来</span></span><br><span class="line">System.out.println(<span class="string">&quot;1-100之间的偶数和是：&quot;</span> + sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="for循环练习-水仙花（应用）"><a href="#for循环练习-水仙花（应用）" class="headerlink" title="for循环练习-水仙花（应用）"></a>for循环练习-水仙花（应用）</h4><ul><li>需求：在控制台输出所有的“水仙花数” </li><li>解释：什么是水仙花数？<ul><li>水仙花数，指的是一个三位数，个位、十位、百位的数字立方和等于原数<ul><li>例如<code>153  3*3*3 + 5*5*5 + 1*1*1 = 153</code></li></ul></li></ul></li><li>思路：<ol><li>获取所有的三位数，准备进行筛选，最小的三位数为100，最大的三位数为999，使用for循环获取</li><li>获取每一个三位数的个位，十位，百位，做if语句判断是否是水仙花数</li></ol></li><li>示例代码</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForTest04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//输出所有的水仙花数必然要使用到循环，遍历所有的三位数，三位数从100开始，到999结束</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">100</span>; i&lt;<span class="number">1000</span>; i++) &#123;</span><br><span class="line"><span class="comment">//在计算之前获取三位数中每个位上的值</span></span><br><span class="line"><span class="type">int</span> <span class="variable">ge</span> <span class="operator">=</span> i%<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">shi</span> <span class="operator">=</span> i/<span class="number">10</span>%<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">bai</span> <span class="operator">=</span> i/<span class="number">10</span>/<span class="number">10</span>%<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判定条件是将三位数中的每个数值取出来，计算立方和后与原始数字比较是否相等</span></span><br><span class="line"><span class="keyword">if</span>(ge*ge*ge + shi*shi*shi + bai*bai*bai == i) &#123;</span><br><span class="line"><span class="comment">//输出满足条件的数字就是水仙花数</span></span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="for循环练习-统计水仙花数个数（应用）"><a href="#for循环练习-统计水仙花数个数（应用）" class="headerlink" title="for循环练习-统计水仙花数个数（应用）"></a>for循环练习-统计水仙花数个数（应用）</h4><ul><li>需求：统计“水仙花数”一共有多少个，并在控制台输出个数 </li><li>示例代码：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForTest05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//定义变量count，用于保存“水仙花数”的数量，初始值为0</span></span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//输出所有的水仙花数必然要使用到循环，遍历所有的三位数，三位数从100开始，到999结束</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">100</span>; i&lt;<span class="number">1000</span>; i++) &#123;</span><br><span class="line"><span class="comment">//在计算之前获取三位数中每个位上的值</span></span><br><span class="line"><span class="type">int</span> <span class="variable">ge</span> <span class="operator">=</span> i%<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">shi</span> <span class="operator">=</span> i/<span class="number">10</span>%<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">bai</span> <span class="operator">=</span> i/<span class="number">10</span>/<span class="number">10</span>%<span class="number">10</span>;</span><br><span class="line"><span class="comment">//在判定水仙花数的过程中，满足条件不再输出，更改为修改count的值，使count+1</span></span><br><span class="line"><span class="keyword">if</span>(ge*ge*ge + shi*shi*shi + bai*bai*bai == i) &#123;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印输出最终结果</span></span><br><span class="line">System.out.println(<span class="string">&quot;水仙花共有：&quot;</span> + count + <span class="string">&quot;个&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>本题要点：<ul><li>今后如果需求带有统计xxx，请先想到计数器变量</li><li>计数器变量定义的位置，必须在循环外部</li></ul></li></ul><h3 id="1-6-循环结构：-while循环"><a href="#1-6-循环结构：-while循环" class="headerlink" title="1.6 循环结构： while循环"></a>1.6 循环结构： while循环</h3><h4 id="while结构（掌握）"><a href="#while结构（掌握）" class="headerlink" title="while结构（掌握）"></a>while结构（掌握）</h4><ul><li><p>while循环完整格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">初始化语句;</span><br><span class="line"><span class="keyword">while</span> (条件判断语句) &#123;</span><br><span class="line">循环体语句;</span><br><span class="line">    条件控制语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>while循环执行流程：</p><p>①执行初始化语句</p><p>②执行条件判断语句，看其结果是true还是false</p><p>​             如果是false，循环结束</p><p>​             如果是true，继续执行</p><p>③执行循环体语句</p><p>④执行条件控制语句</p><p>⑤回到②继续</p></li><li><p>示例代码：</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WhileDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//需求：在控制台输出5次&quot;HelloWorld&quot;</span></span><br><span class="line"><span class="comment">//for循环实现</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;HelloWorld&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line"><span class="comment">//while循环实现</span></span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(j&lt;=<span class="number">5</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;HelloWorld&quot;</span>);</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="while循环练习-珠穆朗玛峰（应用）"><a href="#while循环练习-珠穆朗玛峰（应用）" class="headerlink" title="while循环练习-珠穆朗玛峰（应用）"></a>while循环练习-珠穆朗玛峰（应用）</h4><ul><li>需求：世界最高山峰是珠穆朗玛峰(8844.43米&#x3D;8844430毫米)，假如我有一张足够大的纸，它的厚度是0.1毫米。请问，我折叠多少次，可以折成珠穆朗玛峰的高度?</li><li>示例代码：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WhileTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//定义一个计数器，初始值为0</span></span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//定义纸张厚度</span></span><br><span class="line"><span class="type">double</span> <span class="variable">paper</span> <span class="operator">=</span> <span class="number">0.1</span>;</span><br><span class="line"><span class="comment">//定义珠穆朗玛峰的高度</span></span><br><span class="line"><span class="type">int</span> <span class="variable">zf</span> <span class="operator">=</span> <span class="number">8844430</span>;</span><br><span class="line"><span class="comment">//因为要反复折叠，所以要使用循环，但是不知道折叠多少次，这种情况下更适合使用while循环</span></span><br><span class="line"><span class="comment">//折叠的过程中当纸张厚度大于珠峰就停止了，因此继续执行的要求是纸张厚度小于珠峰高度</span></span><br><span class="line"><span class="keyword">while</span>(paper &lt;= zf) &#123;</span><br><span class="line"><span class="comment">//循环的执行过程中每次纸张折叠，纸张的厚度要加倍</span></span><br><span class="line">paper *= <span class="number">2</span>;</span><br><span class="line"><span class="comment">//在循环中执行累加，对应折叠了多少次</span></span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印计数器的值</span></span><br><span class="line">System.out.println(<span class="string">&quot;需要折叠：&quot;</span> + count + <span class="string">&quot;次&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-7-循环结构：do-while循环"><a href="#1-7-循环结构：do-while循环" class="headerlink" title="1.7 循环结构：do-while循环"></a>1.7 循环结构：do-while循环</h3><h4 id="do…while循环结构（掌握）"><a href="#do…while循环结构（掌握）" class="headerlink" title="do…while循环结构（掌握）"></a>do…while循环结构（掌握）</h4><ul><li><p>完整格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">初始化语句;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">循环体语句;</span><br><span class="line">条件控制语句;</span><br><span class="line">&#125;<span class="keyword">while</span>(条件判断语句);</span><br></pre></td></tr></table></figure></li><li><p>执行流程：</p><p>① 执行初始化语句</p><p>② 执行循环体语句</p><p>③ 执行条件控制语句</p><p>④ 执行条件判断语句，看其结果是true还是false</p><p>如果是false，循环结束</p><p>如果是true，继续执行</p><p>⑤ 回到②继续</p></li><li><p>示例代码：</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoWhileDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//需求：在控制台输出5次&quot;HelloWorld&quot;</span></span><br><span class="line"><span class="comment">//for循环实现</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;HelloWorld&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line"><span class="comment">//do...while循环实现</span></span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;HelloWorld&quot;</span>);</span><br><span class="line">j++;</span><br><span class="line">&#125;<span class="keyword">while</span>(j&lt;=<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-8-三种循环的区别（理解）"><a href="#1-8-三种循环的区别（理解）" class="headerlink" title="1.8 三种循环的区别（理解）"></a>1.8 三种循环的区别（理解）</h3><ul><li>三种循环的区别<ul><li>for循环和while循环先判断条件是否成立，然后决定是否执行循环体（先判断后执行）</li><li>do…while循环先执行一次循环体，然后判断条件是否成立，是否继续执行循环体（先执行后判断）</li></ul></li><li>for循环和while的区别<ul><li>条件控制语句所控制的自增变量，因为归属for循环的语法结构中，在for循环结束后，就不能再次被访问到了</li><li>条件控制语句所控制的自增变量，对于while循环来说不归属其语法结构中，在while循环结束后，该变量还可以继续使用</li></ul></li><li>死循环（无限循环）的三种格式<ol><li>for(;;){}</li><li>while(true){}</li><li>do {} while(true);</li></ol></li></ul><h3 id="1-9-跳转控制语句（掌握）"><a href="#1-9-跳转控制语句（掌握）" class="headerlink" title="1.9  跳转控制语句（掌握）"></a>1.9  跳转控制语句（掌握）</h3><ul><li>跳转控制语句（break）<ul><li>跳出循环，结束循环</li></ul></li><li>跳转控制语句（continue）<ul><li>跳过本次循环，继续下次循环</li></ul></li><li>注意： continue只能在循环中进行使用！</li></ul><h3 id="1-10-循环嵌套（理解）"><a href="#1-10-循环嵌套（理解）" class="headerlink" title="1.10 循环嵌套（理解）"></a>1.10 循环嵌套（理解）</h3><ul><li><p>循环嵌套概述：在循环中，继续定义循环</p></li><li><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="comment">//外循环控制小时的范围，内循环控制分钟的范围</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">hour</span> <span class="operator">=</span> <span class="number">0</span>; hour &lt; <span class="number">24</span>; hour++) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">minute</span> <span class="operator">=</span> <span class="number">0</span>; minute &lt; <span class="number">60</span>; minute++) &#123;</span><br><span class="line">               System.out.println(hour + <span class="string">&quot;时&quot;</span> + minute + <span class="string">&quot;分&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>理解：</p><ul><li>请反复理解这句话（整个内循环，就是外循环的一个循环体，内部循环体没有执行完毕，外循环是不会继续向下执行的）</li></ul></li><li><p>结论：</p><ul><li>外循环执行一次，内循环执行一圈</li></ul></li></ul><h3 id="1-11-Random"><a href="#1-11-Random" class="headerlink" title="1.11 Random"></a>1.11 Random</h3><h4 id="Random产生随机数（掌握）"><a href="#Random产生随机数（掌握）" class="headerlink" title="Random产生随机数（掌握）"></a>Random产生随机数（掌握）</h4><ul><li><p>概述：</p><ul><li>Random类似Scanner，也是Java提供好的API，内部提供了产生随机数的功能<ul><li>API后续课程详细讲解，现在可以简单理解为Java已经写好的代码</li></ul></li></ul></li><li><p>使用步骤：</p><ol><li><p>导入包</p><p>import java.util.Random;</p></li><li><p>创建对象</p><p>Random r &#x3D; new Random();</p></li><li><p>产生随机数</p><p>int num &#x3D; r.nextInt(10);</p><p>解释： 10代表的是一个范围，如果括号写10，产生的随机数就是0-9，括号写20，参数的随机数则是0-19</p></li></ol></li><li><p>示例代码：</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RandomDemo</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//创建对象</span></span><br><span class="line"><span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"><span class="comment">//用循环获取10个随机数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line"><span class="comment">//获取随机数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> r.nextInt(<span class="number">10</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;number:&quot;</span> + number);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//需求：获取一个1-100之间的随机数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> r.nextInt(<span class="number">100</span>) + <span class="number">1</span>;</span><br><span class="line">System.out.println(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Random练习-猜数字（应用）"><a href="#Random练习-猜数字（应用）" class="headerlink" title="Random练习-猜数字（应用）"></a>Random练习-猜数字（应用）</h4><ul><li><p>需求：</p><p>程序自动生成一个1-100之间的数字，使用程序实现猜出这个数字是多少？</p><p>当猜错的时候根据不同情况给出相应的提示</p><p>A. 如果猜的数字比真实数字大，提示你猜的数据大了</p><p>B. 如果猜的数字比真实数字小，提示你猜的数据小了</p><p>C. 如果猜的数字与真实数字相等，提示恭喜你猜中了</p></li><li><p>示例代码：</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RandomTest</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//要完成猜数字的游戏，首先需要有一个要猜的数字，使用随机数生成该数字，范围1到100</span></span><br><span class="line"><span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"><span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> r.nextInt(<span class="number">100</span>) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="comment">//使用程序实现猜数字，每次均要输入猜测的数字值，需要使用键盘录入实现</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;请输入你要猜的数字：&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">guessNumber</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"></span><br><span class="line"><span class="comment">//比较输入的数字和系统产生的数据，需要使用分支语句。</span></span><br><span class="line">             <span class="comment">//这里使用if..else..if..格式，根据不同情况进行猜测结果显示</span></span><br><span class="line"><span class="keyword">if</span>(guessNumber &gt; number) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;你猜的数字&quot;</span> + guessNumber + <span class="string">&quot;大了&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(guessNumber &lt; number) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;你猜的数字&quot;</span> + guessNumber + <span class="string">&quot;小了&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;恭喜你猜中了&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> java,基础语法,循环 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>day02 - Java基础语法</title>
      <link href="/post/87265b95.html"/>
      <url>/post/87265b95.html</url>
      
        <content type="html"><![CDATA[<h1 id="day02-Java基础语法"><a href="#day02-Java基础语法" class="headerlink" title="day02 - Java基础语法"></a>day02 - Java基础语法</h1><h2 id="类型转换问题"><a href="#类型转换问题" class="headerlink" title="类型转换问题"></a>类型转换问题</h2><h4 id="类型转换（理解）"><a href="#类型转换（理解）" class="headerlink" title="类型转换（理解）"></a>类型转换（理解）</h4><p>在Java中，会存在不同类型的数据需要一起参与运算，所以这些数据类型之间是需要相互转换的，分为两种情况：自动类型转换和强制类型转换。</p><h4 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h4><p><strong>类型范围小</strong>的变量，可以<strong>直接赋值</strong>给<strong>类型范围大</strong>的变量。</p><p>把一个表示数据范围小的数值或者变量赋值给另一个表示数据范围大的变量。这种转换方式是自动的，直接书写即可。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// 将int类型的10直接赋值给double类型</span></span><br><span class="line">System.out.println(num); <span class="comment">// 输出10.0</span></span><br><span class="line"></span><br><span class="line"><span class="type">byte</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">12</span> ;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a;</span><br><span class="line">System.out.println(b); <span class="comment">// 12</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="表达式的自动类型转换"><a href="#表达式的自动类型转换" class="headerlink" title="表达式的自动类型转换"></a><strong>表达式的自动类型转换</strong></h4><p>在表达式中，小范围类型的变量会自动转换成当前较大范围的类型再运算。</p><p><strong>注意事项：</strong></p><p><strong>表达式的最终结果类型由表达式中的最高类型决定</strong>。</p><p>在表达式中，byte、short、char 是直接转换成int类型参与运算的。 </p><h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><p>类型范围大的数据或者变量，不能直接<strong>赋值</strong>给<strong>类型范围小</strong>的变量，会报错，把一个表示数据范围大的数值或者变量赋值给另一个表示数据范围小的变量必须进行强制类型转换。</p><p>强制类型转换格式：目标数据类型 变量名 &#x3D; (目标数据类型)值或者变量;</p><p>​例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">5.5</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> (<span class="type">int</span>) num1; <span class="comment">// 将double类型的num1强制转换为int类型</span></span><br><span class="line">System.out.println(num2); <span class="comment">// 输出5（小数位直接舍弃）</span></span><br></pre></td></tr></table></figure><p>说明：</p><ol><li>char类型的数据转换为int类型是按照码表中对应的int值进行计算的。比如在ASCII码表中，’a’对应97。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">System.out.println(x); <span class="comment">// 将输出97</span></span><br></pre></td></tr></table></figure><ol start="2"><li>整数默认是int类型，byte、short和char类型数据参与运算均会自动转换为int类型。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">b3</span> <span class="operator">=</span> b1 + b2; </span><br><span class="line"><span class="comment">// 第三行代码会报错，b1和b2会自动转换为int类型，计算结果为int，int赋值给byte需要强制类型转换。</span></span><br><span class="line"><span class="comment">// 修改为:</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> b1 + b2;</span><br><span class="line"><span class="comment">// 或者：</span></span><br><span class="line"><span class="type">byte</span> <span class="variable">b3</span> <span class="operator">=</span> (<span class="type">byte</span>) (b1 + b2);</span><br></pre></td></tr></table></figure><ol><li>boolean类型不能与其他基本数据类型相互转换。</li></ol><h2 id="1-运算符"><a href="#1-运算符" class="headerlink" title="1. 运算符"></a>1. 运算符</h2><h3 id="1-1-算术运算符（理解）"><a href="#1-1-算术运算符（理解）" class="headerlink" title="1.1 算术运算符（理解）"></a>1.1 算术运算符（理解）</h3><h4 id="1-1-1-运算符和表达式"><a href="#1-1-1-运算符和表达式" class="headerlink" title="1.1.1 运算符和表达式"></a>1.1.1 运算符和表达式</h4><p>运算符：对常量或者变量进行操作的符号</p><p>表达式：用运算符把常量或者变量连接起来符合java语法的式子就可以称为表达式。</p><p>​                    不同运算符连接的表达式体现的是不同类型的表达式。</p><p>举例说明：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + b;</span><br></pre></td></tr></table></figure><p>  +：是运算符，并且是算术运算符。</p><p>  a + b：是表达式，由于+是算术运算符，所以这个表达式叫算术表达式。</p><h4 id="1-1-2-算术运算符"><a href="#1-1-2-算术运算符" class="headerlink" title="1.1.2 算术运算符"></a>1.1.2 算术运算符</h4><table><thead><tr><th>符号</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td>+</td><td>加</td><td>参看小学一年级</td></tr><tr><td>-</td><td>减</td><td>参看小学一年级</td></tr><tr><td>*</td><td>乘</td><td>参看小学二年级，与“×”相同</td></tr><tr><td>&#x2F;</td><td>除</td><td>参看小学二年级，与“÷”相同</td></tr><tr><td>%</td><td>取余</td><td>获取的是两个数据做除法的余数</td></tr></tbody></table><p>注意：</p><p>&#x2F;和%的区别：两个数据做除法，&#x2F;取结果的商，%取结果的余数。</p><p>整数操作只能得到整数，要想得到小数，必须有浮点数参与运算。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">System.out.println(a / b); <span class="comment">// 输出结果3</span></span><br><span class="line">System.out.println(a % b); <span class="comment">// 输出结果1</span></span><br></pre></td></tr></table></figure><h4 id="1-1-3-字符的“-”操作"><a href="#1-1-3-字符的“-”操作" class="headerlink" title="1.1.3 字符的“+”操作"></a>1.1.3 字符的“+”操作</h4><p>char类型参与算术运算，使用的是计算机底层对应的十进制数值。需要我们记住三个字符对应的数值：</p><p>‘a’  –  97a-z是连续的，所以’b’对应的数值是98，’c’是99，依次递加</p><p>‘A’  –  65A-Z是连续的，所以’B’对应的数值是66，’C’是67，依次递加</p><p>‘0’  –  480-9是连续的，所以’1’对应的数值是49，’2’是50，依次递加</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以通过使用字符与整数做算术运算，得出字符对应的数值是多少</span></span><br><span class="line"><span class="type">char</span> <span class="variable">ch1</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">System.out.println(ch1 + <span class="number">1</span>); <span class="comment">// 输出98，97 + 1 = 98</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> <span class="variable">ch2</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">System.out.println(ch2 + <span class="number">1</span>); <span class="comment">// 输出66，65 + 1 = 66</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> <span class="variable">ch3</span> <span class="operator">=</span> <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">System.out.println(ch3 + <span class="number">1</span>); <span class="comment">// 输出49，48 + 1 = 49</span></span><br></pre></td></tr></table></figure><p>算术表达式中包含不同的基本数据类型的值的时候，整个算术表达式的类型会自动进行提升。</p><p>提升规则：</p><p>byte类型，short类型和char类型将被提升到int类型，不管是否有其他类型参与运算。</p><p>整个表达式的类型自动提升到与表达式中最高等级的操作数相同的类型</p><p>​       等级顺序：byte,short,char –&gt; int –&gt; long –&gt; float –&gt; double</p><p>例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="comment">// byte b3 = b1 + b2; // 该行报错，因为byte类型参与算术运算会自动提示为int，int赋值给byte可能损失精度</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i3</span> <span class="operator">=</span> b1 + b2; <span class="comment">// 应该使用int接收</span></span><br><span class="line"><span class="type">byte</span> <span class="variable">b3</span> <span class="operator">=</span> (<span class="type">byte</span>) (b1 + b2); <span class="comment">// 或者将结果强制转换为byte类型</span></span><br><span class="line">-------------------------------</span><br><span class="line"><span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">20.0</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">num3</span> <span class="operator">=</span> num1 + num2; <span class="comment">// 使用double接收，因为num1会自动提升为double类型</span></span><br></pre></td></tr></table></figure><p>tips：正是由于上述原因，所以在程序开发中我们很少使用byte或者short类型定义整数。也很少会使用char类型定义字符，而使用字符串类型，更不会使用char类型做算术运算。</p><h4 id="1-1-4-字符串的“-”操作"><a href="#1-1-4-字符串的“-”操作" class="headerlink" title="1.1.4 字符串的“+”操作"></a>1.1.4 字符串的“+”操作</h4><p>当“+”操作中出现字符串时，这个”+”是字符串连接符，而不是算术运算。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;java_yes&quot;</span>+ <span class="number">666</span>); <span class="comment">// 输出：java_yes666</span></span><br></pre></td></tr></table></figure><p>在”+”操作中，如果出现了字符串，就是连接运算符，否则就是算术运算。当连续进行“+”操作时，从左到右逐个执行。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="number">1</span> + <span class="number">99</span> + <span class="string">&quot;年&quot;</span>); <span class="comment">// 输出：199年</span></span><br><span class="line">System.out.println(<span class="number">1</span> + <span class="number">2</span> + <span class="string">&quot;itjava_test&quot;</span> + <span class="number">3</span> + <span class="number">4</span>); <span class="comment">// 输出：3itjava_test34</span></span><br><span class="line"><span class="comment">// 可以使用小括号改变运算的优先级 </span></span><br><span class="line">System.out.println(<span class="number">1</span> + <span class="number">2</span> + <span class="string">&quot;itjava_test&quot;</span> + (<span class="number">3</span> + <span class="number">4</span>)); <span class="comment">// 输出：3itjava_test7</span></span><br></pre></td></tr></table></figure><h3 id="1-2-赋值运算符（应用）"><a href="#1-2-赋值运算符（应用）" class="headerlink" title="1.2 赋值运算符（应用）"></a>1.2 赋值运算符（应用）</h3><p>赋值运算符的作用是将一个表达式的值赋给左边，左边必须是可修改的，不能是常量。</p><table><thead><tr><th>符号</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td>&#x3D;</td><td>赋值</td><td>a&#x3D;10，将10赋值给变量a</td></tr><tr><td>+&#x3D;</td><td>加后赋值</td><td>a+&#x3D;b，将a+b的值给a</td></tr><tr><td>-&#x3D;</td><td>减后赋值</td><td>a-&#x3D;b，将a-b的值给a</td></tr><tr><td>*&#x3D;</td><td>乘后赋值</td><td>a*&#x3D;b，将a×b的值给a</td></tr><tr><td>&#x2F;&#x3D;</td><td>除后赋值</td><td>a&#x2F;&#x3D;b，将a÷b的商给a</td></tr><tr><td>%&#x3D;</td><td>取余后赋值</td><td>a%&#x3D;b，将a÷b的余数给a</td></tr></tbody></table><p>注意：</p><p>扩展的赋值运算符隐含了强制类型转换。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">short</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">s = s + <span class="number">10</span>; <span class="comment">// 此行代码报出，因为运算中s提升为int类型，运算结果int赋值给short可能损失精度</span></span><br><span class="line"></span><br><span class="line">s += <span class="number">10</span>; <span class="comment">// 此行代码没有问题，隐含了强制类型转换，相当于 s = (short) (s + 10);</span></span><br></pre></td></tr></table></figure><h3 id="1-3-自增自减运算符（理解）"><a href="#1-3-自增自减运算符（理解）" class="headerlink" title="1.3 自增自减运算符（理解）"></a>1.3 自增自减运算符（理解）</h3><table><thead><tr><th>符号</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td>++</td><td>自增</td><td>变量的值加1</td></tr><tr><td>–</td><td>自减</td><td>变量的值减1</td></tr></tbody></table><p>注意事项：</p><p>​++和– 既可以放在变量的后边，也可以放在变量的前边。</p><p>​单独使用的时候， ++和– 无论是放在变量的前边还是后边，结果是一样的。</p><p>​参与操作的时候，如果放在变量的后边，先拿变量参与操作，后拿变量做++或者–。</p><p>​参与操作的时候，如果放在变量的前边，先拿变量做++或者–，后拿变量参与操作。</p><p>​最常见的用法：单独使用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">i++; <span class="comment">// 单独使用</span></span><br><span class="line">System.out.println(<span class="string">&quot;i:&quot;</span> + i); <span class="comment">// i:11</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">++j; <span class="comment">// 单独使用</span></span><br><span class="line">System.out.println(<span class="string">&quot;j:&quot;</span> + j); <span class="comment">// j:11</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> x++; <span class="comment">// 赋值运算，++在后边，所以是使用x原来的值赋值给y，x本身自增1</span></span><br><span class="line">System.out.println(<span class="string">&quot;x:&quot;</span> + x + <span class="string">&quot;, y:&quot;</span> + y); <span class="comment">// x:11，y:10</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> ++m; <span class="comment">// 赋值运算，++在前边，所以是使用m自增后的值赋值给n，m本身自增1</span></span><br><span class="line">System.out.println(<span class="string">&quot;m:&quot;</span> + m + <span class="string">&quot;, m:&quot;</span> + m); <span class="comment">// m:11，m:11</span></span><br></pre></td></tr></table></figure><p>练习：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> x++ + x++ + x++;</span><br><span class="line">System.out.println(y); <span class="comment">// y的值是多少？</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">解析，三个表达式都是++在后，所以每次使用的都是自增前的值，但程序自左至右执行，所以第一次自增时，使用的是10进行计算，但第二次自增时，x的值已经自增到11了，所以第二次使用的是11，然后再次自增。。。</span></span><br><span class="line"><span class="comment">所以整个式子应该是：int y = 10 + 11 + 12;</span></span><br><span class="line"><span class="comment">输出结果为33。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">注意：通过此练习深刻理解自增和自减的规律，但实际开发中强烈建议不要写这样的代码！小心挨打！</span><br></pre></td></tr></table></figure><h3 id="1-4-关系运算符（应用）"><a href="#1-4-关系运算符（应用）" class="headerlink" title="1.4 关系运算符（应用）"></a>1.4 关系运算符（应用）</h3><p>关系运算符有6种关系，分别为小于、小于等于、大于、等于、大于等于、不等于。</p><table><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody><tr><td>&#x3D;&#x3D;</td><td>a&#x3D;&#x3D;b，判断a和b的值是否相等，成立为true，不成立为false</td></tr><tr><td>!&#x3D;</td><td>a!&#x3D;b，判断a和b的值是否不相等，成立为true，不成立为false</td></tr><tr><td>&gt;</td><td>a&gt;b，判断a是否大于b，成立为true，不成立为false</td></tr><tr><td>&gt;&#x3D;</td><td>a&gt;&#x3D;b，判断a是否大于等于b，成立为true，不成立为false</td></tr><tr><td>&lt;</td><td>a&lt;b，判断a是否小于b，成立为true，不成立为false</td></tr><tr><td>&lt;&#x3D;</td><td>a&lt;&#x3D;b，判断a是否小于等于b，成立为true，不成立为false</td></tr></tbody></table><p>注意事项：</p><p>​关系运算符的结果都是boolean类型，要么是true，要么是false。</p><p>​千万不要把“&#x3D;&#x3D;”误写成“&#x3D;”，”&#x3D;&#x3D;”是判断是否相等的关系，”&#x3D;”是赋值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">System.out.println(a == b); <span class="comment">// false</span></span><br><span class="line">System.out.println(a != b); <span class="comment">// true</span></span><br><span class="line">System.out.println(a &gt; b); <span class="comment">// false</span></span><br><span class="line">System.out.println(a &gt;= b); <span class="comment">// false</span></span><br><span class="line">System.out.println(a &lt; b); <span class="comment">// true</span></span><br><span class="line">System.out.println(a &lt;= b); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 关系运算的结果肯定是boolean类型，所以也可以将运算结果赋值给boolean类型的变量</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> a &gt; b;</span><br><span class="line">System.out.println(flag); <span class="comment">// 输出false</span></span><br></pre></td></tr></table></figure><h3 id="1-5-逻辑运算符（应用）"><a href="#1-5-逻辑运算符（应用）" class="headerlink" title="1.5 逻辑运算符（应用）"></a>1.5 逻辑运算符（应用）</h3><p>逻辑运算符把各个运算的关系表达式连接起来组成一个复杂的逻辑表达式，以判断程序中的表达式是否成立，判断的结果是 true 或 false。</p><table><thead><tr><th>符号</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td>&amp;</td><td>逻辑与</td><td>a&amp;b，a和b都是true，结果为true，否则为false</td></tr><tr><td>|</td><td>逻辑或</td><td>a|b，a和b都是false，结果为false，否则为true</td></tr><tr><td>^</td><td>逻辑异或</td><td>a^b，a和b结果不同为true，相同为false</td></tr><tr><td>!</td><td>逻辑非</td><td>!a，结果和a的结果正好相反</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义变量</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//&amp; “与”，并且的关系，只要表达式中有一个值为false，结果即为false</span></span><br><span class="line">System.out.println((i &gt; j) &amp; (i &gt; k)); <span class="comment">//false &amp; false,输出false</span></span><br><span class="line">System.out.println((i &lt; j) &amp; (i &gt; k)); <span class="comment">//true &amp; false,输出false</span></span><br><span class="line">System.out.println((i &gt; j) &amp; (i &lt; k)); <span class="comment">//false &amp; true,输出false</span></span><br><span class="line">System.out.println((i &lt; j) &amp; (i &lt; k)); <span class="comment">//true &amp; true,输出true</span></span><br><span class="line">System.out.println(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//| “或”，或者的关系，只要表达式中有一个值为true，结果即为true</span></span><br><span class="line">System.out.println((i &gt; j) | (i &gt; k)); <span class="comment">//false | false,输出false</span></span><br><span class="line">System.out.println((i &lt; j) | (i &gt; k)); <span class="comment">//true | false,输出true</span></span><br><span class="line">System.out.println((i &gt; j) | (i &lt; k)); <span class="comment">//false | true,输出true</span></span><br><span class="line">System.out.println((i &lt; j) | (i &lt; k)); <span class="comment">//true | true,输出true</span></span><br><span class="line">System.out.println(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//^ “异或”，相同为false，不同为true</span></span><br><span class="line">System.out.println((i &gt; j) ^ (i &gt; k)); <span class="comment">//false ^ false,输出false</span></span><br><span class="line">System.out.println((i &lt; j) ^ (i &gt; k)); <span class="comment">//true ^ false,输出true</span></span><br><span class="line">System.out.println((i &gt; j) ^ (i &lt; k)); <span class="comment">//false ^ true,输出true</span></span><br><span class="line">System.out.println((i &lt; j) ^ (i &lt; k)); <span class="comment">//true ^ true,输出false</span></span><br><span class="line">System.out.println(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//! “非”，取反</span></span><br><span class="line">System.out.println((i &gt; j)); <span class="comment">//false</span></span><br><span class="line">System.out.println(!(i &gt; j)); <span class="comment">//!false，,输出true</span></span><br></pre></td></tr></table></figure><h4 id="短路逻辑运算符"><a href="#短路逻辑运算符" class="headerlink" title="短路逻辑运算符"></a>短路逻辑运算符</h4><table><thead><tr><th>符号</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td>&amp;&amp;</td><td>短路与</td><td>作用和&amp;相同，但是有短路效果</td></tr><tr><td>||</td><td>短路或</td><td>作用和|相同，但是有短路效果</td></tr></tbody></table><p>在逻辑与运算中，只要有一个表达式的值为false，那么结果就可以判定为false了，没有必要将所有表达式的值都计算出来，短路与操作就有这样的效果，可以提高效率。同理在逻辑或运算中，一旦发现值为true，右边的表达式将不再参与运算。</p><ul><li><p>逻辑与&amp;，无论左边真假，右边都要执行。</p></li><li><p>短路与&amp;&amp;，如果左边为真，右边执行；如果左边为假，右边不执行。</p></li><li><p>逻辑或|，无论左边真假，右边都要执行。</p></li><li><p>短路或||，如果左边为假，右边执行；如果左边为真，右边不执行。</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">System.out.println((x++ &gt; <span class="number">4</span>) &amp; (y++ &gt; <span class="number">5</span>)); <span class="comment">// 两个表达都会运算</span></span><br><span class="line">System.out.println(x); <span class="comment">// 4</span></span><br><span class="line">System.out.println(y); <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">System.out.println((x++ &gt; <span class="number">4</span>) &amp;&amp; (y++ &gt; <span class="number">5</span>)); <span class="comment">// 左边已经可以确定结果为false，右边不参与运算</span></span><br><span class="line">System.out.println(x); <span class="comment">// 4</span></span><br><span class="line">System.out.println(y); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><h3 id="1-6-三元运算符（理解）"><a href="#1-6-三元运算符（理解）" class="headerlink" title="1.6 三元运算符（理解）"></a>1.6 三元运算符（理解）</h3><p>三元运算符语法格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">关系表达式 ? 表达式<span class="number">1</span> : 表达式<span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>解释：问号前面的位置是判断的条件，判断结果为boolean型，为true时调用表达式1，为false时调用表达式2。其逻辑为：如果条件表达式成立或者满足则执行表达式1，否则执行第二个。</p><p>举例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a &gt; b ? a : b; <span class="comment">// 判断 a&gt;b 是否为真，如果为真取a的值，如果为假，取b的值</span></span><br></pre></td></tr></table></figure><p>三元运算符案例：</p><p>1、需求：动物园里有两只老虎，已知两只老虎的体重分别为180kg、200kg，请用程序实现判断两只老虎的体重是否相同。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OperatorTest01</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//1：定义两个变量用于保存老虎的体重，单位为kg，这里仅仅体现数值即可。</span></span><br><span class="line"><span class="type">int</span> <span class="variable">weight1</span> <span class="operator">=</span> <span class="number">180</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">weight2</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line"><span class="comment">//2：用三元运算符实现老虎体重的判断，体重相同，返回true，否则，返回false。</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> weight1 == weight2 ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//3：输出结果</span></span><br><span class="line">System.out.println(<span class="string">&quot;b:&quot;</span> + b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、需求：一座寺庙里住着三个和尚，已知他们的身高分别为150cm、210cm、165cm，请用程序实现获取这三个和尚的最高身高。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OperatorTest02</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//1：定义三个变量用于保存和尚的身高，单位为cm，这里仅仅体现数值即可。</span></span><br><span class="line"><span class="type">int</span> <span class="variable">height1</span> <span class="operator">=</span> <span class="number">150</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">height2</span> <span class="operator">=</span> <span class="number">210</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">height3</span> <span class="operator">=</span> <span class="number">165</span>;</span><br><span class="line"><span class="comment">//2：用三元运算符获取前两个和尚的较高身高值，并用临时身高变量保存起来。</span></span><br><span class="line"><span class="type">int</span> <span class="variable">tempHeight</span> <span class="operator">=</span> height1 &gt; height2 ? height1 : height2;</span><br><span class="line"><span class="comment">//3：用三元运算符获取临时身高值和第三个和尚身高较高值，并用最大身高变量保存。</span></span><br><span class="line"><span class="type">int</span> <span class="variable">maxHeight</span> <span class="operator">=</span> tempHeight &gt; height3 ? tempHeight : height3;</span><br><span class="line"><span class="comment">//4：输出结果</span></span><br><span class="line">System.out.println(<span class="string">&quot;maxHeight:&quot;</span> + maxHeight);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-数据输入（应用）"><a href="#2-数据输入（应用）" class="headerlink" title="2. 数据输入（应用）"></a>2. 数据输入（应用）</h2><p>我们可以通过 Scanner 类来获取用户的输入。使用步骤如下：</p><p>1、导包。Scanner 类在java.util包下，所以需要将该类导入。导包的语句需要定义在类的上面。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner; </span><br></pre></td></tr></table></figure><p>2、创建Scanner对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);<span class="comment">// 创建Scanner对象，sc表示变量名，其他均不可变</span></span><br></pre></td></tr></table></figure><p>3、接收数据</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> sc.nextInt(); <span class="comment">// 表示将键盘录入的值作为int数返回。</span></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScannerDemo</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//创建对象</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="comment">//接收数据</span></span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"><span class="comment">//输出数据</span></span><br><span class="line">System.out.println(<span class="string">&quot;x:&quot;</span> + x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改写三个和尚案例，数据使用键盘录入。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScannerTest</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//身高未知，采用键盘录入实现。首先导包，然后创建对象。</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="comment">//键盘录入三个身高分别赋值给三个变量。</span></span><br><span class="line">System.out.println(<span class="string">&quot;请输入第一个和尚的身高：&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">height1</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">System.out.println(<span class="string">&quot;请输入第二个和尚的身高：&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">height2</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">System.out.println(<span class="string">&quot;请输入第三个和尚的身高：&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">height3</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"><span class="comment">//用三元运算符获取前两个和尚的较高身高值，并用临时身高变量保存起来。</span></span><br><span class="line"><span class="type">int</span> <span class="variable">tempHeight</span> <span class="operator">=</span> height1 &gt; height2 ? height1 : height2;</span><br><span class="line"><span class="comment">//用三元运算符获取临时身高值和第三个和尚身高较高值，并用最大身高变量保存。</span></span><br><span class="line"><span class="type">int</span> <span class="variable">maxHeight</span> <span class="operator">=</span> tempHeight &gt; height3 ? tempHeight : height3;</span><br><span class="line"><span class="comment">//输出结果。</span></span><br><span class="line">System.out.println(<span class="string">&quot;这三个和尚中身高最高的是：&quot;</span> + maxHeight +<span class="string">&quot;cm&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IfTest02</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//小明的考试成绩未知，可以使用键盘录入的方式获取值</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">System.out.println(<span class="string">&quot;请输入一个分数：&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"><span class="comment">//由于奖励种类较多，属于多种判断，采用if...else...if格式实现</span></span><br><span class="line"><span class="comment">//为每种判断设置对应的条件</span></span><br><span class="line"><span class="comment">//为每种判断设置对应的奖励</span></span><br><span class="line"><span class="comment">//数据测试：正确数据，边界数据，错误数据</span></span><br><span class="line"><span class="keyword">if</span>(score&gt;<span class="number">100</span> || score&lt;<span class="number">0</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;你输入的分数有误&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(score&gt;=<span class="number">95</span> &amp;&amp; score&lt;=<span class="number">100</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;山地自行车一辆&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(score&gt;=<span class="number">90</span> &amp;&amp; score&lt;=<span class="number">94</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;游乐场玩一次&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(score&gt;=<span class="number">80</span> &amp;&amp; score&lt;=<span class="number">89</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;变形金刚玩具一个&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;胖揍一顿&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> java,基础语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>day01 - Java基础概述</title>
      <link href="/post/aeb1c77.html"/>
      <url>/post/aeb1c77.html</url>
      
        <content type="html"><![CDATA[<h3 id="day01-Java基础概述"><a href="#day01-Java基础概述" class="headerlink" title="day01-Java基础概述"></a>day01-Java基础概述</h3><p>点击查看概述图：<a href="https://raw.githubusercontent.com/Liooser/Liooser.github.io/main/images/index/day01-Java%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0.png">day01-Java基础概述.png (2257×4669) (raw.githubusercontent.com)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> java,面向对象进阶 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/404/index.html"/>
      <url>/404/index.html</url>
      
        <content type="html"><![CDATA[<!DOCTYPE html><html lang="en" ><head>  <meta charset="UTF-8"><title>该页面不存在-404.life</title><link rel="shortcut icon" href="favicon.ico">  <link rel="stylesheet" href="./style.css"></head><body><!-- partial:index.partial.html --><div class="main">  <div>    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1000 355">  <g id="ocean">    <path id="sky" class="st0" d="M0 0h1000v203.1H0z"/>    <linearGradient id="water_1_" gradientUnits="userSpaceOnUse" x1="500" y1="354" x2="500" y2="200.667">      <stop offset="0" stop-color="#fff"/>      <stop offset="1" stop-color="#b3dcdf"/>    </linearGradient>    <path id="water" fill="url(#water_1_)" d="M0 200.7h1000V354H0z"/>    <path id="land" class="st0" d="M0 273.4h1000V354H0z"/>    <g id="bumps">      <path class="st0" d="M0 275.2s83.8-28 180-28 197 28 197 28H0z"/>    <path class="st0" d="M377 275.2s54.7-28 117.5-28 128.6 28 128.6 28H377z"/>    <path class="st0" d="M623.2 275.2s83.7-28 179.9-28 196.9 28 196.9 28H623.2z"/>      <path class="st0" d="M-998 275.2s83.8-28 180-28 197 28 197 28h-377z"/>      <path class="st0" d="M-621 275.2s54.7-28 117.5-28 128.6 28 128.6 28H-621z"/>      <path class="st0" d="M-374.8 275.2s83.7-28 179.9-28S2 275.2 2 275.2h-376.8z"/>    </g>  </g>  <g id="tracks">    <path class="st2" d="M9.8 282.4h-3L0 307.6h3z"/>    <path class="st2" d="M19.8 282.4h-3L10 307.6h3z"/>    <path class="st2" d="M29.8 282.4h-3L20 307.6h3z"/>    <path class="st2" d="M39.8 282.4h-3L30 307.6h3z"/>    <path class="st2" d="M49.8 282.4h-3L40 307.6h3z"/>    <path class="st2" d="M59.8 282.4h-3L50 307.6h3z"/>    <path class="st2" d="M69.8 282.4h-3L60 307.6h3z"/>    <path class="st2" d="M79.8 282.4h-3L70 307.6h3z"/>    <path class="st2" d="M89.8 282.4h-3L80 307.6h3z"/>    <path class="st2" d="M99.8 282.4h-3L90 307.6h3z"/>    <path class="st2" d="M109.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M119.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M129.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M139.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M149.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M159.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M169.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M179.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M189.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M199.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M209.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M219.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M229.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M239.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M249.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M259.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M269.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M279.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M289.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M299.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M309.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M319.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M329.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M339.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M349.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M359.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M369.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M379.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M389.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M399.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M409.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M419.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M429.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M439.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M449.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M459.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M469.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M479.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M489.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M499.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M1000 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M990 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M980 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M970 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M960 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M950 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M940 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M930 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M920 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M910 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M900 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M890 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M880 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M870 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M860 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M850 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M840 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M830 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M820 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M810 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M800 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M790 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M780 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M770 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M760 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M750 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M740 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M730 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M720 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M710 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M700 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M690 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M680 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M670 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M660 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M650 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M640 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M630 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M620 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M610 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M600 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M590 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M580 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M570 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M560 282.4h-3l-6.8 25.2h3z"/>    <g>      <path class="st2" d="M-490.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-480.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-470.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-460.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-450.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-440.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-430.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-420.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-410.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-400.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-390.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-380.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-370.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-360.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-350.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-340.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-330.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-320.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-310.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-300.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-290.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-280.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-270.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-260.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-250.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-240.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-230.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-220.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-210.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-200.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-190.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-180.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-170.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-160.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-150.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-140.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-130.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-120.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-110.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-100.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-90.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-80.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-70.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-60.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-50.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-40.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-30.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-20.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-10.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M500 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M490 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M480 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M470 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M460 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M450 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M440 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M430 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M420 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M410 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M400 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M390 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M380 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M370 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M360 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M350 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M340 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M330 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M320 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M310 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M300 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M290 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M280 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M270 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M260 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M250 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M240 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M230 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M220 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M210 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M200 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M190 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M180 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M170 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M160 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M150 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M140 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M130 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M120 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M110 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M100 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M90 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M80 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M70 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M60 282.4h-3l-6.8 25.2h3z"/>    </g>    <path class="st2" d="M550 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M540 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M530 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M520 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M510 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M550 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M540 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M530 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M520 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M510 282.4h-3l-6.8 25.2h3z"/>    <path class="st3" d="M-499.5 300.2H1000v5.1H-499.5z"/>    <path class="st3" d="M-499.5 283.8H1000v2.8H-499.5z"/>  </g>  <g id="cloudsAll">    <path id="cloud1" class="st4" d="M19.5 69.7s-21.3.5-25-12.2c0 0-4.3-21.3 16-21.8 0 0-2.1-12.2 12.2-14.9 0 0 15-3.2 21.3 6.9 0 0 3.6-20.7 17.8-22.3 0 0 24-3 26.6 13.1 0 0 .1 9.5-2.8 13.5 0 0 9.5-15 26.5-4.8 0 0 12.1 7.9 7 20.2 0 0 16 4.8 10.1 18.1 0 0-10.2 8.5-17.1-1.1 0 0-5.5 16-32.5 16 0 0-19.1 2.1-27-13.3 0 0 .5 10.1-13.3 10.6-.1 0-20.3 3.2-19.8-8z"/>    <path id="cloud3" class="st4" d="M836 132s-18.3 2.1-22.2-4.9c0 0-4.9-11.8 12.5-13.8 0 0-2.5-6.8 9.7-9.6 0 0 12.7-3.1 18.7 2.1 0 0 2-12.2 14-14.3 0 0 16.6-3.3 23.7 2.1 0 0 4.8 3.9 2.4 6.5 0 0 3.1-4.8 18.4-.4 0 0 10.9 3.5 7.2 11 0 0 13.8-1.5 9.7 9.5 0 0-4.1 10.8-15.5 4.8 0 0-3.1 5.6-26.4 7.9 0 0-16.3 2.8-24-5.3 0 0 1 5.7-10.8 7.2-.1.1-17.2 3.6-17.4-2.8z"/>    <path id="cloud2" class="st4" d="M19.3 159.5s-15.9.6-18.8-5.1c0 0-3.4-9.5 11.7-10.1 0 0-1.7-5.5 9-6.9 0 0 11.2-1.7 16 2.8 0 0 2.5-9.4 13.1-10.3 0 0 17.9-1.8 20 5.4 0 0 .2 4.3-2 6.1 0 0 6.9-6.9 19.8-2.6 0 0 9.1 3.4 5.5 9 0 0 6.5 0 4.5 6.7 0 0-2.6 5.6-9.6 1 0 0-4 7.3-24.2 7.7 0 0-14.2 1.3-20.4-5.5 0 0 .5 4.5-9.8 5 0 .1-15 1.8-14.8-3.2z"/>    <path id="cloud4" class="st4" d="M370.3 109.5s15.9.6 18.8-5.1c0 0 3.4-9.5-11.7-10.1 0 0 1.7-5.5-9-6.9 0 0-11.2-1.7-16 2.8 0 0-2.5-9.4-13.1-10.3 0 0-17.9-1.8-20 5.4 0 0-.2 4.3 2 6.1 0 0-6.9-6.9-19.8-2.6 0 0-9.1 3.4-5.5 9 0 0-12 1.9-7.7 8 0 0 7.5 4 12.8-.2 0 0 4 7.3 24.2 7.7 0 0 14.2 1.3 20.4-5.5 0 0-.5 4.5 9.8 5 0 0 15.1 1.7 14.8-3.3z"/>    <path id="cloud5" class="st4" d="M511.7 12.4s-21.3-.3-25 7c0 0-4.3 12.2 16 12.5 0 0-2.1 7 12.2 8.6 0 0 15 1.8 21.3-4 0 0 3.6 11.9 17.8 12.8 0 0 19.5 1.6 27-4.4 0 0 5-4.4 2.1-6.7 0 0 4.1 4.4 21.2-1.5 0 0 12.1-4.6 7-11.6 0 0 16-2.8 10.1-10.4 0 0-10.2-4.9-17.1.6 0 0-5.5-9.2-32.5-9.2 0 0-19.1-1.2-27 7.6 0 0 .5-5.8-13.3-6.1-.1.2-20.3-1.6-19.8 4.8z"/>  </g>  <g id="train">    <path fill="#b3dcdf" d="M344.5 248.5h507.2v37.8H344.5z"/>    <g id="wheels">      <circle class="st6" cx="384.1" cy="285.6" r="15.1"/>      <path class="st2" d="M384.1 295.7c-5.6 0-10.1-4.5-10.1-10.1s4.5-10.1 10.1-10.1 10.1 4.5 10.1 10.1c0 5.5-4.6 10.1-10.1 10.1z"/>      <circle class="st6" cx="416.1" cy="285.6" r="15.1"/>      <path class="st2" d="M416.1 295.7c-5.6 0-10.1-4.5-10.1-10.1s4.5-10.1 10.1-10.1 10.1 4.5 10.1 10.1c0 5.5-4.6 10.1-10.1 10.1z"/>      <circle class="st6" cx="469.1" cy="285.6" r="15.1"/>      <path class="st2" d="M469.1 295.7c-5.6 0-10.1-4.5-10.1-10.1s4.5-10.1 10.1-10.1 10.1 4.5 10.1 10.1c0 5.5-4.6 10.1-10.1 10.1z"/>      <circle class="st6" cx="734.1" cy="285.6" r="15.1"/>      <path class="st2" d="M734.1 295.7c-5.6 0-10.1-4.5-10.1-10.1s4.5-10.1 10.1-10.1 10.1 4.5 10.1 10.1c0 5.5-4.6 10.1-10.1 10.1z"/>      <circle class="st6" cx="766.1" cy="285.6" r="15.1"/>      <path class="st2" d="M766.1 295.7c-5.6 0-10.1-4.5-10.1-10.1s4.5-10.1 10.1-10.1 10.1 4.5 10.1 10.1c0 5.5-4.6 10.1-10.1 10.1z"/>      <circle class="st6" cx="821.1" cy="285.6" r="15.1"/>      <path class="st2" d="M821.1 295.7c-5.6 0-10.1-4.5-10.1-10.1s4.5-10.1 10.1-10.1 10.1 4.5 10.1 10.1c0 5.5-4.6 10.1-10.1 10.1z"/>    </g>    <path id="bracefront" class="st7" d="M383.2 285.6h88.1"/>    <path id="braceback" class="st7" d="M733.2 285.6h88.1"/>    <g id="car-layers">      <path id="car" class="st8" d="M321.8 300.7v-32.4s1.2.7-1.5-2.4v-29.1s3.1-11.6 10.7-21.1c0 0 7.6-12 15.5-17.5h1.3s10.2-4.9 30.9-28h.6s-.9-1.4 0-2.7c0 0 10.1-10.5 21-12.3 0 0 9.4-1.8 20.2-1.8h47.7V151H492v-1.1h10.1v1.1h19v2.2s8.2.9 19.2-4.2c0 0 1.4-1.1 28.8-1.1h291.5v6.8h7.5v2.2s12.2-.6 12.2 9.8V177l-10-.1v57.9s14.9-.5 14.9 10.2c0 0 1 9-14.9 8.9v3.8H719.5s-2.4.1-4.3 3l-15 29s-2.9 5.1-10.8 5.1H504.3s-2.9.1-6.1-5l-13.1-25s-4.5-7.1-11.8-7.1H369v2.4s-3.2 1.3-7.1 8.7L351.4 289s-2.9 6.3-6.9 6.4h-17.8l-4.9 5.3z"/>      <path id="streamline-outine" class="st8" d="M320.3 236.6s1.4-6.8 4.4-11.3c0 0 .1-2.3 23.2-6.3l78-16.6s103.3-21.1 134.9-26.1c0 0 93.3-16 120.5-17.9 0 0 57.6-4.3 100-4.1h88.9v63.4s-10.3 5.4-17.1 5.3c0 0-305.6 4.9-366.3 8.1 0 0-100.3 4.8-119.1 6.8 0-.1-46.6 1.2-47.4-1.3z"/>      <g id="window-grate">        <path class="st9" d="M739.5 182.6H854"/>        <path class="st9" d="M739.5 177.6H854"/>        <path class="st9" d="M739.5 172.6H854"/>        <path class="st9" d="M739.5 167.6H854"/>        <path class="st9" d="M739.5 161.4H854v26.1H739.5z"/>      </g>      <path class="st9" d="M320.3 257.8h549.9"/>      <g id="Text">        <text transform="translate(377.037 230.025)" class="st8 st10" font-size="21">          404        </text>        <text transform="translate(659.5 213.994)" class="st8 st10" font-size="24.025">        Page not found.        </text>      </g>      <g id="ladders">        <g id="ladder-f">          <path id="front-ladder" class="st8" d="M433.8 258.4h17.8v34.8h-17.8z"/>          <path id="fb-rung" class="st9" d="M433.8 281.1h17.7"/>          <path id="ft-rung" class="st9" d="M433.8 268.6h17.7"/>        </g>        <g id="ladder-b">          <path id="ladder-back" class="st8" d="M851.8 257.8h17.8v34.8h-17.8z"/>          <path id="bt-rung" class="st9" d="M851.8 268.6h17.7"/>          <path id="bb-rung" class="st9" d="M851.8 281.1h17.7"/>        </g>      </g>      <path id="window-front" class="st8" d="M350.5 196.4s-.4 3.9 15.2 4.3l32.3-30.3s-18.2 1.1-19-.8l-28.5 26.8z"/>    </g>  </g></svg>  </div></div><!-- partial -->  </body></html>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/404/style.css"/>
      <url>/404/style.css</url>
      
        <content type="html"><![CDATA[.main{  margin-top: 15%;}.st0{fill:#fff}.st2{fill:#5d89af}.st3{fill:#709abf}.st4,.st6{  fill:#fff;  stroke:#b3dcdf;  stroke-miterlimit:10}.st6{  stroke:#5d89af;  stroke-width:2}.st7,.st8,.st9{  stroke:#709abf;  stroke-miterlimit:10}.st7{  stroke-width:5;  stroke-linecap:round;  fill:none}.st8,.st9{  fill:#fff}.st9{  fill:none}.st10{  }#cloud1{  animation: cloud003 15s linear infinite;}#cloud2{  animation: cloud002 25s linear infinite;}#cloud3{  animation: cloud003 20s linear infinite;}#cloud4{  animation: float 4s linear infinite;}#cloud5{  animation: float 8s linear infinite;}#cloud7{  animation: float 5s linear infinite;}#tracks{  animation: slide 650ms linear infinite;}#bumps{  animation: land 10000ms linear infinite;}@keyframes jig {    0% { transform: translateY(0px); }    50% { transform: translateY(1px); }    100% { transform: translateY(0px); }}#car-layers{  animation: jig 0.35s linear infinite;}@keyframes land {    from { transform: translateX(0); }    to { transform: translateX(1000px); }}@keyframes slide {    from { transform: translateX(0px); }    to { transform: translateX(100px); }}/* @keyframes cloudFloat {  0% { transform: translateX(0) translateY(3px); }  100% { transform: translateX(1000px) translateY(0); }} */@keyframes cloud001 {  0% { transform: translateX(-1000px) translateY(3px); }  100% { transform: translateX(1000px) translateY(0); }}@keyframes cloud002 {  0% { transform: translateX(-1000px) translateY(3px); }  100% { transform: translateX(1000px) translateY(0); }}@keyframes cloud003 {  0% { transform: translateX(-1000px) translateY(3px); }  100% { transform: translateX(1000px) translateY(0); }}@keyframes float {    0% { transform: translateY(0px) translateX(0); }    50% { transform: translateY(8px) translateX(5px); }    100% { transform: translateY(0px) translateX(0); }}#bracefront, #braceback{  animation: braces 1s linear infinite;}@keyframes braces {    0% { transform: translateX(-2px); }  25% { transform: translateX(3px); }    50% { transform: translateX(-2px); }    75% { transform: translateX(3px); }  100% { transform: translateX(-2px); }}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>友链</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>留言板</title>
      <link href="/messageboard/index.html"/>
      <url>/messageboard/index.html</url>
      
        <content type="html"><![CDATA[<p>有利的情况和主动的恢复，产生于”再坚持一下”的努力之中。</p><p>​                                                                  ———-《毛泽东选集》</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>butterfly</title>
      <link href="/butterfly/index.html"/>
      <url>/butterfly/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>日志</title>
      <link href="/timeline/index.html"/>
      <url>/timeline/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>myself</title>
      <link href="/myself/index.html"/>
      <url>/myself/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
