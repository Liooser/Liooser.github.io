<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>day23 - XML、xml解析、工厂模式、装饰模式</title>
      <link href="/post/2f2fc17e.html"/>
      <url>/post/2f2fc17e.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-XML"><a href="#1-XML" class="headerlink" title="1.XML"></a>1.XML</h3><h4 id="1-1XML概述"><a href="#1-1XML概述" class="headerlink" title="1.1XML概述"></a>1.1XML概述</h4><p><strong>XML概述</strong></p><ul><li>XML是可扩展标记语言（eXtensible Markup Language）的缩写，它是是一种数据表示格式，可以描述非常复杂的数据结构，常用于传输和存储数据。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;data&gt;</span><br><span class="line">&lt;sender&gt;张三&lt;/sender&gt;</span><br><span class="line">&lt;receiver&gt;李四&lt;/receiver&gt;</span><br><span class="line">&lt;src&gt;</span><br><span class="line">     &lt;addr&gt;北京&lt;/addr&gt;</span><br><span class="line">     &lt;date&gt;<span class="number">2022</span>-<span class="number">11</span>-<span class="number">11</span> <span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span>&lt;/date&gt;</span><br><span class="line">    &lt;/src&gt;</span><br><span class="line">    &lt;current&gt;武汉&lt;/current&gt;</span><br><span class="line">    &lt;dest&gt;广州&lt;/dest&gt;</span><br><span class="line">&lt;/data&gt;</span><br></pre></td></tr></table></figure><p><strong>XML的几个特点和使用场景</strong></p><ul><li><p>一是<strong>纯文本</strong>，默认使用UTF-8编码；二是<strong>可嵌套</strong>；</p></li><li><p>如果把XML内容存为文件，那么它就是一个XML文件。</p></li><li><p>XML的使用场景：XML内容经常被当成消息进行网络传输，或者作为配置文件用于存储系统的信息。</p></li></ul><h4 id="1-2XML的创建、语法规则"><a href="#1-2XML的创建、语法规则" class="headerlink" title="1.2XML的创建、语法规则"></a>1.2XML的创建、语法规则</h4><p><strong>XML的创建</strong></p><ul><li>就是创建一个XML类型的文件，要求<strong>【文件的后缀】必须使用xml</strong>，如<strong>hello_world.xml</strong></li></ul><p><strong>XML的语法规则</strong></p><ul><li><p>XML文件的后缀名为：xml</p></li><li><p>文档声明必须是第一行</p></li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line">//version：XML默认的版本号码、该属性是必须存在的</span><br><span class="line">//encoding：本XML文件的编码</span><br></pre></td></tr></table></figure><p><strong>XML的标签(元素)规则</strong></p><ul><li><p>标签由一对尖括号和合法标识符组成: <name></name>，<strong>必须存在一个根标签，有且只能有一个。</strong></p></li><li><p><strong>标签必须成对出现</strong>，有开始，有结束: <name></name></p></li><li><p><strong>特殊的标签可以不成对</strong>，但是必须有结束标记，如:<br/></p></li><li><p>标签中可以定义属性，<strong>属性和标签名空格隔开,属性值必须用引号引起来</strong>&lt;student id &#x3D; “1”&gt;</name></p></li></ul><p>l标签需要正确的嵌套</p><p><strong>XML的其他组成</strong></p><ul><li><p>XML文件中可以定义注释信息：<!-- 注释内容 --></p></li><li><p>XML文件中可以存在以下特殊字符</p></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;lt;    &lt;  小于</span><br><span class="line">&amp;gt;    &gt;  大于</span><br><span class="line">&amp;amp;   &amp;  和号</span><br><span class="line">&amp;apos;  &#x27;  单引号</span><br><span class="line">&amp;quot;  &quot;  引号</span><br></pre></td></tr></table></figure><ul><li>XML文件中可以存在CDATA区: <![CDATA[  …内容… ]]></li></ul><p><strong>xml文档：</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 注释：根标签有且仅能有一个 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">student</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>女儿国王<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sex</span>&gt;</span>女<span class="tag">&lt;/<span class="name">sex</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hobby</span>&gt;</span>唐僧，追唐僧<span class="tag">&lt;/<span class="name">hobby</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">info</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">age</span>&gt;</span>30<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">addr</span>&gt;</span>女儿国<span class="tag">&lt;/<span class="name">addr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">info</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sql</span>&gt;</span></span><br><span class="line">        select * from user where age <span class="symbol">&amp;lt;</span> 18;</span><br><span class="line">        select * from user where age <span class="symbol">&amp;lt;</span> 18 <span class="symbol">&amp;amp;</span><span class="symbol">&amp;amp;</span> age &gt; 10</span><br><span class="line">        &lt;![CDATA[</span><br><span class="line">                select * from user where age &lt; 18</span><br><span class="line">        ]]&gt;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="1-3XML文档约束方式一-DTD约束-了解"><a href="#1-3XML文档约束方式一-DTD约束-了解" class="headerlink" title="1.3XML文档约束方式一-DTD约束[了解]"></a>1.3XML文档约束方式一-DTD约束[了解]</h4><p><strong>什么是文档约束？</strong></p><p>由于XML文件可以自定义标签，导致XML文件可以随意定义，程序在解析的时候可能出现问题。</p><p><strong>文档约束</strong>：是用来限定xml文件中的标签以及属性应该怎么写。以此强制约束程序员必须按照文档约束的规定来编写xml文件。</p><p><strong>文档约束的分类</strong></p><ul><li><p>DTD</p></li><li><p>schema</p></li></ul><p><strong>XML文档约束-DTD的使用（了解）</strong></p><p><strong>需求：</strong></p><p>利用DTD文档约束，约束一个XML文件的编写。</p><p><strong>分析：</strong></p><p>①：编写DTD约束文档，后缀必须是.dtd</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ELEMENT 书架 (书+)&gt;</span><br><span class="line">&lt;!ELEMENT 书 (书名,作者,售价)&gt;</span><br><span class="line">&lt;!ELEMENT 书名 (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT 作者 (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT 售价 (#PCDATA)&gt;</span><br></pre></td></tr></table></figure><p>②：在需要编写的XML文件中导入该DTD约束文档</p><p>③：按照约束的规定编写XML文件的内容。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE 书架 <span class="keyword">SYSTEM</span> <span class="string">&quot;data.dtd&quot;</span>&gt;</span>  //导入该DTD约束文档</span><br><span class="line"><span class="tag">&lt;<span class="name">书架</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">书</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">书名</span>&gt;</span>精通JavaSE加强<span class="tag">&lt;/<span class="name">书名</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">作者</span>&gt;</span>dlei<span class="tag">&lt;/<span class="name">作者</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">售价</span>&gt;</span>很贵<span class="tag">&lt;/<span class="name">售价</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">书</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">书</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">书名</span>&gt;</span><span class="tag">&lt;/<span class="name">书名</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">作者</span>&gt;</span><span class="tag">&lt;/<span class="name">作者</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">售价</span>&gt;</span><span class="tag">&lt;/<span class="name">售价</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">书</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">书</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">书名</span>&gt;</span><span class="tag">&lt;/<span class="name">书名</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">作者</span>&gt;</span><span class="tag">&lt;/<span class="name">作者</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">售价</span>&gt;</span><span class="tag">&lt;/<span class="name">售价</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">书</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">书架</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="1-4XML文档约束方式二-schema约束-了解"><a href="#1-4XML文档约束方式二-schema约束-了解" class="headerlink" title="1.4XML文档约束方式二-schema约束[了解]"></a>1.4XML文档约束方式二-schema约束[了解]</h4><p><strong>文档约束-schema</strong></p><ul><li><p>schema可以约束具体的数据类型，约束能力上更强大。</p></li><li><p>schema本身也是一个xml文件，本身也受到其他约束文件的要求，所以编写的更加严谨</p></li></ul><p><strong>XML文档约束-schema的使用（了解）</strong></p><p><strong>需求：</strong></p><p>利用schema文档约束，约束一个XML文件的编写。</p><p><strong>分析：</strong></p><p>①：编写schema约束文档，后缀必须是.xsd，具体的形式到代码中观看。</p><figure class="highlight xsd"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 编写schema约束文档 (.xsd)--&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">schema</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">targetNamespace</span>=<span class="string">&quot;http://www.itcast.cn&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">elementFormDefault</span>=<span class="string">&quot;qualified&quot;</span> &gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- targetNamespace:申明约束文档的地址（命名空间）--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">element</span> <span class="attr">name</span>=<span class="string">&#x27;书架&#x27;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 写子元素 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">complexType</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- maxOccurs=&#x27;unbounded&#x27;: 书架下的子元素可以有任意多个！--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">sequence</span> <span class="attr">maxOccurs</span>=<span class="string">&#x27;unbounded&#x27;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">element</span> <span class="attr">name</span>=<span class="string">&#x27;书&#x27;</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!-- 写子元素 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">complexType</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">sequence</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">element</span> <span class="attr">name</span>=<span class="string">&#x27;书名&#x27;</span> <span class="attr">type</span>=<span class="string">&#x27;string&#x27;</span>/&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">element</span> <span class="attr">name</span>=<span class="string">&#x27;作者&#x27;</span> <span class="attr">type</span>=<span class="string">&#x27;string&#x27;</span>/&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">element</span> <span class="attr">name</span>=<span class="string">&#x27;售价&#x27;</span> <span class="attr">type</span>=<span class="string">&#x27;double&#x27;</span>/&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">sequence</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">complexType</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">element</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">sequence</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">complexType</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">element</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br></pre></td></tr></table></figure><p>②：在需要编写的XML文件中导入该schema约束文档</p><p>③：按照约束内容编写XML文件的标签。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">xml<span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">书架</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.itcast.cn&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.itcast.cn data.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- xmlns=&quot;http://www.itcast.cn&quot;  基本位置</span></span><br><span class="line"><span class="comment">         xsi:schemaLocation=&quot;http://www.itcast.cn books02.xsd&quot; 具体的位置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">书</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">书名</span>&gt;</span>神雕侠侣<span class="tag">&lt;/<span class="name">书名</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">作者</span>&gt;</span>金庸<span class="tag">&lt;/<span class="name">作者</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">售价</span>&gt;</span>399.9<span class="tag">&lt;/<span class="name">售价</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">书</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">书</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">书名</span>&gt;</span>神雕侠侣<span class="tag">&lt;/<span class="name">书名</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">作者</span>&gt;</span>金庸<span class="tag">&lt;/<span class="name">作者</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">售价</span>&gt;</span>19.5<span class="tag">&lt;/<span class="name">售价</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">书</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">书架</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-XML解析技术"><a href="#2-XML解析技术" class="headerlink" title="2.XML解析技术"></a>2.XML解析技术</h3><h4 id="2-1XML解析技术概述"><a href="#2-1XML解析技术概述" class="headerlink" title="2.1XML解析技术概述"></a>2.1XML解析技术概述</h4><p>XML的数据的作用是什么，最终需要怎么处理？</p><ul><li><p>存储数据、做配置信息、进行数据传输。</p></li><li><p>最终需要被程序进行读取，解析里面的信息。</p></li></ul><p><strong>什么是XML解析</strong></p><ul><li>使用程序读取XML中的数据</li></ul><p><strong>两种解析方式</strong></p><ul><li><p>SAX解析</p></li><li><p>DOM解析</p></li></ul><p><strong>Dom常见的解析工具</strong></p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>JAXP</td><td>SUN公司提供的一套XML的解析的API</td></tr><tr><td>JDOM</td><td>JDOM是一个开源项目，它基于树型结构，利用纯JAVA的技术对XML文档实现解析、生成、序列化以及多种操作。</td></tr><tr><td><strong>dom4j</strong></td><td><strong>是JDOM的升级品，用来读写XML文件的。具有性能优异、功能强大和极其易使用的特点，它的性能超过sun公司官方的dom  技术，同时它也是一个开放源代码的软件，Hibernate也用它来读写配置文件。</strong></td></tr><tr><td>jsoup</td><td>功能强大DOM方式的XML解析开发包，尤其对HTML解析更加方便</td></tr></tbody></table><p><strong>DOM解析解析文档对象模型</strong></p><p>DOM（文档对象模型）是一种编程接口，用于在浏览器中操作和访问HTML、XML和SVG等文档的结构和内容。它将文档表示为一个树状结构，其中每个节点代表文档中的一个部分（如元素、属性、文本等）。通过DOM，开发人员可以使用编程语言（通常是JavaScript）来操作和修改文档的内容、结构和样式。</p><p>DOM解析是指将HTML或XML文档解析为DOM树的过程。解析器将原始的HTML或XML代码解析为一个由节点和属性组成的树状结构，使开发人员可以使用代码来访问和操作文档中的各个部分。</p><p>在JavaScript中，可以使用以下方法来解析和操作DOM：</p><ol><li><strong>获取元素：</strong> 通过使用选择器（如ID、类名、标签名等）来获取DOM中的元素，例如 <code>document.getElementById(&#39;elementId&#39;)</code>。</li><li><strong>操作元素内容：</strong> 通过属性或方法来修改元素的文本内容或HTML内容，例如 <code>element.textContent</code> 或 <code>element.innerHTML</code>。</li><li><strong>修改属性：</strong> 可以使用属性来读取或修改元素的属性，例如 <code>element.getAttribute(&#39;attributeName&#39;)</code> 和 <code>element.setAttribute(&#39;attributeName&#39;, &#39;value&#39;)</code>。</li><li><strong>创建新元素：</strong> 使用 <code>document.createElement(&#39;tagName&#39;)</code> 来创建新的DOM元素，并将其添加到文档中。</li><li><strong>添加和移除元素：</strong> 使用 <code>parentNode.appendChild(childNode)</code> 或 <code>parentNode.removeChild(childNode)</code> 来添加或移除子元素。</li><li><strong>事件处理：</strong> 通过将事件处理程序附加到元素上来响应用户操作，例如 <code>element.addEventListener(&#39;eventName&#39;, eventHandler)</code>。</li></ol><h4 id="2-2Dom4J解析XML文件"><a href="#2-2Dom4J解析XML文件" class="headerlink" title="2.2Dom4J解析XML文件"></a>2.2Dom4J解析XML文件</h4><p><strong>导包：</strong></p><p>①下载Dom4j框架，官网下载。</p><p>②在项目中创建一个文件夹：lib</p><p>③将dom4j-2.1.1.jar文件复制到 lib 文件夹</p><p>④在jar文件上点右键，选择 Add as Library -&gt; 点击OK</p><p>⑤在类中导包使用</p><p><strong>Dom4j解析XML-得到Document对象</strong></p><p><strong>SAXReader类</strong></p><table><thead><tr><th>构造器&#x2F;方法</th><th>说明</th></tr></thead><tbody><tr><td>public <strong>SAXReader</strong>()</td><td><strong>创建Dom4J的解析器对象</strong></td></tr><tr><td>Document  <strong>read</strong>(String url)</td><td><strong>加载XML文件成为Document对象</strong></td></tr></tbody></table><p><strong>Document类</strong></p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>Element <strong>getRootElement</strong>()</td><td><strong>获得根元素对象</strong></td></tr></tbody></table><p><strong>使用Dom4J解析出XML文件</strong></p><p><strong>需求：</strong>使用Dom4J把一个XML文件进行解析</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--创建xml文档--&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">contactList</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">contact</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span> <span class="attr">vip</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>   潘金莲  <span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">gender</span>&gt;</span>女<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">email</span>&gt;</span>panpan@itcast.cn<span class="tag">&lt;/<span class="name">email</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">contact</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">contact</span> <span class="attr">id</span>=<span class="string">&quot;2&quot;</span> <span class="attr">vip</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>武松<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">gender</span>&gt;</span>男<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">email</span>&gt;</span>wusong@itcast.cn<span class="tag">&lt;/<span class="name">email</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">contact</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">contact</span> <span class="attr">id</span>=<span class="string">&quot;3&quot;</span> <span class="attr">vip</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>武大狼<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">gender</span>&gt;</span>男<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">email</span>&gt;</span>wuda@itcast.cn<span class="tag">&lt;/<span class="name">email</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">contact</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">user</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">contactList</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   目标：学会使用dom4j解析XML文件中的数据。</span></span><br><span class="line"><span class="comment">    1、准备一个XML文件。</span></span><br><span class="line"><span class="comment">    2、导入dom4j框架。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dom4JHelloWorldDemo1</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parseXMLData</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建一个Dom4j的解析器对象，代表了整个dom4j框架</span></span><br><span class="line">        <span class="type">SAXReader</span> <span class="variable">saxReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、把XML文件加载到内存中成为一个Document文档对象</span></span><br><span class="line">        <span class="comment">// File相对路径，需要通过模块名去定位</span></span><br><span class="line">        <span class="comment">// Document document = saxReader.read(new File(&quot;xml-app\\src\\Contacts.xml&quot;)); </span></span><br><span class="line">        <span class="comment">// 字节输入流，需要通过模块名去定位</span></span><br><span class="line">        <span class="comment">// Document document = saxReader.read(new FileInputStream(&quot;xml-app\\src\\Contacts.xml&quot;));</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用Class类对象提供的方法getResourceAsStream(获取资源成为流)</span></span><br><span class="line">        <span class="comment">// 注意: getResourceAsStream中的/是直接去src下寻找的文件</span></span><br><span class="line">        <span class="comment">// a.将路径下的XML文件储存在流中</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> Dom4JHelloWorldDemo1.class.getResourceAsStream(<span class="string">&quot;/Contacts.xml&quot;</span>); <span class="comment">// 最优雅的写法</span></span><br><span class="line">        <span class="comment">// b.把流读到Document对象中</span></span><br><span class="line">        <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> saxReader.read(is); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3Dom4J解析XML文件中的各种节点"><a href="#2-3Dom4J解析XML文件中的各种节点" class="headerlink" title="2.3Dom4J解析XML文件中的各种节点"></a>2.3Dom4J解析XML文件中的各种节点</h4><p><strong>Dom4j解析XML的元素、属性、文本</strong></p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>List<Element> elements()</td><td>得到当前元素下所有子元素</td></tr><tr><td>List<Element>  elements(String name)</td><td>得到当前元素下指定名字的子元素返回集合</td></tr><tr><td>Element  element(String name)</td><td>得到当前元素下指定名字的子元素,如果有很多名字相同的返回第一个</td></tr><tr><td>String  getName()</td><td>得到元素名字</td></tr><tr><td>String attributeValue(String name)</td><td>通过属性名直接得到属性值</td></tr><tr><td>String  elementText(子元素名)</td><td>得到指定名称的子元素的文本</td></tr><tr><td>String  getText()</td><td>得到文本</td></tr></tbody></table><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--创建xml文档--&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">contactList</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">contact</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span> <span class="attr">vip</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>   潘金莲  <span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">gender</span>&gt;</span>女<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">email</span>&gt;</span>panpan@itcast.cn<span class="tag">&lt;/<span class="name">email</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">contact</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">contact</span> <span class="attr">id</span>=<span class="string">&quot;2&quot;</span> <span class="attr">vip</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>武松<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">gender</span>&gt;</span>男<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">email</span>&gt;</span>wusong@itcast.cn<span class="tag">&lt;/<span class="name">email</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">contact</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">contact</span> <span class="attr">id</span>=<span class="string">&quot;3&quot;</span> <span class="attr">vip</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>武大狼<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">gender</span>&gt;</span>男<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">email</span>&gt;</span>wuda@itcast.cn<span class="tag">&lt;/<span class="name">email</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">contact</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">user</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">contactList</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.dom4j.Attribute;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.Document;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.DocumentException;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.Element;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.io.SAXReader;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   目标：学会使用dom4j解析XML文件中的数据。</span></span><br><span class="line"><span class="comment">    1、准备一个XML文件。</span></span><br><span class="line"><span class="comment">    2、导入dom4j框架。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dom4JHelloWorldDemo1</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parseXMLData</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建一个Dom4j的解析器对象，代表了整个dom4j框架</span></span><br><span class="line">        <span class="type">SAXReader</span> <span class="variable">saxReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、把XML文件加载到内存流中,成为一个Document文档对象</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> Dom4JHelloWorldDemo1.class.getResourceAsStream(<span class="string">&quot;/Contacts.xml&quot;</span>);</span><br><span class="line">        <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> saxReader.read(is);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、获取根元素对象</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">root</span> <span class="operator">=</span> document.getRootElement();</span><br><span class="line">        System.out.println(root.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、拿根元素下的全部子元素对象(一级)</span></span><br><span class="line">        <span class="comment">// List&lt;Element&gt; sonEles =  root.elements();</span></span><br><span class="line">        List&lt;Element&gt; sonEles =  root.elements(<span class="string">&quot;contact&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Element sonEle : sonEles) &#123;</span><br><span class="line">            System.out.println(sonEle.getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拿某个子元素</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">userEle</span> <span class="operator">=</span> root.element(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        System.out.println(userEle.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 默认提取第一个子元素对象 (Java语言。)</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">contact</span> <span class="operator">=</span> root.element(<span class="string">&quot;contact&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取子元素文本</span></span><br><span class="line">        System.out.println(contact.elementText(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">        <span class="comment">// 去掉前后空格</span></span><br><span class="line">        System.out.println(contact.elementTextTrim(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">        <span class="comment">// 获取当前元素下的子元素对象</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">email</span> <span class="operator">=</span> contact.element(<span class="string">&quot;email&quot;</span>);</span><br><span class="line">        System.out.println(email.getText());</span><br><span class="line">        <span class="comment">// 去掉前后空格</span></span><br><span class="line">        System.out.println(email.getTextTrim());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据元素获取属性值</span></span><br><span class="line">        <span class="type">Attribute</span> <span class="variable">idAttr</span> <span class="operator">=</span> contact.attribute(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">        System.out.println(idAttr.getName() + <span class="string">&quot;--&gt;&quot;</span> + idAttr.getValue());</span><br><span class="line">        <span class="comment">// 直接提取属性值</span></span><br><span class="line">        System.out.println(contact.attributeValue(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">        System.out.println(contact.attributeValue(<span class="string">&quot;vip&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4Dom4J解析XML文件-案例实战"><a href="#2-4Dom4J解析XML文件-案例实战" class="headerlink" title="2.4Dom4J解析XML文件-案例实战"></a>2.4Dom4J解析XML文件-案例实战</h4><p><strong>XML解析案例：</strong></p><p><strong>需求:</strong></p><p>利用Dom4J的知识，将Contact.xml文件中的联系人数据封装成List集合，其中每个元素是实体类Contact。打印输出 List 中的每个元素。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 创建xml文档 (Contact.xml) --&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">contactList</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">contact</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span> <span class="attr">vip</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>   潘金莲  <span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">gender</span>&gt;</span>女<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">email</span>&gt;</span>panpan@itcast.cn<span class="tag">&lt;/<span class="name">email</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">contact</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">contact</span> <span class="attr">id</span>=<span class="string">&quot;2&quot;</span> <span class="attr">vip</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>武松<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">gender</span>&gt;</span>男<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">email</span>&gt;</span>wusong@itcast.cn<span class="tag">&lt;/<span class="name">email</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">contact</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">contact</span> <span class="attr">id</span>=<span class="string">&quot;3&quot;</span> <span class="attr">vip</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>武大狼<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">gender</span>&gt;</span>男<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">email</span>&gt;</span>wuda@itcast.cn<span class="tag">&lt;/<span class="name">email</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">contact</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">user</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">contactList</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.dom4j.Document;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.Element;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.io.SAXReader;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dom4JTest2</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parseToList</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 需求：解析XML中的数据成为一个List集合对象。</span></span><br><span class="line">        <span class="comment">// 1、导入框架（做过）</span></span><br><span class="line">        <span class="comment">// 2、创建SaxReader对象</span></span><br><span class="line">        <span class="type">SAXReader</span> <span class="variable">saxReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line">        <span class="comment">// 3、加载XML文件成为文档对象Document对象。</span></span><br><span class="line">        <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span></span><br><span class="line">                saxReader.read(Dom4JTest2.class.getResourceAsStream(<span class="string">&quot;/Contacts.xml&quot;</span>));</span><br><span class="line">        <span class="comment">// 4、先拿根元素</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">root</span> <span class="operator">=</span> document.getRootElement();</span><br><span class="line">        <span class="comment">// 5、提取contact子元素</span></span><br><span class="line">        List&lt;Element&gt; contactEles = root.elements(<span class="string">&quot;contact&quot;</span>);</span><br><span class="line">        <span class="comment">// 6、准备一个ArrayList集合封装联系人信息</span></span><br><span class="line">        List&lt;Contact&gt; contacts = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 7、遍历Contact子元素</span></span><br><span class="line">        <span class="keyword">for</span> (Element contactEle : contactEles) &#123;</span><br><span class="line">            <span class="comment">// 8、每个子元素都是一个联系人对象</span></span><br><span class="line">            <span class="type">Contact</span> <span class="variable">contact</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Contact</span>();</span><br><span class="line">            contact.setId(Integer.valueOf(contactEle.attributeValue(<span class="string">&quot;id&quot;</span>)));</span><br><span class="line">            contact.setVip(Boolean.valueOf(contactEle.attributeValue(<span class="string">&quot;vip&quot;</span>)));</span><br><span class="line">            contact.setName(contactEle.elementTextTrim(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">            contact.setGender(contactEle.elementTextTrim(<span class="string">&quot;gender&quot;</span>).charAt(<span class="number">0</span>));</span><br><span class="line">            contact.setEmail(contactEle.elementText(<span class="string">&quot;email&quot;</span>));</span><br><span class="line">            <span class="comment">// 9、把联系人对象数据加入到List集合</span></span><br><span class="line">            contacts.add(contact);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 10、遍历List集合</span></span><br><span class="line">        <span class="keyword">for</span> (Contact contact : contacts) &#123;</span><br><span class="line">            System.out.println(contact);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-XML检索技术：Xpath"><a href="#3-XML检索技术：Xpath" class="headerlink" title="3.XML检索技术：Xpath"></a>3.XML检索技术：Xpath</h3><p>如果需要从XML文件中检索需要的某个信息（如name）怎么解决？</p><ul><li><p>Dom4j需要进行文件的全部解析，然后再寻找数据。</p></li><li><p><strong>Xpath技术更加适合做信息检索。</strong></p></li></ul><p><strong>XPath介绍</strong></p><ul><li><p>XPath在解析XML文档方面提供了一独树一帜的路径思想，更加优雅，高效</p></li><li><p>XPath使用路径表达式来定位XML文档中的元素节点或属性节点。</p></li><li><p><em><strong>导入jar包(dom4j和jaxen-1.1.2.jar)<strong>，</strong>Xpath技术依赖Dom4j技术</strong></em></p></li></ul><p><strong>使用Xpath检索出XML文件</strong></p><p><strong>需求：</strong></p><p>使用Dom4J把一个XML文件的数据进行解析</p><p><strong>分析：</strong></p><p>①导入jar包(dom4j和jaxen-1.1.2.jar)，Xpath技术依赖Dom4j技术</p><p>②通过dom4j的SAXReader获取Document对象</p><p>③利用XPath提供的API,结合XPath的语法完成选取XML文档元素节点进行解析操作。</p><p>④Document中与Xpath相关的API如下：</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>Node  <strong>selectSingleNode</strong>(“表达式”)</td><td><strong>获取符合表达式的唯一元素</strong></td></tr><tr><td>List<Node> <strong>selectNodes</strong>(“表达式”)</td><td><strong>获取符合表达式的元素集合</strong></td></tr></tbody></table><p><strong>Xpath的四大检索方案</strong></p><p><strong>绝对路径</strong></p><ul><li>采用绝对路径获取从根节点开始逐层的查找&#x2F;contactList&#x2F;contact&#x2F;name节点列表并打印信息</li></ul><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>&#x2F;根元素&#x2F;子元素&#x2F;孙元素</td><td>从根元素开始，一级一级向下查找，不能跨级</td></tr></tbody></table><p><strong>相对路径</strong></p><ul><li>先得到根节点contactList</li></ul><p>l再采用相对路径获取下一级contact 节点的name子节点并打印信息</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>.&#x2F;子元素&#x2F;孙元素</td><td>从当前元素开始，一级一级向下查找，不能跨级</td></tr></tbody></table><p><strong>全文检索</strong></p><ul><li>直接全文搜索所有的name元素并打印</li></ul><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>&#x2F;&#x2F;contact</td><td>找contact元素，无论元素在哪里</td></tr><tr><td>&#x2F;&#x2F;contact&#x2F;name</td><td>找contact，无论在哪一级，但name一定是contact的子节点</td></tr><tr><td>&#x2F;&#x2F;contact&#x2F;&#x2F;name</td><td>contact无论在哪一种，name只要是contact的子孙元素都可以找到</td></tr></tbody></table><p><strong>属性查找</strong></p><ul><li>在全文中搜索属性，或者带属性的元素</li></ul><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>&#x2F;&#x2F;@属性名</td><td>查找属性对象，无论是哪个元素，只要有这个属性即可。</td></tr><tr><td>&#x2F;&#x2F;元素[@属性名]</td><td>查找元素对象，全文搜索指定元素名和属性名。</td></tr><tr><td>&#x2F;&#x2F;元素&#x2F;&#x2F;[@属性名&#x3D;‘值’]</td><td>查找元素对象，全文搜索指定元素名和属性名，并且属性值相等。</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：XPath检索XML中的信息啊。(了解)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    引入：</span></span><br><span class="line"><span class="comment">        Dom4J可以用于解析整个XML的数据。</span></span><br><span class="line"><span class="comment">        但是如果要检索XML中的某些信息，建议使用XPath.（Xpath依赖Dom4j技术）</span></span><br><span class="line"><span class="comment">        Dom4J用于解析数据，Xpath用于检索数据。</span></span><br><span class="line"><span class="comment">    XPath使用步骤：</span></span><br><span class="line"><span class="comment">        1.导入dom4j框架。（XPath依赖于Dom4j技术,必须先导入dom4j框架！）</span></span><br><span class="line"><span class="comment">        2.导入XPath独有的框架包。jaxen-1.1.2.jar</span></span><br><span class="line"><span class="comment">    XPath常用API:</span></span><br><span class="line"><span class="comment">        List&lt;Node&gt; selectNodes(String var1):检索出一批节点集合。</span></span><br><span class="line"><span class="comment">        Node selectSingleNode(String var1)：检索出一个节点返回。</span></span><br><span class="line"><span class="comment">    XPath提供的四种检索数据的写法：</span></span><br><span class="line"><span class="comment">        1.绝对路径。</span></span><br><span class="line"><span class="comment">        2.相对路径。</span></span><br><span class="line"><span class="comment">        3.全文搜索。</span></span><br><span class="line"><span class="comment">        4.属性查找。</span></span><br><span class="line"><span class="comment">    小结：</span></span><br><span class="line"><span class="comment">         1.绝对路径： /根元素/子元素/子元素。</span></span><br><span class="line"><span class="comment">         2.相对路径： ./子元素/子元素。 (.代表了当前元素)</span></span><br><span class="line"><span class="comment">         3.全文搜索：</span></span><br><span class="line"><span class="comment">                //元素  在全文找这个元素</span></span><br><span class="line"><span class="comment">                //元素1/元素2  在全文找元素1下面的一级元素2</span></span><br><span class="line"><span class="comment">                //元素1//元素2  在全文找元素1下面的全部元素2</span></span><br><span class="line"><span class="comment">         4.属性查找。</span></span><br><span class="line"><span class="comment">                //@属性名称  在全文检索属性对象。</span></span><br><span class="line"><span class="comment">                //元素[@属性名称]  在全文检索包含该属性的元素对象。</span></span><br><span class="line"><span class="comment">                //元素[@属性名称=值]  在全文检索包含该属性的元素且属性值为该值的元素对象。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XPathDemo</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     1.绝对路径: /根元素/子元素/子元素。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parse01</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// a、创建解析器对象</span></span><br><span class="line">        <span class="type">SAXReader</span> <span class="variable">saxReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line">        <span class="comment">// b、把XML加载成Document文档对象</span></span><br><span class="line">        <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span></span><br><span class="line">                saxReader.read(XPathDemo.class.getResourceAsStream(<span class="string">&quot;/Contacts2.xml&quot;</span>));</span><br><span class="line">        <span class="comment">// c、检索全部的名称</span></span><br><span class="line">        List&lt;Node&gt; nameNodes = document.selectNodes(<span class="string">&quot;/contactList/contact/name&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Node nameNode : nameNodes) &#123;</span><br><span class="line">            <span class="type">Element</span>  <span class="variable">nameEle</span> <span class="operator">=</span> (Element) nameNode;</span><br><span class="line">            System.out.println(nameEle.getTextTrim());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     2.相对路径： ./子元素/子元素。 (.代表了当前元素)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parse02</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// a、创建解析器对象</span></span><br><span class="line">        <span class="type">SAXReader</span> <span class="variable">saxReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line">        <span class="comment">// b、把XML加载成Document文档对象</span></span><br><span class="line">        <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span></span><br><span class="line">                saxReader.read(XPathDemo.class.getResourceAsStream(<span class="string">&quot;/Contacts2.xml&quot;</span>));</span><br><span class="line">        <span class="type">Element</span> <span class="variable">root</span> <span class="operator">=</span> document.getRootElement();</span><br><span class="line">        <span class="comment">// c、检索全部的名称</span></span><br><span class="line">        List&lt;Node&gt; nameNodes = root.selectNodes(<span class="string">&quot;./contact/name&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Node nameNode : nameNodes) &#123;</span><br><span class="line">            <span class="type">Element</span>  <span class="variable">nameEle</span> <span class="operator">=</span> (Element) nameNode;</span><br><span class="line">            System.out.println(nameEle.getTextTrim());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     3.全文搜索：</span></span><br><span class="line"><span class="comment">     //元素  在全文找这个元素</span></span><br><span class="line"><span class="comment">     //元素1/元素2  在全文找元素1下面的一级元素2</span></span><br><span class="line"><span class="comment">     //元素1//元素2  在全文找元素1下面的全部元素2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parse03</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// a、创建解析器对象</span></span><br><span class="line">        <span class="type">SAXReader</span> <span class="variable">saxReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line">        <span class="comment">// b、把XML加载成Document文档对象</span></span><br><span class="line">        <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span></span><br><span class="line">                saxReader.read(XPathDemo.class.getResourceAsStream(<span class="string">&quot;/Contacts2.xml&quot;</span>));</span><br><span class="line">        <span class="comment">// c、检索数据</span></span><br><span class="line">        <span class="comment">//List&lt;Node&gt; nameNodes = document.selectNodes(&quot;//name&quot;);</span></span><br><span class="line">        <span class="comment">// List&lt;Node&gt; nameNodes = document.selectNodes(&quot;//contact/name&quot;);</span></span><br><span class="line">        List&lt;Node&gt; nameNodes = document.selectNodes(<span class="string">&quot;//contact//name&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Node nameNode : nameNodes) &#123;</span><br><span class="line">            <span class="type">Element</span>  <span class="variable">nameEle</span> <span class="operator">=</span> (Element) nameNode;</span><br><span class="line">            System.out.println(nameEle.getTextTrim());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     4.属性查找。</span></span><br><span class="line"><span class="comment">     //@属性名称  在全文检索属性对象。</span></span><br><span class="line"><span class="comment">     //元素[@属性名称]  在全文检索包含该属性的元素对象。</span></span><br><span class="line"><span class="comment">     //元素[@属性名称=值]  在全文检索包含该属性的元素且属性值为该值的元素对象。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parse04</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// a、创建解析器对象</span></span><br><span class="line">        <span class="type">SAXReader</span> <span class="variable">saxReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line">        <span class="comment">// b、把XML加载成Document文档对象</span></span><br><span class="line">        <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span></span><br><span class="line">                saxReader.read(XPathDemo.class.getResourceAsStream(<span class="string">&quot;/Contacts2.xml&quot;</span>));</span><br><span class="line">        <span class="comment">// c、检索数据</span></span><br><span class="line">        List&lt;Node&gt; nodes = document.selectNodes(<span class="string">&quot;//@id&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Node node : nodes) &#123;</span><br><span class="line">            <span class="type">Attribute</span> <span class="variable">attr</span> <span class="operator">=</span> (Attribute) node;</span><br><span class="line">            System.out.println(attr.getName() + <span class="string">&quot;===&gt;&quot;</span> + attr.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查询name元素（包含id属性的）</span></span><br><span class="line"><span class="comment">//      Node node = document.selectSingleNode(&quot;//name[@id]&quot;);</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> document.selectSingleNode(<span class="string">&quot;//name[@id=888]&quot;</span>);</span><br><span class="line">        <span class="type">Element</span> <span class="variable">ele</span> <span class="operator">=</span> (Element) node;</span><br><span class="line">        System.out.println(ele.getTextTrim());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-设计模式：工厂模式-代理创造对象"><a href="#4-设计模式：工厂模式-代理创造对象" class="headerlink" title="4.设计模式：工厂模式(代理创造对象)"></a>4.设计模式：工厂模式(代理创造对象)</h3><p><strong>什么是工厂设计模式？</strong></p><ul><li><p>之前我们创建类对象时, 都是使用new 对象的形式创建,在很多业务场景下也提供了不直接new的方式 。</p></li><li><p>工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一， 这种类型的设计模式属于创建型模式，它提供了一种获取对象的方式。</p></li><li><p>之前我们创建类对象时, 都是使用new 对象的形式创建, 除new 对象方式以外，工厂模式也可以创建对象。</p></li></ul><p><strong>工厂设计模式的作用：</strong></p><ul><li>工厂的方法可以封装对象的创建细节，比如：为该对象进行加工和数据注入。</li><li>可以实现类与类之间的解耦操作（核心思想，重点）。</li></ul><p><strong>代码：模仿设计工厂模式</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义电脑抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getPrice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPrice</span><span class="params">(<span class="type">double</span> price)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//电脑对象1实现抽象方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Huawei</span> <span class="keyword">extends</span> <span class="title class_">Computer</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(getName() + <span class="string">&quot;开机了，展示了华为的菊花图标~~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//电脑对象2实现抽象方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mac</span> <span class="keyword">extends</span> <span class="title class_">Computer</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(getName() + <span class="string">&quot;以非常优雅的方法启动了，展示了一个苹果logo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义工厂类，提供一个工厂方法返回对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FactoryPattern</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">       定义一个方法，创建对象返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Computer <span class="title function_">createComputer</span><span class="params">(String info)</span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (info)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;huawei&quot;</span>:</span><br><span class="line">                <span class="type">Computer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Huawei</span>();</span><br><span class="line">                c.setName(<span class="string">&quot;huawei pro 16&quot;</span>);</span><br><span class="line">                c.setPrice(<span class="number">5999</span>);</span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;mac&quot;</span>:</span><br><span class="line">                <span class="type">Computer</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Mac</span>();</span><br><span class="line">                c2.setName(<span class="string">&quot;MacBook pro&quot;</span>);</span><br><span class="line">                c2.setPrice(<span class="number">11999</span>);</span><br><span class="line">                <span class="keyword">return</span> c2;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：工厂模式。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FactoryDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Computer</span> <span class="variable">c1</span> <span class="operator">=</span> FactoryPattern.createComputer(<span class="string">&quot;huawei&quot;</span>); <span class="comment">// 调用工厂类的工厂方法，返回指定对象</span></span><br><span class="line">        c1.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">Computer</span> <span class="variable">c2</span> <span class="operator">=</span> FactoryPattern.createComputer(<span class="string">&quot;mac&quot;</span>);</span><br><span class="line">        c2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-设计模式：装饰模式-构造器层层包装"><a href="#5-设计模式：装饰模式-构造器层层包装" class="headerlink" title="5.设计模式：装饰模式(构造器层层包装)"></a>5.设计模式：装饰模式(构造器层层包装)</h3><p><strong>什么是装饰设计模式？</strong></p><ul><li>创建一个新类，包装原始类，从而在新类中提升原来类的功能。</li></ul><p><strong>装饰设计模式的作用：</strong></p><ul><li>作用：装饰模式指的是在不改变原类的基础上, 动态地扩展一个类的功能。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">InputStream(抽象父类)</span><br><span class="line">FileInputStream(实现子类，读写性能较差)</span><br><span class="line">BufferedInputStream(实现子类，装饰类，读写性能高)</span><br></pre></td></tr></table></figure><p><strong>设计过程说明：</strong></p><p>①定义父类。</p><p>②定义原始类，继承父类，定义功能。</p><p>③定义装饰类，继承父类，包装原始类，增强功能！！</p><p><strong>代码：模拟装饰模式</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   使用抽象类，定义共同父类(InputStream),提供抽象方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">InputStream</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">byte</span>[] buffer)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   定义原始类(FileInputStream)继承父类(InputStream)，设计原始方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileInputStream</span> <span class="keyword">extends</span> <span class="title class_">InputStream</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;低性能的方式读取了一个字节a&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">97</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">byte</span>[] buffer)</span> &#123;</span><br><span class="line">        buffer[<span class="number">0</span>] = <span class="number">97</span>;</span><br><span class="line">        buffer[<span class="number">1</span>] = <span class="number">98</span>;</span><br><span class="line">        buffer[<span class="number">2</span>] = <span class="number">99</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;低性能的方式读取了一个字节数组：&quot;</span> + Arrays.toString(buffer));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   定义装饰类，继承父类(InputStream) 拓展原始类的功能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedInputStream</span> <span class="keyword">extends</span> <span class="title class_">InputStream</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> InputStream is;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BufferedInputStream</span><span class="params">(InputStream is)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.is = is;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;提供8KB的缓冲区，提高读数据性能~~~~&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> is.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">byte</span>[] buffer)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;提供8KB的缓冲区，提高读数据性能~~~~&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> is.read(buffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  装饰模式模拟实现</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    1.定义父类：InputStream</span></span><br><span class="line"><span class="comment">    2.定义实现类：FileInputStream 继续父类 定义功能</span></span><br><span class="line"><span class="comment">    3.定义装饰实现类：BufferedInputStream 继承父类 定义功能 包装原始类，增强功能。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DecoratorPattern</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>());</span><br><span class="line">        System.out.println(is.read());</span><br><span class="line">        System.out.println(is.read(<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">3</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> java,面向对象进阶,XML,xml解析,工厂模式,装饰模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>day22 - 单元测试、反射、注解、动态代理</title>
      <link href="/post/a44e5d86.html"/>
      <url>/post/a44e5d86.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-单元测试"><a href="#1-单元测试" class="headerlink" title="1.单元测试"></a>1.单元测试</h3><h4 id="1-1单元测试概述"><a href="#1-1单元测试概述" class="headerlink" title="1.1单元测试概述"></a>1.1单元测试概述</h4><p><strong>单元测试</strong></p><ul><li>单元测试就是针对最小的功能单元编写测试代码，Java程序最小的功能单元是方法，因此，单元测试就是针对Java方法的测试，进而检查方法的正确性。</li></ul><p><strong>目前测试方法是怎么进行的，存在什么问题</strong></p><ul><li><p>只有一个main方法，如果一个方法的测试失败了，其他方法测试会受到影响。</p></li><li><p>无法得到测试的结果报告，需要程序员自己去观察测试是否成功。</p></li><li><p>无法实现自动化测试。</p></li></ul><p><strong>Junit单元测试框架</strong></p><ul><li><p>JUnit是使用Java语言实现的单元测试框架，它是开源的，Java开发者都应当学习并使用JUnit编写单元测试。</p></li><li><p>此外，几乎所有的IDE工具都集成了JUnit，这样我们就可以直接在IDE中编写并运行JUnit测试，JUnit目前最新版本是5。</p></li></ul><p><strong>JUnit优点</strong></p><ul><li><p>JUnit可以灵活的选择执行哪些测试方法，可以一键执行全部测试方法。</p></li><li><p>Junit可以生成全部方法的测试报告。</p></li><li><p>单元测试中的某个方法测试失败了，不会影响其他测试方法的测试。</p></li></ul><h4 id="1-2单元测试快速入门"><a href="#1-2单元测试快速入门" class="headerlink" title="1.2单元测试快速入门"></a>1.2单元测试快速入门</h4><p><strong>需求：</strong></p><p>使用单元测试进行业务方法预期结果、正确性测试的快速入门</p><p><strong>分析：</strong></p><ul><li><p>①将JUnit的jar包导入到项目中</p><ul><li>IDEA通常整合好了Junit框架，一般不需要导入。</li><li>如果IDEA没有整合好，需要自己手工导入如下2个JUnit的jar包到模块</li></ul></li><li><p>②编写测试方法：该测试方法必须是<strong>公共的无参数无返回值的非静态方法</strong>。</p></li><li><p>③在测试方法上<strong>使用@Test注解</strong>：标注该方法是一个测试方法</p></li><li><p>④在测试方法中完成被测试方法的预期正确性测试。</p></li><li><p>⑤选中测试方法，选择“JUnit运行” ，如果<strong>测试良好</strong>则是<strong>绿色</strong>；如果<strong>测试失败</strong>，则是<strong>红色</strong></p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   业务方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">loginName</span><span class="params">(String loginName , String passWord)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;admin&quot;</span>.equals(loginName) &amp;&amp; <span class="string">&quot;123456&quot;</span>.equals(passWord))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;登录成功&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;用户名或者密码有问题&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">selectNames</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="number">10</span>/<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;查询全部用户名称成功~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestUserService</span> &#123;</span><br><span class="line">    <span class="comment">// 修饰实例方法的</span></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===before方法执行一次===&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===after方法执行一次===&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修饰静态方法</span></span><br><span class="line">    <span class="meta">@BeforeClass</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">beforeClass</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===beforeClass方法执行一次===&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterClass</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">afterClass</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===afterClass方法执行一次===&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">       测试方法</span></span><br><span class="line"><span class="comment">       注意点：</span></span><br><span class="line"><span class="comment">            1、必须是公开的，无参数 无返回值的方法</span></span><br><span class="line"><span class="comment">            2、测试方法必须使用<span class="doctag">@Test</span>注解标记。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLoginName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//1.使用业务创建对象</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserService</span>(); </span><br><span class="line">        <span class="comment">//2.用对象调用需要测试的方法</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> userService.loginName(<span class="string">&quot;admin&quot;</span>,<span class="string">&quot;123456&quot;</span>); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进行预期结果的正确性测试：断言。</span></span><br><span class="line">        Assert.assertEquals(<span class="string">&quot;您的登录业务可能出现问题&quot;</span>, <span class="string">&quot;登录成功&quot;</span>, rs );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectNames</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserService</span>();</span><br><span class="line">        userService.selectNames();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3单元测试常用注解"><a href="#1-3单元测试常用注解" class="headerlink" title="1.3单元测试常用注解"></a>1.3单元测试常用注解</h4><p><strong>Junit常用注解(Junit 4.xxxx版本)</strong></p><table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td>@Test</td><td>测试方法</td></tr><tr><td>@Before</td><td>用来修饰实例方法，该方法会在每一个测试方法执行之前执行一次。</td></tr><tr><td>@After</td><td>用来修饰实例方法，该方法会在每一个测试方法执行之后执行一次。</td></tr><tr><td>@BeforeClass</td><td>用来静态修饰方法，该方法会在所有测试方法之前只执行一次。</td></tr><tr><td>@AfterClass</td><td>用来静态修饰方法，该方法会在所有测试方法之后只执行一次。</td></tr></tbody></table><ul><li><p>开始执行的方法:初始化资源。</p></li><li><p>执行完之后的方法:释放资源。</p></li></ul><p><strong>Junit常用注解(Junit 5.xxxx版本)</strong></p><table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td>@Test</td><td>测试方法</td></tr><tr><td>@BeforeEach</td><td>用来修饰实例方法，该方法会在每一个测试方法执行之前执行一次。</td></tr><tr><td>@AfterEach</td><td>用来修饰实例方法，该方法会在每一个测试方法执行之后执行一次。</td></tr><tr><td>@BeforeAll</td><td>用来静态修饰方法，该方法会在所有测试方法之前只执行一次。</td></tr><tr><td>@AfterAll</td><td>用来静态修饰方法，该方法会在所有测试方法之后只执行一次。</td></tr></tbody></table><ul><li><p>开始执行的方法:初始化资源。</p></li><li><p>执行完之后的方法:释放资源。</p></li></ul><h3 id="2-反射"><a href="#2-反射" class="headerlink" title="2.反射"></a>2.反射</h3><h4 id="2-1反射概述"><a href="#2-1反射概述" class="headerlink" title="2.1反射概述"></a>2.1反射概述</h4><p><strong>反射概述</strong></p><ul><li><p>反射是指对于任何一个Class类，在”运行的时候”都可以直接得到这个类全部成分。</p></li><li><p>在运行时,可以直接得到这个类的构造器对象：Constructor</p></li><li><p>在运行时,可以直接得到这个类的成员变量对象：Field</p></li><li><p>在运行时,可以直接得到这个类的成员方法对象：Method</p></li><li><p>这种运行时动态获取类信息以及动态调用类中成分的能力称为Java语言的反射机制。</p></li></ul><p><strong>反射的关键：</strong></p><ul><li>反射的第一步都是先得到编译后的Class类对象，然后就可以得到Class的全部成分。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HelloWorld.java -&gt; javac -&gt; HelloWorld.class</span><br><span class="line">Class c = HelloWorld.class;</span><br></pre></td></tr></table></figure><h4 id="2-2反射获取类对象"><a href="#2-2反射获取类对象" class="headerlink" title="2.2反射获取类对象"></a>2.2反射获取类对象</h4><p><strong>获取Class类的对象的三种方法</strong></p><p><strong>使用对象的getClass()方法</strong>：如果已经有一个对象，可以使用该对象的getClass()方法来获取它的Class类对象。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javaCopy <span class="type">codeMyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">Class&lt;?&gt; clazz = obj.getClass();</span><br></pre></td></tr></table></figure><p><strong>使用类的.class属性</strong>：每个类都有一个特殊的属性，通过在类名后面加上”.class”来获取该类的Class类对象。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javaCopy code</span><br><span class="line">Class&lt;?&gt; clazz = MyClass.class;</span><br></pre></td></tr></table></figure><p><strong>使用Class类的forName()方法</strong>：可以通过提供类的全限定名（包括包名）来使用Class类的forName()方法来获取Class类对象。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javaCopy code</span><br><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.example.MyClass&quot;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个学生类</span></span><br><span class="line"><span class="keyword">package</span> com.itheima.d2_reflect_class;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   目标：反射的第一步：获取学生类的Class对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、Class类中的一个静态方法：forName(全限名：包名 + 类名)</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.itheima.d2_reflect_class.Student&quot;</span>);</span><br><span class="line">        System.out.println(c); <span class="comment">// Student.class</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、类名.class (常用)</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> Student.class;</span><br><span class="line">        System.out.println(c1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、对象.getClass() 获取对象对应类的Class对象。</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        <span class="type">Class</span> <span class="variable">c2</span> <span class="operator">=</span> s.getClass();</span><br><span class="line">        System.out.println(c2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3反射获取构造器对象"><a href="#2-3反射获取构造器对象" class="headerlink" title="2.3反射获取构造器对象"></a>2.3反射获取构造器对象</h4><p><strong>使用反射技术获取构造器对象并使用</strong></p><p>反射是一种在运行时检查、访问和操作类、接口、字段、方法等程序元素的能力。在Java中，您可以使用反射技术来获取构造器对象并使用它来创建新的实例。下面是一个使用反射获取构造器对象并创建实例的示例：</p><p>假设有一个类 <code>Person</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javaCopy codepublic <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">introduce</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, I&#x27;m &quot;</span> + name + <span class="string">&quot; and I&#x27;m &quot;</span> + age + <span class="string">&quot; years old.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用以下代码来使用反射获取构造器对象并创建 <code>Person</code> 类的实例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javaCopy code<span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectionExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取Person类的Class对象</span></span><br><span class="line">        Class&lt;Person&gt; personClass = Person.class;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取带有两个参数的构造器</span></span><br><span class="line">        Constructor&lt;Person&gt; constructor = personClass.getConstructor(String.class, <span class="type">int</span>.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用构造器创建实例</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> constructor.newInstance(<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用实例方法</span></span><br><span class="line">        person.introduce();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用反射技术获取构造器对象并使用</strong></p><ul><li><p>反射的第一步是先得到类对象，然后从类对象中获取类的成分对象。</p></li><li><p>Class类中用于获取构造器的方法</p></li><li><p>获取构造器的作用依然是初始化一个对象返回。</p></li></ul><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>Constructor&lt;?&gt;[]  <strong>getConstructors</strong>()</td><td>返回<strong>所有 public</strong> 修饰的构造器对象的数组</td></tr><tr><td>Constructor&lt;?&gt;[]  <strong>getDeclaredConstructors</strong>()</td><td>返回<strong>所有构造器对象</strong>的数组，存在就能拿到</td></tr><tr><td>Constructor<T>  <strong>getConstructor</strong>(Class&lt;?&gt;…  parameterTypes)</td><td>返回<strong>单个 public</strong> 修饰构造器对象</td></tr><tr><td>Constructor<T>  <strong>getDeclaredConstructor</strong>(Class&lt;?&gt;…  parameterTypes)</td><td>返回<strong>单个构造器对象</strong>，存在就能拿到</td></tr></tbody></table><p><strong>Constructor类中用于创建对象的方法</strong></p><table><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody><tr><td>T <strong>newInstance</strong>(Object…  initargs)</td><td>根据指定的构造器创建对象</td></tr><tr><td>public  void <strong>setAccessible</strong>(boolean  flag)</td><td>设置为true,表示取消访问检查，进行暴力反射</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个学生类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Student</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;无参数构造器执行！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;有参数构造器执行！&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>获取<Constructor>构造器对象</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：反射_获取&lt;Constructor&gt;构造器对象.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    反射的第一步是先得到Class类对象。（Class文件）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">小结：</span></span><br><span class="line"><span class="comment">        2获取类的全部构造器对象： Constructor[] getDeclaredConstructors()</span></span><br><span class="line"><span class="comment">            -- 获取所有申明的构造器，只要你写我就能拿到，无所谓权限。建议使用！</span></span><br><span class="line"><span class="comment">        4获取类的某个构造器对象：Constructor getDeclaredConstructor(Class... parameterTypes)</span></span><br><span class="line"><span class="comment">            -- 根据参数匹配获取某个构造器，只要申明就可以定位，不关心权限修饰符，建议使用！</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStudent01</span> &#123;</span><br><span class="line">    <span class="comment">// 1. getConstructors</span></span><br><span class="line">    <span class="comment">//获取全部的构造器：只能获取public修饰的构造器。</span></span><br><span class="line">    <span class="comment">// Constructor[] - getConstructors()</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getConstructors</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// a.第一步：获取类对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Student.class;</span><br><span class="line">        <span class="comment">// b.提取类中的全部的构造器对象(这里只能拿public修饰)</span></span><br><span class="line">        Constructor[] constructors = c.getConstructors();</span><br><span class="line">        <span class="comment">// c.遍历构造器</span></span><br><span class="line">        <span class="keyword">for</span> (Constructor constructor : constructors) &#123;</span><br><span class="line">            System.out.println(constructor.getName() + <span class="string">&quot;===&gt;&quot;</span> + constructor.getParameterCount());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.getDeclaredConstructors():</span></span><br><span class="line">    <span class="comment">// 获取全部的构造器数组：只要你敢写，这里就能拿到，无所谓权限是否可及。</span></span><br><span class="line">    <span class="comment">//Constructor[] - getDeclaredConstructors()</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getDeclaredConstructors</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// a.第一步：获取类对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Student.class;</span><br><span class="line">        <span class="comment">// b.提取类中的全部的构造器对象</span></span><br><span class="line">        Constructor[] constructors = c.getDeclaredConstructors();</span><br><span class="line">        <span class="comment">// c.遍历构造器</span></span><br><span class="line">        <span class="keyword">for</span> (Constructor constructor : constructors) &#123;</span><br><span class="line">            System.out.println(constructor.getName() + <span class="string">&quot;===&gt;&quot;</span> + constructor.getParameterCount());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.getConstructor(Class... parameterTypes)</span></span><br><span class="line">    <span class="comment">// 获取某个构造器：只能拿public修饰的某个构造器</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getConstructor</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// a.第一步：获取类对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Student.class;</span><br><span class="line">        <span class="comment">// b.定位单个构造器对象 (按照参数定位无参数构造器 只能拿public修饰的某个构造器)</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">cons</span> <span class="operator">=</span> c.getConstructor();</span><br><span class="line">        System.out.println(cons.getName() + <span class="string">&quot;===&gt;&quot;</span> + cons.getParameterCount());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.getConstructor(Class... parameterTypes)</span></span><br><span class="line">    <span class="comment">// 获取某个构造器：只要你敢写，这里就能拿到，无所谓权限是否可及。</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getDeclaredConstructor</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// a.第一步：获取类对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Student.class;</span><br><span class="line">        <span class="comment">// b.定位单个构造器对象 (按照参数定位无参数构造器)</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">cons</span> <span class="operator">=</span> c.getDeclaredConstructor();</span><br><span class="line">        System.out.println(cons.getName() + <span class="string">&quot;===&gt;&quot;</span> + cons.getParameterCount());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// c.定位某个有参构造器</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">cons1</span> <span class="operator">=</span> c.getDeclaredConstructor(String.class, <span class="type">int</span>.class);</span><br><span class="line">        System.out.println(cons1.getName() + <span class="string">&quot;===&gt;&quot;</span> + cons1.getParameterCount());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><Constructor>构造器初始化对象</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标: 反射_获取Constructor构造器然后通过这个构造器初始化对象。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    反射获取Class中的构造器对象Constructor作用：</span></span><br><span class="line"><span class="comment">            也是初始化并得到类的一个对象返回。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Constructor的API:</span></span><br><span class="line"><span class="comment">         1. T newInstance(Object... initargs)</span></span><br><span class="line"><span class="comment">                创建对象，注入构造器需要的数据。</span></span><br><span class="line"><span class="comment">         2. void setAccessible(true)</span></span><br><span class="line"><span class="comment">                修改访问权限，true代表暴力攻破权限，false表示保留不可访问权限(暴力反射)</span></span><br><span class="line"><span class="comment">    小结：</span></span><br><span class="line"><span class="comment">        可以通过定位类的构造器对象。</span></span><br><span class="line"><span class="comment">        如果构造器对象没有访问权限可以通过：void setAccessible(true)打开权限</span></span><br><span class="line"><span class="comment">        构造器可以通过T newInstance(Object... initargs)调用自己，传入参数！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStudent02</span> &#123;</span><br><span class="line">    <span class="comment">// 1.调用构造器得到一个类的对象返回。</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getDeclaredConstructor</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// a.第一步：获取类对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Student.class;</span><br><span class="line">        <span class="comment">// b.定位单个构造器对象 </span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">cons</span> <span class="operator">=</span> c.getDeclaredConstructor(); <span class="comment">//按照参数定位无参数构造器</span></span><br><span class="line">        System.out.println(cons.getName() + <span class="string">&quot;===&gt;&quot;</span> + cons.getParameterCount());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果遇到了私有的构造器，可以暴力反射</span></span><br><span class="line">        cons.setAccessible(<span class="literal">true</span>); <span class="comment">// 权限被打开</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> (Student) cons.newInstance(); <span class="comment">//创建无参构造器对象</span></span><br><span class="line">        System.out.println(s);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// c.定位某个有参构造器</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">cons1</span> <span class="operator">=</span> c.getDeclaredConstructor(String.class, <span class="type">int</span>.class); <span class="comment">//按照参数定位有参构造器</span></span><br><span class="line">        System.out.println(cons1.getName() + <span class="string">&quot;===&gt;&quot;</span> + cons1.getParameterCount());</span><br><span class="line"></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> (Student) cons1.newInstance(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">1000</span>); <span class="comment">//创建有参构造器对象</span></span><br><span class="line">        System.out.println(s1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4反射获取成员变量对象"><a href="#2-4反射获取成员变量对象" class="headerlink" title="2.4反射获取成员变量对象"></a>2.4反射获取成员变量对象</h4><p><strong>使用反射技术获取成员变量对象并使用</strong></p><p>假设有一个名为<code>Person</code>的类，其中包含一个成员变量<code>name</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javaCopy codepublic <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用反射来获取并操作<code>Person</code>类的成员变量<code>name</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javaCopy code<span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectionExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line">        <span class="comment">// 创建一个Person对象</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取Person类的Class对象</span></span><br><span class="line">        Class&lt;Person&gt; personClass = Person.class;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取名为 &quot;name&quot; 的成员变量</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">nameField</span> <span class="operator">=</span> personClass.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置允许访问私有字段</span></span><br><span class="line">        nameField.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取字段的值</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">nameValue</span> <span class="operator">=</span> (String) nameField.get(person);</span><br><span class="line">            System.out.println(<span class="string">&quot;Original Name: &quot;</span> + nameValue);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 修改字段的值</span></span><br><span class="line">            nameField.set(person, <span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">newNameValue</span> <span class="operator">=</span> (String) nameField.get(person);</span><br><span class="line">            System.out.println(<span class="string">&quot;New Name: &quot;</span> + newNameValue);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用反射技术获取成员变量对象并使用</strong></p><ul><li><p>反射的第一步是先得到类对象，然后从类对象中获取类的成分对象。</p></li><li><p>Class类中用于获取成员变量的方法</p></li><li><p>获取成员变量的作用依然是在某个对象中取值、赋值</p></li></ul><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>Field[]  <strong>getFields</strong>()</td><td>返回所有成员变量对象的数组（只能拿public的）</td></tr><tr><td>Field[]  <strong>getDeclaredFields</strong>()</td><td>返回所有成员变量对象的数组，存在就能拿到</td></tr><tr><td>Field  <strong>getField</strong>(String  name)</td><td>返回单个成员变量对象（只能拿public的）</td></tr><tr><td>Field  <strong>getDeclaredField</strong>(String  name)</td><td>返回单个成员变量对象，存在就能拿到</td></tr></tbody></table><p><strong>Field类中用于取值、赋值的方法</strong></p><table><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody><tr><td>void  <strong>set</strong>(Object obj, Object value)：</td><td>赋值</td></tr><tr><td>Object  <strong>get</strong>(Object obj)</td><td>获取值。</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个学生类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name; </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String schoolName;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">COUNTTRY</span> <span class="operator">=</span> <span class="string">&quot;中国&quot;</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;无参数构造器执行！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;有参数构造器执行！&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>获取<Field>成员变量对象</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     目标：反射_获取Field成员变量对象。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     反射的第一步是先得到Class类对象。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     1、Field getField(String name);</span></span><br><span class="line"><span class="comment">            根据成员变量名获得对应Field对象，只能获得public修饰</span></span><br><span class="line"><span class="comment">     2.Field getDeclaredField(String name);</span></span><br><span class="line"><span class="comment">            根据成员变量名获得对应Field对象，只要申明了就可以得到</span></span><br><span class="line"><span class="comment">     3.Field[] getFields();</span></span><br><span class="line"><span class="comment">            获得所有的成员变量对应的Field对象，只能获得public的</span></span><br><span class="line"><span class="comment">     4.Field[] getDeclaredFields();</span></span><br><span class="line"><span class="comment">            获得所有的成员变量对应的Field对象，只要申明了就可以得到</span></span><br><span class="line"><span class="comment">     小结：</span></span><br><span class="line"><span class="comment">        获取全部成员变量：getDeclaredFields</span></span><br><span class="line"><span class="comment">        获取某个成员变量：getDeclaredField</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FieldDemo01</span> &#123;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">//1.获取全部的成员变量。</span></span><br><span class="line">     <span class="comment">//Field[] - getDeclaredFields();</span></span><br><span class="line">     <span class="comment">//获得所有的成员变量对应的Field对象，只要申明了就可以得到</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getDeclaredFields</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// a.定位Class对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Student.class;</span><br><span class="line">        <span class="comment">// b.定位全部成员变量</span></span><br><span class="line">        Field[] fields = c.getDeclaredFields();</span><br><span class="line">        <span class="comment">// c.遍历一下</span></span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            System.out.println(field.getName() + <span class="string">&quot;==&gt;&quot;</span> + field.getType());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">———————————————————————————————————————————————————————————————————————————————————————————————————————————— </span><br><span class="line">    </span><br><span class="line">        <span class="comment">//2.获取某个成员变量对象</span></span><br><span class="line">        <span class="comment">//Field - getDeclaredField(String name);</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getDeclaredField</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// a.定位Class对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Student.class;</span><br><span class="line">        <span class="comment">// b.根据名称定位某个成员变量</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">        System.out.println(f.getName() +<span class="string">&quot;===&gt;&quot;</span> + f.getType());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><Field>成员变量对象赋值</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：反射获取成员变量: 取值和赋值。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Field的方法：给成员变量赋值和取值</span></span><br><span class="line"><span class="comment">        void set(Object obj, Object value)：给对象注入某个成员变量数据</span></span><br><span class="line"><span class="comment">        Object get(Object obj):获取对象的成员变量的值。</span></span><br><span class="line"><span class="comment">        void setAccessible(true);暴力反射，设置为可以直接访问私有类型的属性。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FieldDemo02</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setField</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// a.反射第一步，获取类对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Student.class;</span><br><span class="line">        <span class="comment">// b.提取某个成员变量</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">ageF</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ageF.setAccessible(<span class="literal">true</span>); <span class="comment">// 暴力打开权限</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// c.赋值</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        ageF.set(s , <span class="number">18</span>);  <span class="comment">// s.setAge(18);</span></span><br><span class="line">        System.out.println(s);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// d、取值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> (<span class="type">int</span>) ageF.get(s);</span><br><span class="line">        System.out.println(age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-5反射获取方法对象"><a href="#2-5反射获取方法对象" class="headerlink" title="2.5反射获取方法对象"></a>2.5反射获取方法对象</h4><p><strong>使用反射技术获取方法对象并使用</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectionExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Class&lt;?&gt; targetClass = Class.forName(<span class="string">&quot;com.example.TargetClass&quot;</span>); <span class="comment">// 替换成目标类名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> <span class="string">&quot;methodName&quot;</span>; <span class="comment">// 替换成方法名</span></span><br><span class="line">        Class&lt;?&gt;[] parameterTypes = &#123;String.class, <span class="type">int</span>.class&#125;; <span class="comment">// 替换成参数类型</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> targetClass.getDeclaredMethod(methodName, parameterTypes);</span><br><span class="line">        method.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> targetClass.getDeclaredConstructor().newInstance();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(instance, <span class="string">&quot;argument1&quot;</span>, <span class="number">42</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Result: &quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用反射技术获取方法对象并使用</strong></p><ul><li><p>反射的第一步是先得到类对象，然后从类对象中获取类的成分对象。</p></li><li><p>Class类中用于获取成员方法的方法</p></li><li><p>获取成员方法的作用依然是在某个对象中进行执行此方法</p></li></ul><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>Method[]  <strong>getMethods</strong>()</td><td>返回所有成员方法对象的数组（只能拿public的）</td></tr><tr><td>Method[]  <strong>getDeclaredMethods</strong>()</td><td>返回所有成员方法对象的数组，存在就能拿到</td></tr><tr><td>Method  <strong>getMethod</strong>(String  name, Class&lt;?&gt;… parameterTypes)</td><td>返回单个成员方法对象（只能拿public的）</td></tr><tr><td>Method  <strong>getDeclaredMethod</strong>(String  name, Class&lt;?&gt;… parameterTypes)</td><td>返回单个成员方法对象，存在就能拿到</td></tr></tbody></table><p><strong>Method类中用于触发执行的方法</strong></p><table><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody><tr><td>Object <strong>invoke</strong>(Object obj, Object… args)</td><td>运行方法                                                                                                                                                                             参数一：<strong>用obj对象调用该方法</strong>                                                                                                                                           参数二：<strong>调用方法传递的参数</strong>（如果没有就不写）                                                                                                               返回值：<strong>方法的返回值</strong>（如果没有就不写）</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个dog类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name ;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗跑的贼快~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗吃骨头&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">eat</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗吃&quot;</span> + name);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;吃的很开心！&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">inAddr</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;在黑马学习Java!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>获取<Method>方法对象</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：反射——获取Method方法对象</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    反射获取类的Method方法对象：</span></span><br><span class="line"><span class="comment">         1、Method getMethod(String name,Class...args);</span></span><br><span class="line"><span class="comment">             根据方法名和参数类型获得对应的方法对象，只能获得public的</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         2、Method getDeclaredMethod(String name,Class...args);</span></span><br><span class="line"><span class="comment">             根据方法名和参数类型获得对应的方法对象，包括private的</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         3、Method[] getMethods();</span></span><br><span class="line"><span class="comment">             获得类中的所有成员方法对象，返回数组，只能获得public修饰的且包含父类的</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         4、Method[] getDeclaredMethods();</span></span><br><span class="line"><span class="comment">            获得类中的所有成员方法对象，返回数组,只获得本类申明的方法。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Method的方法执行：</span></span><br><span class="line"><span class="comment">        Object invoke(Object obj, Object... args)</span></span><br><span class="line"><span class="comment">          参数一：触发的是哪个对象的方法执行。</span></span><br><span class="line"><span class="comment">          参数二： args：调用方法时传递的实际参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodDemo01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.获得类中的所有成员方法对象</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getDeclaredMethods</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// a.获取类对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Dog.class;</span><br><span class="line">        <span class="comment">// b.提取全部方法；包括私有的</span></span><br><span class="line">        Method[] methods = c.getDeclaredMethods();</span><br><span class="line">        <span class="comment">// c.遍历全部方法</span></span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            System.out.println(method.getName() +<span class="string">&quot; 返回值类型：&quot;</span> + method.getReturnType() + <span class="string">&quot; 参数个数：&quot;</span> + method.getParameterCount());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   ————————————————————————————————————————————————————————————————————————————————————————————————————————————</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2. 获取某个方法对象</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getDeclardMethod</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// a.获取类对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Dog.class;</span><br><span class="line">        <span class="comment">// b.提取单个方法对象</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> c.getDeclaredMethod(<span class="string">&quot;eat&quot;</span>); <span class="comment">//方法名</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">m2</span> <span class="operator">=</span> c.getDeclaredMethod(<span class="string">&quot;eat&quot;</span>, String.class); <span class="comment">//方法名，传入参数类型</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 暴力打开权限了</span></span><br><span class="line">        m.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        m2.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// c.触发方法的执行</span></span><br><span class="line">        <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="comment">// 注意：方法如果是没有结果回来的，那么返回的是null.</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> m.invoke(d);</span><br><span class="line">        System.out.println(result);</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result2</span> <span class="operator">=</span> m2.invoke(d, <span class="string">&quot;骨头&quot;</span>); <span class="comment">//对象，传入参数</span></span><br><span class="line">        System.out.println(result2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-6反射的作用-绕过编译阶段为集合添加数据"><a href="#2-6反射的作用-绕过编译阶段为集合添加数据" class="headerlink" title="2.6反射的作用-绕过编译阶段为集合添加数据"></a>2.6反射的作用-绕过编译阶段为集合添加数据</h4><p><strong>反射的作用-绕过编译阶段为集合添加数据</strong></p><ul><li>反射是作用在运行时的技术，此时集合的泛型将不能产生约束了，此时是可以为集合存入其他任意类型的元素的。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="number">100</span>);</span><br><span class="line"><span class="comment">// list.add(“黑马&quot;); // 报错</span></span><br><span class="line">list.add(<span class="number">99</span>);</span><br></pre></td></tr></table></figure><ul><li>泛型只是在编译阶段可以约束集合只能操作某种数据类型，在编译成Class文件进入运行阶段的时候，其真实类型都是ArrayList了，泛型相当于被擦除了。</li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 需求：反射实现泛型擦除后，加入其他类型的元素</span></span><br><span class="line">        ArrayList&lt;String&gt; lists1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; lists2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        System.out.println(lists1.getClass());</span><br><span class="line">        System.out.println(lists2.getClass());</span><br><span class="line"></span><br><span class="line">        System.out.println(lists1.getClass() ==  lists2.getClass());  <span class="comment">// 运行阶段的，泛型将不存在，其真实类型都是ArrayList，都具有相同地址</span></span><br><span class="line"></span><br><span class="line">————————————————————————————————————————————————————————————————————————————————————————————————————————————</span><br><span class="line">    </span><br><span class="line">        ArrayList&lt;Integer&gt; lists3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        lists3.add(<span class="number">23</span>); </span><br><span class="line">        lists3.add(<span class="number">22</span>);</span><br><span class="line">        <span class="comment">// lists3.add(&quot;黑马&quot;); //此时不能添加String类型</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//a.获取lists3集合类的对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> lists3.getClass(); <span class="comment">// ArrayList.class  ===&gt; public boolean add(E e)</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//b.定位c类中的add方法</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">add</span> <span class="operator">=</span> c.getDeclaredMethod(<span class="string">&quot;add&quot;</span>, Object.class);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//c.调用invoke触发执行的方法,执行add添加内容</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">rs</span> <span class="operator">=</span> (<span class="type">boolean</span>) add.invoke(lists3, <span class="string">&quot;黑马&quot;</span>);</span><br><span class="line">        System.out.println(rs);</span><br><span class="line"></span><br><span class="line">        System.out.println(lists3);</span><br><span class="line"></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">list4</span> <span class="operator">=</span> lists3;</span><br><span class="line">        list4.add(<span class="string">&quot;白马&quot;</span>);</span><br><span class="line">        list4.add(<span class="literal">false</span>);</span><br><span class="line">        System.out.println(lists3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-7反射的作用-通用框架的底层原理"><a href="#2-7反射的作用-通用框架的底层原理" class="headerlink" title="2.7反射的作用-通用框架的底层原理"></a>2.7反射的作用-通用框架的底层原理</h4><p><strong>反射做通用框架</strong></p><p><strong>需求：</strong></p><p>给你任意一个对象，在不清楚对象字段的情况可以，可以把对象的字段名称和对应值存储到文件中去。</p><p><strong>需求</strong></p><ul><li>给你任意一个对象，在不清楚对象字段的情况可以，可以把对象的字段名称和对应值存储到文件中去。</li></ul><p><strong>分析</strong></p><p>①定义一个方法，可以接收任意类的对象。</p><p>②每次收到一个对象后，需要解析这个对象的全部成员变量名称。</p><p>③这个对象可能是任意的，那么怎么样才可以知道这个对象的全部成员变量名称呢？</p><p>④使用反射获取对象的Class类对象，然后获取全部成员变量信息。</p><p>⑤遍历成员变量信息，然后提取本成员变量在对象中的具体值</p><p>⑥存入成员变量名称和值到文件中去即可。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建学生类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span> sex;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String className;</span><br><span class="line">    <span class="keyword">private</span> String hobby;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">char</span> sex, <span class="type">int</span> age, String className, String hobby)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.className = className;</span><br><span class="line">        <span class="built_in">this</span>.hobby = hobby;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">getSex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSex</span><span class="params">(<span class="type">char</span> sex)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getClassName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> className;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setClassName</span><span class="params">(String className)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.className = className;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getHobby</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> hobby;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHobby</span><span class="params">(String hobby)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.hobby = hobby;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建老师类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span> sex;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> salary;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Teacher</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Teacher</span><span class="params">(String name, <span class="type">char</span> sex, <span class="type">double</span> salary)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">        <span class="built_in">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">getSex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSex</span><span class="params">(<span class="type">char</span> sex)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getSalary</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSalary</span><span class="params">(<span class="type">double</span> salary)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    创建save方法 </span></span><br><span class="line"><span class="comment">    保存任意类型的对象到文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;junit-reflect-annotation-proxy-app/src/data.txt&quot;</span>, <span class="literal">true</span>));</span><br><span class="line">        )&#123;</span><br><span class="line">            <span class="comment">// 1、提取这个对象的全部成员变量：只有反射可以解决</span></span><br><span class="line">            <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> obj.getClass();  </span><br><span class="line">            <span class="comment">// c.getSimpleName()获取当前类名   c.getName获取全限名：包名+类名</span></span><br><span class="line">            ps.println(<span class="string">&quot;================&quot;</span> + c.getSimpleName() + <span class="string">&quot;================&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2、提取它的全部成员变量</span></span><br><span class="line">            Field[] fields = c.getDeclaredFields(); </span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 3、遍历 获取成员变量的信息</span></span><br><span class="line">            <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> field.getName();</span><br><span class="line">                <span class="comment">// 提取本成员变量在obj对象中的值（取值）</span></span><br><span class="line">                field.setAccessible(<span class="literal">true</span>); <span class="comment">//暴力反射</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> field.get(obj) + <span class="string">&quot;&quot;</span>;</span><br><span class="line">                ps.println(name  + <span class="string">&quot;=&quot;</span> + value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   目标：提供一个通用框架，支持保存所有对象的具体信息。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        s.setName(<span class="string">&quot;猪八戒&quot;</span>);</span><br><span class="line">        s.setClassName(<span class="string">&quot;西天跑路1班&quot;</span>);</span><br><span class="line">        s.setAge(<span class="number">1000</span>);</span><br><span class="line">        s.setHobby(<span class="string">&quot;吃，睡&quot;</span>);</span><br><span class="line">        s.setSex(<span class="string">&#x27;男&#x27;</span>);</span><br><span class="line">        MybatisUtil.save(s);</span><br><span class="line"></span><br><span class="line">        <span class="type">Teacher</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>();</span><br><span class="line">        t.setName(<span class="string">&quot;波仔&quot;</span>);</span><br><span class="line">        t.setSex(<span class="string">&#x27;男&#x27;</span>);</span><br><span class="line">        t.setSalary(<span class="number">6000</span>);</span><br><span class="line">        MybatisUtil.save(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-注解"><a href="#3-注解" class="headerlink" title="3.注解"></a>3.注解</h3><h4 id="3-1注解概述"><a href="#3-1注解概述" class="headerlink" title="3.1注解概述"></a>3.1注解概述</h4><p><strong>注解概述、作用</strong></p><ul><li><p>Java 注解（Annotation）又称 Java 标注，是 JDK5.0 引入的一种注释机制。</p></li><li><p>Java 语言中的类、构造器、方法、成员变量、参数等都可以被注解进行标注。</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceTest</span> &#123;</span><br><span class="line"><span class="meta">@Test</span> <span class="comment">//注解（Annotation）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLogin</span><span class="params">()</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="meta">@Test</span> <span class="comment">//注解（Annotation）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testChu</span><span class="params">()</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注解的作用是什么呢？</strong></p><ul><li><p>对Java中类、方法、成员变量做<strong>标记，然后进行特殊处理</strong>，至于到底做何种处理由业务需求来决定。</p></li><li><p>例如：JUnit框架中，标记了注解@Test的方法就可以被当成测试方法执行，而没有标记的就不能当成测试方法执行。</p></li></ul><h4 id="3-2自定义注解"><a href="#3-2自定义注解" class="headerlink" title="3.2自定义注解"></a>3.2自定义注解</h4><p><strong>自定义注解</strong> <strong>—</strong> <strong>格式</strong></p><ul><li>自定义注解就是自己做一个注解来使用。</li></ul><p>属性类型：Java支持的数据类型基本上都支持</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> 注解名称 &#123; <span class="comment">// @interface为自定义注解</span></span><br><span class="line"><span class="keyword">public</span>(可省略) 属性类型 属性名() <span class="keyword">default</span> 默认值 ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>特殊属性</strong></p><ul><li><p>value属性，如果只有一个value属性的情况下，使用value属性的时候可以省略value名称不写!!</p></li><li><p>但是如果有多个属性, 且多个属性没有默认值，那么value名称是不能省略的。</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Book &#123;  <span class="comment">// @interface注解标识</span></span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>; <span class="comment">// 特殊属性</span></span><br><span class="line">    <span class="type">double</span> <span class="title function_">price</span><span class="params">()</span> ;</span><br><span class="line">    <span class="comment">//double price() default 9.9; // 默认值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   目标：学会自定义注解。掌握其定义格式和语法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//注解</span></span><br><span class="line"><span class="meta">@MyBook(name=&quot;《精通JavaSE》&quot;,authors = &#123;&quot;黑马&quot;, &quot;dlei&quot;&#125; , price = 199.5)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationDemo1</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//注解</span></span><br><span class="line">    <span class="meta">@MyBook(name=&quot;《精通JavaSE2》&quot;,authors = &#123;&quot;黑马&quot;, &quot;dlei&quot;&#125; , price = 199.5)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">AnnotationDemo1</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注解</span></span><br><span class="line">    <span class="meta">@MyBook(name=&quot;《精通JavaSE1》&quot;,authors = &#123;&quot;黑马&quot;, &quot;dlei&quot;&#125; , price = 199.5)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//注解</span></span><br><span class="line">        <span class="meta">@MyBook(name=&quot;《精通JavaSE2》&quot;,authors = &#123;&quot;黑马&quot;, &quot;dlei&quot;&#125; , price = 199.5)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">21</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3元注解"><a href="#3-3元注解" class="headerlink" title="3.3元注解"></a>3.3元注解</h4><p><strong>元注解</strong></p><ul><li>元注解：就是注解注解的注解。</li></ul><p><strong>元注解常用的两个：</strong></p><ul><li><p><strong>@Target</strong>: 约束自定义注解只能在哪些地方使用，</p></li><li><p><strong>@Retention</strong>：申明注解的生命周期</p></li></ul><p>@Target中可使用的值定义在ElementType枚举类中，常用值如下</p><ul><li><p>TYPE，类，接口</p></li><li><p>FIELD, 成员变量</p></li><li><p>METHOD, 成员方法</p></li><li><p>PARAMETER, 方法参数</p></li><li><p>CONSTRUCTOR, 构造器</p></li><li><p>LOCAL_VARIABLE, 局部变量</p></li></ul><p>@Retention中可使用的值定义在RetentionPolicy枚举类中，常用值如下</p><ul><li><p>SOURCE： 注解只作用在源码阶段，生成的字节码文件中不存在</p></li><li><p>CLASS： 注解作用在源码阶段，字节码文件阶段，运行阶段不存在，默认值.</p></li><li><p><strong>RUNTIME</strong>：注解作用在源码阶段，字节码文件阶段，运行阶段（开发常用）</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个元注解, 注解注解的注解。 </span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD,ElementType.FIELD&#125;)</span> <span class="comment">// 元注解 (METHOD注解成员方法，FIELD注解成员变量)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span> <span class="comment">// 一直活着，在运行阶段这个注解也不消失</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyTest &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   目标：认识元注解</span></span><br><span class="line"><span class="comment">   <span class="doctag">@MyTest</span> 只能注解方法和成员变量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//@MyTest //元注解未提供TYPE，此时不可以注解类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationDemo2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MyTest</span>  <span class="comment">//注解成员变量</span></span><br><span class="line">    <span class="keyword">private</span> String name; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">         <span class="meta">@MyTest</span>  <span class="comment">//注解成员方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-4注解解析"><a href="#3-4注解解析" class="headerlink" title="3.4注解解析"></a>3.4注解解析</h4><p><strong>注解的解析</strong></p><ul><li>注解的操作中经常需要进行解析，注解的解析就是判断是否存在注解，存在注解就解析出内容。</li></ul><p><strong>与注解解析相关的接口</strong></p><ul><li><p><strong>Annotation: 注解的顶级接口</strong>，注解都是Annotation类型的对象</p></li><li><p>AnnotatedElement:该接口定义了与注解解析相关的解析方法</p></li></ul><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>Annotation[]  <strong>getDeclaredAnnotations</strong>()</td><td>获得当前对象上使用的所有注解，返回注解数组。</td></tr><tr><td>T <strong>getDeclaredAnnotation</strong>(Class<T>  annotationClass)</td><td>根据注解类型获得对应注解对象</td></tr><tr><td>boolean <strong>isAnnotationPresent</strong>(Class<Annotation>  annotationClass)</td><td>判断当前对象是否使用了指定的注解，如果使用了则返回true，否则false</td></tr></tbody></table><ul><li>所有的类成分Class, Method , Field , Constructor，都实现了AnnotatedElement接口他们都拥有解析注解的能力：</li></ul><p><strong>解析注解的技巧</strong></p><ul><li><p>注解在哪个成分上，我们就先拿哪个成分对象。</p></li><li><p>比如注解作用成员方法，则要获得该成员方法对应的Method对象，再来拿上面的注解</p></li><li><p>比如注解作用在类上，则要该类的Class对象，再来拿上面的注解</p></li><li><p>比如注解作用在成员变量上，则要获得该成员变量对应的Field对象，再来拿上面的注解</p></li></ul><p><strong>案例:</strong></p><p><strong>需求：</strong></p><p>注解解析的案例</p><p><strong>分析</strong></p><p>①定义注解Bookk，要求如下：<br>     - 包含属性：String value()  书名<br>     - 包含属性：double price() 价格，默认值为 100<br>     - 包含属性：String[] authors() 多位作者<br>     - 限制注解使用的位置：类和成员方法上<br>     - 指定注解的有效范围：RUNTIME</p><p>②定义BookStore类，在类和成员方法上使用Bookk注解</p><p>③定义AnnotationDemo01测试类获取Bookk注解上的数据</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义注解Bookk</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span> <span class="comment">//注解 类和方法</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Bookk &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">double</span> <span class="title function_">price</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">100</span>;</span><br><span class="line">    String[] author();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义BookStore类，在类和成员方法上使用Bookk注解</span></span><br><span class="line"><span class="comment">//1.注解类</span></span><br><span class="line"><span class="meta">@Bookk(value = &quot;《情深深雨濛濛》&quot;, price = 99.9, author = &#123;&quot;琼瑶&quot;, &quot;dlei&quot;&#125;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BookStore</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.注解方法</span></span><br><span class="line">    <span class="meta">@Bookk(value = &quot;《三少爷的剑》&quot;, price = 399.9, author = &#123;&quot;古龙&quot;, &quot;熊耀华&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   目标：完成注解的解析</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationDemo3</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parseClass</span><span class="params">()</span>&#123; <span class="comment">// 解析类</span></span><br><span class="line">        <span class="comment">// a.先得到类对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> BookStore.class;</span><br><span class="line">        <span class="comment">// b.判断这个类上面是否存在这个注解</span></span><br><span class="line">        <span class="keyword">if</span>(c.isAnnotationPresent(Bookk.class))&#123;</span><br><span class="line">            <span class="comment">//c.直接获取该注解对象</span></span><br><span class="line">            <span class="type">Bookk</span> <span class="variable">book</span> <span class="operator">=</span> (Bookk) c.getDeclaredAnnotation(Bookk.class);</span><br><span class="line">            System.out.println(book.value());</span><br><span class="line">            System.out.println(book.price());</span><br><span class="line">            System.out.println(Arrays.toString(book.author()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parseMethod</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123; <span class="comment">// 解析方法</span></span><br><span class="line">        <span class="comment">// a.先得到类对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> BookStore.class;</span><br><span class="line"></span><br><span class="line">        <span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> c.getDeclaredMethod(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// b.判断这个类上面是否存在这个注解</span></span><br><span class="line">        <span class="keyword">if</span>(m.isAnnotationPresent(Bookk.class))&#123;</span><br><span class="line">            <span class="comment">//c.直接获取该注解对象</span></span><br><span class="line">            <span class="type">Bookk</span> <span class="variable">book</span> <span class="operator">=</span> (Bookk) m.getDeclaredAnnotation(Bookk.class);</span><br><span class="line">            System.out.println(book.value());</span><br><span class="line">            System.out.println(book.price());</span><br><span class="line">            System.out.println(Arrays.toString(book.author()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-5注解的应用场景一：junit框架"><a href="#3-5注解的应用场景一：junit框架" class="headerlink" title="3.5注解的应用场景一：junit框架"></a>3.5注解的应用场景一：junit框架</h4><p><strong>案例：</strong></p><p>模拟Junit框架</p><p><strong>需求</strong></p><ul><li>定义若干个方法，只要加了MyTest注解，就可以在启动时被触发执行</li></ul><p><strong>分析</strong></p><p>①定义一个自定义注解MyTest，只能注解方法，存活范围是一直都在。</p><p>②定义若干个方法，只要有@MyTest注解的方法就能在启动时被触发执行，没有这个注解的方法不能执行。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个自定义注解MyTest</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD,ElementType.FIELD&#125;)</span> <span class="comment">// 元注解</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span> <span class="comment">// 一直活着，在运行阶段这个注解也不消失</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyTest &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationDemo4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===test1===&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MyTest</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===test2===&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MyTest</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===test3===&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      启动菜单：有注解的才被调用。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">AnnotationDemo4</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationDemo4</span>();</span><br><span class="line">        <span class="comment">// a.获取类对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> AnnotationDemo4.class;</span><br><span class="line">        <span class="comment">// b.提取全部方法</span></span><br><span class="line">        Method[] methods = c.getDeclaredMethods();</span><br><span class="line">        <span class="comment">// c.遍历方法，看是否有MyTest注解，有就跑它</span></span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            <span class="keyword">if</span>(method.isAnnotationPresent(MyTest.class))&#123;</span><br><span class="line">                <span class="comment">// 跑它</span></span><br><span class="line">                method.invoke(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-动态代理"><a href="#4-动态代理" class="headerlink" title="4.动态代理"></a>4.动态代理</h3><h4 id="4-1准备案例、提出问题"><a href="#4-1准备案例、提出问题" class="headerlink" title="4.1准备案例、提出问题"></a>4.1准备案例、提出问题</h4><p><strong>案例：</strong></p><p>模拟企业业务功能开发，并完成每个功能的性能统计</p><p><strong>需求</strong></p><ul><li>模拟某企业用户管理业务，需包含用户登录，用户删除，用户查询功能，并要统计每个功能的耗时。</li></ul><p><strong>分析</strong></p><p>①定义一个UserService表示用户业务接口，规定必须完成用户登录，用户删除，用户查询功能。</p><p>②定义一个实现类UserServiceImpl实现UserService，并完成相关功能，且统计每个功能的耗时。</p><p>③定义测试类，创建实现类对象，调用方法。</p><p><strong>本案例存在哪些问题？</strong></p><p>答：业务对象的的每个方法都要进行性能统计，存在大量重复的代码。</p><h4 id="4-2使用动态代理解决问题"><a href="#4-2使用动态代理解决问题" class="headerlink" title="4.2使用动态代理解决问题"></a>4.2使用动态代理解决问题</h4><p>动态代理</p><ul><li>代理就是被代理者没有能力或者不愿意去完成某件事情，需要找个人代替自己去完成这件事，动态代理就是用来对业务功能（方法）进行代理的。</li></ul><p><strong>关键步骤</strong></p><ul><li><p><strong>必须有接口，实现类要实现接口</strong>（代理通常是基于接口实现的）。</p></li><li><p><strong>创建一个实现类的对象</strong>，该对象为业务对象，紧接着为业务对象做一个代理对象。</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">定义接口</span></span><br><span class="line"><span class="comment">   模拟用户业务功能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    String <span class="title function_">login</span><span class="params">(String loginName , String passWord)</span> ;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">selectUsers</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">deleteUsers</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">updateUsers</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">定义实现类，实现UserService接口</span></span><br><span class="line"><span class="comment">   模拟用户业务功能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">login</span><span class="params">(String loginName, String passWord)</span>  &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;admin&quot;</span>.equals(loginName) &amp;&amp; <span class="string">&quot;1234&quot;</span>.equals(passWord)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;登录名和密码可能有毛病&quot;</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">selectUsers</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;查询了100个用户数据！&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">deleteUsers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;删除100个用户数据！&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUsers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;修改100个用户数据！&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    public static Object newProxyInstance(ClassLoader loader,  Class&lt;?&gt;[] interfaces, InvocationHandler h)</span></span><br><span class="line"><span class="comment">    参数一：类加载器，负责加载代理类到内存中使用。</span></span><br><span class="line"><span class="comment">    参数二：获取被代理对象实现的全部接口。代理要为全部接口的全部方法进行代理</span></span><br><span class="line"><span class="comment">    参数三：代理的核心处理逻辑</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyUtil</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      生成业务对象的代理对象。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T  <span class="title function_">getProxy</span><span class="params">(T obj)</span> &#123; <span class="comment">// 参数类型和返回值类型都为任意类型</span></span><br><span class="line">        <span class="comment">// 1.调用Proxy.newProxyInstance创建一个实现类的对象，返回一个代理对象</span></span><br><span class="line">        <span class="keyword">return</span> (T)Proxy.newProxyInstance(obj.getClass().getClassLoader(),</span><br><span class="line">                obj.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                        <span class="comment">// 参数一：代理对象本身。一般不管</span></span><br><span class="line">                        <span class="comment">// 参数二：正在被代理的方法</span></span><br><span class="line">                        <span class="comment">// 参数三：被代理方法，应该传入的参数</span></span><br><span class="line">                       <span class="type">long</span> <span class="variable">startTimer</span> <span class="operator">=</span> System .currentTimeMillis(); <span class="comment">// 创建开始时间</span></span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 2.触发方法的真正执行。(触发真正的业务功能)</span></span><br><span class="line">                        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(obj, args); <span class="comment">//obj真实业务对象</span></span><br><span class="line"></span><br><span class="line">                        <span class="type">long</span> <span class="variable">endTimer</span> <span class="operator">=</span> System.currentTimeMillis(); <span class="comment">// 创建结束时间</span></span><br><span class="line">                        System.out.println(method.getName() + <span class="string">&quot;方法耗时：&quot;</span> + (endTimer - startTimer) / <span class="number">1000.0</span> + <span class="string">&quot;s&quot;</span>); <span class="comment">// 计算时间差</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 3.把业务功能方法执行的结果返回给调用者</span></span><br><span class="line">                        <span class="keyword">return</span> result;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、把业务对象，直接做成一个代理对象返回，代理对象的类型也是 UserService类型</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> ProxyUtil.getProxy(<span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>());</span><br><span class="line">        System.out.println(userService.login(<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;1234&quot;</span>));</span><br><span class="line">        System.out.println(userService.deleteUsers());</span><br><span class="line">        userService.selectUsers();</span><br><span class="line">        userService.updateUsers(); <span class="comment">// 走代理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>动态代理的优点</strong></p><ul><li><p>非常的灵活，支持任意接口类型的实现类对象做代理，也可以直接为接本身做代理。</p></li><li><p>可以为被代理对象的所有方法做代理。</p></li><li><p>可以在不改变方法源码的情况下，实现对方法功能的增强。</p></li><li><p>不仅简化了编程工作、提高了软件系统的可扩展性，同时也提高了开发效率。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> java,面向对象进阶,单元测试,反射,注解,动态代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>day21 - 网络编程</title>
      <link href="/post/9d3e5e46.html"/>
      <url>/post/9d3e5e46.html</url>
      
        <content type="html"><![CDATA[<p>什么是网络编程？</p><ul><li>网络编程可以让程序与网络上的其他设备中的程序进行数据交互。</li></ul><p>网络通信基本模式</p><ul><li>常见的通信模式有如下2种形式：Client-Server(CS 、 Browser&#x2F;Server(BS)</li></ul><h3 id="1-网络通信三要素"><a href="#1-网络通信三要素" class="headerlink" title="1.网络通信三要素"></a>1.网络通信三要素</h3><p><strong>实现网络编程关键的三要素</strong></p><p><strong>IP地址</strong>：设备在网络中的地址，是唯一的标识。</p><p><strong>端口：</strong>应用程序在设备中唯一的标识。</p><p><strong>协议</strong>: 数据在网络中传输的规则，常见的协议有UDP协议和TCP协议。</p><h4 id="1-1三要素概述、"><a href="#1-1三要素概述、" class="headerlink" title="1.1三要素概述、"></a>1.1三要素概述、</h4><h4 id="要素一：IP地址"><a href="#要素一：IP地址" class="headerlink" title="要素一：IP地址"></a>要素一：IP地址</h4><p>IP（Internet Protocol）：全称”互联网协议地址”，是分配给上网设备的唯一标志。</p><p>常见的IP分类为：IPv4和IPv6</p><p> <strong>IPv4</strong></p><ul><li><strong>地址空间：</strong> IPv4使用32位地址，共有约42亿个可能的地址。由于互联网的爆炸式增长，IPv4地址已经不够用，导致IPv4地址短缺问题。</li><li><strong>地址表示：</strong> IPv4地址使用四个十进制数，每个数范围在0到255之间，通过点分十进制表示（例如：192.168.1.1）。</li><li><strong>地址配置：</strong> IPv4地址可以是静态分配或动态分配（使用DHCP等协议）。</li><li><strong>网络地址转换（NAT）：</strong> 由于地址短缺，IPv4常常使用NAT技术将多个设备共享同一个公网IP地址。</li><li><strong>不足之处：</strong> 除了地址短缺，IPv4还存在一些安全性和管理方面的问题，如IP地址伪造等。</li></ul><p><strong>IPv6：</strong></p><ul><li><strong>地址空间：</strong> IPv6使用128位地址，地址空间极其庞大，约为3.4 x 10^38个地址，解决了IPv4地址不足的问题。128位（16个字节），号称可以为地球每一粒沙子编号。</li><li><strong>地址表示：</strong> IPv6地址使用八组四位十六进制数字，通过冒号分隔（例如：2001:0db8:85a3:0000:0000:8a2e:0370:7334）。</li><li><strong>地址配置：</strong> IPv6引入了更灵活的地址配置方式，可以使用自动配置或者动态主机配置协议。</li><li><strong>NAT不再是必需：</strong> 由于IPv6地址充足，不再需要像IPv4那样频繁使用NAT技术，每个设备都可以拥有公网IP地址。</li><li><strong>安全性和其他改进：</strong> IPv6引入了一些安全性和性能方面的改进，同时也考虑了移动设备、多播通信等需求。</li></ul><p><strong>IP地址形式：</strong></p><ul><li><p>公网地址、和私有地址(局域网使用)。</p></li><li><p>192.168. 开头的就是常见的局域网地址，范围即为192.168.0.0–192.168.255.255，专门为组织机构内部使用。</p></li></ul><p><strong>IP常用命令：</strong></p><ul><li><p>ipconfig：查看本机IP地址</p></li><li><p>ping IP地址：检查网络是否连通</p></li></ul><p><strong>特殊IP地址</strong>：</p><ul><li>本机IP: 127.0.0.1或者localhost：称为回送地址也可称本地回环地址，只会寻找当前所在本机。</li></ul><h4 id="IP地址操作类-InetAddress"><a href="#IP地址操作类-InetAddress" class="headerlink" title="IP地址操作类-InetAddress"></a>IP地址操作类-InetAddress</h4><p><strong>InetAddress</strong> <strong>的使用</strong></p><ul><li>此类表示Internet协议（IP）地址。</li></ul><p><strong>InetAddress  API如下</strong></p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>public static InetAddress <strong>getLocalHost</strong>()</td><td>返回<strong>本主机的地址对象</strong></td></tr><tr><td>public static  InetAddress getByName(String host)</td><td>得到指定主机的IP地址对象，参数是域名或者IP地址</td></tr><tr><td>public String  getHostName()</td><td>获取此IP地址的主机名</td></tr><tr><td>public String  getHostAddress()</td><td>返回IP地址字符串</td></tr><tr><td>public boolean isReachable(int timeout)</td><td>在指定毫秒内连通该IP地址对应的主机，连通返回true</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：InetAddress类概述（了解）</span></span><br><span class="line"><span class="comment">         一个该类的对象就代表一个IP地址对象。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    InetAddress类成员方法：</span></span><br><span class="line"><span class="comment">         static InetAddress getLocalHost()</span></span><br><span class="line"><span class="comment">            * 获得本地主机IP地址对象。</span></span><br><span class="line"><span class="comment">         static InetAddress getByName(String host)</span></span><br><span class="line"><span class="comment">            * 根据IP地址字符串或主机名获得对应的IP地址对象。</span></span><br><span class="line"><span class="comment">         String getHostName()</span></span><br><span class="line"><span class="comment">            * 获得主机名。</span></span><br><span class="line"><span class="comment">         String getHostAddress()</span></span><br><span class="line"><span class="comment">            * 获得IP地址字符串。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InetAddressDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.获取本机地址对象。</span></span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">ip1</span> <span class="operator">=</span> InetAddress.getLocalHost();</span><br><span class="line">        System.out.println(ip1.getHostName());</span><br><span class="line">        System.out.println(ip1.getHostAddress());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.获取域名ip对象</span></span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">ip2</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;www.baidu.com&quot;</span>);</span><br><span class="line">        System.out.println(ip2.getHostName());</span><br><span class="line">        System.out.println(ip2.getHostAddress());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.获取公网IP对象。</span></span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">ip3</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;112.80.248.76&quot;</span>);</span><br><span class="line">        System.out.println(ip3.getHostName());</span><br><span class="line">        System.out.println(ip3.getHostAddress());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.判断是否能通： ping  5s之前测试是否可通</span></span><br><span class="line">        System.out.println(ip3.isReachable(<span class="number">5000</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="要素二：端口号"><a href="#要素二：端口号" class="headerlink" title="要素二：端口号"></a>要素二：端口号</h4><p><strong>端口号</strong></p><ul><li>端口号：标识正在计算机设备上运行的进程（程序），被规定为一个 16 位的二进制，范围是 0~65535。</li></ul><p><strong>端口类型</strong></p><ul><li><p>周知端口：0~1023，被预先定义的知名应用占用（如：HTTP占用 80，FTP占用21） </p></li><li><p><strong>注册端口</strong>：1024~49151，分配给用户进程或某些应用程序。（如：Tomcat占 用8080，MySQL占用3306）</p></li><li><p>动态端口：49152到65535，之所以称为动态端口，是因为它 一般不固定分配某种进程，而是动态分配。</p></li></ul><p><strong>注意：我们自己开发的程序选择注册端口，且一个设备中不能出现两个程序的端口号一样，否则出错。</strong></p><h4 id="要素三：协议"><a href="#要素三：协议" class="headerlink" title="要素三：协议"></a>要素三：协议</h4><p><strong>通信协议</strong></p><ul><li>连接和通信数据的规则被称为网络通信协议</li></ul><p><strong>网络通信协议有两套参考模型</strong></p><ul><li><p>OSI参考模型：世界互联协议标准，全球通信规范，由于此模型过于理想化，未能在因特网上进行广泛推广。</p></li><li><p>TCP&#x2F;IP参考模型(或TCP&#x2F;IP协议)：事实上的国际标准。</p></li></ul><table><thead><tr><th>OSI参考模型</th><th>TCP&#x2F;IP参考模型</th><th>各层对应</th><th>面向操作</th></tr></thead><tbody><tr><td>应用层</td><td>应用层</td><td>HTTP、FTP、DNS、SMTP…</td><td>应用程序需要关注的：浏览器，邮箱。程序员一般在这一层开发</td></tr><tr><td>表示层</td><td></td><td></td><td></td></tr><tr><td>会话层</td><td></td><td></td><td></td></tr><tr><td>传输层</td><td>传输层</td><td>TCP、UDP…</td><td>选择使用的TCP , UDP协议</td></tr><tr><td>网络层</td><td>网络层</td><td>IP、ICMP…</td><td>封装源和目标IP，进行路径选择</td></tr><tr><td>数据链路层</td><td>数据链路层+物理</td><td>物理寻址、比特流…</td><td>物理设备中传输</td></tr><tr><td>物理层</td><td></td><td></td><td></td></tr></tbody></table><p><strong>传输层的2个常见协议</strong></p><ul><li><p>TCP(Transmission Control Protocol) ：传输控制协议</p></li><li><p>UDP(User Datagram Protocol)：用户数据报协议</p></li></ul><p><strong>TCP协议特点</strong></p><ul><li><p>使用TCP协议，必须双方先建立连接，它是一种面向连接的<strong>可靠通信协议</strong>。</p></li><li><p>传输前，采用<strong>“三次握手”</strong>方式建立连接，所以是可靠的 。</p></li><li><p>在连接中可进行<strong>大数据量</strong>的传输 。</p></li><li><p>连接、发送数据都<strong>需要确认</strong>，且传输完毕后，还需释放已建立的连接，通信效率较低。</p></li></ul><p><strong>TCP协议通信场景</strong></p><ul><li>对信息安全要求较高的场景，例如：文件下载、金融等数据通信。</li></ul><p><strong>TCP三次握手确立连接</strong></p><ol><li><strong>第一次握手</strong>：客户端向服务器发送一个SYN（同步）标志位，请求建立连接。</li><li><strong>第二次握手</strong>：服务器接收到客户端的SYN请求后，会发送一个SYN+ACK（同步和确认）标志位作为回应，表示同意建立连接。</li><li><strong>第三次握手</strong>：客户端接收到服务器的SYN+ACK后，会发送一个ACK（确认）标志位，确认连接已经建立。</li></ol><p>通过这个过程，客户端和服务器都确认了彼此可以通信，并且双方已经准备好开始传输数据。</p><p><strong>TCP四次挥手断开连接</strong></p><ol><li><strong>第一次挥手</strong>：当客户端有数据要传输完成后，它会向服务器发送一个FIN（结束）标志位，表示它已经完成了数据的发送。</li><li><strong>第二次挥手</strong>：服务器收到客户端的FIN后，会发送一个ACK标志位，确认收到了客户端的关闭请求。</li><li><strong>第三次挥手</strong>：服务器自己完成数据的发送后，会发送一个FIN标志位给客户端，表示服务器也准备好关闭连接了。</li><li><strong>第四次挥手</strong>：客户端接收到服务器的FIN后，发送一个ACK标志位作为确认。此时连接被彻底关闭。</li></ol><p>通过这个过程，双方确认彼此都没有数据需要传输了，并且连接被正确地关闭。</p><p><strong>UDP协议：</strong> </p><ul><li><p>UDP是一种<strong>无连接、不可靠</strong>传输的协议。</p></li><li><p>将数据源IP、目的地IP和端口封装成数据包，<strong>不需要建立连接</strong></p></li><li><p>每个数据包的大小限制在<strong>64KB内</strong></p></li><li><p>发送不管对方是否准备好，接收方收到也不确认，故是不可靠的 </p></li><li><p>可以广播发送 ，发送数据结束时无需释放资源，开销小，速度快。</p></li></ul><p><strong>UDP协议通信场景</strong></p><ul><li>语音通话，视频会话等。</li></ul><h3 id="2-UDP通信-快速入门"><a href="#2-UDP通信-快速入门" class="headerlink" title="2.UDP通信-快速入门"></a>2.UDP通信-快速入门</h3><h4 id="2-1UDP通信：快速入门"><a href="#2-1UDP通信：快速入门" class="headerlink" title="2.1UDP通信：快速入门"></a>2.1UDP通信：快速入门</h4><p><strong>UDP协议的特点</strong></p><ul><li><p>UDP是一种无连接、不可靠传输的协议。</p></li><li><p>将数据源IP、目的地IP和端口以及数据封装成数据包，大小限制在64KB内，直接发送出去即可。</p></li></ul><p><strong>DatagramPacket：数据包对象（容器）</strong></p><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public <strong>DatagramPacket</strong>(byte[] buf, int  length, InetAddress address,  int port)</td><td>创建发送端数据包对象 字节数组  <strong>buf：要发送的内容</strong>，  <strong>length：要发送内容的字节长度</strong>，  <strong>address：接收端的IP地址对象</strong>，  <strong>port：接收端的端口号</strong></td></tr><tr><td>public <strong>DatagramPacket</strong>(byte[] buf, int  length)</td><td>创建接收端的数据包对象 字节数组 <strong>buf：用来存储接收的内容</strong>，   <strong>length：能够接收内容的长度</strong></td></tr></tbody></table><p><strong>DatagramPacket常用方法</strong>   </p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public int <strong>getLength</strong>()</td><td>获得实际接收到的<strong>字节个数</strong></td></tr></tbody></table><p><strong>DatagramSocket：发送端和接收端对象（人）</strong></p><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public <strong>DatagramSocket</strong>()</td><td><strong>创建发送端的Socket对象</strong>，系统会随机分配一个端口号。</td></tr><tr><td>public <strong>DatagramSocket</strong>(int port)</td><td><strong>创建接收端的Socket对象</strong>，并指定端口号</td></tr></tbody></table><p><strong>DatagramSocket类成员方法</strong></p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public void <strong>send</strong>(DatagramPacket dp)</td><td><strong>发送数据包</strong></td></tr><tr><td>public void <strong>receive</strong>(DatagramPacket p)</td><td><strong>接收数据包</strong></td></tr></tbody></table><p><strong>案例：</strong></p><p>使用UDP通信实现：发送消息、接收消息</p><p><strong>需求：</strong></p><p><strong>客户端实现步骤</strong></p><p>①创建DatagramSocket对象（发送端对象）           扔韭菜的人</p><p>②创建DatagramPacket对象封装需要发送的数据（数据包对象）        韭菜盘子</p><p>③使用DatagramSocket对象的send方法传入DatagramPacket对象         开始抛出韭菜</p><p>④释放资源</p><p><strong>接收端实现步骤</strong></p><p>①创建DatagramSocket对象并指定端口（接收端对象）           接韭菜的人</p><p>②创建DatagramPacket对象接收数据（数据包对象）         韭菜盘子</p><p>③使用DatagramSocket对象的receive方法传入DatagramPacket对象         开始接收韭菜</p><p>④释放资源</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  发送端 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====客户端启动======&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、创建发送端对象：发送端自带默认的端口号（人）</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">6666</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、创建一个数据包对象封装数据（容器）</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         public DatagramPacket(byte buf[], int length,</span></span><br><span class="line"><span class="comment">         InetAddress address, int port)</span></span><br><span class="line"><span class="comment">         参数一：封装要发送的数据（韭菜）</span></span><br><span class="line"><span class="comment">         参数二：发送数据的大小</span></span><br><span class="line"><span class="comment">         参数三：服务端的主机IP地址</span></span><br><span class="line"><span class="comment">         参数四：服务端的端口</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="string">&quot;我是一个数据包&quot;</span>.getBytes();</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buffer, buffer.length, InetAddress.getLocalHost(), <span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、发送数据出去</span></span><br><span class="line">        socket.send(packet);</span><br><span class="line"></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  接收端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====服务端启动======&quot;</span>);</span><br><span class="line">        <span class="comment">// 1、创建接收端对象：注册端口（人）</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、创建一个数据包对象接收数据（容器）</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">64</span>]; <span class="comment">//64kb</span></span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buffer, buffer.length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、等待接收数据。</span></span><br><span class="line">        socket.receive(packet);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、取出数据即可</span></span><br><span class="line">        <span class="comment">// 读取多少倒出多少</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> packet.getLength();</span><br><span class="line">        <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer,<span class="number">0</span>, len);</span><br><span class="line">        System.out.println(<span class="string">&quot;收到了：&quot;</span> + rs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取发送端的ip和端口</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">ip</span>  <span class="operator">=</span>packet.getSocketAddress().toString();</span><br><span class="line">        System.out.println(<span class="string">&quot;对方地址：&quot;</span> + ip);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span>  <span class="operator">=</span> packet.getPort();</span><br><span class="line">        System.out.println(<span class="string">&quot;对方端口：&quot;</span> + port);</span><br><span class="line"></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2UDP通信：多发多收"><a href="#2-2UDP通信：多发多收" class="headerlink" title="2.2UDP通信：多发多收"></a>2.2UDP通信：多发多收</h4><p><strong>案例：</strong></p><p>使用UDP通信实现：多发多收消息</p><p><strong>需求</strong></p><ul><li>使用UDP通信方式开发接收端和发送端。</li></ul><p><strong>分析</strong></p><p>①发送端可以一直发送消息。</p><p>②接收端可以不断的接收多个发送端的消息展示。</p><p>③发送端输入了exit则结束发送端程序。</p><p><strong>客户端实现步骤</strong></p><p>①创建DatagramSocket对象（发送端对象）           扔韭菜的人</p><p>②使用while死循环不断的接收用户的数据输入，如果用户输入的exit则退出程序</p><p>③如果用户输入的不是exit, 把数据封装成DatagramPacket           韭菜盘子</p><p>④使用DatagramSocket对象的send方法将数据包对象进行发送          开始抛出韭菜</p><p>⑤释放资源</p><p><strong>接收端实现步骤</strong></p><p>①创建DatagramSocket对象并指定端口（接收端对象）           接韭菜的人</p><p>②创建DatagramPacket对象接收数据（数据包对象）         韭菜盘子</p><p>③使用while死循环不断的进行第4步</p><p>④使用DatagramSocket对象的receive方法传入DatagramPacket对象         开始接收韭菜</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  发送端  多发 多收</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====客户端启动======&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、创建发送端对象：发送端自带默认的端口号（人）</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">7777</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in); <span class="comment">//键盘录入</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请说：&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;exit&quot;</span>.equals(msg))&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;离线成功！&quot;</span>);</span><br><span class="line">                socket.close();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2、创建一个数据包对象封装数据（容器）</span></span><br><span class="line">            <span class="type">byte</span>[] buffer = msg.getBytes();</span><br><span class="line">            <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buffer, buffer.length, InetAddress.getLocalHost(), <span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3、发送数据出去</span></span><br><span class="line">            socket.send(packet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  接收端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====服务端启动======&quot;</span>);</span><br><span class="line">        <span class="comment">// 1、创建接收端对象：注册端口（人）</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、创建一个数据包对象接收数据（韭菜盘子）</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">64</span>];  <span class="comment">//64kb</span></span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buffer, buffer.length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 3、等待接收数据。</span></span><br><span class="line">            socket.receive(packet);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 4、取出数据即可</span></span><br><span class="line">            <span class="comment">// 读取多少倒出多少</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> packet.getLength();</span><br><span class="line">            <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer, <span class="number">0</span>, len);</span><br><span class="line">            System.out.println(<span class="string">&quot;收到了来自：&quot;</span> + packet.getAddress() +<span class="string">&quot;, 对方端口是&quot;</span> + packet.getPort() +<span class="string">&quot;的消息：&quot;</span> + rs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-UDP通信-广播、组播"><a href="#3-UDP通信-广播、组播" class="headerlink" title="3.UDP通信-广播、组播"></a>3.UDP通信-广播、组播</h3><p><strong>UDP的三种通信方式</strong></p><p>单播：单台主机与单台主机之间的通信。</p><p>广播：当前主机与所在网络中的所有主机通信。</p><p>组播：当前主机与选定的一组主机的通信。</p><p><strong>UDP如何实现广播</strong></p><ul><li><strong>使用广播地址：255.255.255.255</strong></li></ul><p>具体操作：</p><p>①发送端发送的数据包的目的地写的是广播地址、且指定端口。 （255.255.255.255 ,  9999）</p><p>②本机所在网段的其他主机的程序只要注册对应端口就可以收到消息了。（9999）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   广播  发送端  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====客户端启动======&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、创建发送端对象：发送端自带默认的端口号（人）</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请说：&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;exit&quot;</span>.equals(msg))&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;离线成功！&quot;</span>);</span><br><span class="line">                socket.close();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2、创建一个数据包对象封装数据（韭菜盘子）</span></span><br><span class="line">            <span class="type">byte</span>[] buffer = msg.getBytes();</span><br><span class="line">            <span class="comment">// 注意：只要目的地IP是 255.255.255.255 这个消息将以广播的形式对外发送</span></span><br><span class="line">            <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>( buffer, buffer.length,</span><br><span class="line">                    InetAddress.getByName(<span class="string">&quot;255.255.255.255&quot;</span>) , <span class="number">8888</span>);  </span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3、发送数据出去</span></span><br><span class="line">            socket.send(packet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   广播  接收端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====服务端启动======&quot;</span>);</span><br><span class="line">        <span class="comment">// 1、创建接收端对象：注册端口（人）</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、创建一个数据包对象接收数据（韭菜盘子）</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">64</span>];</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buffer, buffer.length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 3、等待接收数据。</span></span><br><span class="line">            socket.receive(packet);</span><br><span class="line">            <span class="comment">// 4、取出数据即可</span></span><br><span class="line">            <span class="comment">// 读取多少倒出多少</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> packet.getLength();</span><br><span class="line">            <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer,<span class="number">0</span>, len);</span><br><span class="line">            System.out.println(<span class="string">&quot;收到了来自：&quot;</span> + packet.getAddress() +<span class="string">&quot;, 对方端口是&quot;</span> + packet.getPort() +<span class="string">&quot;的消息：&quot;</span> + rs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>UDP如何实现组播</strong></p><ul><li><strong>使用组播地址：224.0.0.0 ~ 239.255.255.255</strong></li></ul><p>具体操作：</p><p>①发送端的数据包的目的地是组播IP (例如：224.0.1.1, 端口：9999)</p><p>②接收端必须绑定该组播IP(224.0.1.1)，端口还要注册发送端的目的端口9999 ，这样即可接收该组播消息。</p><p>③DatagramSocket的子类MulticastSocket可以在接收端绑定组播IP。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   组播  发送端  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====客户端启动======&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、创建发送端对象：发送端自带默认的端口号（人）</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请说：&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;exit&quot;</span>.equals(msg))&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;离线成功！&quot;</span>);</span><br><span class="line">                socket.close();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2、创建一个数据包对象封装数据（韭菜盘子）</span></span><br><span class="line">            <span class="type">byte</span>[] buffer = msg.getBytes();</span><br><span class="line">            <span class="comment">// 注意：只要目的地IP是 224.0.0.0 ~ 239.255.255.255 这个消息将以组播的形式对外发</span></span><br><span class="line">            <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>( buffer, buffer.length,</span><br><span class="line">                    InetAddress.getByName(<span class="string">&quot;224.0.1.1&quot;</span>) , <span class="number">9898</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3、发送数据出去</span></span><br><span class="line">            socket.send(packet);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   组播  接收端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerDemo3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====服务端启动======&quot;</span>);</span><br><span class="line">        <span class="comment">// 1、创建接收端对象：注册端口（人）</span></span><br><span class="line">        <span class="type">MulticastSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MulticastSocket</span>(<span class="number">9898</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意：绑定组播地址（加群）要有和发送到相同的IP和端口号</span></span><br><span class="line">        socket.joinGroup(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(InetAddress.getByName(<span class="string">&quot;224.0.1.1&quot;</span>) , <span class="number">9898</span>),</span><br><span class="line">                NetworkInterface.getByInetAddress(InetAddress.getLocalHost()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、创建一个数据包对象接收数据（韭菜盘子）</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">64</span>];</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buffer, buffer.length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 3、等待接收数据。</span></span><br><span class="line">            socket.receive(packet);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 4、取出数据即可</span></span><br><span class="line">            <span class="comment">// 读取多少倒出多少</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> packet.getLength();</span><br><span class="line">            <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer,<span class="number">0</span>, len);</span><br><span class="line">            System.out.println(<span class="string">&quot;收到了来自：&quot;</span> + packet.getAddress() +<span class="string">&quot;, 对方端口是&quot;</span> + packet.getPort() +<span class="string">&quot;的消息：&quot;</span> + rs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-TCP通信-快速入门"><a href="#4-TCP通信-快速入门" class="headerlink" title="4.TCP通信-快速入门"></a>4.TCP通信-快速入门</h3><h4 id="4-1编写客户端代码"><a href="#4-1编写客户端代码" class="headerlink" title="4.1编写客户端代码"></a>4.1编写客户端代码</h4><p><strong>TCP协议回顾：</strong> </p><ul><li><p>TCP是一种面向连接，安全、可靠的传输数据的协议 </p></li><li><p>传输前，采用“三次握手”方式，点对点通信，是可靠的 </p></li><li><p>在连接中可进行大数据量的传输</p></li></ul><p><strong>注意：在java中只要是使用 java.net.Socket 类实现通信，底层即是使用了 TCP 协议</strong></p><p><strong>Socket(发送端)</strong></p><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public <strong>Socket</strong>(String host , int port)</td><td><strong>创建发送端的Socket对象</strong>与服务端连接，参数为服务端程序的ip和端口。</td></tr></tbody></table><p> <strong>Socket类成员方法</strong></p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>OutputStream <strong>getOutputStream</strong>()</td><td>获得<strong>字节输出流</strong>对象</td></tr><tr><td>InputStream <strong>getInputStream</strong>()</td><td>获得<strong>字节输入流</strong>对象</td></tr></tbody></table><p><strong>客户端发送消息</strong></p><p><strong>需求：</strong></p><p>客户端实现步骤</p><p>①创建客户端的Socket对象，请求与服务端的连接。</p><p>②使用socket对象调用getOutputStream()方法得到字节输出流。</p><p>③使用字节输出流完成数据的发送。</p><p>④释放资源：关闭socket管道。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   目标：完成Socket网络编程入门案例的客户端开发，实现1发1收。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;====客户端启动===&quot;</span>);</span><br><span class="line">            <span class="comment">// 1、创建Socket通信管道请求有服务端的连接</span></span><br><span class="line">            <span class="comment">// public Socket(String host, int port)</span></span><br><span class="line">            <span class="comment">// 参数一：服务端的IP地址</span></span><br><span class="line">            <span class="comment">// 参数二：服务端的端口</span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">7777</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2、从socket通信管道中得到一个字节输出流 负责发送数据</span></span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3、把低级的字节流包装成打印流</span></span><br><span class="line">            <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(os);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4、发送消息</span></span><br><span class="line">            ps.println(<span class="string">&quot;我是TCP的客户端，我已经与你对接，并发出邀请&quot;</span>);</span><br><span class="line">            ps.flush();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 关闭资源。</span></span><br><span class="line">            <span class="comment">// socket.close(); </span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2编写服务端代码"><a href="#4-2编写服务端代码" class="headerlink" title="4.2编写服务端代码"></a>4.2编写服务端代码</h4><p><strong>ServerSocket(服务端)</strong></p><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public <strong>ServerSocket</strong>(int port)</td><td><strong>注册服务端端口</strong></td></tr></tbody></table><p> <strong>ServerSocket类成员方法</strong></p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public Socket <strong>accept</strong>()</td><td><strong>等待接收客户端的Socket通信连接</strong>  连接成功返回Socket对象与客户端建立端到端通信</td></tr></tbody></table><p><strong>服务端实现接收消息</strong></p><p><strong>需求：</strong></p><p>服务端实现步骤</p><p>①创建ServerSocket对象，注册服务端端口。</p><p>②调用ServerSocket对象的accept()方法，等待客户端的连接，并得到Socket管道对象。</p><p>③通过Socket对象调用getInputStream()方法得到字节输入流、完成数据的接收。</p><p>④释放资源：关闭socket管道</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   目标：开发Socket网络编程入门代码的服务端，实现接收消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;===服务端启动成功===&quot;</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 1、 注册服务端端口</span></span><br><span class="line">            <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">7777</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 2、必须调用accept方法：等待接收客户端的Socket连接请求，建立Socket通信管道</span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 3、从socket通信管道中得到一个字节输入流</span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 4、把字节输入流包装成缓冲字符输入流进行消息的接收</span></span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is));</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 5、按照行读取消息</span></span><br><span class="line">            String msg;</span><br><span class="line">            <span class="keyword">if</span> ((msg = br.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">                System.out.println(socket.getRemoteSocketAddress() + <span class="string">&quot;说了：: &quot;</span> + msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Socket类(客户端的代表类)</strong></p><ul><li><p>public Socket(String host , int port)</p></li><li><p>使用Socket管道发送、接收数据。</p><ul><li><p>OutputStream getOutputStream() : 获得字节输出流对象(发）</p></li><li><p>InputStream getInputStream() : 获得字节输入流对象(收）</p></li></ul></li></ul><p><strong>ServerSocket类(服务端用的代表类)</strong></p><ul><li>ServerSocket类,注册端口。</li><li>等待接收客户端连接。<ul><li>调用accept()方法阻塞,得到Socket对象。</li></ul></li></ul><h5 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h5><p>TCP通信的基本原理</p><ul><li><p><strong>客户端怎么发，服务端就应该怎么收。</strong></p></li><li><p><strong>客户端如果没有消息，服务端会进入阻塞等待。</strong></p></li><li><p><strong>Socket一方关闭或者出现异常、对方Socket也会失效或者出错。</strong></p></li></ul><h3 id="5-TCP通信-多发多收消息"><a href="#5-TCP通信-多发多收消息" class="headerlink" title="5.TCP通信-多发多收消息"></a>5.TCP通信-多发多收消息</h3><p><strong>案例：</strong></p><p>使用TCP通信实现：多发多收消息</p><p><strong>需求：</strong></p><p>使用TCP通信方式实现：多发多收消息。</p><p>具体要求：</p><p>①可以使用死循环控制服务端收完消息继续等待接收下一个消息。</p><p>②客户端也可以使用死循环等待用户不断输入消息。</p><p>③客户端一旦输入了exit，则关闭客户端程序，并释放资源。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   目标：实现多发和多收</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;====客户端启动===&quot;</span>);</span><br><span class="line">            <span class="comment">// 1、创建Socket通信管道请求有服务端的连接</span></span><br><span class="line">            <span class="comment">// public Socket(String host, int port)</span></span><br><span class="line">            <span class="comment">// 参数一：服务端的IP地址</span></span><br><span class="line">            <span class="comment">// 参数二：服务端的端口</span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">7777</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2、从socket通信管道中得到一个字节输出流 负责发送数据</span></span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3、把低级的字节流包装成打印流</span></span><br><span class="line">            <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(os);</span><br><span class="line"></span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;请说：&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">                <span class="comment">// 4、发送消息</span></span><br><span class="line">                ps.println(msg);</span><br><span class="line">                ps.flush();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 关闭资源。</span></span><br><span class="line">            <span class="comment">// socket.close();</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   目标：开发Socket网络编程入门代码的服务端，实现接收消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;===服务端启动成功===&quot;</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 1、注册服务端端口</span></span><br><span class="line">            <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">7777</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 2、必须调用accept方法：等待接收客户端的Socket连接请求，建立Socket通信管道</span></span><br><span class="line">                <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 3、从socket通信管道中得到一个字节输入流</span></span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 4、把字节输入流包装成缓冲字符输入流进行消息的接收</span></span><br><span class="line">                <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is));</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 5、按照行读取消息</span></span><br><span class="line">                String msg;</span><br><span class="line">                <span class="keyword">while</span> ((msg = br.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">                    System.out.println(socket.getRemoteSocketAddress() + <span class="string">&quot;说了：: &quot;</span> + msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-TCP通信-同时接受多个客户端消息"><a href="#6-TCP通信-同时接受多个客户端消息" class="headerlink" title="6.TCP通信-同时接受多个客户端消息"></a>6.TCP通信-同时接受多个客户端消息</h3><p>1、之前我们的通信是否可以同时与多个客户端通信，为什么？</p><ul><li><p><strong>不可以的</strong></p></li><li><p><strong>单线程每次只能处理一个客户端的Socket通信</strong></p></li></ul><p>2、如何才可以让服务端可以处理多个客户端的通信需求？</p><ul><li><strong>引入多线程。</strong></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">客户端</span></span><br><span class="line"><span class="comment">    目标：实现服务端可以同时处理多个客户端的消息。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;====客户端启动===&quot;</span>);</span><br><span class="line">            <span class="comment">// 1、创建Socket通信管道请求有服务端的连接</span></span><br><span class="line">            <span class="comment">// public Socket(String host, int port)</span></span><br><span class="line">            <span class="comment">// 参数一：服务端的IP地址</span></span><br><span class="line">            <span class="comment">// 参数二：服务端的端口</span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">7777</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2、从socket通信管道中得到一个字节输出流 负责发送数据</span></span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3、把低级的字节流包装成打印流</span></span><br><span class="line">            <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(os);</span><br><span class="line"></span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;请说：&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">                <span class="comment">// 4、发送消息</span></span><br><span class="line">                ps.println(msg);</span><br><span class="line">                ps.flush();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 关闭资源。</span></span><br><span class="line">            <span class="comment">// socket.close();</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">服务端</span></span><br><span class="line"><span class="comment">   目标：实现服务端可以同时处理多个客户端的消息。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;===服务端启动成功===&quot;</span>);</span><br><span class="line">            <span class="comment">// 1、注册端口</span></span><br><span class="line">            <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">7777</span>);</span><br><span class="line">            <span class="comment">// a.定义一个死循环由主线程负责不断的接收客户端的Socket管道连接。</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 2、每接收到一个客户端的Socket管道，交给一个独立的子线程负责读取消息</span></span><br><span class="line">                <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">                System.out.println(socket.getRemoteSocketAddress()+ <span class="string">&quot;它来了，上线了！&quot;</span>);</span><br><span class="line">                <span class="comment">// 3、开始创建独立线程处理socket</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ServerReaderThread</span>(socket).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个多线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerReaderThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServerReaderThread</span><span class="params">(Socket socket)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 3、从socket通信管道中得到一个字节输入流</span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">            <span class="comment">// 4、把字节输入流包装成缓冲字符输入流进行消息的接收</span></span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is));</span><br><span class="line">            <span class="comment">// 5、按照行读取消息</span></span><br><span class="line">            String msg;</span><br><span class="line">            <span class="keyword">while</span> ((msg = br.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">                System.out.println(socket.getRemoteSocketAddress() + <span class="string">&quot;说了：: &quot;</span> + msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(socket.getRemoteSocketAddress() + <span class="string">&quot;下线了！！！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-TCP通信-使用线程池优化"><a href="#7-TCP通信-使用线程池优化" class="headerlink" title="7.TCP通信-使用线程池优化"></a>7.TCP通信-使用线程池优化</h3><p>1、目前的通信架构存在什么问题？</p><ul><li><p><strong>客户端与服务端的线程模型是： N-N的关系。</strong></p></li><li><p><strong>客户端并发越多，系统瘫痪的越快。</strong></p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">客户端</span></span><br><span class="line"><span class="comment">    拓展：使用线程池优化：实现通信。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;====客户端启动===&quot;</span>);</span><br><span class="line">            <span class="comment">// 1、创建Socket通信管道请求有服务端的连接</span></span><br><span class="line">            <span class="comment">// public Socket(String host, int port)</span></span><br><span class="line">            <span class="comment">// 参数一：服务端的IP地址</span></span><br><span class="line">            <span class="comment">// 参数二：服务端的端口</span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6666</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2、从socket通信管道中得到一个字节输出流 负责发送数据</span></span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3、把低级的字节流包装成打印流</span></span><br><span class="line">            <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(os);</span><br><span class="line"></span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;请说：&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">                <span class="comment">// 4、发送消息</span></span><br><span class="line">                ps.println(msg);</span><br><span class="line">                ps.flush();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 关闭资源。</span></span><br><span class="line">            <span class="comment">// socket.close();</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">服务端</span></span><br><span class="line"><span class="comment">   目标：实现服务端可以同时处理多个客户端的消息。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerDemo2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用静态变量记住一个线程池对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">300</span>,</span><br><span class="line">            <span class="number">1500</span>, <span class="number">6</span>, TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">2</span>)</span><br><span class="line">    , Executors.defaultThreadFactory(), <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;===服务端启动成功===&quot;</span>);</span><br><span class="line">            <span class="comment">// 1、注册端口</span></span><br><span class="line">            <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">6666</span>);</span><br><span class="line">            <span class="comment">// a.定义一个死循环由主线程负责不断的接收客户端的Socket管道连接。</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 2、每接收到一个客户端的Socket管道，</span></span><br><span class="line">                <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">                System.out.println(socket.getRemoteSocketAddress()+ <span class="string">&quot;它来了，上线了！&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 任务对象负责读取消息。</span></span><br><span class="line">                <span class="type">Runnable</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerReaderRunnable</span>(socket);</span><br><span class="line">                pool.execute(target);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-TCP通信实战案例-即时通信"><a href="#8-TCP通信实战案例-即时通信" class="headerlink" title="8.TCP通信实战案例-即时通信"></a>8.TCP通信实战案例-即时通信</h3><p>1、即时通信是什么含义，要实现怎么样的设计？</p><ul><li><p><strong>即时通信，是指一个客户端的消息发出去，其他客户端可以接收到。</strong></p></li><li><p><strong>之前我们的消息都是发给服务端的。</strong></p></li><li><p><strong>即时通信需要进行端口转发的设计思想。(发送端可以接受消息)</strong></p></li></ul><p><strong>客户端:</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    拓展：即时通信</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    客户端：发消息的同时，随时有人发消息过来。</span></span><br><span class="line"><span class="comment">    服务端：接收消息后，推送给其他所有的在线socket</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;====客户端启动===&quot;</span>);</span><br><span class="line">            <span class="comment">// 1、创建Socket通信管道请求有服务端的连接</span></span><br><span class="line">            <span class="comment">// public Socket(String host, int port)</span></span><br><span class="line">            <span class="comment">// 参数一：服务端的IP地址</span></span><br><span class="line">            <span class="comment">// 参数二：服务端的端口</span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6868</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 马上为客户端分配一个独立的线程负责读取它收到的消息</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ClientReaderThread</span>(socket).start();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2、从socket通信管道中得到一个字节输出流 负责发送数据</span></span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3、把低级的字节流包装成打印流</span></span><br><span class="line">            <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(os);</span><br><span class="line"></span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;请说：&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">                <span class="comment">// 4、发送消息</span></span><br><span class="line">                ps.println(msg);</span><br><span class="line">                ps.flush();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 关闭资源。</span></span><br><span class="line">            <span class="comment">// socket.close();</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientReaderThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ClientReaderThread</span><span class="params">(Socket socket)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 3、从socket通信管道中得到一个字节输入流</span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">            <span class="comment">// 4、把字节输入流包装成缓冲字符输入流进行消息的接收</span></span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is));</span><br><span class="line">            <span class="comment">// 5、按照行读取消息</span></span><br><span class="line">            String msg;</span><br><span class="line">            <span class="keyword">while</span> ((msg = br.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">                System.out.println(socket.getRemoteSocketAddress() + <span class="string">&quot;收到了: &quot;</span> + msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;服务端把你踢出去了~~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>服务端:</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   目标: 即时通信</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerDemo2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Socket&gt; onLineSockets = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;===服务端启动成功===&quot;</span>);</span><br><span class="line">            <span class="comment">// 1、注册端口</span></span><br><span class="line">            <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">6868</span>);</span><br><span class="line">            <span class="comment">// a.定义一个死循环由主线程负责不断的接收客户端的Socket管道连接。</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 2、每接收到一个客户端的Socket管道，交给一个独立的子线程负责读取消息</span></span><br><span class="line">                <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">                System.out.println(socket.getRemoteSocketAddress()+ <span class="string">&quot;它来了，上线了！&quot;</span>);</span><br><span class="line">                <span class="comment">// 把当前客户端管道Socket加入到在线集合中去</span></span><br><span class="line">                onLineSockets.add(socket);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3、开始创建独立线程处理socket</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ServerReaderThread</span>(socket).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerReaderThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServerReaderThread</span><span class="params">(Socket socket)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 3、从socket通信管道中得到一个字节输入流</span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">            <span class="comment">// 4、把字节输入流包装成缓冲字符输入流进行消息的接收</span></span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is));</span><br><span class="line">            <span class="comment">// 5、按照行读取消息</span></span><br><span class="line">            String msg;</span><br><span class="line">            <span class="keyword">while</span> ((msg = br.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">                System.out.println(socket.getRemoteSocketAddress() + <span class="string">&quot;说了：: &quot;</span> + msg);</span><br><span class="line">                <span class="comment">// 把这个消息发给当前所有在线socket</span></span><br><span class="line">                sendMsgToAll(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(socket.getRemoteSocketAddress() + <span class="string">&quot;下线了！！！&quot;</span>);</span><br><span class="line">            <span class="comment">// 从在线集合中抹掉本客户端socket</span></span><br><span class="line">            ServerDemo2.onLineSockets.remove(socket);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sendMsgToAll</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 遍历全部的在线 socket给他们发消息</span></span><br><span class="line">            <span class="keyword">for</span> (Socket onLineSocket : ServerDemo2.onLineSockets) &#123;</span><br><span class="line">                <span class="comment">// 除了自己的socket，其他socket我都发！！</span></span><br><span class="line">                <span class="keyword">if</span>(onLineSocket != socket)&#123;</span><br><span class="line">                    <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(socket.getOutputStream());</span><br><span class="line">                    ps.println(msg);</span><br><span class="line">                    ps.flush();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-TCP通信实战案例-模拟BS系统"><a href="#9-TCP通信实战案例-模拟BS系统" class="headerlink" title="9.TCP通信实战案例-模拟BS系统"></a>9.TCP通信实战案例-模拟BS系统</h3><p>1、之前的客户端都是什么样的</p><ul><li><strong>其实就是CS架构，客户端实需要我们自己开发实现的。</strong></li></ul><p>2、BS结构是什么样的，需要开发客户端吗？</p><ul><li><p><strong>浏览器访问服务端，不需要开发客户端。</strong></p></li><li><p><strong>HTTP响应数据的协议格式：就是给浏览器显示的网页信息</strong></p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    了解：BS-浏览器-服务器基本了解。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    引入：</span></span><br><span class="line"><span class="comment">        之前客户端和服务端都需要自己开发。也就是CS架构。</span></span><br><span class="line"><span class="comment">        接下来模拟一下BS架构。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    客户端：浏览器。（无需开发）</span></span><br><span class="line"><span class="comment">    服务端：自己开发。</span></span><br><span class="line"><span class="comment">    需求：在浏览器中请求本程序，响应一个网页文字给浏览器显示</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BSserverDemo</span> &#123;</span><br><span class="line">    <span class="comment">// 使用静态变量记住一个线程池对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">3</span>,</span><br><span class="line">            <span class="number">5</span>, <span class="number">6</span>, TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">2</span>)</span><br><span class="line">            , Executors.defaultThreadFactory(), <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1.注册端口</span></span><br><span class="line">            <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8080</span>);</span><br><span class="line">            <span class="comment">// 2.创建一个循环接收多个客户端的请求。</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> ss.accept();</span><br><span class="line">                <span class="comment">// 3.交给一个独立的线程来处理！</span></span><br><span class="line">                pool.execute(<span class="keyword">new</span> <span class="title class_">ServerReaderRunnable</span>(socket));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//多线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerReaderRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServerReaderRunnable</span><span class="params">(Socket socket)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 浏览器 已经与本线程建立了Socket管道</span></span><br><span class="line">            <span class="comment">// 响应消息给浏览器显示</span></span><br><span class="line">            <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(socket.getOutputStream());</span><br><span class="line">            <span class="comment">// 必须响应HTTP协议格式数据，否则浏览器不认识消息</span></span><br><span class="line">            ps.println(<span class="string">&quot;HTTP/1.1 200 OK&quot;</span>); <span class="comment">// 协议类型和版本 响应成功的消息！</span></span><br><span class="line">            ps.println(<span class="string">&quot;Content-Type:text/html;charset=UTF-8&quot;</span>); <span class="comment">// 响应的数据类型：文本/网页</span></span><br><span class="line"></span><br><span class="line">            ps.println(); <span class="comment">// 必须发送一个空行</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 才可以响应数据回去给浏览器</span></span><br><span class="line">            ps.println(<span class="string">&quot;&lt;span style=&#x27;color:red;font-size:90px&#x27;&gt;《最牛的149期》 &lt;/span&gt;&quot;</span>);</span><br><span class="line">            ps.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(socket.getRemoteSocketAddress() + <span class="string">&quot;下线了！！！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> java,面向对象进阶,网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>day20 - 多线程</title>
      <link href="/post/c880ece8.html"/>
      <url>/post/c880ece8.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-多线程的创建"><a href="#1-多线程的创建" class="headerlink" title="1.多线程的创建"></a>1.多线程的创建</h3><h4 id="1-1方式一：继承Thread类"><a href="#1-1方式一：继承Thread类" class="headerlink" title="1.1方式一：继承Thread类"></a>1.1方式一：继承Thread类</h4><p><strong>Thread类</strong></p><ul><li><p>Java是通过java.lang.Thread 类来代表线程的。 </p></li><li><p>按照面向对象的思想，Thread类应该提供了实现多线程的方式。</p></li></ul><p><strong>继承Thread类</strong></p><p><strong>①定义一个子类MyThread继承线程类java.lang.Thread，重写run()方法</strong></p><p><strong>②创建MyThread类的对象</strong></p><p><strong>③调用线程对象的start()方法启动线程（启动后还是执行run方法的）</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   目标：多线程的创建方式一：继承Thread类实现。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 3、new一个新线程对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="comment">// 4、调用start方法启动线程（执行的还是run方法）</span></span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;主线程执行输出：&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   1、定义一个线程类继承Thread类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;  <span class="comment">//继承Thread类</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">       2、重写run方法，里面是定义线程以后要干啥</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;子线程执行输出：&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方式一优缺点：</strong></p><ul><li><p>优点：编码简单</p></li><li><p>缺点：线程类已经继承Thread，无法继承其他类，不利于扩展。</p></li></ul><h4 id="1-2方式二：实现Runnable接口"><a href="#1-2方式二：实现Runnable接口" class="headerlink" title="1.2方式二：实现Runnable接口"></a>1.2方式二：实现Runnable接口</h4><p><strong>Thread的构造器</strong></p><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public Thread(String name)</td><td>可以为当前线程指定名称</td></tr><tr><td>public Thread(Runnable target)</td><td>封装Runnable对象成为线程对象</td></tr><tr><td>public Thread(Runnable target ，String name )</td><td>封装Runnable对象成为线程对象，并指定线程名称</td></tr></tbody></table><p><strong>(一).实现Runnable接口(普通形式)</strong></p><p><strong>①定义一个线程任务类MyRunnable实现Runnable接口，重写run()方法</strong></p><p><strong>②创建MyRunnable任务对象</strong></p><p><strong>③把MyRunnable任务对象交给Thread处理。</strong></p><p><strong>④调用线程对象的start()方法启动线程</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   目标：学会线程的创建方式二，理解它的优缺点。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 3、创建一个任务对象</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">        <span class="comment">// 4、把任务对象交给Thread处理</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(target);</span><br><span class="line">        <span class="comment">// Thread t = new Thread(target, &quot;1号&quot;); //第二个参数可以给线程取名</span></span><br><span class="line">        <span class="comment">// 5、启动线程</span></span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;主线程执行输出：&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   1、定义一个线程任务类 实现Runnable接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;  <span class="comment">//实现Runnable接口</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">       2、重写run方法，定义线程的执行任务的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;子线程执行输出：&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(二).实现Runnable接口(匿名内部类形式–&gt;简化语法)</strong></p><p>①可以创建Runnable的匿名内部类对象。</p><p>②交给Thread处理。</p><p>③调用线程对象的start()启动线程。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   目标：学会线程的创建方式二(匿名内部类方式实现，语法形式)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo2Other</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//子线程1</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;子线程1执行输出：&quot;</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(target);</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//子线程2</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;子线程2执行输出：&quot;</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//子线程3</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;子线程3执行输出：&quot;</span> + i);</span><br><span class="line">            &#125;&#125;).start();</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment">//主线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;主线程执行输出：&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>方式二优缺点：</strong></p><ul><li><p>优点：线程任务类只是实现接口，可以继续继承类和实现接口，扩展性强。</p></li><li><p>缺点：编程多一层对象包装，如果线程有执行结果是不可以直接返回的。</p></li></ul><h4 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h4><ul><li><p><strong>前2种方式都存在一个问题：</strong></p><ul><li><strong>他们重写的run方法均不能直接返回结果。</strong></li><li><strong>不适合需要返回线程执行结果的业务场景。</strong></li></ul></li><li><p><strong>怎么解决这个问题呢？</strong></p><ul><li><p><strong>JDK 5.0提供了Callable和FutureTask来实现(及方式三)。</strong></p></li><li><p><strong>这种方式的优点是：可以得到线程执行的结果。</strong></p></li></ul></li></ul><h4 id="1-3方式三：JDK-5-0新增：实现Callable接口"><a href="#1-3方式三：JDK-5-0新增：实现Callable接口" class="headerlink" title="1.3方式三：JDK 5.0新增：实现Callable接口"></a>1.3方式三：JDK 5.0新增：实现Callable接口</h4><p><strong>利用Callable、FutureTask接口实现。</strong></p><ol><li><p><strong>得到任务对象</strong></p><p><strong>①定义类实现Callable&lt;&gt;接口，重写call方法，封装要做的事情。</strong></p><p><strong>②获得Callable&lt;&gt;对象</strong></p><p><strong>③把Callable任务对象 交给 FutureTask 对象</strong><br>（FutureTask对象的作用1： FutureTask是Runnable的对象（因为实现了Runnable接口），可以交给Thread了<br>FutureTask对象的作用2： 可以在线程执行完毕之后通过调用其get方法得到线程执行完成的结果）</p></li><li><p><strong>把线程任务对象交给Thread处理。</strong></p></li><li><p><strong>调用Thread的start方法启动线程，执行任务</strong></p></li><li><p><strong>线程执行完毕后、通过FutureTask的get方法去获取任务执行的结果。</strong></p></li></ol><p><strong>FutureTask的API</strong></p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>public FutureTask&lt;&gt;(Callable call)</td><td>把Callable对象封装成FutureTask对象。</td></tr><tr><td>public V get() throws Exception</td><td>获取线程执行call方法返回的结果。</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   目标：学会线程的创建方式三：实现Callable接口，结合FutureTask完成。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 3、创建Callable任务对象</span></span><br><span class="line">        Callable&lt;String&gt; call = <span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">100</span>);</span><br><span class="line">        <span class="comment">// 4、把Callable任务对象 交给 FutureTask 对象</span></span><br><span class="line">        <span class="comment">//  FutureTask对象的作用1： 是Runnable的对象（实现了Runnable接口），可以交给Thread了</span></span><br><span class="line">        <span class="comment">//  FutureTask对象的作用2： 可以在线程执行完毕之后通过调用其get方法得到线程执行完成的结果</span></span><br><span class="line">        FutureTask&lt;String&gt; f1 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(call);</span><br><span class="line">        <span class="comment">// 5、交给线程处理</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(f1);</span><br><span class="line">        <span class="comment">// 6、启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Callable&lt;String&gt; call2 = <span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">200</span>);</span><br><span class="line">        FutureTask&lt;String&gt; f2 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(call2);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(f2);</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 如果f1任务没有执行完毕，这里的代码会等待，直到线程1跑完才提取结果。</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">rs1</span> <span class="operator">=</span> f1.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;第一个结果：&quot;</span> + rs1);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 如果f2任务没有执行完毕，这里的代码会等待，直到线程2跑完才提取结果。</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">rs2</span> <span class="operator">=</span> f2.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;第二个结果：&quot;</span> + rs2);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1、定义一个任务类 实现Callable接口  应该申明线程任务执行完毕后的结果的数据类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt;&#123;  <span class="comment">//实现Callable接口</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyCallable</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">       2、重写call方法（任务方法）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n ; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;子线程执行的结果是：&quot;</span> + sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方式三优缺点：</strong></p><ul><li><p>优点：线程任务类只是实现接口，可以继续继承类和实现接口，扩展性强。</p><p><strong>可以在线程执行完毕后去获取线程执行的结果。</strong></p></li><li><p>缺点：编码复杂一点。</p></li></ul><p>3种方式对比</p><table><thead><tr><th>方式</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>继承Thread类</td><td>编程比较简单，可以直接使用Thread类中的方法</td><td>扩展性较差，不能再继承其他的类，不能返回线程执行的结果</td></tr><tr><td>实现Runnable接口</td><td>扩展性强，实现该接口的同时还可以继承其他的类。</td><td>编程相对复杂，不能返回线程执行的结果</td></tr><tr><td>实现Callable接口</td><td>扩展性强，实现该接口的同时还可以继承其他的类。可以得到线程执行的结果</td><td>编程相对复杂</td></tr></tbody></table><h3 id="2-Thread的常用方法"><a href="#2-Thread的常用方法" class="headerlink" title="2.Thread的常用方法"></a>2.Thread的常用方法</h3><p><strong>Thread常用API说明</strong></p><ul><li><p>Thread常用方法：获取线程名称<strong>getName</strong>()、设置名称<strong>setName</strong>()、获取当前线程对象<strong>currentThread</strong>()。</p></li><li><p>至于Thread类提供的诸如：yield、join、interrupt、不推荐的方法 stop 、守护线程、线程优先级等线程的控制方法，在开发中很少使用，这些方法会在高级篇以及后续需要用到的时候再为大家讲解。</p></li></ul><p>当有很多线程在执行的时候，我们怎么去区分这些线程呢？</p><ul><li><strong>此时需要使用Thread的常用方法：getName()、setName()、currentThread</strong>()<strong>等。</strong></li></ul><p><strong>Thread获取和设置线程名称</strong></p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>String  getName()</td><td>获取当前线程的名称，默认线程名称是Thread-索引</td></tr><tr><td>void  setName(String  name)</td><td>将此线程的名称更改为指定的名称，通过构造器也可以设置线程名称</td></tr></tbody></table><p><strong>Thread类获得当前线程的对象</strong></p><p><strong>注意:</strong></p><ul><li><p>此方法是Thread类的静态方法，可以直接使用Thread类调用。</p></li><li><p><strong>这个方法是在哪个线程执行中调用的，就会得到哪个线程对象。</strong></p></li></ul><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>public  static Thread currentThread()：</td><td>返回对当前正在执行的线程对象的引用</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：线程的API  </span></span><br><span class="line"><span class="comment">     getName、setName、currentThread</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo01</span> &#123;</span><br><span class="line">    <span class="comment">// main方法是由主线程负责调度的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;1号&quot;</span>);</span><br><span class="line">        <span class="comment">// t1.setName(&quot;1号&quot;);</span></span><br><span class="line">        t1.start();</span><br><span class="line">        System.out.println(t1.getName());</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;2号&quot;</span>);</span><br><span class="line">        <span class="comment">// t2.setName(&quot;2号&quot;);</span></span><br><span class="line">        t2.start();</span><br><span class="line">        System.out.println(t2.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 哪个线程执行它，它就得到哪个线程对象（当前线程对象）</span></span><br><span class="line">        <span class="comment">// 主线程的名称就叫main</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">m</span> <span class="operator">=</span> Thread.currentThread(<span class="string">&quot;最牛的线程&quot;</span>);</span><br><span class="line">        System.out.println(m.getName());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println( m.getName() + <span class="string">&quot;输出：&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Thread其他常用方法、构造器</strong></p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>public  static void sleep(long time)</td><td>让当前线程休眠指定的时间后再继续执行，单位为毫秒。</td></tr><tr><td>public  void run()</td><td>线程任务方法</td></tr><tr><td>public  void start()</td><td>线程启动方法</td></tr></tbody></table><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public  Thread(String name)</td><td>可以为当前线程指定名称</td></tr><tr><td>public  Thread(Runnable target)</td><td>封装Runnable对象成为线程对象</td></tr><tr><td>public  Thread(Runnable target  ，String  name )</td><td>封装Runnable对象成为线程对象，并指定线程名称</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;第一&quot;</span>);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(target);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(target,<span class="string">&quot;第二&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="3-线程安全"><a href="#3-线程安全" class="headerlink" title="3.线程安全"></a>3.线程安全</h3><h4 id="3-1线程安全问题是什么、发生的原因"><a href="#3-1线程安全问题是什么、发生的原因" class="headerlink" title="3.1线程安全问题是什么、发生的原因"></a>3.1线程安全问题是什么、发生的原因</h4><p><strong>线程安全问题</strong></p><ul><li>多个线程同时操作同一个共享资源的时候可能会出现业务安全问题，称为线程安全问题。</li></ul><p>线程安全问题出现的原因？</p><ul><li><p><strong>存在多线程并发</strong></p></li><li><p><strong>同时访问共享资源</strong></p></li><li><p><strong>存在修改共享资源</strong></p></li></ul><h4 id="3-2线程安全问题案例模拟"><a href="#3-2线程安全问题案例模拟" class="headerlink" title="3.2线程安全问题案例模拟"></a>3.2线程安全问题案例模拟</h4><p><strong>需求：</strong></p><ul><li>小明和小红是一对夫妻，他们有一个共同的账户，余额是10万元，模拟2人同时去取钱10万。</li></ul><p><strong>分析：</strong></p><p>①：需要提供一个账户类，创建一个账户对象代表2个人的共享账户。</p><p>②：需要定义一个线程类，线程类可以处理账户对象。</p><p>③：创建2个线程对象，传入同一个账户对象。</p><p>④：启动2个线程，去同一个账户对象中取钱10万。</p><h3 id="4-线程同步"><a href="#4-线程同步" class="headerlink" title="4.线程同步"></a>4.线程同步</h3><h4 id="4-1同步思想概述"><a href="#4-1同步思想概述" class="headerlink" title="4.1同步思想概述"></a>4.1同步思想概述</h4><p><strong>线程同步</strong></p><ul><li>为了解决线程安全问题。</li></ul><p>1、取钱案例出现问题的原因？</p><ul><li>多个线程同时执行，发现账户都是够钱的。</li></ul><p>2、如何才能保证线程安全呢？</p><ul><li>让多个线程实现先后依次访问共享资源，这样就解决了安全问题</li></ul><p><strong>线程同步的核心思想:</strong></p><p><strong>加锁，把共享资源进行上锁</strong>，每次只能一个线程进入访问完毕以后解锁，然后其他线程才能进来。</p><h4 id="4-2方式一：同步代码块"><a href="#4-2方式一：同步代码块" class="headerlink" title="4.2方式一：同步代码块"></a>4.2方式一：同步代码块</h4><p><strong>同步代码块</strong></p><ul><li><p>作用：把出现线程安全问题的核心代码给上锁。</p></li><li><p>原理：每次只能一个线程进入，执行完毕后自动解锁，其他线程才可以进来执行。</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步锁对象) &#123;</span><br><span class="line">操作共享资源的代码(核心代码)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试线程安全问题</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSafeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、创建一个共享的账户对象。</span></span><br><span class="line">        <span class="type">Account</span> <span class="variable">acc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span>(<span class="string">&quot;ICBC-111&quot;</span> , <span class="number">100000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、创建2个线程对象，操作同一个账户对象</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DrawThread</span>(acc, <span class="string">&quot;小明&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DrawThread</span>(acc,<span class="string">&quot;小红&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">————————————————————————————————————————————————————————————————————————————————————————————————————————————</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    账户类：余额，卡号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String cardId;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> money; <span class="comment">// 余额 关键信息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">(String cardId, <span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cardId = cardId;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCardId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cardId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCardId</span><span class="params">(String cardId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cardId = cardId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getMoney</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMoney</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="comment">//小明 小红</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawMoney</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、拿到是谁来取钱</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">        <span class="comment">// 同步代码块</span></span><br><span class="line">        <span class="comment">// 小明 小红</span></span><br><span class="line">        <span class="comment">// this == acc 共享账户</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="comment">// 2、判断余额是否足够</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span>.money &gt;= money)&#123;</span><br><span class="line">                <span class="comment">// 钱够了</span></span><br><span class="line">                System.out.println(name+<span class="string">&quot;来取钱，吐出：&quot;</span> + money);</span><br><span class="line">                <span class="comment">// 更新余额</span></span><br><span class="line">                <span class="built_in">this</span>.money -= money;</span><br><span class="line">                System.out.println(name+<span class="string">&quot;取钱后，余额剩余：&quot;</span> + <span class="built_in">this</span>.money);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 3、余额不足</span></span><br><span class="line">                System.out.println(name+<span class="string">&quot;来取钱，余额不足！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">————————————————————————————————————————————————————————————————————————————————————————————————————————————</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  线程类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DrawThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;  <span class="comment">//继承Thread</span></span><br><span class="line">    <span class="keyword">private</span> Account acc;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DrawThread</span><span class="params">(Account acc, String name)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.acc = acc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写run()方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 小明 小红  ： acc</span></span><br><span class="line">        acc.drawMoney(<span class="number">100000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><p><strong>锁对象要求</strong></p><ul><li>理论上：锁对象只要对于当前同时执行的线程来说是同一个对象即可。</li></ul><p><strong>锁对象用任意唯一的对象好不好呢</strong><strong>?</strong></p><ul><li>不好，会影响其他无关线程的执行。</li></ul><p><strong>锁对象的规范要求</strong></p><ul><li><p>规范上：建议使用共享资源作为锁对象。</p></li><li><p>对于<strong>实例方法</strong>建议使用<strong>this</strong>作为锁对象。</p></li><li><p>对于<strong>静态方法</strong>建议使用字节码（<strong>类名.class</strong>）对象作为锁对象。</p></li></ul><h4 id="4-3方式二：同步方法"><a href="#4-3方式二：同步方法" class="headerlink" title="4.3方式二：同步方法"></a>4.3方式二：同步方法</h4><p><strong>同步方法</strong></p><ul><li><p>作用：把出现线程安全问题的核心方法给上锁。</p></li><li><p>原理：每次只能一个线程进入，执行完毕以后自动解锁，其他线程才可以进来执行。</p></li></ul><p><strong>格式</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 <span class="keyword">synchronized</span> 返回值类型 方法名称(形参列表) &#123;</span><br><span class="line">(操作共享资源的代码)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    账户类：余额，卡号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String cardId;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> money; <span class="comment">// 余额 关键信息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">(String cardId, <span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cardId = cardId;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCardId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cardId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCardId</span><span class="params">(String cardId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cardId = cardId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getMoney</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMoney</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//小明 小红  this == acc</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">drawMoney</span><span class="params">(<span class="type">double</span> money)</span> &#123; <span class="comment">//synchronized修饰符</span></span><br><span class="line">        <span class="comment">// 1、拿到是谁来取钱</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">        <span class="comment">// 2、判断余额是否足够</span></span><br><span class="line">        <span class="comment">// 小明  小红</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.money &gt;= money)&#123;</span><br><span class="line">            <span class="comment">// 钱够了</span></span><br><span class="line">            System.out.println(name+<span class="string">&quot;来取钱，吐出：&quot;</span> + money);</span><br><span class="line">            <span class="comment">// 更新余额</span></span><br><span class="line">            <span class="built_in">this</span>.money -= money;</span><br><span class="line">            System.out.println(name+<span class="string">&quot;取钱后，余额剩余：&quot;</span> + <span class="built_in">this</span>.money);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 3、余额不足</span></span><br><span class="line">            System.out.println(name+<span class="string">&quot;来取钱，余额不足！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>同步方法底层原理</strong></p><ul><li><p>同步方法其实底层也是有隐式锁对象的，只是锁的范围是整个方法代码。</p></li><li><p>如果方法是<strong>实例方法</strong>：同步方法默认用<strong>this</strong>作为的锁对象。但是代码要高度面向对象！</p></li><li><p>如果方法是<strong>静态方法</strong>：同步方法默认<strong>用类名.class</strong>作为的锁对象。</p></li></ul><p><strong>是同步代码块好还是同步方法好一点？</strong></p><ul><li><strong>同步代码块锁的范围更小，同步方法锁的范围更大。</strong></li></ul><h4 id="4-4方式三：Lock锁"><a href="#4-4方式三：Lock锁" class="headerlink" title="4.4方式三：Lock锁"></a>4.4方式三：Lock锁</h4><p><strong>Lock锁</strong></p><ul><li><p>为了更清晰的表达如何加锁和释放锁，JDK5以后提供了一个新的锁对象Lock，更加灵活、方便。</p></li><li><p>Lock实现提供比使用synchronized方法和语句可以获得更广泛的锁定操作。</p></li><li><p>Lock是接口不能直接实例化，这里采用它的实现类ReentrantLock来构建Lock锁对象。</p></li></ul><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>public ReentrantLock()</td><td>获得Lock锁的实现类对象</td></tr></tbody></table><p><strong>Lock的API</strong></p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>void lock()</td><td>获得锁</td></tr><tr><td>void  unlock()</td><td>释放锁</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    账户类：余额 , 卡号。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String cardId;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> money; <span class="comment">// 余额 关键信息</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//一.获得Lock锁的实现类对象  </span></span><br><span class="line">    <span class="comment">// final修饰后：锁对象是唯一和不可替换的，非常专业</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">(String cardId, <span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cardId = cardId;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCardId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cardId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCardId</span><span class="params">(String cardId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cardId = cardId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getMoney</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMoney</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  小明 小红</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawMoney</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、拿到是谁来取钱</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">        <span class="comment">// 2、判断余额是否足够</span></span><br><span class="line">        <span class="comment">// 小明  小红</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//二.获得锁 | 释放锁 </span></span><br><span class="line">        lock.lock(); <span class="comment">// 上锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span>.money &gt;= money)&#123;</span><br><span class="line">                <span class="comment">// 钱够了</span></span><br><span class="line">                System.out.println(name+<span class="string">&quot;来取钱，吐出：&quot;</span> + money);</span><br><span class="line">                <span class="comment">// 更新余额</span></span><br><span class="line">                <span class="built_in">this</span>.money -= money;</span><br><span class="line">                System.out.println(name+<span class="string">&quot;取钱后，余额剩余：&quot;</span> + <span class="built_in">this</span>.money);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 3、余额不足</span></span><br><span class="line">                System.out.println(name+<span class="string">&quot;来取钱，余额不足！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;  <span class="comment">// finally是必须执行，防止代码锁死</span></span><br><span class="line">            lock.unlock(); <span class="comment">// 解锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-线程通信"><a href="#5-线程通信" class="headerlink" title="5.线程通信"></a>5.线程通信</h3><p><strong>什么是线程通信、如何实现？</strong></p><ul><li>所谓线程通信就是线程间相互发送数据，线程间共享一个资源即可实现线程通信。</li></ul><p><strong>线程通信常见形式</strong></p><ul><li><p>通过共享一个数据的方式实现。</p></li><li><p>根据共享数据的情况决定自己该怎么做，以及通知其他线程怎么做。</p></li></ul><p><strong>线程通信实际应用场景</strong></p><ul><li><p>生产者与消费者模型：生产者线程负责生产数据，消费者线程负责消费生产者产生的数据。</p></li><li><p>要求：生产者线程生产完数据后唤醒消费者，然后等待自己，消费者消费完该数据后唤醒生产者，然后等待自己。</p></li></ul><p><strong>线程通信案例模拟</strong></p><ul><li><p>模拟客服系统，系统可以不断的接入电话 和 分发给客服。</p></li><li><p>线程通信的前提：线程通信通常是在多个线程操作同一个共享资源的时候需要进行通信，且要保证线程安全。</p></li></ul><p><strong>Object类的等待和唤醒方法：</strong></p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>void  wait()</td><td>让当前线程等待并释放所占锁，直到另一个线程调用notify()方法或 notifyAll()方法</td></tr><tr><td>void  notify()</td><td>唤醒正在等待的单个线程</td></tr><tr><td>void notifyAll()</td><td>唤醒正在等待的所有线程</td></tr></tbody></table><p><strong>注意</strong></p><ul><li>上述方法应该使用当前同步锁对象进行调用。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   接电话线程类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 1号  2号</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            CallSystem.receive();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 不断的打入电话</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            CallSystem.call();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  线程类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DrawThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Account acc;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DrawThread</span><span class="params">(Account acc, String name)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.acc = acc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 小明 小红  ： acc</span></span><br><span class="line">        acc.drawMoney(<span class="number">100000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   呼叫系统。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallSystem</span> &#123;</span><br><span class="line">    <span class="comment">// 定义一个变量记录当前呼入进来的电话。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 最多只接听一个。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 接入电话</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            number++;</span><br><span class="line">            System.out.println(<span class="string">&quot;成功接入一个用户，等待分发~~~~&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 唤醒别人 : 1个</span></span><br><span class="line">            CallSystem.class.notify();</span><br><span class="line">            <span class="comment">// 让当前线程对象进入等待状态。</span></span><br><span class="line">            CallSystem.class.wait();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">       分发电话</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">receive</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">            <span class="keyword">if</span>(number == <span class="number">1</span>)&#123;</span><br><span class="line">                System.out.println(name + <span class="string">&quot;此电话已经分发给客服并接听完毕了~~~~~&quot;</span>);</span><br><span class="line">                number--;</span><br><span class="line">                <span class="comment">// 唤醒别人 : 1个</span></span><br><span class="line">                CallSystem.class.notify();</span><br><span class="line">                CallSystem.class.wait(); <span class="comment">// 让当前线程等待</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 唤醒别人 : 1个</span></span><br><span class="line">                CallSystem.class.notify();</span><br><span class="line">                CallSystem.class.wait(); <span class="comment">// 让当前线程等待</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-线程池"><a href="#6-线程池" class="headerlink" title="6.线程池"></a>6.线程池</h3><h4 id="6-1线程池概述"><a href="#6-1线程池概述" class="headerlink" title="6.1线程池概述"></a>6.1线程池概述</h4><p><strong>什么是线程池？</strong></p><ul><li>线程池就是一个可以复用线程的技术。</li></ul><p><strong>不使用线程池的问题</strong> </p><ul><li>如果用户每发起一个请求，后台就创建一个新线程来处理，下次新任务来了又要创建新线程，而创建新线程的开销是很大的，这样会严重影响系统的性能。</li></ul><h4 id="6-2线程池实现的API、参数说明"><a href="#6-2线程池实现的API、参数说明" class="headerlink" title="6.2线程池实现的API、参数说明"></a>6.2线程池实现的API、参数说明</h4><p><strong>谁代表线程池？</strong></p><ul><li>JDK 5.0起提供了代表线程池<strong>ExecutorService接口</strong></li></ul><p><strong>如何得到线程池对象</strong></p><ul><li><p>方式一：使用ExecutorService的实现类ThreadPoolExecutor自创建一个线程池对象</p></li><li><p>方式二：使用Executors（线程池的工具类）调用方法返回不同特点的线程池对象</p></li></ul><p><strong>ThreadPoolExecutor构造器的参数说明</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">  <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">  <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">  TimeUnit unit,</span></span><br><span class="line"><span class="params">  BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">  ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">  RejectedExecutionHandler handler)</span> </span><br></pre></td></tr></table></figure><table><thead><tr><th>参数一：指定线程池的线程数量（核心线程）： corePoolSize</th><th>不能小于0</th></tr></thead><tbody><tr><td>参数二：指定线程池可支持的最大线程数： maximumPoolSize</td><td>最大数量 &gt;&#x3D; 核心线程数量</td></tr><tr><td>参数三：指定临时线程的最大存活时间： keepAliveTime</td><td>不能小于0</td></tr><tr><td>参数四：指定存活时间的单位(秒、分、时、天)： unit</td><td>时间单位</td></tr><tr><td>参数五：指定任务队列： workQueue</td><td>不能为null</td></tr><tr><td>参数六：指定用哪个线程工厂创建线程： threadFactory</td><td>不能为null</td></tr><tr><td>参数七：指定线程忙，任务满的时候，新任务来了怎么办： handler</td><td>不能为null</td></tr></tbody></table><p><strong>ExecutorService的常用方法</strong></p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>void <strong>execute</strong>(Runnable command)</td><td>执行任务&#x2F;命令，没有返回值，一般用来<strong>执行  Runnable 任务</strong></td></tr><tr><td>Future<T>  <strong>submit</strong>(Callable<T> task)</td><td>执行任务，返回未来任务对象获取线程结果，一般拿来<strong>执行  Callable  任务</strong></td></tr><tr><td>void  <strong>shutdown</strong>()</td><td>等<strong>任务执行完毕后关闭线程池</strong></td></tr><tr><td><strong><a href="mk:@MSITStore:D:\course\jdk-11中文api修订版.CHM::/java.base/java/util/List.html">List</a><Runnable> shutdownNow</strong>()</td><td><strong>立刻关闭</strong>，停止正在执行的任务，并返回队列中未执行的任务</td></tr></tbody></table><p><strong>新任务拒绝策略</strong></p><table><thead><tr><th>策略</th><th>详解</th></tr></thead><tbody><tr><td>ThreadPoolExecutor.AbortPolicy</td><td>丢弃任务并抛出RejectedExecutionException异常。<strong>是默认的策略</strong></td></tr><tr><td>ThreadPoolExecutor.DiscardPolicy：</td><td>丢弃任务，但是不抛出异常  这是不推荐的做法</td></tr><tr><td>ThreadPoolExecutor.DiscardOldestPolicy</td><td>抛弃队列中等待最久的任务  然后把当前任务加入队列中</td></tr><tr><td>ThreadPoolExecutor.CallerRunsPolicy</td><td>由主线程负责调用任务的run()方法从而绕过线程池直接执行</td></tr></tbody></table><p><strong>线程池常见面试题</strong></p><p><strong>临时线程什么时候创建啊？</strong></p><ul><li>新任务提交时发现核心线程都在忙，任务队列也满了，并且还可以创建临时线程，此时才会创建临时线程。</li></ul><p><strong>什么时候会开始拒绝任务？</strong></p><ul><li>核心线程和临时线程都在忙，任务队列也满了，新的任务过来的时候才会开始任务拒绝。</li></ul><h4 id="6-3线程池处理"><a href="#6-3线程池处理" class="headerlink" title="6.3线程池处理"></a><strong>6.3线程池处理</strong></h4><h5 id="方式一：Runnable任务"><a href="#方式一：Runnable任务" class="headerlink" title="方式一：Runnable任务"></a>方式一：Runnable任务</h5><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>void <strong>execute</strong>(Runnable command)</td><td>执行任务&#x2F;命令，没有返回值，一般用来执行  <strong>Runnable 任务</strong></td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首先，自定义线程，实现Runnable接口，重写Run方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*目标：自定义一个线程池对象，并测试其特性。 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、创建线程池对象</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         public ThreadPoolExecutor(int corePoolSize,</span></span><br><span class="line"><span class="comment">                                  int maximumPoolSize,</span></span><br><span class="line"><span class="comment">                                  long keepAliveTime,</span></span><br><span class="line"><span class="comment">                                  TimeUnit unit,</span></span><br><span class="line"><span class="comment">                                  BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="comment">                                  ThreadFactory threadFactory,</span></span><br><span class="line"><span class="comment">                                  RejectedExecutionHandler handler)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, TimeUnit.SECONDS, </span><br><span class="line">                                                      <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">5</span>) , </span><br><span class="line">                                                      Executors.defaultThreadFactory(),</span><br><span class="line">                                                      <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy() );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、给任务线程池处理。 </span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">        pool.execute(target);  <span class="comment">//调用execute方法</span></span><br><span class="line">        pool.execute(target);</span><br><span class="line">        pool.execute(target);</span><br><span class="line"></span><br><span class="line">        pool.execute(target);</span><br><span class="line">        pool.execute(target);</span><br><span class="line">        pool.execute(target);</span><br><span class="line">        pool.execute(target);</span><br><span class="line">        pool.execute(target);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建临时线程</span></span><br><span class="line">        pool.execute(target);</span><br><span class="line">        pool.execute(target);</span><br><span class="line">      </span><br><span class="line"><span class="comment">//      pool.execute(target);  // 最多10个线程，此时不创建，拒绝策略被触发！！！</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池（开发中一般不会使用）。</span></span><br><span class="line"><span class="comment">//      pool.shutdownNow(); // 立即关闭，即使任务没有完成，会丢失任务的！</span></span><br><span class="line">        pool.shutdown(); <span class="comment">// 会等待全部任务执行完毕之后再关闭（建议使用的）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="方式二：Callable任务"><a href="#方式二：Callable任务" class="headerlink" title="方式二：Callable任务"></a>方式二：Callable任务</h5><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>Future<T> <strong>submit</strong>(Callable<T> task)</td><td>返回未来任务对象获取线程结果 ，执行  <strong>Callable任务</strong></td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：自定义一个线程池对象，并测试其特性。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建线程池对象</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         public ThreadPoolExecutor(int corePoolSize,</span></span><br><span class="line"><span class="comment">                                  int maximumPoolSize,</span></span><br><span class="line"><span class="comment">                                  long keepAliveTime,</span></span><br><span class="line"><span class="comment">                                  TimeUnit unit,</span></span><br><span class="line"><span class="comment">                                  BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="comment">                                  ThreadFactory threadFactory,</span></span><br><span class="line"><span class="comment">                                  RejectedExecutionHandler handler)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">3</span>, <span class="number">5</span> ,<span class="number">6</span>, TimeUnit.SECONDS, </span><br><span class="line">                                                      <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">5</span>) , </span><br><span class="line">                                                      Executors.defaultThreadFactory(),</span><br><span class="line">                                                      <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy() );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、给任务线程池处理。</span></span><br><span class="line"><span class="comment">//        Callable call = new MyCallable(100);</span></span><br><span class="line"><span class="comment">//        Future&lt;String&gt; f1 = pool.submit(call); // 有返回值，返回未来任务对象</span></span><br><span class="line">        </span><br><span class="line">        Future&lt;String&gt; f1 = pool.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">100</span>));</span><br><span class="line">        Future&lt;String&gt; f2 = pool.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">200</span>));</span><br><span class="line">        Future&lt;String&gt; f3 = pool.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">300</span>));</span><br><span class="line">        Future&lt;String&gt; f4 = pool.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">400</span>));</span><br><span class="line">        Future&lt;String&gt; f5 = pool.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">500</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.调用get方法输出返回值</span></span><br><span class="line"><span class="comment">//        String rs = f1.get();</span></span><br><span class="line"><span class="comment">//        System.out.println(rs);</span></span><br><span class="line"></span><br><span class="line">        System.out.println(f1.get());</span><br><span class="line">        System.out.println(f2.get());</span><br><span class="line">        System.out.println(f3.get());</span><br><span class="line">        System.out.println(f4.get());</span><br><span class="line">        System.out.println(f5.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-4Executors工具类实现线程池"><a href="#6-4Executors工具类实现线程池" class="headerlink" title="6.4Executors工具类实现线程池"></a><strong>6.4Executors工具类实现线程池</strong></h4><p><strong>Executors得到线程池对象的常用方法</strong></p><ul><li>Executors：线程池的工具类通过调用方法返回不同类型的线程池对象。</li></ul><p><strong>注意：大型并发系统环境中使用Executors如果不注意可能会出现系统风险。</strong></p><table><thead><tr><th>方法名称</th><th>说明</th><th>存在问题</th></tr></thead><tbody><tr><td>public  static <a href="mk:@MSITStore:D:\course\jdk-11中文api修订版.CHM::/java.base/java/util/concurrent/ExecutorService.html">ExecutorService</a> newCachedThreadPool()</td><td>线程数量随着任务增加而增加，如果线程任务执行完毕且空闲了一段时间则会被回收掉。</td><td>创建的线程数量最大上限是Integer.MAX_VALUE，  线程数可能会随着任务1:1增长，也可能出现OOM错误（ java.lang.OutOfMemoryError ）</td></tr><tr><td>public  static <a href="mk:@MSITStore:D:\course\jdk-11中文api修订版.CHM::/java.base/java/util/concurrent/ScheduledExecutorService.html">ScheduledExecutorService</a> newScheduledThreadPool(int corePoolSize)</td><td>创建一个线程池，可以实现在给定的延迟后运行任务，或者定期执行任务。</td><td>同上</td></tr><tr><td>public static <a href="mk:@MSITStore:D:\course\jdk-11中文api修订版.CHM::/java.base/java/util/concurrent/ExecutorService.html">ExecutorService</a> newFixedThreadPool(int nThreads)</td><td>创建固定线程数量的线程池，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程替代它。</td><td>允许请求的任务队列长度是Integer.MAX_VALUE，可能出现OOM错误（ java.lang.OutOfMemoryError ）</td></tr><tr><td>public  static <a href="mk:@MSITStore:D:\course\jdk-11中文api修订版.CHM::/java.base/java/util/concurrent/ExecutorService.html">ExecutorService</a> newSingleThreadExecutor ()</td><td>创建只有一个线程的线程池对象，如果该线程出现异常而结束，那么线程池会补充一个新线程。</td><td>同上</td></tr></tbody></table><p><strong>注意：Executors的底层其实也是基于线程池的实现类ThreadPoolExecutor创建线程池对象的。</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：使用Executors的工具方法直接得到一个线程池对象。</span></span><br><span class="line"><span class="comment">    newFixedThreadPool方法，创建固定线程数量的线程池</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolDemo3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建固定线程数据的线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        pool.execute(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">        pool.execute(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">        pool.execute(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">        pool.execute(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>()); <span class="comment">// 已经没有多余线程了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Executors使用可能存在的陷阱</strong></p><ul><li>大型并发系统环境中使用Executors如果不注意可能会出现系统风险。</li></ul><h3 id="7-补充知识："><a href="#7-补充知识：" class="headerlink" title="7.补充知识："></a><strong>7.补充知识：</strong></h3><h4 id="7-1定时器"><a href="#7-1定时器" class="headerlink" title="7.1定时器"></a><strong>7.1定时器</strong></h4><p><strong>定时器</strong></p><ul><li><p>定时器是一种控制任务延时调用，或者周期调用的技术。</p></li><li><p>作用：闹钟、定时邮件发送。</p></li></ul><p><strong>定时器的实现方式</strong></p><ul><li><p>方式一：Timer</p></li><li><p>方式二： ScheduledExecutorService</p></li></ul><h5 id="方式一：Timer定时器"><a href="#方式一：Timer定时器" class="headerlink" title="方式一：Timer定时器"></a>方式一：Timer定时器</h5><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public  <strong>Timer</strong>()</td><td>创建Timer定时器对象</td></tr></tbody></table><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public void <strong>schedule</strong>(<a href="file:///D:/course/%E5%9F%BA%E7%A1%80%E9%98%B6%E6%AE%B5/API%E6%96%87%E6%A1%A3/docs/api/java.base/java/util/TimerTask.html">TimerTask</a> task,  long delay, long period)</td><td>开启一个定时器，按照计划处理TimerTask任务</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：Timer定时器的使用和了解。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimerDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、创建Timer定时器</span></span><br><span class="line">        <span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>();  <span class="comment">// 定时器本身就是一个单线程。</span></span><br><span class="line">        <span class="comment">// 2、调用方法，处理定时任务</span></span><br><span class="line">        <span class="comment">//线程一：</span></span><br><span class="line">        timer.schedule(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行AAA~~~&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>, <span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//线程二：</span></span><br><span class="line">        timer.schedule(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行BBB~~~&quot;</span>+ <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">                System.out.println(<span class="number">10</span>/<span class="number">0</span>);  <span class="comment">// ** &gt;注意：此时代码异常  后续方法不执行  &lt;**</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>, <span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//线程三：</span></span><br><span class="line">        timer.schedule(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行CCC~~~&quot;</span>+ <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>, <span class="number">3000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Timer定时器的特点和存在的问题</strong></p><ol><li><p>Timer是单线程，处理多个任务按照顺序执行，存在延时与设置定时器的时间有出入。</p></li><li><p>可能因为其中的某个任务的异常使Timer线程死掉，从而影响后续任务执行。</p></li></ol><h5 id="方式二：-ScheduledExecutorService定时器"><a href="#方式二：-ScheduledExecutorService定时器" class="headerlink" title="方式二： ScheduledExecutorService定时器"></a>方式二： ScheduledExecutorService<strong>定时器</strong></h5><ul><li>ScheduledExecutorService是 jdk1.5中引入了并发包，目的是为了弥补Timer的缺陷, ScheduledExecutorService内部为线程池。</li></ul><table><thead><tr><th>Executors的方法</th><th>说明</th></tr></thead><tbody><tr><td>public static ScheduledExecutorService <strong>newScheduledThreadPool</strong>(int corePoolSize)</td><td>得到线程池对象</td></tr></tbody></table><table><thead><tr><th>ScheduledExecutorService的方法</th><th>说明</th></tr></thead><tbody><tr><td>public ScheduledFuture&lt;?&gt; <strong>scheduleAtFixedRate</strong>(Runnable command, long initialDelay, long period,                              TimeUnit unit)</td><td>周期调度方法</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标： ScheduledExecutorService定时器的使用和了解。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimerDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、创建ScheduledExecutorService线程池，做定时器</span></span><br><span class="line">        <span class="type">ScheduledExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、开启定时任务</span></span><br><span class="line">        <span class="comment">//线程一：</span></span><br><span class="line">        pool.scheduleAtFixedRate(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行输出：AAA  ==》 &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>, <span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//线程二：</span></span><br><span class="line">        pool.scheduleAtFixedRate(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行输出：BBB  ==》 &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">                System.out.println(<span class="number">10</span> / <span class="number">0</span>);  <span class="comment">// ** &gt;注意：此时代码异常  后续线程还会执行  &lt;**</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>, <span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//线程三：</span></span><br><span class="line">        pool.scheduleAtFixedRate(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行输出：CCC  ==》 &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>, <span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ScheduledExecutorService的优点</strong></p><ul><li>基于线程池，某个任务的执行情况不会影响其他定时任务的执行。</li></ul><h4 id="7-2-并发、并行"><a href="#7-2-并发、并行" class="headerlink" title="7.2.并发、并行"></a><strong>7.2.并发、并行</strong></h4><p><strong>并发与并行</strong></p><ul><li>正在运行的程序（软件）就是一个独立的进程， 线程是属于进程的，多个线程其实是并发与并行同时进行的。</li></ul><p><strong>并发的理解：</strong></p><ul><li><p>CPU同时处理线程的数量有限。</p></li><li><p>CPU会轮询为系统的每个线程服务，由于CPU切换的速度很快，给我们的感觉这些线程在同时执行，这就是并发。</p></li></ul><p><strong>并行的理解：</strong></p><ul><li>在同一个时刻上，同时有多个线程在被CPU处理并执行。</li></ul><h4 id="7-3线程的生命周期"><a href="#7-3线程的生命周期" class="headerlink" title="7.3线程的生命周期"></a><strong>7.3线程的生命周期</strong></h4><p><strong>线程的状态</strong></p><ul><li><p>线程的状态：也就是线程从生到死的过程，以及中间经历的各种状态及状态转换。</p></li><li><p>理解线程的状态有利于提升并发编程的理解能力。</p></li></ul><p><strong>Java线程的状态</strong></p><ul><li>Java总共定义了6种状态</li><li>6种状态都定义在Thread类的内部枚举类中。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">     ...</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">     NEW,</span><br><span class="line">     RUNNABLE,</span><br><span class="line">     BLOCKED,</span><br><span class="line">     WAITING,</span><br><span class="line">     TIMED_WAITING,</span><br><span class="line">     TERMINATED;</span><br><span class="line">     &#125;</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>线程的6种状态</strong></p><ol><li><strong>新建（New）状态</strong>：当创建一个线程对象但尚未调用其<code>start()</code>方法时，线程处于新建状态。</li><li><strong>就绪（Runnable）状态</strong>：一旦调用了线程对象的<code>start()</code>方法，线程进入就绪状态。在就绪状态下，线程已经准备好执行，但尚未分配到CPU时间片。</li><li><strong>运行（Running）状态</strong>：当线程获取到CPU时间片并真正开始执行时，线程处于运行状态。</li><li><strong>阻塞（Blocked）状态</strong>：线程可能因为某些条件无法继续执行，比如等待某个资源、等待用户输入等情况。在这种情况下，线程会进入阻塞状态。阻塞状态分为多个子状态，比如等待阻塞、同步阻塞、等待超时阻塞等。</li><li><strong>等待（Waiting）状态</strong>：线程在某些特定条件下等待一段时间，等待条件满足后会进入就绪状态。线程可以通过调用<code>Object.wait()</code>方法、<code>Thread.join()</code>方法等进入等待状态。</li><li><strong>终止（Terminated）状态</strong>：线程执行完任务或者出现异常导致线程终止时，线程进入终止状态。</li></ol><p><strong>线程的6种状态互相转换</strong></p><ol><li>新建（New） -&gt; 就绪（Runnable）：调用线程对象的<code>start()</code>方法。</li><li>就绪（Runnable） -&gt; 运行（Running）：获取到CPU时间片。</li><li>运行（Running） -&gt; 就绪（Runnable）：时间片用完，或线程主动释放CPU。</li><li>运行（Running） -&gt; 阻塞（Blocked）：线程等待某些条件，如等待I&#x2F;O操作完成。</li><li>阻塞（Blocked） -&gt; 就绪（Runnable）：条件满足，或等待超时。</li><li>运行（Running） -&gt; 等待（Waiting）：线程调用了<code>Object.wait()</code>等方法。</li><li>等待（Waiting） -&gt; 就绪（Runnable）：等待时间结束或其他线程通知。</li><li>运行（Running） -&gt; 终止（Terminated）：线程执行完毕或出现未捕获的异常。</li></ol><p><strong>线程的6种状态总结</strong></p><table><thead><tr><th align="left">线程状态</th><th align="left">描述</th><th>状态</th></tr></thead><tbody><tr><td align="left">NEW(新建)</td><td align="left">线程刚被创建，但是并未启动。</td><td>创建线程对象</td></tr><tr><td align="left">Runnable(可运行)</td><td align="left">线程已经调用了start()等待CPU调度</td><td>start方法</td></tr><tr><td align="left">Blocked(锁阻塞)</td><td align="left">线程在执行的时候未竞争到锁对象，则该线程进入Blocked状态</td><td>无法获得锁对象</td></tr><tr><td align="left">Waiting(无限等待)</td><td align="left">一个线程进入Waiting状态，另一个线程调用notify或者notifyAll方法才能够唤醒</td><td>wait方法</td></tr><tr><td align="left">Timed Waiting(计时等待)</td><td align="left">同waiting状态，有几个方法有超时参数，调用他们将进入Timed Waiting状态。带有超时参数的常用方法有Thread.sleep 、Object.wait</td><td>sleep方法</td></tr><tr><td align="left">Teminated(被终止)</td><td align="left">因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡</td><td>全部代码运行完毕</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> java,面向对象进阶,多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>day19 - Io二</title>
      <link href="/post/c0dc36c0.html"/>
      <url>/post/c0dc36c0.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-缓冲流"><a href="#1-缓冲流" class="headerlink" title="1.缓冲流"></a>1.缓冲流</h3><h4 id="1-缓冲流概述"><a href="#1-缓冲流概述" class="headerlink" title="1.缓冲流概述"></a>1.缓冲流概述</h4><p><strong>缓冲流概述</strong></p><ul><li><p>缓冲流也称为高效流、或者高级流。之前学习的字节流可以称为原始流。</p></li><li><p>作用：缓冲流自带缓冲区、可以提高原始字节流、字符流读写数据的性能</p></li></ul><p><strong>4种缓冲流</strong></p><ul><li><p><strong>字节缓冲流</strong></p><ul><li><strong>字节缓冲输入流：</strong> <strong>BufferedInputStream</strong></li><li><strong>字节缓冲输出流：BufferedOutputStream</strong></li></ul></li><li><p><strong>字符缓冲流</strong></p><ul><li><strong>字符缓冲输入流：BufferedReader</strong></li><li><strong>字符缓冲输出流：BufferedWriter</strong></li></ul></li></ul><h4 id="1-2字节缓冲流"><a href="#1-2字节缓冲流" class="headerlink" title="1.2字节缓冲流"></a>1.2字节缓冲流</h4><p><strong>字节缓冲流性能优化原理：</strong></p><ul><li><p>字节缓冲输入流自带了8KB缓冲池，以后我们直接从缓冲池读取数据，所以性能较好。</p></li><li><p>字节缓冲输出流自带了8KB缓冲池，数据就直接写入到缓冲池中去，写数据性能极高了。</p></li></ul><p><strong>字节缓冲流</strong></p><ul><li><p>字节缓冲输入流：BufferedInputStream，提高字节输入流读取数据的性能，读写功能上并无变化。</p></li><li><p>字节缓冲输出流：BufferedOutputStream，提高字节输出流读取数据的性能，读写功能上并无变化。</p></li></ul><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public <strong>BufferedInputStream</strong>(InputStream is)</td><td>可以把低级的字节输入流包装成一个高级的缓冲字节输入流管道，从而提高字节输入流读数据的性能</td></tr><tr><td>public <strong>BufferedOutputStream</strong>(OutputStream os)</td><td>可以把低级的字节输出流包装成一个高级的缓冲字节输出流，从而提高写数据的性能</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：使用字节缓冲流完成数据的读写操作。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ByteBufferDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">// 这里面只能放置资源对象，用完会自动关闭：自动调用资源对象的close方法关闭资源（即使出现异常也会做关闭操作）</span></span><br><span class="line">                <span class="comment">// 1、创建一个字节输入流管道与原始管道接通</span></span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\\resources\\newmeinv.jpeg&quot;</span>);</span><br><span class="line">                <span class="comment">// a.把原始的字节输入流包装成高级的缓冲字节输入流</span></span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(is);</span><br><span class="line">            </span><br><span class="line">                <span class="comment">// 2、创建一个字节输出流管道与目标文件接通</span></span><br><span class="line">                <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D:\\resources\\newmeinv222.jpeg&quot;</span>);</span><br><span class="line">                <span class="comment">// b.把字节输出流管道包装成高级的缓冲字节输出流管道</span></span><br><span class="line">                <span class="type">OutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(os);</span><br><span class="line">) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 3、定义一个字节数组转移数据</span></span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> len; <span class="comment">// 记录每次读取的字节数。</span></span><br><span class="line">            <span class="keyword">while</span> ((len = bis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                bos.write(buffer, <span class="number">0</span> , len);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;复制完成了！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3字节缓冲流的性能分析"><a href="#1-3字节缓冲流的性能分析" class="headerlink" title="1.3字节缓冲流的性能分析"></a>1.3字节缓冲流的性能分析</h4><p><strong>1、我们已经说明了字节缓冲流的性能高效，但是没有直接感受到。</strong></p><p><strong>2、如何测试字节缓冲流的读写性能呢？</strong></p><p><strong>案例：</strong></p><p>分别使用不同的方式复制大视频观察性能情况</p><p><strong>需求</strong></p><ul><li>分别使用低级字节流和高级字节缓冲流拷贝大视频，记录耗时。</li></ul><p><strong>分析</strong></p><p>①使用低级的字节流按照一个一个字节的形式复制文件。</p><p>②使用低级的字节流按照一个一个字节数组的形式复制文件。</p><p>③使用高级的缓冲字节流按照一个一个字节的形式复制文件。</p><p>④使用高级的缓冲字节流按照一个一个字节数组的形式复制文件。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：利用字节流的复制统计各种写法形式下缓冲流的性能执行情况。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    复制流：</span></span><br><span class="line"><span class="comment">        （1）使用低级的字节流按照一个一个字节的形式复制文件。</span></span><br><span class="line"><span class="comment">        （2）使用低级的字节流按照一个一个字节数组的形式复制文件。</span></span><br><span class="line"><span class="comment">        （3）使用高级的缓冲字节流按照一个一个字节的形式复制文件。</span></span><br><span class="line"><span class="comment">        （4）使用高级的缓冲字节流按照一个一个字节数组的形式复制文件。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    源文件：C:\course\3-视频\18、IO流-文件字节输出流FileOutputStream写字节数据出去.avi</span></span><br><span class="line"><span class="comment">    目标文件：C:\course\</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    小结：</span></span><br><span class="line"><span class="comment">        使用高级的缓冲字节流按照一个一个字节数组的形式复制文件，性能好，建议开发使用！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ByteBufferTimeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SRC_FILE</span> <span class="operator">=</span> <span class="string">&quot;D:\\course\\基础加强\\day08-日志框架、阶段项目\\视频\\14、用户购票功能.avi&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEST_FILE</span> <span class="operator">=</span> <span class="string">&quot;D:\\course\\&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// copy01(); // 使用低级的字节流按照一个一个字节的形式复制文件：慢的让人简直无法忍受。直接被淘汰。</span></span><br><span class="line">        copy02(); <span class="comment">// 使用低级的字节流按照一个一个字节数组的形式复制文件: 比较慢，但是还是可以忍受的！</span></span><br><span class="line">        <span class="comment">// copy03(); // 缓冲流一个一个字节复制：很慢，不建议使用。</span></span><br><span class="line">        copy04(); <span class="comment">// 缓冲流一个一个字节数组复制：飞快，简直太完美了（推荐使用）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//（4）使用高级的缓冲字节流按照一个一个字节数组的形式复制文件。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copy04</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">// 1、创建低级的字节输入流与源文件接通</span></span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(SRC_FILE);</span><br><span class="line">                <span class="comment">// a.把原始的字节输入流包装成高级的缓冲字节输入流</span></span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(is);</span><br><span class="line">                <span class="comment">// 2、创建低级的字节输出流与目标文件接通</span></span><br><span class="line">                <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(DEST_FILE + <span class="string">&quot;video4.avi&quot;</span>);</span><br><span class="line">                <span class="comment">// b.把字节输出流管道包装成高级的缓冲字节输出流管道</span></span><br><span class="line">                <span class="type">OutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(os);</span><br><span class="line">        ) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3、定义一个字节数组转移数据</span></span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> len; <span class="comment">// 记录每次读取的字节数。</span></span><br><span class="line">            <span class="keyword">while</span> ((len = bis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                bos.write(buffer, <span class="number">0</span> , len);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;使用缓冲的字节流按照一个一个字节数组的形式复制文件耗时：&quot;</span> + (endTime - startTime)/<span class="number">1000.0</span> + <span class="string">&quot;s&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//（3）使用高级的缓冲字节流按照一个一个字节的形式复制文件。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copy03</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">// 1、创建低级的字节输入流与源文件接通</span></span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(SRC_FILE);</span><br><span class="line">                <span class="comment">// a.把原始的字节输入流包装成高级的缓冲字节输入流</span></span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(is);</span><br><span class="line">                <span class="comment">// 2、创建低级的字节输出流与目标文件接通</span></span><br><span class="line">                <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(DEST_FILE + <span class="string">&quot;video3.avi&quot;</span>);</span><br><span class="line">                <span class="comment">// b.把字节输出流管道包装成高级的缓冲字节输出流管道</span></span><br><span class="line">                <span class="type">OutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(os);</span><br><span class="line">        )&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3、定义一个变量记录每次读取的字节（一个一个字节的复制）</span></span><br><span class="line">            <span class="type">int</span> b;</span><br><span class="line">            <span class="keyword">while</span> ((b = bis.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">                bos.write(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;使用缓冲的字节流按照一个一个字节的形式复制文件耗时：&quot;</span> + (endTime - startTime)/<span class="number">1000.0</span> + <span class="string">&quot;s&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//（2）使用低级的字节流按照一个一个字节数组的形式复制文件。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copy02</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">// 这里面只能放置资源对象，用完会自动关闭：自动调用资源对象的close方法关闭资源（即使出现异常也会做关闭操作）</span></span><br><span class="line">                <span class="comment">// 1、创建一个字节输入流管道与原视频接通</span></span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(SRC_FILE);</span><br><span class="line">                <span class="comment">// 2、创建一个字节输出流管道与目标文件接通</span></span><br><span class="line">                <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(DEST_FILE + <span class="string">&quot;video2.avi&quot;</span>)</span><br><span class="line">        ) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3、定义一个字节数组转移数据</span></span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> len; <span class="comment">// 记录每次读取的字节数。</span></span><br><span class="line">            <span class="keyword">while</span> ((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                os.write(buffer, <span class="number">0</span> , len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;使用低级的字节流按照一个一个字节数组的形式复制文件耗时：&quot;</span> + (endTime - startTime)/<span class="number">1000.0</span> + <span class="string">&quot;s&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//（1）使用低级的字节流按照一个一个字节的形式复制文件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copy01</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">// 1、创建低级的字节输入流与源文件接通</span></span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(SRC_FILE);</span><br><span class="line">                <span class="comment">// 2、创建低级的字节输出流与目标文件接通</span></span><br><span class="line">                <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(DEST_FILE + <span class="string">&quot;video1.avi&quot;</span>)</span><br><span class="line">                )&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3、定义一个变量记录每次读取的字节（一个一个字节的复制）</span></span><br><span class="line">            <span class="type">int</span> b;</span><br><span class="line">            <span class="keyword">while</span> ((b = is.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">                os.write(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;使用低级的字节流按照一个一个字节的形式复制文件耗时：&quot;</span> + (endTime - startTime)/<span class="number">1000.0</span> + <span class="string">&quot;s&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>推荐使用哪种方式提高字节流读写数据的性能？</p><ul><li><strong>建议使用字节缓冲输入流、字节缓冲输出流，结合字节数组的方式，目前来看是性能最优的组合。</strong></li></ul><h4 id="1-4字符缓冲流"><a href="#1-4字符缓冲流" class="headerlink" title="1.4字符缓冲流"></a>1.4字符缓冲流</h4><p><strong>字符缓冲输入流</strong></p><ul><li><p>字符缓冲输入流：BufferedReader。</p></li><li><p>作用：提高字符输入流读取数据的性能，除此之外多了按照行读取数据的功能。</p></li></ul><p><strong>字符缓冲输出流</strong></p><ul><li><p>字符缓冲输出流：BufferedWriter。</p></li><li><p>作用：提高字符输出流写取数据的性能，除此之外多了换行功能</p></li></ul><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public  <strong>BufferedReader</strong>(Reader r)</td><td>可以把低级的字符输入流包装成一个高级的<strong>缓冲字符输入流</strong>管道，从而提高字符输入流读数据的性能</td></tr><tr><td>public <strong>BufferedWriter</strong>(Writer  w)</td><td>可以把低级的字符输出流包装成一个高级的<strong>缓冲字符输出流</strong>管道，从而提高字符输出流写数据的性能</td></tr></tbody></table><p><strong>字符缓冲输入流新增功能</strong></p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public  String <strong>readLine</strong>()</td><td>读取一行数据返回，如果读取没有完毕，无行可读返回null</td></tr></tbody></table><p><strong>字符缓冲输出流新增功能</strong></p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public  void <strong>newLine</strong>()</td><td>换行操作</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：学会使用缓冲字符输入流提高字符输入流的性能，新增了按照行读取的方法(经典代码)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedReaderDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">// 1、创建一个文件字符输入流与源文件接通。</span></span><br><span class="line">                <span class="type">Reader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;io-app2/src/data01.txt&quot;</span>);</span><br><span class="line">                <span class="comment">// a、把低级的字符输入流包装成高级的缓冲字符输入流。</span></span><br><span class="line">                <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(fr);</span><br><span class="line">                )&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2、用循环，每次读取一个字符数组的数据。  1024 + 1024 + 8</span></span><br><span class="line"><span class="comment">//            char[] buffer = new char[1024]; // 1K字符</span></span><br><span class="line"><span class="comment">//            int len;</span></span><br><span class="line"><span class="comment">//            while ((len = br.read(buffer)) != -1) &#123;</span></span><br><span class="line"><span class="comment">//                String rs = new String(buffer, 0, len);</span></span><br><span class="line"><span class="comment">//                System.out.print(rs);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"></span><br><span class="line">              String line;</span><br><span class="line">              <span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">                  System.out.println(line);</span><br><span class="line">              &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     目标：缓冲字符输出流的使用，学会它多出来的一个功能：newLine();</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedWriterDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建一个字符输出流管道与目标文件接通</span></span><br><span class="line">        <span class="type">Writer</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;io-app2/src/out02.txt&quot;</span>); <span class="comment">// 覆盖管道，每次启动都会清空文件之前的数据</span></span><br><span class="line">       <span class="comment">//Writer fw = new FileWriter(&quot;io-app2/src/out02.txt&quot;, true); // 追加数据</span></span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(fw);</span><br><span class="line"></span><br><span class="line"><span class="comment">//      a.public void write(int c):写一个字符出去</span></span><br><span class="line">        bw.write(<span class="number">98</span>);</span><br><span class="line">        bw.write(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        bw.write(<span class="string">&#x27;徐&#x27;</span>); <span class="comment">// 不会出问题了</span></span><br><span class="line">        bw.newLine(); <span class="comment">// bw.write(&quot;\r\n&quot;); // 换行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//       b.public void write(String c)写一个字符串出去</span></span><br><span class="line">        bw.write(<span class="string">&quot;abc我是中国人&quot;</span>);</span><br><span class="line">        bw.newLine(); <span class="comment">// bw.write(&quot;\r\n&quot;); // 换行</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//       c.public void write(char[] buffer):写一个字符数组出去</span></span><br><span class="line">        <span class="type">char</span>[] chars = <span class="string">&quot;abc我是中国人&quot;</span>.toCharArray();</span><br><span class="line">        bw.write(chars);</span><br><span class="line">        bw.newLine(); <span class="comment">// bw.write(&quot;\r\n&quot;); // 换行</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//       d.public void write(String c ,int pos ,int len):写字符串的一部分出去</span></span><br><span class="line">        bw.write(<span class="string">&quot;abc我是中国人&quot;</span>, <span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">        bw.newLine(); <span class="comment">// bw.write(&quot;\r\n&quot;); // 换行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//       e.public void write(char[] buffer ,int pos ,int len):写字符数组的一部分出去</span></span><br><span class="line">        bw.write(chars, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">        bw.newLine(); <span class="comment">// bw.write(&quot;\r\n&quot;); // 换行</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// fw.flush();// 刷新后流可以继续使用</span></span><br><span class="line">        bw.close(); <span class="comment">// 关闭包含刷线，关闭后流不能使用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.字符缓冲流为什么提高了操作数据的性能？</p><ul><li><p><strong>字符缓冲流自带8k缓冲区</strong></p></li><li><p><strong>可以提高原始字符流读写数据的性能</strong></p></li></ul><p>2.字符缓冲流的功能如何使用？</p><ul><li><p><strong>public BufferedReader(Reader r)</strong></p><p><strong>性能提升了, 多了readLine()  按照行读取的功能</strong></p></li><li><p><strong>public BufferedWriter(Writer w)</strong></p><p><strong>性能提升了, 多了newLine()  换行的功能</strong></p></li></ul><p><strong>案例：</strong></p><p>拷贝出师表到另一个文件，恢复顺序</p><p>需求：</p><p>把《出师表》的文章顺序进行恢复到一个新文件中。</p><p>分析：</p><p>①定义一个缓存字符输入流管道与源文件接通。</p><p>②定义一个List集合存储读取的每行数据。</p><p>③定义一个循环按照行读取数据，存入到List集合中去。</p><p>④对List集合中的每行数据按照首字符编号升序排序。</p><p>⑤定义一个缓存字符输出管道与目标文件接通。</p><p>⑥遍历List集合中的每个元素，用缓冲输出管道写出并换行。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   目标：完成出师表顺序的恢复，并存入到另一个新文件中去。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedCharTest3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>(</span><br><span class="line">                <span class="comment">// 1、创建缓冲字符输入流管道与源文件接通</span></span><br><span class="line">                <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;io-app2/src/csb.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 5、定义缓冲字符输出管道与目标文件接通</span></span><br><span class="line">                <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;io-app2/src/new.txt&quot;</span>));</span><br><span class="line">                ) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2、定义一个List集合存储每行内容</span></span><br><span class="line">            List&lt;String&gt; data = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="comment">// 3、定义循环，按照行读取文章</span></span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">                data.add(line);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(data);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4、排序</span></span><br><span class="line">            <span class="comment">// 自定义排序规则</span></span><br><span class="line">            List&lt;String&gt; sizes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            Collections.addAll(sizes, <span class="string">&quot;一&quot;</span>,<span class="string">&quot;二&quot;</span>,<span class="string">&quot;三&quot;</span>,<span class="string">&quot;四&quot;</span>,<span class="string">&quot;五&quot;</span>,<span class="string">&quot;陆&quot;</span>,<span class="string">&quot;柒&quot;</span>,<span class="string">&quot;八&quot;</span>,<span class="string">&quot;九&quot;</span>,<span class="string">&quot;十&quot;</span>,<span class="string">&quot;十一&quot;</span>);</span><br><span class="line"></span><br><span class="line">            Collections.sort(data, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String o1, String o2)</span> &#123;</span><br><span class="line">                    <span class="comment">// o1   八.,....</span></span><br><span class="line">                    <span class="comment">// o2   柒.,....</span></span><br><span class="line">                    <span class="keyword">return</span> sizes.indexOf(o1.substring(<span class="number">0</span>, o1.indexOf(<span class="string">&quot;.&quot;</span>)))</span><br><span class="line">                            - sizes.indexOf(o2.substring(<span class="number">0</span>, o2.indexOf(<span class="string">&quot;.&quot;</span>)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            System.out.println(data);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 6、遍历集合中的每行文章写出去，且要换行</span></span><br><span class="line">            <span class="keyword">for</span> (String datum : data) &#123;</span><br><span class="line">                bw.write(datum);</span><br><span class="line">                bw.newLine(); <span class="comment">// 换行</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-转换"><a href="#2-转换" class="headerlink" title="2.转换"></a>2.转换</h3><h4 id="2-1问题引出：不同编码读取乱码问题"><a href="#2-1问题引出：不同编码读取乱码问题" class="headerlink" title="2.1问题引出：不同编码读取乱码问题"></a>2.1问题引出：不同编码读取乱码问题</h4><p>1、之前我们使用字符流读取中文是否有乱码？</p><ul><li><strong>没有的，因为代码编码和文件编码都是UTF-8。</strong></li></ul><p>2、如果代码编码和文件编码不一致，使用字符流直接读取还能不乱码吗？</p><ul><li><p><strong>会乱码。</strong></p></li><li><p><strong>文件编码和读取的编码必须一致才不会乱码。</strong></p></li></ul><p><strong>使用相同编码读取不同编码的文件内容</strong></p><p>需求：</p><p>分别使用如下两种方式读取文件内容</p><p>①代码编码是UTF-8，文件编码也是UTF-8，使用字符流读取观察输出的中文字符结果。</p><p>②代码编码是UTF-8，文件编码使用GBK，使用字符流读取观察输出的中文字符结果</p><p><strong>结论：</strong></p><p>字符流直接读取文本内容。</p><ul><li><p><strong>必须文件和代码编码一致才不会乱码</strong></p></li><li><p><strong>如果文件和代码编码不一致，读取将出现乱码。</strong></p></li></ul><h4 id="2-2字符输入转换流"><a href="#2-2字符输入转换流" class="headerlink" title="2.2字符输入转换流"></a>2.2字符输入转换流</h4><p>1、如果代码编码和文件编码不一致，使用字符流直接读取还能不乱码吗？</p><ul><li><strong>会乱码。</strong></li></ul><p>2、如果如何解决呢？</p><ul><li><p><strong>使用字符输入转换流</strong></p></li><li><p><strong>可以提取文件（GBK）的原始字节流，原始字节不会存在问题。</strong></p></li><li><p><strong>然后把字节流以指定编码转换成字符输入流，这样字符输入流中的字符就不乱码了</strong></p></li></ul><p><strong>字符输入转换流</strong></p><ul><li>字符输入转换流：<strong>InputStreamReader</strong>，可以把原始的字节流按照指定编码转换成字符输入流。</li></ul><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public InputStreamReader(InputStream is)</td><td>可以把原始的字节流按照代码默认编码转换成字符输入流。几乎不用，与默认的FileReader一样。</td></tr><tr><td>public InputStreamReader(InputStream is ，String charset)</td><td>可以把原始的字节流按照指定编码转换成字符输入流，这样字符流中的字符就不乱码了(重点)</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     目标：字符输入转换流InputStreamReader的使用。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     作用：可以解决字符流读取不同编码乱码的问题。</span></span><br><span class="line"><span class="comment">          也可以把原始的字节流按照指定编码转换成字符输入流</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     小结：</span></span><br><span class="line"><span class="comment">        字符输入转换流InputStreamReader:作用：可以解决字符流读取不同编码乱码的问题。</span></span><br><span class="line"><span class="comment">        public InputStreamReader(InputStream is,String charset):可以指定编码把字节流转换成字符流(核心)</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InputStreamReaderDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 代码UTF-8   文件 GBK  &quot;D:\\resources\\data.txt&quot;</span></span><br><span class="line">        <span class="comment">// 1、提取GBK文件的原始字节流。   abc 我</span></span><br><span class="line">        <span class="comment">//                            ooo oo</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\\resources\\data.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 2、把原始字节流转换成字符输入流</span></span><br><span class="line">        <span class="comment">// Reader isr = new InputStreamReader(is); // 默认以UTF-8的方式转换成字符流。 还是会乱码的  跟直接使用FileReader是一样的</span></span><br><span class="line">        <span class="type">Reader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is , <span class="string">&quot;GBK&quot;</span>); <span class="comment">// 以指定的GBK编码转换成字符输入流  完美的解决了乱码问题</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、把低级的字符输入流包装成高级的缓冲字符输入流。</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(isr);</span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3字符输出转换流"><a href="#2-3字符输出转换流" class="headerlink" title="2.3字符输出转换流"></a>2.3字符输出转换流</h4><p>1、如果需要控制写出去的字符使用的编码，怎么办？</p><ul><li><p><strong>可以把字符以指定编码获取字节后再使用字节输出流写出去：</strong></p><p><strong>“我爱你中国”.getBytes(编码)</strong></p></li><li><p><strong>也可以使用字符输出转换流实现。</strong></p></li></ul><p><strong>字符输出转换流</strong></p><ul><li>字符输入转换流：<strong>OutputStreamWriter</strong>，可以把字节输出流按照指定编码转换成字符输出流。</li></ul><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public OutputStreamWriter(OutputStream os)</td><td>可以把原始的字节输出流按照代码默认编码转换成字符输出流。几乎不用。</td></tr><tr><td>public OutputStreamWriter(OutputStream os，String  charset)</td><td>可以把原始的字节输出流按照指定编码转换成字符输出流(重点)</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     目标：字符输出转换OutputStreamWriter流的使用。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     作用：可以指定编码把字节输出流转换成字符输出流。</span></span><br><span class="line"><span class="comment">                   可以指定写出去的字符的编码。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     小结：</span></span><br><span class="line"><span class="comment">        字符输出转换流OutputStreamWriter可以指定编码把字节输出流转换成字符输出流。</span></span><br><span class="line"><span class="comment">        从而实现指定写出去的字符编码！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OutputStreamWriterDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、定义一个字节输出流</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;io-app2/src/out03.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、把原始的字节输出流转换成字符输出流</span></span><br><span class="line">        <span class="comment">// Writer osw = new OutputStreamWriter(os); // 以默认的UTF-8写字符出去 跟直接写FileWriter一样</span></span><br><span class="line">        <span class="type">Writer</span> <span class="variable">osw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(os , <span class="string">&quot;GBK&quot;</span>); <span class="comment">// 指定GBK的方式写字符出去</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、把低级的字符输出流包装成高级的缓冲字符输出流。</span></span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(osw);</span><br><span class="line"></span><br><span class="line">        bw.write(<span class="string">&quot;我爱中国1~~&quot;</span>);</span><br><span class="line">        bw.write(<span class="string">&quot;我爱中国2~~&quot;</span>);</span><br><span class="line">        bw.write(<span class="string">&quot;我爱中国3~~&quot;</span>);</span><br><span class="line"></span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-序列化对象"><a href="#3-序列化对象" class="headerlink" title="3.序列化对象"></a>3.序列化对象</h3><h4 id="3-1对象序列化"><a href="#3-1对象序列化" class="headerlink" title="3.1对象序列化"></a>3.1对象序列化</h4><p><strong>对象序列化：</strong></p><ul><li><p>作用：以内存为基准，把内存中的对象存储到磁盘文件中去，称为对象序列化。</p></li><li><p><strong>使用到的流是对象字节输出流：ObjectOutputStream</strong></p></li></ul><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public <strong>ObjectOutputStream</strong>(OutputStream  out)</td><td>把低级字节输出流包装成高级的对象字节输出流</td></tr></tbody></table><p><strong>ObjectOutputStream序列化方法</strong></p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>public final void <strong>writeObject</strong>(Object obj)</td><td>把对象写出去到对象序列化流的文件中去</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     目标：学会对象序列化，使用 ObjectOutputStream 把内存中的对象存入到磁盘文件中。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> 注意：对象如果要序列化，必须实现Serializable序列化接口。</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> 拓展知识：1.transient修饰的成员变量不参与序列化了</span></span><br><span class="line"><span class="comment">             2.申明序列化的版本号码，序列化的版本号与反序列化的版本号必须一致才不会出错！</span></span><br><span class="line"><span class="comment">     private static final long serialVersionUID = 1;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectOutputStreamDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建学生对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;陈磊&quot;</span>, <span class="string">&quot;chenlei&quot;</span>,<span class="string">&quot;1314520&quot;</span>, <span class="number">21</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、对象序列化：使用对象字节输出流包装字节输出流管道</span></span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;io-app2/src/obj.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、直接调用序列化方法</span></span><br><span class="line">        oos.writeObject(s);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、释放资源</span></span><br><span class="line">        oos.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;序列化完成了~~&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>创建学生对象，(注意：实现Serializable序列化接口)。</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  对象如果要序列化，必须实现Serializable序列化接口。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;  <span class="comment">//Serializable接口</span></span><br><span class="line">    <span class="comment">// 序列化的版本号与反序列化的版本号必须一致才不会出错！</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1</span>;  <span class="comment">// 申明序列化的版本号码</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String loginName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String passWord;  <span class="comment">// transient修饰的成员变量不参与序列化了，反序列化结果为null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, String loginName, String passWord, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.loginName = loginName;</span><br><span class="line">        <span class="built_in">this</span>.passWord = passWord;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getLoginName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> loginName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLoginName</span><span class="params">(String loginName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.loginName = loginName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPassWord</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> passWord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPassWord</span><span class="params">(String passWord)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.passWord = passWord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, loginName=&#x27;&quot;</span> + loginName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, passWord=&#x27;&quot;</span> + passWord + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p><strong>对象如果要序列化，必须实现Serializable序列化接口。</strong></p><p><strong>拓展知识：</strong></p><p><strong>1. transient修饰的成员变量不参与序列化了</strong></p><p>​ <strong>private transient String passWord;</strong></p><p><strong>2. 申明序列化的版本号码，序列化的版本号与反序列化的版本号必须一致才不会出错！</strong></p><pre><code> **private static final long serialVersionUID = 1;**</code></pre><h4 id="3-2对象反序列化"><a href="#3-2对象反序列化" class="headerlink" title="3.2对象反序列化"></a>3.2对象反序列化</h4><p><strong>对象反序列化：</strong></p><ul><li><p><strong>使用到的流是对象字节输入流：ObjectInputStream</strong></p></li><li><p>作用：以内存为基准，<strong>把存储到磁盘文件中去的对象数据恢复成内存中的对象</strong>，称为对象反序列化。</p></li></ul><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public <strong>ObjectInputStream</strong>(InputStream  out)</td><td>把低级字节输如流包装成高级的对象字节输入流</td></tr></tbody></table><p><strong>ObjectInputStream序列化方法</strong></p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>public  Object <strong>readObject</strong>()</td><td>把存储到磁盘文件中去的对象数据恢复成内存中的对象返回</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：学会进行对象反序列化：使用对象字节输入流把文件中的对象数据恢复成内存中的Java对象。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectInputStreamDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建对象字节输入流管道包装低级的字节输入流管道</span></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;io-app2/src/obj.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、调用对象字节输入流的反序列化方法</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> (Student) is.readObject();</span><br><span class="line"></span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-打印流"><a href="#4-打印流" class="headerlink" title="4.打印流"></a>4.打印流</h3><h4 id="4-1PrintStream、PrintWriter"><a href="#4-1PrintStream、PrintWriter" class="headerlink" title="4.1PrintStream、PrintWriter"></a>4.1PrintStream、PrintWriter</h4><p><strong>打印流</strong></p><ul><li><p>作用：打印流可以实现方便、高效的打印数据到文件中去。打印流一般是指：PrintStream，PrintWriter两个类。</p></li><li><p>可以实现打印什么数据就是什么数据，例如打印整数97写出去就是97，打印boolean的true，写出去就是true。</p></li></ul><p><strong>PrintStream</strong></p><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public PrintStream(OutputStream os)</td><td>打印流直接通向字节输出流管道</td></tr><tr><td>public PrintStream(File f)</td><td>打印流直接通向文件对象</td></tr><tr><td>public PrintStream(String filepath)</td><td>打印流直接通向文件路径</td></tr></tbody></table><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public void print(Xxx  xx)</td><td>打印任意类型的数据出去</td></tr></tbody></table><p><strong>PrintWriter</strong></p><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public PrintWriter(OutputStream os)</td><td>打印流直接通向字节输出流管道</td></tr><tr><td>public PrintWriter (Writer w)</td><td>打印流直接通向字符输出流管道</td></tr><tr><td>public PrintWriter (File f)</td><td>打印流直接通向文件对象</td></tr><tr><td>public PrintWriter (String filepath)</td><td>打印流直接通向文件路径</td></tr></tbody></table><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public void print(Xxx  xx)</td><td>打印任意类型的数据出去</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：学会使用打印流 高效 方便 写数据到文件。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建一个打印流对象</span></span><br><span class="line"><span class="comment">//        PrintStream ps = new PrintStream(new FileOutputStream(&quot;io-app2/src/ps.txt&quot;));</span></span><br><span class="line"><span class="comment">//        PrintStream ps = new PrintStream(new FileOutputStream(&quot;io-app2/src/ps.txt&quot; , true)); // 追加数据，在低级管道后面加True</span></span><br><span class="line"><span class="comment">//        PrintStream ps = new PrintStream(&quot;io-app2/src/ps.txt&quot; ); // PrintStream简化写法 </span></span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="string">&quot;io-app2/src/ps.txt&quot;</span>); <span class="comment">// 打印功能上与PrintStream的使用没有区别</span></span><br><span class="line"></span><br><span class="line">        ps.println(<span class="number">97</span>);</span><br><span class="line">        ps.println(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        ps.println(<span class="number">23.3</span>);</span><br><span class="line">        ps.println(<span class="literal">true</span>);</span><br><span class="line">        ps.println(<span class="string">&quot;我是打印流输出的，我是啥就打印啥&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ps.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>PrintStream和PrintWriter的区别</strong></p><ul><li><p>打印数据功能上是一模一样的，都是使用方便，性能高效（核心优势）</p></li><li><p>PrintStream继承自字节输出流OutputStream，支持写字节。</p></li><li><p>PrintWriter继承自字符输出流Writer，支持写字符数。</p></li></ul><h4 id="4-2输出语句的重定向"><a href="#4-2输出语句的重定向" class="headerlink" title="4.2输出语句的重定向"></a>4.2输出语句的重定向</h4><p><strong>输出语句重定向</strong></p><ul><li>属于打印流的一种应用，可以把输出语句的打印位置改到文件。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="string">&quot;文件地址&quot;</span>)</span><br><span class="line">System.setOut(ps);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：了解**PrintStream**改变输出语句的位置到文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 默认打印控制台 (默认)</span></span><br><span class="line">        System.out.println(<span class="string">&quot;锦瑟无端五十弦&quot;</span>); </span><br><span class="line">        System.out.println(<span class="string">&quot;一弦一柱思华年&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 改变输出语句的位置(重定向)</span></span><br><span class="line">        <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="string">&quot;io-app2/src/log.txt&quot;</span>); <span class="comment">//将打印位置改为io-app2/src/log.txt</span></span><br><span class="line">        System.setOut(ps); <span class="comment">// 把系统默认打印流改成我们自己的打印流</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;庄生晓梦迷蝴蝶&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;望帝春心托杜鹃&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-补充知识：Properties"><a href="#5-补充知识：Properties" class="headerlink" title="5.补充知识：Properties"></a>5.补充知识：Properties</h3><p><strong>Properties属性集对象</strong></p><ul><li>其实就是一个Map集合，但是我们一般不会当集合使用，因为HashMap更好用。</li></ul><p><strong>Properties核心作用：</strong></p><ul><li><p><strong>Properties代表的是一个属性文件</strong>，可以把自己对象中的键值对信息存入到一个属性文件中去。</p><p>void store((Writer writer), String comments)</p></li><li><p><strong>属性文件：后缀是.properties结尾的文件</strong>,里面的内容都是 key&#x3D;value，后续做系统配置信息的。</p></li><li><p>可以加载属性文件中的数据到Properties对象中来：</p><p>void load(Reader reader)</p></li></ul><p><strong>Properties的API:</strong></p><ul><li>Properties和IO流结合的方法：</li></ul><table><thead><tr><th><strong>构造器</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>public  Object <strong>setProperty</strong>(String key, String value)</td><td>保存键值对（put）</td></tr><tr><td>void  <strong>load</strong>(InputStream inStream)</td><td>从输入字节流读取属性列表（键和元素对）</td></tr><tr><td>void  load(Reader reader)</td><td>从输入字符流读取属性列表（键和元素对）</td></tr><tr><td>void  <strong>store</strong>((OutputStream out), String comments)</td><td>将此属性列表（键和元素对）写入此  Properties表中，以适合于使用  load(InputStream)方法的格式写入输出字节流</td></tr><tr><td>void  store((Writer writer), String comments)</td><td>将此属性列表（键和元素对）写入此  Properties表中，以适合使用  load(Reader)方法的格式写入输出字符流</td></tr><tr><td>public  String <strong>getProperty</strong>(String key)</td><td>使用此属性列表中指定的<strong>键搜索属性值</strong>  (get)</td></tr><tr><td>public  Set<String> <strong>stringPropertyNames</strong>()</td><td><strong>所有键的名称</strong>的集合  (keySet())</td></tr></tbody></table><p><strong>代码1：使用Properties对象生成一个属性文件(setProperty，store)</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     目标：Properties的概述和使用(框架底层使用，了解这个技术即可)（保存数据到属性文件）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     需求：使用Properties对象生成一个属性文件，里面存入用户名和密码信息。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     小结：Properties可以保存键值对数据到属性文件</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PropertiesDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 需求：使用Properties把键值对信息存入到属性文件中去。</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        properties.setProperty(<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;dlei&quot;</span>, <span class="string">&quot;003197&quot;</span>);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;heima&quot;</span>, <span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">        System.out.println(properties);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">           参数一：保存管道 字符输出流管道</span></span><br><span class="line"><span class="comment">           参数二：保存心得</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        properties.store(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;io-app2/src/users.properties&quot;</span>), <span class="string">&quot;i am very happy!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码2：使用Properties的方法</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：Properties读取属性文件中的键值对信息。（读取）</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    小结：</span></span><br><span class="line"><span class="comment">        属性集对象可以加载读取属性文件中的数据!!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PropertiesDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 需求：Properties读取属性文件中的键值对信息。（读取）</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        System.out.println(properties); <span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加载属性文件中的键值对数据到属性对象properties中去</span></span><br><span class="line">        properties.load(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;io-app2/src/users.properties&quot;</span>));</span><br><span class="line">        System.out.println(properties); <span class="comment">// 所有键值对信息</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;dlei&quot;</span>); </span><br><span class="line">        System.out.println(rs); <span class="comment">// 003194</span></span><br><span class="line">        </span><br><span class="line">        Set&lt;String&gt; sw = properties.stringPropertyNames();</span><br><span class="line">        System.out.println(sw); <span class="comment">// &#123;&quot;admin&quot;,&quot;dlei&quot;,&quot;heima&quot;&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>案例：</strong></p><p>拷贝文件夹</p><p>需求：</p><p>将某个磁盘的文件夹拷贝到另一个文件夹下去，包括文件夹中的全部信息</p><p>分析：</p><p>①：IO默认不可以拷贝文件夹</p><p>②：我们需要遍历文件夹，如果是文件则拷贝过去，如果是文件夹则要进行1-1创建，再递归。</p><h3 id="6-补充知识：IO框架"><a href="#6-补充知识：IO框架" class="headerlink" title="6.补充知识：IO框架"></a>6.补充知识：IO框架</h3><p><strong>commons-io概述</strong></p><ul><li><p>commons-io是apache开源基金组织提供的一组有关IO操作的类库，可以提高IO功能开发的效率。</p></li><li><p>commons-io工具包提供了很多有关io操作的类。有两个主要的类FileUtils, IOUtils</p></li></ul><p><strong>步骤：导入commons-io-2.6.jar做开发</strong></p><p><strong>需求</strong></p><ul><li>使用commons-io简化io流读写</li></ul><p><strong>分析</strong></p><p>①在项目中创建一个文件夹：lib</p><p>②将commons-io-2.6.jar文件复制到lib文件夹</p><p>③在jar文件上点右键，选择 Add as Library -&gt; 点击OK</p><p>④在类中导包使用</p><p><strong>FileUtils主要有如下方法:</strong></p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>String  readFileToString(File  file, String encoding)</td><td>读取文件中的数据, 返回字符串</td></tr><tr><td>void  copyFile(File  srcFile, File destFile)</td><td>复制文件。</td></tr><tr><td>void  copyDirectoryToDirectory(File  srcDir,  File destDir)</td><td>复制文件夹。</td></tr></tbody></table><p><strong>commons-io 的API文档：  <a href="C:\Users\廖永森\Desktop\JavaSE\day20、IO流二\资料\5-类库\commons-io-2.11.0\docs\index.html">index.html</a></strong> </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标:Commons-io包的使用介绍。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    见下表：</span></span><br><span class="line"><span class="comment">         | 包                                  | 功能描述                                     |</span></span><br><span class="line"><span class="comment">         | ----------------------------------- | :------------------------------------------- |</span></span><br><span class="line"><span class="comment">         | org.apache.commons.io               | 有关Streams、Readers、Writers、Files的工具类 |</span></span><br><span class="line"><span class="comment">         | org.apache.commons.io.input         | 输入流相关的实现类，包含Reader和InputStream  |</span></span><br><span class="line"><span class="comment">         | org.apache.commons.io.output        | 输出流相关的实现类，包含Writer和OutputStream |</span></span><br><span class="line"><span class="comment">         | org.apache.commons.io.serialization | 序列化相关的类</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    小结：</span></span><br><span class="line"><span class="comment">         IOUtils和FileUtils可以方便的复制文件和文件夹！！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonsIODemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">////        // 1.完成文件复制！</span></span><br><span class="line"><span class="comment">//        IOUtils.copy(new FileInputStream(&quot;D:\\resources\\hushui.jpeg&quot;),</span></span><br><span class="line"><span class="comment">//                new FileOutputStream(&quot;D:\\resources\\hushui2.jpeg&quot;));</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">////        // 2.完成文件复制到某个文件夹下！</span></span><br><span class="line"><span class="comment">//        FileUtils.copyFileToDirectory(new File(&quot;D:\\resources\\hushui.jpeg&quot;), new File(&quot;D:/&quot;));</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">          <span class="comment">// 3.完成文件夹复制到某个文件夹下！</span></span><br><span class="line"><span class="comment">//          FileUtils.copyDirectoryToDirectory(new File(&quot;D:\\resources&quot;) , new File(&quot;D:\\new&quot;));</span></span><br><span class="line"><span class="comment">//           FileUtils.deleteDirectory(new File(&quot;D:\\new&quot;));</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">// JDK1.7 自己也做了一些一行代码完成复制的操作:New IO的技术</span></span><br><span class="line">         <span class="comment">// Files.copy(Path.of(&quot;D:\\resources\\hushui.jpeg&quot;), Path.of(&quot;D:\\resources\\hushui3.jpeg&quot;));</span></span><br><span class="line"></span><br><span class="line">        FileUtils.deleteDirectory(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\new&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> java,面向对象进阶,IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>day18 - File、递归、IO一</title>
      <link href="/post/2edfce22.html"/>
      <url>/post/2edfce22.html</url>
      
        <content type="html"><![CDATA[<p><strong>1、目前是怎么样存储数据的？弊端是什么？</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> [] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><ul><li>在内存中存储的数据是用来处理、修改、运算的，不能长久保存。</li></ul><p><strong>2、计算机中，有没有一块硬件可以永久存储数据的？</strong></p><ul><li>磁盘中数据的形式就是文件，文件是数据的载体。</li></ul><p>1、先要定位文件</p><ul><li><p>File类可以定位文件：进行删除、获取文本本身信息等操作<strong>。</strong></p></li><li><p><strong>但是不能读写文件内容。</strong></p></li></ul><p>2、读写文件数据</p><ul><li>IO流技术可以对硬盘中的文件进行读写</li></ul><p>3、今日总体学习思路</p><ul><li><p><strong>先学会使用File类定位文件以及操作文件本身</strong></p></li><li><p><strong>然后学习IO流读写文件数据。</strong></p></li></ul><h3 id="1-File类概述"><a href="#1-File类概述" class="headerlink" title="1.File类概述"></a>1.File类概述</h3><p><strong>File类概述</strong></p><ul><li><p>File类在包java.io.File下、代表操作系统的文件对象（文件、文件夹）。</p></li><li><p>File类提供了诸如：定位文件，获取文件本身的信息、删除文件、创建文件（文件夹）等功能。</p></li></ul><p><strong>File类创建对象</strong></p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td><strong>public</strong> File(String  pathname)</td><td>根据文件路径创建文件对象</td></tr><tr><td><strong>public</strong> File(String  parent, String child)</td><td>从父路径名字符串和子路径名字符串创建文件对象</td></tr><tr><td><strong>public</strong> File(File parent, String child)</td><td>根据父路径对应文件对象和子路径名字符串创建文件对象</td></tr></tbody></table><ul><li><p>File对象可以定位文件和文件夹</p></li><li><p>File封装的对象仅仅是一个路径名，这个路径可以是存在的，也可以是不存在的。</p></li></ul><p><strong>绝对路径和相对路径</strong></p><ul><li>绝对路径：从盘符开始</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(“D:\\itheima\\a.txt”); </span><br></pre></td></tr></table></figure><ul><li>相对路径：不带盘符，默认直接到当前工程下的目录寻找文件。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(“模块名\\a.txt”);</span><br></pre></td></tr></table></figure><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1、创建File对象（指定了文件的路径）</span></span><br><span class="line"><span class="comment">// 路径写法：D:\\resources\\xueshan.jpeg</span></span><br><span class="line">        <span class="comment">// D:/resources/xueshan.jpeg</span></span><br><span class="line">        <span class="comment">// File.separator(转义的方法 = \\)</span></span><br><span class="line"><span class="comment">//      File f = new File(&quot;D:\\resources\\xueshan.jpeg&quot;);</span></span><br><span class="line"><span class="comment">//      File f = new File(&quot;D:/resources/xueshan.jpeg&quot;);</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:&quot;</span> + File.separator+<span class="string">&quot;resources&quot;</span>+ File.separator +<span class="string">&quot;xueshan.jpeg&quot;</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> f.length(); <span class="comment">// 是文件的字节大小</span></span><br><span class="line">        System.out.println(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、File创建对象，支持绝对路径 支持相对路径（重点）</span></span><br><span class="line"><span class="comment">// 绝对路径:从盘符开始</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\resources\\beauty.jpeg&quot;</span>); </span><br><span class="line">        System.out.println(f1.length());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 相对路径：一般定位模块中的文件的。 相对到工程下！！</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;file-io-app/src/data.txt&quot;</span>);</span><br><span class="line">        System.out.println(f2.length());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、File创建对象 ，可以是文件也可以是文件夹</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\resources&quot;</span>);</span><br><span class="line">        System.out.println(f3.exists()); <span class="comment">// 判断这个路径是否存在，这个文件夹存在否</span></span><br></pre></td></tr></table></figure><h3 id="2-File类的常用API"><a href="#2-File类的常用API" class="headerlink" title="2.File类的常用API"></a>2.File类的常用API</h3><h4 id="1-判断文件类型、获取文件信息"><a href="#1-判断文件类型、获取文件信息" class="headerlink" title="1.判断文件类型、获取文件信息"></a>1.判断文件类型、获取文件信息</h4><p><strong>File类的判断文件类型、获取文件信息功能</strong></p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>public  boolean isDirectory()</td><td>测试此抽象路径名表示的File是否为文件夹</td></tr><tr><td>public  boolean isFile()</td><td>测试此抽象路径名表示的File是否为文件</td></tr><tr><td>public  boolean  exists()</td><td>测试此抽象路径名表示的File是否存在</td></tr><tr><td>public  String getAbsolutePath()</td><td>返回此抽象路径名的绝对路径名字符串</td></tr><tr><td>public  String getPath()</td><td>将此抽象路径名转换为路径名字符串</td></tr><tr><td>public  String getName()</td><td>返回由此抽象路径名表示的文件或文件夹的名称</td></tr><tr><td>public  long lastModified()</td><td>返回文件最后修改的时间毫秒值</td></tr></tbody></table><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.绝对路径创建一个文件对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/resources/xueshan.jpeg&quot;</span>);</span><br><span class="line">        <span class="comment">// a.获取它的绝对路径。</span></span><br><span class="line">        System.out.println(f1.getAbsolutePath());</span><br><span class="line">        <span class="comment">// b.获取文件定义的时候使用的路径。</span></span><br><span class="line">        System.out.println(f1.getPath());</span><br><span class="line">        <span class="comment">// c.获取文件的名称：带后缀。</span></span><br><span class="line">        System.out.println(f1.getName()); <span class="comment">//xueshan.jpeg</span></span><br><span class="line">        <span class="comment">// d.获取文件的大小：字节个数。</span></span><br><span class="line">        System.out.println(f1.length()); <span class="comment">//字节大小</span></span><br><span class="line">        <span class="comment">// e.获取文件的最后修改时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> f1.lastModified();</span><br><span class="line">        System.out.println(<span class="string">&quot;最后修改时间：&quot;</span> + <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy/MM/dd HH:mm:ss&quot;</span>).format(time));</span><br><span class="line">        <span class="comment">// f、判断是否是文件</span></span><br><span class="line">        System.out.println(f1.isFile()); <span class="comment">// true</span></span><br><span class="line"><span class="comment">//判断是否是文件夹</span></span><br><span class="line">        System.out.println(f1.isDirectory()); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.相对路径创建一个文件对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;file-io-app\\src\\data.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// a.获取它的绝对路径。</span></span><br><span class="line">        System.out.println(f2.getAbsolutePath());</span><br><span class="line">        <span class="comment">// b.获取文件定义的时候使用的路径。</span></span><br><span class="line">        System.out.println(f2.getPath());</span><br><span class="line">        <span class="comment">// c.获取文件的名称：带后缀。</span></span><br><span class="line">        System.out.println(f2.getName());</span><br><span class="line">        <span class="comment">// d.获取文件的大小：字节个数。</span></span><br><span class="line">        System.out.println(f2.length()); <span class="comment">// 字节大小</span></span><br><span class="line">        <span class="comment">// e.获取文件的最后修改时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">time1</span> <span class="operator">=</span> f2.lastModified();</span><br><span class="line">        System.out.println(<span class="string">&quot;最后修改时间：&quot;</span> + <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy/MM/dd HH:mm:ss&quot;</span>).format(time1));</span><br><span class="line">        <span class="comment">// f、判断是否是文件</span></span><br><span class="line">        System.out.println(f2.isFile()); <span class="comment">// true</span></span><br><span class="line"><span class="comment">//判断是否是文件夹</span></span><br><span class="line">        System.out.println(f2.isDirectory()); <span class="comment">// false</span></span><br><span class="line"><span class="comment">//判断这个路径是否存在</span></span><br><span class="line">        System.out.println(f2.exists()); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/&quot;</span>);</span><br><span class="line">        System.out.println(file.isFile()); <span class="comment">// false</span></span><br><span class="line">        System.out.println(file.isDirectory()); <span class="comment">// true</span></span><br><span class="line">        System.out.println(file.exists()); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/aaa&quot;</span>);</span><br><span class="line">        System.out.println(file1.isFile()); <span class="comment">// false</span></span><br><span class="line">        System.out.println(file1.isDirectory()); <span class="comment">// false</span></span><br><span class="line">        System.out.println(file1.exists()); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h4 id="2-创建文件、删除文件功能"><a href="#2-创建文件、删除文件功能" class="headerlink" title="2.创建文件、删除文件功能"></a>2.创建文件、删除文件功能</h4><p><strong>File类创建文件的功能</strong></p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>public boolean createNewFile()</td><td>创建一个新的空的文件</td></tr><tr><td>public boolean mkdir()</td><td>只能创建一级文件夹</td></tr><tr><td>public boolean mkdirs()</td><td>可以创建多级文件夹</td></tr></tbody></table><p><strong>File类删除文件的功能</strong></p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>public  boolean delete()</td><td>删除由此抽象路径名表示的文件或空文件夹</td></tr></tbody></table><ul><li><p><strong>delete方法默认只能删除文件和空文件夹。</strong></p></li><li><p><strong>delete方法直接删除不走回收站</strong></p></li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.创建新文件，createNewFile,创建成功返回true ,反之 ,不需要这个，以后文件写出去的时候都会自动创建</span></span><br><span class="line"><span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;file-io-app\\src\\data.txt&quot;</span>);</span><br><span class="line">        System.out.println(f.createNewFile());</span><br><span class="line"></span><br><span class="line">        <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;file-io-app\\src\\data02.txt&quot;</span>);</span><br><span class="line">        System.out.println(f1.createNewFile()); <span class="comment">// （几乎不用的，因为以后文件都是自动创建的！）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// b.mkdir创建一级目录</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/resources/aaa&quot;</span>);</span><br><span class="line">        System.out.println(f2.mkdir());</span><br><span class="line"></span><br><span class="line"><span class="comment">// c.mkdirs创建多级目录(重点)</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/resources/ccc/ddd/eee/ffff&quot;</span>);</span><br><span class="line"><span class="comment">//System.out.println(f3.mkdir()); //mkdirs</span></span><br><span class="line">        System.out.println(f3.mkdirs()); <span class="comment">// 支持多级创建</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// d.删除文件或者空文件夹</span></span><br><span class="line">        System.out.println(f1.delete());</span><br><span class="line">        <span class="type">File</span> <span class="variable">f4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/resources/xueshan.jpeg&quot;</span>);</span><br><span class="line">        System.out.println(f4.delete()); <span class="comment">// 占用一样可以删除</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只能删除空文件夹,不能删除非空文件夹(多级文件夹).</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/resources/aaa&quot;</span>);</span><br><span class="line">        System.out.println(f5.delete()); </span><br></pre></td></tr></table></figure><h4 id="3-遍历文件夹"><a href="#3-遍历文件夹" class="headerlink" title="3.遍历文件夹"></a>3.遍历文件夹</h4><p><strong>File类的遍历功能</strong></p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>public String[] list()</td><td>获取当前目录下所有的”一级文件名称”到一个字符串数组中去返回。</td></tr><tr><td>public File[] listFiles()(常用)</td><td>获取当前目录下所有的”一级文件对象”到一个文件对象数组中去返回（重点）</td></tr></tbody></table><p><strong>listFiles方法注意事项：</strong></p><ul><li><p>当调用者不存在时，返回null</p></li><li><p>当调用者是一个文件时，返回null</p></li><li><p>当调用者是一个空文件夹时，返回一个长度为0的数组</p></li><li><p>当调用者是一个有内容的文件夹时，将里面所有文件和文件夹的路径放在File数组中返回</p></li><li><p>当调用者是一个有隐藏文件的文件夹时，将里面所有文件和文件夹的路径放在File数组中返回，包含隐藏内容</p></li><li><p>当调用者是一个需要权限才能进入的文件夹时，返回null</p></li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：File针对目录的遍历</span></span><br><span class="line"><span class="comment">    - public String[] list()：</span></span><br><span class="line"><span class="comment">         获取当前目录下所有的&quot;一级文件名称&quot;到一个字符串数组中去返回。</span></span><br><span class="line"><span class="comment">         </span></span><br><span class="line"><span class="comment">    - public File[] listFiles()(常用)：（重点）</span></span><br><span class="line"><span class="comment">         获取当前目录下所有的&quot;一级文件对象&quot;到一个文件对象数组中去返回</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、定位一个目录</span></span><br><span class="line"><span class="comment">//获取当前目录下所有的&quot;一级文件名称&quot;到一个字符串数组中去返回。</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/resources&quot;</span>);</span><br><span class="line">        String[] names = f1.list();</span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.一级文件对象</span></span><br><span class="line">        <span class="comment">// 获取当前目录下所有的&quot;一级文件对象&quot;到一个文件对象数组中去返回（重点）</span></span><br><span class="line"><span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/resources&quot;</span>);</span><br><span class="line">        File[] files = f1.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File f : files) &#123;</span><br><span class="line">            System.out.println(f.getAbsolutePath());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意事项</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">dir1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:/resources&quot;</span>); <span class="comment">//当调用者不存在时，返回null</span></span><br><span class="line"></span><br><span class="line"><span class="type">File</span> <span class="variable">dir2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/resources/xueshan&quot;</span>); <span class="comment">//当调用者是一个文件时，返回null</span></span><br><span class="line"></span><br><span class="line"><span class="type">File</span> <span class="variable">dir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/resources/ddd&quot;</span>); <span class="comment">//首先目录存在，当调用者是一个空文件夹时，返回一个长度为0的数组</span></span><br><span class="line">File[] fi = f1.listFiles();</span><br><span class="line">        System.out.println(Arrays.toString(fi)); <span class="comment">// [] </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-方法递归"><a href="#3-方法递归" class="headerlink" title="3.方法递归"></a>3.方法递归</h3><h4 id="3-1递归的形式和特点"><a href="#3-1递归的形式和特点" class="headerlink" title="3.1递归的形式和特点"></a>3.1递归的形式和特点</h4><p><strong>什么是方法递归?</strong></p><ul><li><p>方法直接调用自己或者间接调用自己的形式称为方法递归（ recursion）。</p></li><li><p>递归做为一种<a href="https://baike.baidu.com/item/%E7%AE%97%E6%B3%95">算法</a>在<a href="https://baike.baidu.com/item/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">程序设计语言</a>中广泛应用。</p></li></ul><p><strong>递归的形式</strong></p><ul><li><p>直接递归：方法自己调用自己。</p></li><li><p>间接递归：方法调用其他方法，其他方法又回调方法自己。</p></li></ul><p><strong>方法递归存在的问题？</strong></p><ul><li>递归如果没有控制好终止，会出现递归死循环，导致栈内存溢出现象。</li></ul><h4 id="3-2递归的算法流程、核心要素"><a href="#3-2递归的算法流程、核心要素" class="headerlink" title="3.2递归的算法流程、核心要素"></a>3.2递归的算法流程、核心要素</h4><p><strong>递归解决问题的思路：</strong></p><ul><li>把一个复杂的问题层层转化为一个<strong>与原问题相似的规模较小</strong>的问题来求解。</li></ul><p><strong>递归算法三要素大体可以总结为：</strong></p><ul><li><p><strong>递归的公式：</strong> <strong>f(n) &#x3D; f(n-1) * n</strong></p></li><li><p><strong>递归的终结点：f(1)</strong> </p></li><li><p><strong>递归的方向必须走向终结点：</strong></p></li></ul><h4 id="3-3递归常见案例"><a href="#3-3递归常见案例" class="headerlink" title="3.3递归常见案例"></a>3.3递归常见案例</h4><p><strong>递归案例导学-计算1-n的阶乘</strong></p><p><strong>需求：</strong></p><p>计算1-n的阶乘的结果，使用递归思想解决，我们先从数学思维上理解递归的流程和核心点。</p><p><strong>分析:</strong></p><p>①假如我们认为存在一个公式是 f(n) &#x3D; 1<em>2</em>3<em>4</em>5<em>6</em>7*…(n-1)*n;</p><p>②那么公式等价形式就是： f(n) &#x3D; f(n-1) *n</p><p>③如果求的是 1-5的阶乘 的结果，我们手工应该应该如何应用上述公式计算。</p><p>④f(5) &#x3D; f(4) * 5<br> f(4) &#x3D; f(3) * 4<br> f(3) &#x3D; f(2) * 3<br> f(2) &#x3D; f(1) * 2<br> f(1) &#x3D; 1</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">      目标：递归的算法和执行流程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RecursionDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(f(<span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> f(n - <span class="number">1</span>) * n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>递归案例导学-计算1–n的和</strong></p><p><strong>需求：</strong></p><p>计算1-n的和的结果，使用递归思想解决，我们先从数学思维上理解递归的流程和核心点。</p><p><strong>分析:</strong></p><p>①假如我们认为存在一个公式是 f(n) &#x3D; 1 + 2 + 3 + 4 + 5 + 6 + 7 + …(n-1) + n;</p><p>②那么公式等价形式就是： f(n) &#x3D; f(n-1) + n</p><p>③递归的终结点：f(1) &#x3D; 1</p><p>④如果求的是 1-5的和 的结果，应该如何计算。</p><p>⑤f(5) &#x3D; f(4)  + 5<br> f(4) &#x3D; f(3)  + 4<br> f(3) &#x3D; f(2)  + 3<br> f(2) &#x3D; f(1)  + 2<br> f(1) &#x3D; 1</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">      目标：1 - n求和</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RecursionDemo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(f(<span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> f(n - <span class="number">1</span>)  + n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-4递归的经典问题"><a href="#3-4递归的经典问题" class="headerlink" title="3.4递归的经典问题"></a>3.4递归的经典问题</h4><p><strong>猴子吃桃问题</strong></p><p>猴子第一天摘下若干桃子，当即吃了一半，觉得好不过瘾，于是又多吃了一个</p><p>第二天又吃了前天剩余桃子数量的一半，觉得好不过瘾，于是又多吃了一个</p><p>以后每天都是吃前天剩余桃子数量的一半，觉得好不过瘾，又多吃了一个</p><p>等到第10天的时候发现桃子只有1个了。</p><p>需求：请问猴子第一天摘了多少个桃子？</p><p><strong>分析：</strong></p><p>①整体来看，每一天都是做同一个事件，典型的规律化问题，考虑递归三要素：</p><p>②递归公式： </p><p>③递归终结点：</p><p>④递归方向：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     目标 猴子吃桃。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     公式（合理的）： f(x) - f(x)/2 - 1 = f(x+1)</span></span><br><span class="line"><span class="comment">                   2f(x) - f(x) - 2 = 2f(x + 1)</span></span><br><span class="line"><span class="comment">                   f(x) = 2f(x + 1) + 2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    求f(1) = ?</span></span><br><span class="line"><span class="comment">    终结点： f（10） = 1</span></span><br><span class="line"><span class="comment">    递归的方向：合理的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RecursionDemo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(f(<span class="number">1</span>));</span><br><span class="line">        System.out.println(f(<span class="number">2</span>));</span><br><span class="line">        System.out.println(f(<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">10</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span> * f(n + <span class="number">1</span>) + <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-5非规律化递归案例-文件搜索"><a href="#3-5非规律化递归案例-文件搜索" class="headerlink" title="3.5非规律化递归案例-文件搜索"></a>3.5非规律化递归案例-文件搜索</h4><p><strong>文件搜索：</strong></p><p><strong>需求：</strong></p><p>文件搜索、从C:盘中，搜索出某个文件名称并输出绝对路径。</p><p><strong>分析：</strong></p><p>①先定位出的应该是一级文件对象</p><p>②遍历全部一级文件对象，判断是否是文件</p><p>③如果是文件，判断是否是自己想要的</p><p>④如果是文件夹，需要继续递归进去重复上述过程</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：去D判断搜索 eDiary.exe文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RecursionDemo05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 2、传入目录 和  文件名称</span></span><br><span class="line">        searchFile(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/&quot;</span>) , <span class="string">&quot;eDiary.exe&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1、搜索某个目录下的全部文件，找到我们想要的文件。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dir  被搜索的源目录</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fileName 被搜索的文件名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">searchFile</span><span class="params">(File dir,String fileName)</span>&#123;</span><br><span class="line">        <span class="comment">// 3、判断dir是否是目录</span></span><br><span class="line">        <span class="keyword">if</span>(dir != <span class="literal">null</span> &amp;&amp; dir.isDirectory())&#123;</span><br><span class="line">            <span class="comment">// 可以找了</span></span><br><span class="line">            <span class="comment">// 4、提取当前目录下的一级文件对象</span></span><br><span class="line">            File[] files = dir.listFiles(); <span class="comment">// null  []</span></span><br><span class="line">            <span class="comment">// 5、判断是否存在一级文件对象，存在才可以遍历</span></span><br><span class="line">            <span class="keyword">if</span>(files != <span class="literal">null</span> &amp;&amp; files.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">                    <span class="comment">// 6、判断当前遍历的一级文件对象是文件 还是 目录</span></span><br><span class="line">                    <span class="keyword">if</span>(file.isFile())&#123;</span><br><span class="line">                        <span class="comment">// 7、是不是咱们要找的，是把其路径输出即可</span></span><br><span class="line">                        <span class="keyword">if</span>(file.getName().contains(fileName))&#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;找到了：&quot;</span> + file.getAbsolutePath());</span><br><span class="line">                            <span class="comment">// 启动它。</span></span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                <span class="type">Runtime</span> <span class="variable">r</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line">                                r.exec(file.getAbsolutePath());</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                                e.printStackTrace();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 8、是文件夹，需要继续递归寻找</span></span><br><span class="line">                        searchFile(file, fileName);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;对不起，当前搜索的位置不是文件夹！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-6非规律化递归案例-啤酒问题"><a href="#3-6非规律化递归案例-啤酒问题" class="headerlink" title="3.6非规律化递归案例-啤酒问题"></a>3.6非规律化递归案例-啤酒问题</h4><p><strong>啤酒问题:</strong></p><p><strong>需求：</strong></p><p>啤酒2元1瓶，4个盖子可以换一瓶，2个空瓶可以换一瓶，</p><p>请问10元钱可以喝多少瓶酒，剩余多少空瓶和盖子。</p><p><strong>答案：</strong></p><p>15瓶 3盖子 1瓶子</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：啤酒2元1瓶，4个盖子可以换一瓶，2个空瓶可以换一瓶，</span></span><br><span class="line"><span class="comment">        请问10元钱可以喝多少瓶酒，剩余多少空瓶和盖子。</span></span><br><span class="line"><span class="comment">        答案：15瓶 3盖子 1瓶子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RecursionDemo06</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个静态的成员变量用于存储可以买的酒数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> totalNumber; <span class="comment">// 总数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> lastBottleNumber; <span class="comment">// 记录每次剩余的瓶子个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> lastCoverNumber; <span class="comment">// 记录每次剩余的盖子个数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、拿钱买酒</span></span><br><span class="line">        buy(<span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;总数：&quot;</span> + totalNumber);</span><br><span class="line">        System.out.println(<span class="string">&quot;剩余盖子数：&quot;</span> + lastCoverNumber);</span><br><span class="line">        System.out.println(<span class="string">&quot;剩余瓶子数：&quot;</span> + lastBottleNumber);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">buy</span><span class="params">(<span class="type">int</span> money)</span>&#123;</span><br><span class="line">        <span class="comment">// 2、看可以立马买多少瓶</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">buyNumber</span> <span class="operator">=</span> money / <span class="number">2</span>; <span class="comment">// 5</span></span><br><span class="line">        totalNumber += buyNumber;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、把盖子 和瓶子换算成钱</span></span><br><span class="line">        <span class="comment">// 统计本轮总的盖子数  和 瓶子数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">coverNumber</span> <span class="operator">=</span> lastCoverNumber + buyNumber;</span><br><span class="line">        <span class="type">int</span> <span class="variable">bottleNumber</span> <span class="operator">=</span> lastBottleNumber + buyNumber;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 统计可以换算的钱</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">allMoney</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(coverNumber &gt;= <span class="number">4</span>)&#123;</span><br><span class="line">            allMoney += (coverNumber / <span class="number">4</span>) * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lastCoverNumber = coverNumber % <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(bottleNumber &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">            allMoney += (bottleNumber / <span class="number">2</span>) * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lastBottleNumber = bottleNumber % <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(allMoney &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">            buy(allMoney);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Integer[] arr2 = <span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>&#125;;</span><br><span class="line">        Arrays.sort(arr2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-字符集"><a href="#4-字符集" class="headerlink" title="4.字符集"></a>4.字符集</h3><h4 id="4-1常见字符集介绍"><a href="#4-1常见字符集介绍" class="headerlink" title="4.1常见字符集介绍"></a>4.1常见字符集介绍</h4><p><strong>字符集基础知识：</strong></p><ul><li><p>计算机底层不可以直接存储字符的。计算机中底层只能存储<strong>二进制(0、1)</strong></p></li><li><p>二进制是可以转换成十进制的</p></li></ul><p>11 &#x3D; 1<em>2^1 + 1</em>2^0 &#x3D; 2 + 1 &#x3D; 3<br>10 &#x3D; 1<em>2^1 + 0</em>2^0 &#x3D; 2 + 0 &#x3D; 2<br> 01 &#x3D; 0<em>2^1 + 1</em>2^0 &#x3D; 0 + 1 &#x3D; 1<br> 00 &#x3D; 0<em>2^1 + 0</em>2^0 &#x3D; 0 + 0 &#x3D; 0</p><p>‭01100001‬ &#x3D; 97</p><p>‭01100010‬ &#x3D; 98</p><p><strong>结论：计算机底层可以表示十进制编号。计算机可以给人类字符进行编号存储，这套编号规则就是字符集。</strong></p><p><strong>ASCII字符集：</strong></p><ul><li><p>ASCII(American Standard Code for Information Interchange，美国信息交换标准代码)：包括了数字、英文、符号。</p></li><li><p>ASCII使用1个字节存储一个字符，一个字节是8位，总共可以表示128个字符信息，对于英文，数字来说是够用的。</p></li></ul><p>01100001‬ &#x3D; 97 &#x3D;&gt; a</p><p>‭01100010‬ &#x3D; 98 &#x3D;&gt; b</p><p><strong>GBK：</strong></p><ul><li><p>window系统默认的码表。兼容ASCII码表，也包含了几万个汉字，并支持繁体汉字以及部分日韩文字。</p></li><li><p>注意：GBK是中国的码表，一个中文以<strong>两个字节</strong>的形式存储。但不包含世界上所有国家的文字。</p></li></ul><p><strong>Unicode码表：</strong></p><ul><li><p>unicode（又称统一码、万国码、单一码）是计算机科学领域里的一项业界字符编码标准。</p></li><li><p>容纳世界上大多数国家的所有常见文字和符号。</p></li><li><p>由于Unicode会先通过UTF-8，UTF-16，以及 UTF-32的编码成二进制后再存储到计算机，其中最为常见的就是UTF-8。</p></li></ul><p><strong>注意</strong></p><ul><li><p>Unicode是万国码，以UTF-8编码后一个中文一般以<strong>三个字节</strong>的形式存储。</p></li><li><p>UTF-8也要兼容ASCII编码表。</p></li><li><p>技术人员都应该使用UTF-8的字符集编码。</p></li><li><p>编码前和编码后的字符集需要一致，否则会出现中文乱码。</p></li></ul><h4 id="4-2字符集的编码、解码操作"><a href="#4-2字符集的编码、解码操作" class="headerlink" title="4.2字符集的编码、解码操作"></a>4.2字符集的编码、解码操作</h4><p><strong>String编码</strong></p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>byte[] getBytes()</td><td>使用平台的默认字符集将该  String编码为一系列字节，将结果存储到新的字节数组中</td></tr><tr><td>byte[] getBytes(String charsetName)</td><td>使用指定的字符集将该 String编码为一系列字节，将结果存储到新的字节数组中</td></tr></tbody></table><p><strong>String解码</strong></p><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>String(byte[] bytes)</td><td>通过使用平台的默认字符集解码指定的字节数组来构造新的  String</td></tr><tr><td>String(byte[] bytes, String charsetName)</td><td>通过指定的字符集解码指定的字节数组来构造新的 String</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     目标：学会自己进行文字的编码和解码，为以后可能用到的场景做准备。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、编码：把文字转换成字节</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;abc我爱你中国&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 以当前代码默认字符集进行编码 （UTF-8）</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = name.getBytes(); </span><br><span class="line">        System.out.println(bytes.length); <span class="comment">//18</span></span><br><span class="line">        System.out.println(Arrays.toString(bytes)); </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 指定编码</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = name.getBytes(<span class="string">&quot;GBK&quot;</span>); </span><br><span class="line">        System.out.println(bytes.length); <span class="comment">//13</span></span><br><span class="line">        System.out.println(Arrays.toString(bytes));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、解码：把字节转换成对应的中文形式（编码前 和 编码后的字符集必须一致，否则乱码 ）</span></span><br><span class="line">        <span class="comment">// 默认的UTF-8</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes); </span><br><span class="line">        <span class="comment">// 指定GBK解码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="string">&quot;GBK&quot;</span>); </span><br><span class="line">        System.out.println(rs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-IO流概述"><a href="#5-IO流概述" class="headerlink" title="5.IO流概述"></a>5.IO流概述</h3><p><strong>IO流概述</strong></p><ul><li><p>I 表示intput，是数据从硬盘文件读入到内存的过程，称之输入，负责读。</p></li><li><p>O表示output，是内存程序的数据从内存到写出到硬盘文件的过程，称之输出，负责写。</p></li></ul><p><strong>IO流的作用</strong></p><ul><li>读写文件数据</li></ul><p><strong>IO流的分类</strong></p><ol><li><p><strong>字节流（Byte Streams）</strong>：字节流以字节为单位进行数据的输入和输出。它们适用于处理二进制数据或字符数据，不关心数据的具体含义。在Java中，<code>InputStream</code>和<code>OutputStream</code>是字节流的基本抽象类。</p><ul><li><code>InputStream</code>：用于从数据源（如文件、网络等）读取字节数据。</li><li><code>OutputStream</code>：用于将字节数据写入目标（如文件、网络等）。</li></ul></li><li><p><strong>字符流（Character Streams）</strong>：字符流以字符为单位进行数据的输入和输出，可以更方便地处理文本数据。在处理字符数据时，字符流会考虑字符的编码方式，如UTF-8、UTF-16等。在Java中，<code>Reader</code>和<code>Writer</code>是字符流的基本抽象类。</p><ul><li><code>Reader</code>：用于从数据源读取字符数据。</li><li><code>Writer</code>：用于将字符数据写入目标。</li></ul></li><li><p><strong>节点流（Node Streams）</strong>：节点流直接与数据源或目标进行连接，是I&#x2F;O流的最基本形式。例如，从文件中读取数据的<code>FileInputStream</code>和向文件写入数据的<code>FileOutputStream</code>就是节点流。</p></li><li><p><strong>处理流（Filter Streams）</strong>：处理流是建立在节点流之上的，它们提供了一些额外的功能，如缓冲、数据转换等。处理流可以通过链式结构进行组合，将多个处理流串联起来以实现更复杂的数据处理操作。例如，<code>BufferedReader</code>和<code>BufferedWriter</code>就是处理流的例子，它们可以用来缓冲字符流的输入和输出。</p></li><li><p><strong>对象流（Object Streams）</strong>：对象流可以用来读写Java对象，而不仅仅是字节或字符数据。这对于在应用程序之间传递复杂的数据结构非常有用。<code>ObjectInputStream</code>和<code>ObjectOutputStream</code>用于实现对象流。</p></li><li><p><strong>数据流（Data Streams）</strong>：数据流允许以基本数据类型（如整数、浮点数等）的形式进行读写操作，而不必考虑字节的表示。<code>DataInputStream</code>和<code>DataOutputStream</code>提供了数据流的功能。</p></li><li><p><strong>输入流和输出流</strong>：根据数据流的方向，可以将I&#x2F;O流分为输入流和输出流。输入流用于读取数据，输出流用于写入数据。</p></li></ol><p><strong>总结流的四大类:</strong></p><ul><li><p>字节输入流：以内存为基准，来自磁盘文件&#x2F;网络中的数据以字节的形式读入到内存中去的流称为字节输入流。</p></li><li><p>字节输出流：以内存为基准，把内存中的数据以字节写出到磁盘文件或者网络中去的流称为字节输出流。</p></li><li><p>字符输入流：以内存为基准，来自磁盘文件&#x2F;网络中的数据以字符的形式读入到内存中去的流称为字符输入流。</p></li><li><p>字符输出流：以内存为基准，把内存中的数据以字符写出到磁盘文件或者网络介质中去的流称为字符输出流。</p></li></ul><p><strong>IO流体系</strong></p><ol><li><strong>字节流（Byte Streams）</strong>： 字节流操作以字节为单位进行读写，适用于处理任何类型的数据，包括文本和二进制数据。主要的字节流类有：<ul><li><code>InputStream</code>：字节输入流的基类。</li><li><code>OutputStream</code>：字节输出流的基类。</li><li><code>FileInputStream</code>：从文件中读取字节数据的输入流。</li><li><code>FileOutputStream</code>：向文件写入字节数据的输出流。</li><li><code>BufferedInputStream</code> 和 <code>BufferedOutputStream</code>：带有缓冲功能的字节流。</li><li><code>DataInputStream</code> 和 <code>DataOutputStream</code>：用于读写基本数据类型的字节流。</li></ul></li><li><strong>字符流（Character Streams）</strong>： 字符流操作以字符为单位进行读写，适用于处理文本数据。字符流会自动处理字符编码和解码，以确保正确处理各种字符集。主要的字符流类有：<ul><li><code>Reader</code>：字符输入流的基类。</li><li><code>Writer</code>：字符输出流的基类。</li><li><code>FileReader</code>：从文件中读取字符数据的输入流。</li><li><code>FileWriter</code>：向文件写入字符数据的输出流。</li><li><code>BufferedReader</code> 和 <code>BufferedWriter</code>：带有缓冲功能的字符流。</li><li><code>InputStreamReader</code> 和 <code>OutputStreamWriter</code>：将字节流转换为字符流的桥梁。</li></ul></li></ol><h3 id="6-字节流的使用"><a href="#6-字节流的使用" class="headerlink" title="6.字节流的使用"></a>6.字节流的使用</h3><h4 id="6-1文件字节输入流：FileInputStream"><a href="#6-1文件字节输入流：FileInputStream" class="headerlink" title="6.1文件字节输入流：FileInputStream"></a>6.1文件字节输入流：FileInputStream</h4><p><strong>注意：读数据会自己换行</strong></p><p><strong>构造器</strong></p><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public  <strong>FileInputStream</strong>(File file)</td><td>创建字节输入流管道与源文件对象接通</td></tr><tr><td>public  <strong>FileInputStream</strong>(String pathname)</td><td>创建字节输入流管道与源文件路径接通</td></tr></tbody></table><h5 id="6-1-1每次读取一个字节"><a href="#6-1-1每次读取一个字节" class="headerlink" title="6.1.1每次读取一个字节"></a>6.1.1每次读取一个字节</h5><ul><li>作用：以内存为基准，把磁盘文件中的数据以字节的形式读取到内存中去。</li></ul><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>public int  read()</td><td>每次读取一个字节返回，如果字节已经没有可读的返回-1</td></tr></tbody></table><p><strong>每次读取一个字节存在什么问题？</strong></p><ul><li><p><strong>性能较慢</strong></p></li><li><p><strong>读取中文字符输出无法避免乱码问题。</strong></p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：字节输入流的使用。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    IO流的体系：</span></span><br><span class="line"><span class="comment">                    字节流                                     字符流</span></span><br><span class="line"><span class="comment">        字节输入流             字节输出流               字符输入流         字符输出流</span></span><br><span class="line"><span class="comment">        InputStream          OutputStream            Reader           Writer  (抽象类)</span></span><br><span class="line"><span class="comment">        FileInputStream      FileOutputStream        FileReader       FileWriter(实现类，可以使用的)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    小结：</span></span><br><span class="line"><span class="comment">        一个一个字节读取中文数据输出其实是被淘汰的，性能极差！</span></span><br><span class="line"><span class="comment">         一个一个字节读取中文数据输出，会出现截断中文字节的情况，无法避免读取中文输出乱码的问题。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileInputStreamDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建一个文件字节输入流管道与源文件接通。</span></span><br><span class="line">        <span class="comment">// InputStream is = new FileInputStream(new File(&quot;file-io-app\\src\\data.txt&quot;));</span></span><br><span class="line">        <span class="comment">// 简化写法</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;file-io-app\\src\\data.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、读取一个字节返回 （每次读取一滴水）</span></span><br><span class="line"><span class="comment">//        int b1 = is.read();</span></span><br><span class="line"><span class="comment">//        System.out.println((char)b1);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        int b2 = is.read();</span></span><br><span class="line"><span class="comment">//        System.out.println((char)b2);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        int b3 = is.read();</span></span><br><span class="line"><span class="comment">//        System.out.println((char)b3);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        int b4 = is.read(); // 读取完毕返回-1</span></span><br><span class="line"><span class="comment">//        System.out.println(b4);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、使用循环改进</span></span><br><span class="line">        <span class="comment">// 定义一个变量记录每次读取的字节    a  b  3    爱</span></span><br><span class="line">        <span class="comment">//                              o  o  o   [ooo]</span></span><br><span class="line">        <span class="type">int</span> b;</span><br><span class="line">        <span class="keyword">while</span> (( b = is.read() ) != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print((<span class="type">char</span>) b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="6-1-2每次读取一个字节数组"><a href="#6-1-2每次读取一个字节数组" class="headerlink" title="6.1.2每次读取一个字节数组"></a>6.1.2每次读取一个字节数组</h5><ul><li>作用：以内存为基准，把磁盘文件中的数据以字节的形式读取到内存中去。</li></ul><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>public int read(byte[] buffer)</td><td>每次读取一个字节数组返回，如果字节已经没有可读的返回-1</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   目标：使用文件字节输入流每次读取一个字节数组的数据。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileInputStreamDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建一个文件字节输入流管道与源文件接通</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;file-io-app/src/data02.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、定义一个字节数组，用于读取字节数组</span></span><br><span class="line"><span class="comment">//        byte[] buffer = new byte[3]; // 3B</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//        int len = is.read(buffer); // 3</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;读取了几个字节：&quot; + len); / 3</span></span><br><span class="line"><span class="comment">//        String rs = new String(buffer);</span></span><br><span class="line"><span class="comment">//        System.out.println(rs);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        int len1 = is.read(buffer);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;读取了几个字节：&quot; + len1);</span></span><br><span class="line"><span class="comment">//        String rs1 = new String(buffer);</span></span><br><span class="line"><span class="comment">//        System.out.println(rs1);</span></span><br><span class="line"><span class="comment">//        // buffer = [a b c]</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        // buffer = [a b c]  ==&gt;  [c d c]</span></span><br><span class="line"><span class="comment">//        int len2 = is.read(buffer);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;读取了几个字节：&quot; + len2);</span></span><br><span class="line"><span class="comment">//        // 读取多少倒出多少</span></span><br><span class="line"><span class="comment">//        String rs2 = new String(buffer,0 ,len2);</span></span><br><span class="line"><span class="comment">//        System.out.println(rs2);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        int len3 = is.read(buffer);</span></span><br><span class="line"><span class="comment">//        System.out.println(len3); // 读取完毕返回-1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、改进使用循环，每次读取一个字节数组</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="type">int</span> len; <span class="comment">// 记录每次读取的字节数。</span></span><br><span class="line">        <span class="keyword">while</span> ((len = is.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 读取多少倒出多少</span></span><br><span class="line">            System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(buffer, <span class="number">0</span> , len));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="6-1-3一次读完全部字节"><a href="#6-1-3一次读完全部字节" class="headerlink" title="6.1.3一次读完全部字节"></a>6.1.3一次读完全部字节</h5><p>1、如何使用字节输入流读取中文内容输出不乱码呢？</p><ul><li><strong>定义一个与文件一样大的字节数组，一次性读取完文件的全部字节。</strong></li></ul><p>2、直接把文件数据全部读取到一个字节数组可以避免乱码，是否存在问题？</p><ul><li><strong>如果文件过大，字节数组可能引起内存溢出。</strong></li></ul><p><strong>方式一</strong></p><ul><li>自己定义一个字节数组与文件的大小一样大，然后使用读取字节数组的方法，一次性读取完成。</li></ul><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>public int  read(byte[] buffer)</td><td>每次读取一个字节数组返回，如果字节已经没有可读的返回-1</td></tr></tbody></table><p><strong>方式二</strong></p><ul><li>官方为字节输入流InputStream提供了如下<strong>API</strong>可以直接把文件的全部数据读取到一个字节数组中</li></ul><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>public byte[] readAllBytes() throws IOException</td><td>直接将当前字节输入流对应的文件对象的字节数据装到一个字节数组返回</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   目标：使用文件字节输入流一次读完文件的全部字节。可以解决乱码问题。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileInputStreamDemo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建一个文件字节输入流管道与源文件接通</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;file-io-app/src/data03.txt&quot;</span>);</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(f);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方法一:定义一个字节数组与文件的大小刚刚一样大。</span></span><br><span class="line">        <span class="comment">// f.length()为long 型，需要强转</span></span><br><span class="line"><span class="comment">//        byte[] buffer = new byte[(int) f.length()]; </span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//        int len = is.read(buffer); //(int) f.length()</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;读取了多少个字节：&quot; + len); </span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;文件大小：&quot; + f.length());</span></span><br><span class="line"><span class="comment">//        System.out.println(new String(buffer));</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方法二:官方APIreadAllBytes，读取全部字节数组</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = is.readAllBytes();</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(buffer));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-2文件字节输出流：FileOutputStream"><a href="#6-2文件字节输出流：FileOutputStream" class="headerlink" title="6.2文件字节输出流：FileOutputStream"></a>6.2文件字节输出流：FileOutputStream</h4><p><strong>写字节数据到文件</strong></p><ul><li>作用：以内存为基准，把内存中的数据以字节的形式写出到磁盘文件中去的流。</li></ul><p><strong>构造器</strong></p><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public <strong>FileOutputStream</strong>(File file , boolean append)</td><td>创建一个追加数据的字节输出流管道通向目标文件对象。</td></tr><tr><td>public <strong>FileOutputStream</strong>(String filepath，boolean append)</td><td>创建字节输出流管道与源文件路径接通，可追加数据</td></tr></tbody></table><p><strong>FileOutputStream写数据出去的API</strong></p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>public void write(int a)</td><td>写一个字节出去</td></tr><tr><td>public void write(byte[] buffer)</td><td>写一个字节数组出去</td></tr><tr><td>public void write(byte[] buffer , int pos , int len)</td><td>写一个字节数组的一部分出去。</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：字节输出流的使用。</span></span><br><span class="line"><span class="comment">         把内存数据按照字节写出到磁盘文件中去。</span></span><br><span class="line"><span class="comment">         </span></span><br><span class="line"><span class="comment">-- 构造器：</span></span><br><span class="line"><span class="comment">         public FileOutputStream(File file):创建一个字节输出流管道通向目标文件对象。</span></span><br><span class="line"><span class="comment">         public FileOutputStream(String file):创建一个字节输出流管道通向目标文件路径。</span></span><br><span class="line"><span class="comment">         public FileOutputStream(File file , boolean append):创建一个追加数据的字节输出流管道通向目标文件对象。</span></span><br><span class="line"><span class="comment">         public FileOutputStream(String file , boolean append):创建一个追加数据的字节输出流管道通向目标文件路径。</span></span><br><span class="line"><span class="comment">         </span></span><br><span class="line"><span class="comment">-- 方法：</span></span><br><span class="line"><span class="comment">         public void write(int a):写一个字节出去 。</span></span><br><span class="line"><span class="comment">         public void write(byte[] buffer):写一个字节数组出去。</span></span><br><span class="line"><span class="comment">         public void write(byte[] buffer , int pos , int len):写一个字节数组的一部分出去。</span></span><br><span class="line"><span class="comment">         参数一，字节数组；参数二：起始字节索引位置，参数三：写多少个字节数出去。</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">         换行：  os.write(&quot;\r\n&quot;.getBytes()); // 换行</span></span><br><span class="line"><span class="comment">   追加数据管道： OutputStream os = new FileOutputStream(&quot;day10_demo/out01.txt&quot; , true); // 追加管道！！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OutputStreamDemo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="comment">// 1、创建一个文件字节输出流管道与目标文件接通</span></span><br><span class="line">        <span class="comment">// 追加数据管道</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;file-io-app/src/out04.txt&quot;</span> , <span class="literal">true</span>); </span><br><span class="line">        <span class="comment">// 先清空之前的数据，写新数据进入</span></span><br><span class="line">        <span class="comment">//OutputStream os = new FileOutputStream(&quot;file-io-app/src/out04.txt&quot;); </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、写数据出去</span></span><br><span class="line">        <span class="comment">// a.public void write(int a):写一个字节出去</span></span><br><span class="line">        os.write(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        os.write(<span class="number">98</span>);</span><br><span class="line">        os.write(<span class="string">&quot;\r\n&quot;</span>.getBytes()); <span class="comment">// 换行</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// b.public void write(byte[] buffer):写一个字节数组出去。</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = &#123;<span class="string">&#x27;a&#x27;</span> , <span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>&#125;;</span><br><span class="line">        os.write(buffer);</span><br><span class="line">        os.write(<span class="string">&quot;\r\n&quot;</span>.getBytes()); <span class="comment">// 换行</span></span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] buffer2 = <span class="string">&quot;我是中国人&quot;</span>.getBytes();</span><br><span class="line">        <span class="comment">//byte[] buffer2 = &quot;我是中国人&quot;.getBytes(&quot;GBK&quot;);</span></span><br><span class="line">        os.write(buffer2);</span><br><span class="line">        os.write(<span class="string">&quot;\r\n&quot;</span>.getBytes()); <span class="comment">// 换行</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// c. public void write(byte[] buffer , int pos , int len):写一个字节数组的一部分出去。</span></span><br><span class="line">        <span class="type">byte</span>[] buffer3 = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>&#125;;</span><br><span class="line">        os.write(buffer3, <span class="number">0</span> , <span class="number">3</span>); <span class="comment">//从索引0开始 ，三个字节</span></span><br><span class="line">        os.write(<span class="string">&quot;\r\n&quot;</span>.getBytes()); <span class="comment">// 换行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>流的关闭与刷新</strong> </p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><strong>flush</strong>()</td><td>刷新流，还可以继续写数据</td></tr><tr><td><strong>close</strong>()</td><td>关闭流，释放资源，但是在关闭之前会先刷新流。一旦关闭，就不能再写数据</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写数据必须，刷新数据 可以继续使用流</span></span><br><span class="line">os.flush();</span><br><span class="line"><span class="comment">// 释放资源，包含了刷新的！关闭后流不可以使用了</span></span><br><span class="line">os.close(); </span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>字节输出流如何实现写出去的数据能换行?</p><ul><li><strong>os.write(“\r\n”.getBytes());</strong></li></ul><p>如何让写出去的数据能成功生效？</p><ul><li><p><strong>flush()刷新数据</strong></p></li><li><p><strong>close()方法是关闭流，关闭包含刷新，关闭后流不可以继续使用了。</strong></p></li></ul><h4 id="6-3文件拷贝"><a href="#6-3文件拷贝" class="headerlink" title="6.3文件拷贝"></a>6.3文件拷贝</h4><p><strong>文件拷贝</strong></p><p><strong>需求：</strong></p><p>把某个视频复制到其他目录下的“b.avi”</p><p><strong>思路</strong>：</p><p>①根据数据源创建字节输入流对象</p><p>②根据目的地创建字节输出流对象</p><p>③读写数据，复制视频</p><p>④释放资源</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *   目标：学会使用字节流完成文件的复制（支持一切文件类型的复制）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopyDemo05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1、创建一个字节输入流管道与原视频接通</span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;file-io-app/src/out04.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2、创建一个字节输出流管道与目标文件接通</span></span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;file-io-app/src/out05.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3、定义一个字节数组转移数据</span></span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> len; <span class="comment">// 记录每次读取的字节数。</span></span><br><span class="line">            <span class="keyword">while</span> ((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                os.write(buffer, <span class="number">0</span> , len);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            System.out.println(<span class="string">&quot;复制完成了！&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4、关闭流。</span></span><br><span class="line">            os.close();</span><br><span class="line">            is.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-资源释放的方式"><a href="#7-资源释放的方式" class="headerlink" title="7.资源释放的方式"></a>7.资源释放的方式</h3><h4 id="7-1try-catch-finally"><a href="#7-1try-catch-finally" class="headerlink" title="7.1try-catch-finally"></a>7.1try-catch-finally</h4><p><strong>try-catch-finally</strong></p><ul><li><p>finally：在异常处理时提供finally块来执行所有清除操作，比如说IO流中的释放资源</p></li><li><p><strong>特点：被finally控制的语句最终一定会执行，除非JVM退出</strong></p></li><li><p>异常处理标准格式：<strong>try….catch…finally</strong></p></li></ul><p><strong>try-catch-finally格式</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//手动释放资源</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">可能出现异常的代码;</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类名 变量名)&#123;</span><br><span class="line">异常的处理代码;</span><br><span class="line"> &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">执行所有资源释放操作;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//代码繁琐</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *   目标：学会使用finally释放资源。</span></span><br><span class="line"><span class="comment">   try….catch…finally</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TryCatchFinallyDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// System.out.println(10/ 0);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1、创建一个字节输入流管道与原视频接通</span></span><br><span class="line">             is = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;file-io-app/src/out04.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2、创建一个字节输出流管道与目标文件接通</span></span><br><span class="line">             os = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;file-io-app/src/out05.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3、定义一个字节数组转移数据</span></span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> len; <span class="comment">// 记录每次读取的字节数。</span></span><br><span class="line">            <span class="keyword">while</span> ((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                os.write(buffer, <span class="number">0</span> , len);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;复制完成了！&quot;</span>);</span><br><span class="line"></span><br><span class="line">         <span class="comment">//   System.out.println( 10 / 0);</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 无论代码是正常结束，还是出现异常都要最后执行这里</span></span><br><span class="line">            System.out.println(<span class="string">&quot;========finally=========&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 4、关闭流。</span></span><br><span class="line">                <span class="keyword">if</span>(os!=<span class="literal">null</span>)os.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(is != <span class="literal">null</span>) is.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(test(<span class="number">10</span>, <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a , <span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a / b;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">111111</span>; <span class="comment">// 计算出现bug.</span></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;--finally--&quot;</span>);</span><br><span class="line">            <span class="comment">// 哪怕上面有return语句执行，也必须先执行完这里才可以！</span></span><br><span class="line">            <span class="comment">// 开发中不建议在这里加return ，如果加了，返回的永远是这里的数据了，这样会出问题！</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-2try-with-resource-改进方案"><a href="#7-2try-with-resource-改进方案" class="headerlink" title="7.2try-with-resource(改进方案)"></a>7.2try-with-resource(改进方案)</h4><p><strong>JDK7 和 JDK9 中都简化了资源释放操作</strong></p><p><strong>JDK7改进方案(较常用)：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//资源用完最终自动释放</span></span><br><span class="line"><span class="keyword">try</span>(定义流对象)&#123;</span><br><span class="line">可能出现异常的代码;</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类名 变量名)&#123;</span><br><span class="line">异常的处理代码;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *   目标：学会使用JDK 7的新方式释放资源 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TryCatchResouceDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">// 这里面只能放置资源对象，用完会自动关闭：自动调用资源对象的close方法关闭资源（即使出现异常也会做关闭操作）</span></span><br><span class="line">                <span class="comment">// 1、创建一个字节输入流管道与原视频接通</span></span><br><span class="line">               <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;file-io-app/src/out04.txt&quot;</span>);</span><br><span class="line">                <span class="comment">// 2、创建一个字节输出流管道与目标文件接通</span></span><br><span class="line">               <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;file-io-app/src/out05.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">               <span class="comment">// int age = 23; // 这里只能放资源</span></span><br><span class="line">                <span class="type">MyConnection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyConnection</span>(); <span class="comment">// 最终会自动调用资源的close方法</span></span><br><span class="line">                ) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3、定义一个字节数组转移数据</span></span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> len; <span class="comment">// 记录每次读取的字节数。</span></span><br><span class="line">            <span class="keyword">while</span> ((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                os.write(buffer, <span class="number">0</span> , len);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;复制完成了！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyConnection</span> <span class="keyword">implements</span> <span class="title class_">AutoCloseable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;连接资源被成功释放了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>JDK9改进方案：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//资源用完最终自动释放</span></span><br><span class="line">定义输入流对象;</span><br><span class="line">定义输出流对象;</span><br><span class="line"><span class="keyword">try</span>(输入流对象；输出流对象)&#123;</span><br><span class="line">可能出现异常的代码;</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类名 变量名)&#123;</span><br><span class="line">异常的处理代码;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *   目标：JDK 9释放资源的方式：可以了解下。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TryCatchResouceDemo3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123; <span class="comment">//这里必须抛出错误</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里面只能放置资源对象，用完会自动关闭：自动调用资源对象的close方法关闭资源（即使出现异常也会做关闭操作）</span></span><br><span class="line">        <span class="comment">// 1、创建一个字节输入流管道与原视频接通</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;file-io-app/src/out04.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 2、创建一个字节输出流管道与目标文件接通</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;file-io-app/src/out05.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> ( is ; os ) &#123;</span><br><span class="line">            <span class="comment">// 3、定义一个字节数组转移数据</span></span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> len; <span class="comment">// 记录每次读取的字节数。</span></span><br><span class="line">            <span class="keyword">while</span> ((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                os.write(buffer, <span class="number">0</span> , len);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;复制完成了！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><ul><li><p>JDK 7 以及 JDK 9的()中只能放置资源对象，否则报错</p></li><li><p>什么是资源呢？</p><p>资源都是实现了Closeable&#x2F;AutoCloseable接口的类对象</p></li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">InputStream</span> <span class="keyword">implements</span> <span class="title class_">Closeable</span> &#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">OutputStream</span> <span class="keyword">implements</span> <span class="title class_">Closeable</span>, Flushable&#123;&#125; </span><br></pre></td></tr></table></figure><p><strong>案例：</strong></p><p><strong>拷贝文件夹</strong></p><p>需求：</p><p>将某个磁盘的文件夹拷贝到另一个文件夹下去，包括文件夹中的全部信息</p><p>分析：</p><p>①：IO默认不可以拷贝文件夹</p><p>②：我们需要遍历文件夹，如果是文件则拷贝过去，如果是文件夹则要进行1-1创建，继续复制内容。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   目标：拷贝文件夹</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">         <span class="comment">// D:\resources</span></span><br><span class="line">        copy(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\resources&quot;</span>) , <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\new&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copy</span><span class="params">(File src , File dest)</span>&#123;</span><br><span class="line">        <span class="comment">// 1、判断源目录是否存在</span></span><br><span class="line">        <span class="keyword">if</span>(src!= <span class="literal">null</span> &amp;&amp; src.exists() &amp;&amp; src.isDirectory())&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 2、目标目录需要创建一下  D:\new\resources</span></span><br><span class="line">            <span class="type">File</span> <span class="variable">destOne</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(dest , src.getName());</span><br><span class="line">            destOne.mkdirs(); <span class="comment">//创建多级</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3、提取原目录下的全部一级文件对象</span></span><br><span class="line">            File[] files = src.listFiles();</span><br><span class="line">            <span class="comment">// 4、判断是否存在一级文件对象</span></span><br><span class="line">            <span class="keyword">if</span>(files != <span class="literal">null</span> &amp;&amp; files.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 5、遍历一级文件对象</span></span><br><span class="line">                <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">                    <span class="comment">// 6、判断是文件还是文件夹，是文件直接复制过去</span></span><br><span class="line">                    <span class="keyword">if</span>(file.isFile())&#123;</span><br><span class="line">                        copyFile(file, <span class="keyword">new</span> <span class="title class_">File</span>(destOne , file.getName()));</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 7、当前遍历的是文件夹，递归复制</span></span><br><span class="line">                        copy(file, destOne);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copyFile</span><span class="params">(File srcFile, File destFile)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">// 1、创建一个字节输入流管道与原视频接通</span></span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcFile);</span><br><span class="line">                <span class="comment">// 2、创建一个字节输出流管道与目标文件接通</span></span><br><span class="line">                <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destFile);</span><br><span class="line">                ) &#123;</span><br><span class="line">            <span class="comment">// 3、定义一个字节数组转移数据</span></span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> len; <span class="comment">// 记录每次读取的字节数。</span></span><br><span class="line">            <span class="keyword">while</span> ((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                os.write(buffer, <span class="number">0</span> , len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-字符流的使用"><a href="#8-字符流的使用" class="headerlink" title="8.字符流的使用"></a>8.字符流的使用</h3><h4 id="8-1文件字符输入流"><a href="#8-1文件字符输入流" class="headerlink" title="8.1文件字符输入流"></a>8.1文件字符输入流</h4><p>1.字节流读取中文输出会存在什么问题？</p><ul><li><strong>会乱码。或者内存溢出。</strong></li></ul><p>2.读取中文输出，哪个流更合适，为什么？</p><ul><li><p><strong>字符流更合适，最小单位是按照单个字符读取的。</strong></p><p><strong>构造器  Reader</strong></p></li><li><p>作用：以内存为基准，把磁盘文件中的数据以字符的形式读取到内存中去。</p></li></ul><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public <strong>FileReader</strong>(File file)</td><td>创建字符输入流管道与源文件对象接通</td></tr><tr><td>public <strong>FileReader</strong>(String  pathname)</td><td>创建字符输入流管道与源文件路径接通</td></tr></tbody></table><h5 id="8-1-1一次读取一个字符"><a href="#8-1-1一次读取一个字符" class="headerlink" title="8.1.1一次读取一个字符"></a>8.1.1一次读取一个字符</h5><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>public int read()</td><td>每次读取一个字符返回，如果字符已经没有可读的返回-1</td></tr></tbody></table><p>1.字符流的好处。每次读取一个字符存在什么问题？</p><ul><li><p><strong>读取中文字符不会出现乱码（如果代码文件编码一致）</strong></p></li><li><p><strong>性能较慢</strong></p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     目标：字符输入流的使用。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  读取文本文件内容到内存中去。</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">小结：</span></span><br><span class="line"><span class="comment">    字符流一个一个字符的读取文本内容输出，可以解决中文读取输出乱码的问题。</span></span><br><span class="line"><span class="comment">    字符流很适合操作文本文件内容。</span></span><br><span class="line"><span class="comment">    但是：一个一个字符的读取文本内容性能较差！！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileReaderDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 目标：每次读取一个字符。</span></span><br><span class="line">        <span class="comment">// 1、创建一个字符输入流管道与源文件接通</span></span><br><span class="line">        <span class="type">Reader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;file-io-app\\src\\data06.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、读取一个字符返回，没有可读的字符了返回-1</span></span><br><span class="line"><span class="comment">//        int code = fr.read();</span></span><br><span class="line"><span class="comment">//        System.out.print((char)code);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        int code1 = fr.read();</span></span><br><span class="line"><span class="comment">//        System.out.print((char)code1);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、使用循环读取字符</span></span><br><span class="line">        <span class="type">int</span> code;</span><br><span class="line">        <span class="keyword">while</span> ((code = fr.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print((<span class="type">char</span>) code);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="8-1-2文件字符输入流-一次读取一个字符数组"><a href="#8-1-2文件字符输入流-一次读取一个字符数组" class="headerlink" title="8.1.2文件字符输入流-一次读取一个字符数组"></a>8.1.2文件字符输入流-一次读取一个字符数组</h5><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>public int  read(char[] buffer)</td><td>每次读取一个字符数组，返回读取的字符数，如果字符已经没有可读的返回-1</td></tr></tbody></table><p>1.每次读取一个字符数组的优势？</p><ul><li><p><strong>读取的性能得到了提升</strong></p></li><li><p><strong>读取中文字符输出不会乱码。</strong></p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     目标：字符输入流的使用-按照字符数组读取。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  读取文本文件内容到内存中去。</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">     小结：</span></span><br><span class="line"><span class="comment">         字符流按照字符数组循环读取数据，可以解决中文读取输出乱码的问题，而且性能也较好！！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileReaderDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建一个文件字符输入流与源文件接通</span></span><br><span class="line">        <span class="type">Reader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;file-io-app/src/data07.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、用循环，每次读取一个字符数组的数据。  1024 + 1024 + 8</span></span><br><span class="line">        <span class="type">char</span>[] buffer = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>]; <span class="comment">// 1K字符</span></span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = fr.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer, <span class="number">0</span>, len);</span><br><span class="line">            System.out.print(rs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-2文件字符输出流"><a href="#8-2文件字符输出流" class="headerlink" title="8.2文件字符输出流"></a>8.2文件字符输出流</h4><p><strong>构造器 FileWriter</strong></p><ul><li>作用：以内存为基准，把内存中的数据以字符的形式写出到磁盘文件中去的流。</li></ul><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public FileWriter(File file)</td><td>创建字符输出流管道与源文件对象接通</td></tr><tr><td>public FileWriter(File file，boolean append)</td><td>创建字符输出流管道与源文件对象接通，可追加数据</td></tr><tr><td>public FileWriter(String filepath)</td><td>创建字符输出流管道与源文件路径接通</td></tr><tr><td>public FileWriter(String filepath，boolean append)</td><td>创建字符输出流管道与源文件路径接通，可追加数据</td></tr></tbody></table><p><strong>（FileWriter）写数据出去的API</strong></p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>void  write(int c)</td><td>写一个字符</td></tr><tr><td>void  write(char[] cbuf)</td><td>写入一个字符数组</td></tr><tr><td>void  write(char[] cbuf, int off, int len)</td><td>写入字符数组的一部分</td></tr><tr><td>void  write(String str)</td><td>写一个字符串</td></tr><tr><td>void  write(String str, int off, int len)</td><td>写一个字符串的一部分</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     目标：字符输出流的使用。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment"> 作用：以内存为基准，把内存中的数据按照字符的形式写出到磁盘文件中去。</span></span><br><span class="line"><span class="comment">            </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     小结：</span></span><br><span class="line"><span class="comment">        字符输出流可以写字符数据出去，总共有5个方法写字符。</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">  覆盖管道：</span></span><br><span class="line"><span class="comment">             Writer fw = new FileWriter(&quot;Day10Demo/src/dlei03.txt&quot;); // 覆盖数据管道</span></span><br><span class="line"><span class="comment">        追加数据管道：</span></span><br><span class="line"><span class="comment">             Writer fw = new FileWriter(&quot;Day10Demo/src/dlei03.txt&quot;,true); // 追加数据管道</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">     换行：fw.write(&quot;\r\n&quot;); // 换行</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">     结论：读写字符文件数据建议使用字符流。复制文件建议使用字节流。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileWriterDemo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建一个字符输出流管道与目标文件接通</span></span><br><span class="line">        <span class="comment">// Writer fw = new FileWriter(&quot;file-io-app/src/out08.txt&quot;); // 覆盖管道，每次启动都会清空文件之前的数据</span></span><br><span class="line">        <span class="type">Writer</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;file-io-app/src/out08.txt&quot;</span>, <span class="literal">true</span>); <span class="comment">// 覆盖管道，每次启动都会清空文件之前的数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//      a.public void write(int c):写一个字符出去</span></span><br><span class="line">        fw.write(<span class="number">98</span>);</span><br><span class="line">        fw.write(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        fw.write(<span class="string">&#x27;徐&#x27;</span>); <span class="comment">// 不会出问题了</span></span><br><span class="line">        fw.write(<span class="string">&quot;\r\n&quot;</span>); <span class="comment">// 换行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//       b.public void write(String c)写一个字符串出去</span></span><br><span class="line">        fw.write(<span class="string">&quot;abc我是中国人&quot;</span>);</span><br><span class="line">        fw.write(<span class="string">&quot;\r\n&quot;</span>); <span class="comment">// 换行</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//       c.public void write(char[] buffer):写一个字符数组出去</span></span><br><span class="line">        <span class="type">char</span>[] chars = <span class="string">&quot;abc我是中国人&quot;</span>.toCharArray();</span><br><span class="line">        fw.write(chars);</span><br><span class="line">        fw.write(<span class="string">&quot;\r\n&quot;</span>); <span class="comment">// 换行</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//       d.public void write(String c ,int pos ,int len):写字符串的一部分出去</span></span><br><span class="line">        fw.write(<span class="string">&quot;abc我是中国人&quot;</span>, <span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">        fw.write(<span class="string">&quot;\r\n&quot;</span>); <span class="comment">// 换行</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//       e.public void write(char[] buffer ,int pos ,int len):写字符数组的一部分出去</span></span><br><span class="line">        fw.write(chars, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">        fw.write(<span class="string">&quot;\r\n&quot;</span>); <span class="comment">// 换行</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// fw.flush();// 刷新后流可以继续使用</span></span><br><span class="line">        fw.close(); <span class="comment">// 关闭包含刷线，关闭后流不能使用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>流的关闭与刷新 (同字节流)</strong></p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>flush()</td><td>刷新流，还可以继续写数据</td></tr><tr><td>close()</td><td>关闭流，释放资源，但是在关闭之前会先刷新流。一旦关闭，就不能再写数据</td></tr></tbody></table><p><strong>注意：</strong></p><p>1.字符输出流如何实现写出去的数据能换行</p><ul><li><strong>fw.write(“\r\n”)</strong></li></ul><p>2.字符输出流如何实现写出去的数据能换行</p><ul><li><p>flush()刷新数据</p></li><li><p>close()方法是关闭流，关闭包含刷新，关闭后流不可以继续使用了。</p></li></ul><p><strong>字节流、字符流如何选择使用？</strong></p><ul><li><p><strong>字节流适合做一切文件数据的拷贝（音视频，文本）</strong></p></li><li><p><strong>字节流不适合读取中文内容输出</strong></p></li><li><p><strong>你字符流适合做文本文件的操作（读，写）</strong></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> java,面向对象进阶,File,递归,IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>day17 - 日志框架、阶段项目</title>
      <link href="/post/ca240fc7.html"/>
      <url>/post/ca240fc7.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-日志框架"><a href="#1-日志框架" class="headerlink" title="1.日志框架"></a>1.日志框架</h3><h4 id="1-1日志技术的概述"><a href="#1-1日志技术的概述" class="headerlink" title="1.1日志技术的概述"></a>1.1日志技术的概述</h4><p><strong>想清楚的知道一个系统运行的过程和详情怎么办？</strong></p><p><strong>日志</strong></p><ul><li><p>生活中的日志： 生活中的日志就好比日记，可以记录你生活的点点滴滴。</p></li><li><p>程序中的日志： 程序中的日志可以用来记录程序运行过程中的信息，并可以进行永久存储。</p></li></ul><p><strong>以前记录日志的方式</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">System.out.println(<span class="string">&quot;请输入一个整数&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">number</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Integer.parseInt(number);</span><br><span class="line">System.out.println(<span class="string">&quot;输入的数字为&quot;</span> + result);</span><br><span class="line">&#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;输入的数字有误，请输入一个整数&quot;</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>输出语句的弊端</strong></p><ul><li><p>信息只能展示在控制台</p></li><li><p>不能将其记录到其他的位置（文件，数据库）</p></li><li><p>想取消记录的信息需要修改代码才可以完成</p></li></ul><p><strong>日志技术具备的优势</strong></p><ul><li><p>可以将系统执行的信息选择性的记录到指定的位置（控制台、文件中、数据库中）。</p></li><li><p>可以随时以<strong>开关的形式控制</strong>是否记录日志，无需修改源代码。</p></li></ul><table><thead><tr><th></th><th><strong>输出语句</strong></th><th><strong>日志技术</strong></th></tr></thead><tbody><tr><td>输出位置</td><td>只能是控制台</td><td>可以将日志信息写入到文件或者数据库中</td></tr><tr><td>取消日志</td><td>需要修改代码，灵活性比较差</td><td>不需要修改代码，灵活性比较好</td></tr><tr><td>多线程</td><td>性能较差</td><td>性能较好</td></tr></tbody></table><h4 id="1-2日志技术体系结构"><a href="#1-2日志技术体系结构" class="headerlink" title="1.2日志技术体系结构"></a>1.2日志技术体系结构</h4><p><strong>体系结构</strong></p><ol><li><strong>日志源（Log Sources）</strong>： 这是生成日志信息的实体，可以是应用程序、服务器、网络设备等。日志源负责生成各种事件和状态信息，以便后续记录和分析。</li><li><strong>日志记录器（Loggers）</strong>： 日志记录器是负责将日志消息从日志源发送到日志系统的组件。它们通常具有各种日志级别，如调试、信息、警告和错误，可以根据事件的重要性选择适当的级别进行记录。</li><li><strong>日志处理器（Log Processors）</strong>： 日志处理器负责接收、过滤、格式化和处理日志消息。它们可以将日志消息存储到文件、数据库或发送到监控系统。处理器还可以执行预处理操作，如数据转换、脱敏等。</li><li><strong>日志存储（Log Storage）</strong>： 这是用于保存日志消息的地方，可以是本地文件系统、云存储、数据库等。存储通常需要支持高效的读写操作，以及对日志数据的搜索和检索功能。</li><li><strong>日志检索和查询（Log Retrieval and Querying）</strong>： 这些组件允许用户从日志存储中检索和查询特定的日志消息。它们提供了搜索、过滤和排序等功能，以帮助用户找到所需的信息。</li><li><strong>实时监控和报警（Real-time Monitoring and Alerting）</strong>： 日志技术体系结构通常还包括监控和报警功能，以便在发生重要事件或异常时能够实时通知相关人员。这可以通过设置警报规则和触发条件来实现。</li><li><strong>可视化和分析工具（Visualization and Analysis Tools）</strong>： 可视化工具可以将日志数据以图表、图形和仪表板的形式展示出来，帮助用户更好地理解系统的状态和性能。分析工具则可以对日志数据进行深入分析，识别趋势、异常模式和潜在问题。</li><li><strong>日志轮换和管理（Log Rotation and Management）</strong>： 长时间保存所有日志数据可能会占用大量存储空间，因此日志系统通常会实施日志轮换策略，以便定期删除或归档旧的日志数据。</li></ol><ul><li><p><strong>日志规范：</strong>一些接口，提供给日志的实现框架设计的标准。</p><p>​常见的规范是：</p><p>​Commons Logging</p><p>​Simple Logging Facade for Java</p></li><li><p><strong>日志框架：</strong>牛人或者第三方公司已经做好的日志记录实现代码，后来者直接可以拿去使用。</p><p>​日志常见的实现框架</p><p>​                     Log4J</p><p>​                     Logback(我们重点学习的，其他的都大同小异)</p></li><li><p>因为对Commons Logging的接口不满意，有人就搞了SLF4J。因为对Log4j的性能不满意，有人就搞了Logback。</p></li></ul><h4 id="1-3Logback概述"><a href="#1-3Logback概述" class="headerlink" title="1.3Logback概述"></a>1.3Logback概述</h4><p><strong>Logback日志框架</strong></p><ul><li><p>Logback是由log4j创始人设计的另一个开源日志组件，性能比log4j要好</p></li><li><p>官方网站：<a href="https://logback.qos.ch/index.htmlLogback">https://logback.qos.ch/index.htmlLogback</a></p></li><li><p>Logback是基于slf4j的日志规范实现的框架。</p></li></ul><p><strong>Logback主要分为三个技术模块：</strong></p><ul><li><p>logback-core： logback-core 模块为其他两个模块奠定了基础，必须有。</p></li><li><p>logback-classic：它是log4j的一个改良版本，同时它完整实现了slf4j API。</p></li><li><p>logback-access 模块与 Tomcat 和 Jetty 等 Servlet 容器集成，以提供 HTTP 访问日志功能</p></li></ul><p><strong>使用Logback需要使用哪几个模块，各自的作用是什么。</strong></p><ul><li><p><strong>slf4j-api</strong>：日志规范</p></li><li><p><strong>logback-core</strong>：基础模块。</p></li><li><p><strong>logback-classic</strong>：它是log4j的一个改良版本，同时它完整实现了slf4j API</p></li></ul><h4 id="1-4Logback快速入门-文档"><a href="#1-4Logback快速入门-文档" class="headerlink" title="1.4Logback快速入门(文档)"></a>1.4Logback快速入门(文档)</h4><p> <a href="....%5CDesktop%5CJavaSE%5Cday18%E3%80%81%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E3%80%81%E9%98%B6%E6%AE%B5%E9%A1%B9%E7%9B%AE%5C%E8%B5%84%E6%96%99%5C%E7%B1%BB%E5%BA%93%5CLogback%E7%B1%BB%E5%BA%93%5Clogback-core-1.2.3.jar">logback-core-1.2.3.jar</a> </p><p> <a href="....%5CDesktop%5CJavaSE%5Cday18%E3%80%81%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E3%80%81%E9%98%B6%E6%AE%B5%E9%A1%B9%E7%9B%AE%5C%E8%B5%84%E6%96%99%5C%E7%B1%BB%E5%BA%93%5CLogback%E7%B1%BB%E5%BA%93%5Cslf4j-api-1.7.26.jar">slf4j-api-1.7.26.jar</a> </p><p> <a href="....%5CDesktop%5CJavaSE%5Cday18%E3%80%81%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E3%80%81%E9%98%B6%E6%AE%B5%E9%A1%B9%E7%9B%AE%5C%E8%B5%84%E6%96%99%5C%E7%B1%BB%E5%BA%93%5CLogback%E7%B1%BB%E5%BA%93%5Clogback-classic-1.2.3.jar">logback-classic-1.2.3.jar</a> </p><p> <a href="....%5CDesktop%5CJavaSE%5Cday18%E3%80%81%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E3%80%81%E9%98%B6%E6%AE%B5%E9%A1%B9%E7%9B%AE%5C%E8%B5%84%E6%96%99%5C%E7%B1%BB%E5%BA%93%5Clogback.xml">logback.xml</a> </p><p>需求：</p><p>导入Logback日志技术到项目中，用于纪录系统的日志信息</p><p>分析：</p><p>①：在项目下新建文件夹lib，导入Logback的相关jar包到该文件夹下，并添加到项目依赖库中去。</p><p>②：将Logback的核心配置文件logback.xml直接拷贝到src目录下（必须是src下）。</p><p>③：在代码中获取日志的对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="string">&quot;类对象&quot;</span>);</span><br></pre></td></tr></table></figure><p>④：使用日志对象LOGGER调用其方法输出日志信息</p><p> <strong>方法详解：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">一： 1.在模块下创建一个lib包</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2.将Logbake的三个Jar文件拷贝到lib下</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3.右键Add as Library将三个Jar文件加到依赖库中</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">二：将核心配置文件logBake.xml拷贝到src目录下</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">三：在代码中获取日志对象</span></span><br><span class="line"><span class="comment">    public static final Logger LOGGER = LoggerFactory.getLogger(&quot;Test.class&quot;);                      */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">//快速搭建logBack日志框架，记录程序的执行到控制台 到文件中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="comment">//创建logBack的日志对象，代表日志技术</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="string">&quot;Test.class&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            LOGGER.debug(<span class="string">&quot;main开始了&quot;</span>);</span><br><span class="line">            LOGGER.info(<span class="string">&quot;除法&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            LOGGER.trace(<span class="string">&quot;a=&quot;</span> + a);</span><br><span class="line">            LOGGER.trace(<span class="string">&quot;b=&quot;</span> + b);</span><br><span class="line"></span><br><span class="line">            System.out.println(a / b);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            LOGGER.error(<span class="string">&quot;功能出错&quot;</span>+ e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-5Logback配置详解-输出位置、格式设置"><a href="#1-5Logback配置详解-输出位置、格式设置" class="headerlink" title="1.5Logback配置详解-输出位置、格式设置"></a>1.5Logback配置详解-输出位置、格式设置</h4><p>Logback日志系统的特性都是通过核心配置文件logback.xml控制的。</p><p><strong>Logback日志输出位置、格式设置：</strong></p><ul><li><p>通过logback.xml 中的<append>标签可以设置输出位置和日志信息的详细格式。</p></li><li><p>通常可以设置2个日志输出位置：一个是控制台、一个是系统文件中</p></li></ul><p><strong>输出到控制台的配置标志</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;appender name=<span class="string">&quot;CONSOLE&quot;</span> class=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p><strong>输出到系统文件的配置标志</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;appender name=<span class="string">&quot;FILE&quot;</span> class=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p><strong>配置文件解读：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> &lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;configuration&gt; </span><br><span class="line"></span><br><span class="line"><span class="comment">//CONSOLE ：表示当前的日志信息是可以输出到控制台的。</span></span><br><span class="line">    &lt;appender name=<span class="string">&quot;CONSOLE&quot;</span> class=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;   </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//输出流对象 默认 System.out(黑色) 改为 System.err(红色)</span></span><br><span class="line">        &lt;target&gt;System.out&lt;/target&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;encoder&gt;</span><br><span class="line">        <span class="comment">/*格式化输出：</span></span><br><span class="line"><span class="comment">       %d:表示日期，</span></span><br><span class="line"><span class="comment">       %-5level:级别[DEBUG]、[INFO ]、[TRACE],从左显示5个字符宽度</span></span><br><span class="line"><span class="comment">       %c:取类 Test.class</span></span><br><span class="line"><span class="comment">       %thread:表示线程名(方法名),如[main]</span></span><br><span class="line"><span class="comment">            %msg:日志消息打印的内容</span></span><br><span class="line"><span class="comment">         %n:是换行符</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">            &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%-5level]  %c [%thread] : %msg%n&lt;/pattern&gt;</span><br><span class="line">        &lt;/encoder&gt;</span><br><span class="line">    &lt;/appender&gt;</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------------------------------------------------------ </span><br><span class="line">             </span><br><span class="line"><span class="comment">//File是输出的方向通向文件的 </span></span><br><span class="line">    &lt;appender name=<span class="string">&quot;FILE&quot;</span> class=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span><br><span class="line">        &lt;encoder&gt;</span><br><span class="line">            &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;<span class="number">36</span>&#125; - %msg%n&lt;/pattern&gt;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//utf-8的编码形式   </span></span><br><span class="line">        &lt;charset&gt;utf-<span class="number">8</span>&lt;/charset&gt;</span><br><span class="line">        &lt;/encoder&gt;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//日志输出路径</span></span><br><span class="line">        &lt;file&gt;C:/code/itheima-data.log&lt;/file&gt;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">//指定日志文件拆分和压缩规则</span></span><br><span class="line">        &lt;rollingPolicy</span><br><span class="line">                class=<span class="string">&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy&quot;</span>&gt;</span><br><span class="line">                    </span><br><span class="line">            <span class="comment">//通过指定压缩文件名称，来确定分割文件方式</span></span><br><span class="line">            &lt;fileNamePattern&gt;C:/code/itheima-data2-%d&#123;yyyy-MMdd&#125;.log%i.gz&lt;/fileNamePattern&gt; </span><br><span class="line">                </span><br><span class="line">            <span class="comment">//文件拆分大小</span></span><br><span class="line">            &lt;maxFileSize&gt;1MB&lt;/maxFileSize&gt;</span><br><span class="line">        &lt;/rollingPolicy&gt;</span><br><span class="line">    &lt;/appender&gt;</span><br></pre></td></tr></table></figure><h4 id="1-6Logback配置详解-日志级别设置"><a href="#1-6Logback配置详解-日志级别设置" class="headerlink" title="1.6Logback配置详解-日志级别设置"></a>1.6Logback配置详解-日志级别设置</h4><p>如果系统上线后只想记录一些错误的日志信息或者不想记录日志了，怎么办？</p><p><strong>可以通过设置日志的输出级别来控制哪些日志信息输出或者不输出。</strong></p><p><strong>日志级别</strong></p><ul><li><p>级别程度依次是：TRACE&lt; DEBUG&lt; INFO&lt;WARN&lt;ERROR ; 默认级别是debug（忽略大小写），对应其方法。</p></li><li><p>作用：用于控制系统中哪些日志级别是可以输出的，只输出级别不低于设定级别的日志信息。</p></li><li><p>ALL  和 OFF分别是打开全部日志信息，及关闭全部日志信息。</p></li></ul><p><strong>具体在<root level="INFO">标签的level属性中设置日志级别</strong>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;root level=“INFO<span class="string">&quot;&gt;</span></span><br><span class="line"><span class="string">&lt;appender-ref ref=&quot;</span>CONSOLE<span class="string">&quot;/&gt;</span></span><br><span class="line"><span class="string">&lt;appender-ref ref=&quot;</span>FILE<span class="string">&quot; /&gt;</span></span><br><span class="line"><span class="string">&lt;/root&gt;</span></span><br></pre></td></tr></table></figure><p><strong>配置文件解读：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">------------------------------------------------------------------------------------------------------------ </span><br><span class="line"><span class="comment">/*    level:用来设置打印级别，大小写无关：TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR(错误日志) ,</span></span><br><span class="line"><span class="comment">ALL 和 OFF分别是打开全部日志和关闭全部日志 , 默认debug</span></span><br><span class="line"><span class="comment">    只会打印此级别及以上级别的日志</span></span><br><span class="line"><span class="comment">      root:可以包含零个或多个&lt;appender-ref&gt;元素，标识这个输出位置将会被本日志级别控制。                              */</span></span><br><span class="line">    &lt;root level=<span class="string">&quot;ALL&quot;</span>&gt;</span><br><span class="line">        &lt;appender-ref ref=<span class="string">&quot;CONSOLE&quot;</span>/&gt;  <span class="comment">//控制台开关</span></span><br><span class="line">        &lt;appender-ref ref=<span class="string">&quot;FILE&quot;</span> /&gt;   <span class="comment">//文件开关</span></span><br><span class="line">    &lt;/root&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><h3 id="2-阶段项目实战"><a href="#2-阶段项目实战" class="headerlink" title="2.阶段项目实战"></a>2.阶段项目实战</h3><p>•电影购票系统简介、项目功能演示</p><p>•日志框架搭建、系统角色分析</p><p>•首页设计、登录、商家界面、用户界面实现</p><p>•商家-详情页设计、影片上架、退出</p><p>•商家-影片下架、影片修改</p><p>•用户-展示全部影片</p><p>•用户-购票功能</p><p>•用户-评分功能</p><p>•用户-评分降序展示(学生作业)</p><p>•用户-根据片名查询全部影片信息（学生作业）</p>]]></content>
      
      
      
        <tags>
            
            <tag> java,面向对象进阶,日志框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>day16 - 不可变集合、Stream、异常、日志框架</title>
      <link href="/post/342bf346.html"/>
      <url>/post/342bf346.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-创建不可变集合"><a href="#1-创建不可变集合" class="headerlink" title="1.创建不可变集合"></a>1.创建不可变集合</h3><p><strong>什么是不可变集合？</strong></p><ul><li><p>不可变集合，就是<strong>不可被修改的集合</strong>。</p></li><li><p>l定义完成后<strong>不可以修改，或者添加、删除</strong>。</p></li><li><p>集合的数据项在创建的时候提供，并且在整个生命周期中都不可改变。否则报错。</p></li></ul><p><strong>为什么要创建不可变集合？</strong></p><ul><li><p>如果某个数据不能被修改，把它防御性地拷贝到不可变集合中是个很好的实践。</p></li><li><p>或者当集合对象被不可信的库调用时，不可变形式是安全的。</p></li></ul><p><strong>如何创建不可变集合？</strong></p><ul><li>在List、Set、Map接口中，都存在of方法，可以创建一个不可变的集合。</li></ul><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>static  <E> List<E> of(E…elements)</td><td>创建一个具有指定元素的List集合对象</td></tr><tr><td>static  <E> Set<E> of(E…elements)</td><td>创建一个具有指定元素的Set集合对象</td></tr><tr><td>static &lt;K  , V&gt;  Map&lt;K，V&gt; of(E…elements)</td><td>创建一个具有指定元素的Map集合对象</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//List集合</span></span><br><span class="line">       List&lt;Double&gt; liets = List.of(<span class="number">150.2</span>,<span class="number">598.4</span>);</span><br><span class="line">       <span class="comment">//liets.add(585.3); //不可添加</span></span><br><span class="line">       System.out.println(liets);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//Set集合</span></span><br><span class="line">       Set&lt;String&gt; sets = Set.of(<span class="string">&quot;Java&quot;</span>,<span class="string">&quot;javaSE&quot;</span>);</span><br><span class="line">       <span class="comment">//sets.add(&quot;Java1&quot;); //不可添加</span></span><br><span class="line">       System.out.println(sets);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//Map集合</span></span><br><span class="line">       Map&lt;String,Integer&gt; maps = Map.of(<span class="string">&quot;Java&quot;</span>,<span class="number">100</span>);</span><br><span class="line">       <span class="comment">//maps.put(&quot;C语言&quot;,100); //不可添加</span></span><br><span class="line">       System.out.println(maps);</span><br></pre></td></tr></table></figure><h3 id="2-Stream流"><a href="#2-Stream流" class="headerlink" title="2.Stream流"></a>2.Stream流</h3><h4 id="2-1Stream流的概述"><a href="#2-1Stream流的概述" class="headerlink" title="2.1Stream流的概述"></a>2.1Stream流的概述</h4><p><strong>什么是Stream流？</strong></p><ul><li><p>在Java 8中，得益于Lambda所带来的函数式编程， 引入了一个全新的Stream流概念。</p></li><li><p><strong>目的：用于简化集合和数组操作的API。</strong></p></li></ul><p><strong>Stream流思想</strong></p><p><strong>Stream流式思想的核心：</strong></p><p>1.先得到集合或者数组的Stream流（就是一根传送带）</p><p>2.把元素放上去</p><p>3.然后就用这个Stream流简化的API来方便的操作元素。</p><p><strong>体验Stream流的作用</strong></p><p>需求：</p><p>按照下面的要求完成集合的创建和遍历</p><ul><li><p>创建一个集合，存储多个字符串元素</p></li><li><p>把集合中所有以”张”开头的元素存储到一个新的集合</p></li><li><p>把”张”开头的集合中的长度为3的元素存储到一个新的集合</p></li><li><p>遍历上一步得到的集合中的元素输出。</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建集合</span></span><br><span class="line">List&lt;String&gt; names = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(names,<span class="string">&quot;雷柏&quot;</span>,<span class="string">&quot;帕克&quot;</span>,<span class="string">&quot;凯萨文&quot;</span>,<span class="string">&quot;凯撒&quot;</span>,<span class="string">&quot;迪奥&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">//创建kailist集合，储存以&quot;凯&quot;开头的元素</span></span><br><span class="line"><span class="comment">//        List&lt;String&gt; kailist = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">//        for (String name : names)&#123;</span></span><br><span class="line"><span class="comment">//            if (name.startsWith(&quot;凯&quot;))&#123;</span></span><br><span class="line"><span class="comment">//                kailist.add(name);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        System.out.println(kailist);</span></span><br><span class="line">          <span class="comment">//创建kaithree集合，储存&quot;张&quot;开头的集合中的长度为3的元素</span></span><br><span class="line"><span class="comment">//        List&lt;String&gt; kaithree = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">//        for (String name : kailist) &#123;</span></span><br><span class="line"><span class="comment">//            if (name.length() == 3)&#123;</span></span><br><span class="line"><span class="comment">//                kaithree.add(name);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        System.out.println(kaithree);</span></span><br><span class="line"><span class="comment">//总结：操作繁琐</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用Stream流</span></span><br><span class="line">        names.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;凯&quot;</span>)).filter(s -&gt; s.length() == <span class="number">3</span>).forEach(s -&gt; System.out.println(s));  <span class="comment">//凯萨文</span></span><br><span class="line"><span class="comment">//总结：迅捷高效</span></span><br></pre></td></tr></table></figure><h4 id="2-2Stream流的获取"><a href="#2-2Stream流的获取" class="headerlink" title="2.2Stream流的获取"></a>2.2Stream流的获取</h4><p><strong>Stream流的三类方法</strong></p><ul><li><p><strong>获取Stream流</strong></p><ul><li>创建一条流水线，并把数据放到流水线上准备进行操作</li></ul></li><li><p><strong>中间方法</strong></p><ul><li>流水线上的操作。一次操作完毕之后，还可以继续进行其他操作。</li></ul></li><li><p><strong>终结方法</strong></p><ul><li>一个Stream流只能有一个终结方法，是流水线上的最后一个操作</li></ul></li></ul><p><strong>Stream操作集合或者数组的第一步是先得到Stream流，然后才能使用流的功能。</strong></p><p><strong>【集合】获取Stream流的方式</strong></p><ul><li>可以使用Collection接口中的默认方法stream()生成流</li></ul><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>default  Stream<E> stream()</td><td>获取当前集合对象的Stream流</td></tr></tbody></table><p> <strong>【数组】获取Stream流的方式</strong></p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>public  static <T>  Stream<T>  stream(T[]  array)  &#x2F;&#x2F;Arrays.stream()</td><td>获取当前数组的Stream流</td></tr><tr><td>public  static<T>  Stream<T>  of(T…  values)  &#x2F;&#x2F;Stream.of()</td><td>获取当前数组&#x2F;可变数据的Stream流</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Collection集合获取Stream流</span></span><br><span class="line">Collection&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Stream&lt;String&gt; s = list.stream();</span><br><span class="line"></span><br><span class="line"><span class="comment">//Map集合获取Stream流</span></span><br><span class="line">Map&lt;String, Integer&gt; maps = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//键流</span></span><br><span class="line">Stream&lt;String&gt; mapsStream = maps.keySet().stream();</span><br><span class="line"><span class="comment">//值流</span></span><br><span class="line">Stream&lt;Integer&gt; valuesStream = maps.values().stream();</span><br><span class="line"><span class="comment">//键值对流</span></span><br><span class="line">Stream&lt;Map.Entry&lt;String,Integer&gt;&gt; kAndv = maps.entrySet().stream();</span><br><span class="line"></span><br><span class="line"><span class="comment">//集合集合获取Stream流</span></span><br><span class="line">String[] names = &#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>&#125;; <span class="comment">//首先获取集合对象</span></span><br><span class="line">Stream&lt;String&gt; Arr = Arrays.stream(names); <span class="comment">//方法一</span></span><br><span class="line">Stream&lt;String&gt; Arr = Stream.of(names);  <span class="comment">//方法二</span></span><br></pre></td></tr></table></figure><h4 id="2-3Stream流的常用API"><a href="#2-3Stream流的常用API" class="headerlink" title="2.3Stream流的常用API"></a>2.3Stream流的常用API</h4><p><strong>Stream流的常用API(中间操作方法)</strong></p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>Stream<T>  <strong>filter</strong>(Predicate&lt;?  super  T&gt;  predicate)</td><td>用于对流中的数据进行<strong>过滤。</strong></td></tr><tr><td>Stream<T>  <strong>limit</strong>(long maxSize)</td><td>获取前几个元素</td></tr><tr><td>Stream<T>  <strong>skip</strong>(long n)</td><td>跳过前几个元素</td></tr><tr><td>Stream<T>  <strong>distinct</strong>()</td><td><strong>去除流中重复的元素</strong>。依赖(hashCode和equals方法)</td></tr><tr><td>static  <T> Stream<T> <strong>concat</strong>(Stream  a, Stream b)</td><td><strong>合并a和b</strong>两个流为一个流</td></tr></tbody></table><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//forEach:逐个遍历</span></span><br><span class="line"><span class="comment">//count:统计个数</span></span><br><span class="line"><span class="comment">//filter:过滤元素</span></span><br><span class="line"><span class="comment">//limit:取前几个元素</span></span><br><span class="line"><span class="comment">//skip:跳过前几个</span></span><br><span class="line"><span class="comment">//map:加工方法</span></span><br><span class="line"><span class="comment">//concat:合并流</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;张无忌&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;雷柏&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;帕克&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;凯萨文&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;凯撒&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;迪奥&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取姓凯的元素</span></span><br><span class="line">        list.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;凯&quot;</span>)).forEach(s -&gt; System.out.println(s)); <span class="comment">//凯萨文 凯撒</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//count:统计姓凯的个数</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> list.stream().filter(s -&gt; s.length() ==<span class="number">3</span>).count();</span><br><span class="line">        System.out.println(size); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//limit:取前1个姓凯的元素</span></span><br><span class="line">        list.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;凯&quot;</span>)).limit(<span class="number">1</span>).forEach(s -&gt; System.out.println(s)); <span class="comment">//凯萨文</span></span><br><span class="line">        <span class="comment">//list.stream().filter(s -&gt; s.startsWith(&quot;凯&quot;)).limit(1).forEach(System.out::println); // 两个参数相同是可简化</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//skip:跳过前1个姓凯的元素</span></span><br><span class="line">        list.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;凯&quot;</span>)).skip(<span class="number">1</span>).forEach(System.out::println);  <span class="comment">//凯撒</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//map:加工方法</span></span><br><span class="line">        list.stream().map(s -&gt; <span class="string">&quot;中国的&quot;</span> + s).forEach(s -&gt; System.out.println(s)); <span class="comment">//中国的xx</span></span><br><span class="line">        <span class="comment">//需求：把所有名称 都加工成一个学生对象</span></span><br><span class="line">        <span class="comment">//1.创建一个学生类</span></span><br><span class="line">        <span class="comment">//2.使用Stream的map加工方法</span></span><br><span class="line">        list.stream().map(s -&gt; <span class="keyword">new</span> <span class="title class_">Student</span>).forEach(s -&gt; System.out.println(s));</span><br><span class="line">        <span class="comment">//list.stream().map(Student::new).forEach(s -&gt; System.out.println(s)); //构造器引用  //方法引用</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//concat:合并流</span></span><br><span class="line">        Stream&lt;String&gt; s1 = list.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;凯&quot;</span>));</span><br><span class="line">        Stream&lt;String&gt; s2 = Stream.of(<span class="string">&quot;java&quot;</span>,<span class="string">&quot;java1&quot;</span>);</span><br><span class="line">        Stream&lt;String&gt; s3 = Stream.concat(s1 , s2);</span><br><span class="line">        s3.forEach(s -&gt; System.out.println(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li><p><strong><em>中间方法</em>，也称为非终结方法，调用完成后返回新的Stream流可以继续使用，支持链式编程</strong>。</p></li><li><p><strong>在Stream流中无法直接修改集合、数组中的数据。</strong></p></li></ul><p><strong>Stream流的常见终结操作方法</strong></p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>void  forEach(Consumer  action)</td><td>对此流的每个元素执行遍历操作</td></tr><tr><td>long count()</td><td>返回此流中的元素数</td></tr></tbody></table><p><strong>注意：<em>终结操作方法</em>，调用完成后流就无法继续使用了，原因是不会返回Stream了。</strong></p><h4 id="2-4Stream流的综合应用"><a href="#2-4Stream流的综合应用" class="headerlink" title="2.4Stream流的综合应用"></a>2.4Stream流的综合应用</h4><p><strong>案例标题</strong></p><p>需求：</p><p>某个公司的开发部门，分为开发一部和二部，现在需要进行年中数据结算。</p><p>分析：</p><p>①：员工信息至少包含了(名称、性别、工资、奖金、处罚记录)</p><p>②：开发一部有4个员工、开发二部有5名员工</p><p>③：分别筛选出2个部门的最高工资的员工信息，封装成优秀员工对象Topperformer</p><p>④：分别统计出2个部门的平均月收入，要求去掉最高和最低工资。</p><p>⑤：统计2个开发部门整体的平均工资，去掉最低和最高工资的平均值。</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建公司员工对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span> sex;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> salary;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> bonus;</span><br><span class="line">    <span class="keyword">private</span> String punish;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String name, <span class="type">char</span> sex, <span class="type">double</span> salary, <span class="type">double</span> bonus, String punish)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">        <span class="built_in">this</span>.salary = salary;</span><br><span class="line">        <span class="built_in">this</span>.bonus = bonus;</span><br><span class="line">        <span class="built_in">this</span>.punish = punish;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">getSex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSex</span><span class="params">(<span class="type">char</span> sex)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getSalary</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSalary</span><span class="params">(<span class="type">double</span> salary)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getBonus</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bonus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBonus</span><span class="params">(<span class="type">double</span> bonus)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bonus = bonus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPunish</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> punish;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPunish</span><span class="params">(String punish)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.punish = punish;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建公司优秀员工对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Topperformer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> money;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Topperformer</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Topperformer</span><span class="params">(String name, <span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getMoney</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMoney</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Topperformer&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, money=&quot;</span> + money +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义静态变量，储存剩余员工的工资总和(静态变量可以共享)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> allmoney; <span class="comment">//一个部门去除最高工资和最低工资的总和</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> allmoney2; <span class="comment">//两个部门去除最高工资和最低工资的总和</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注意：使用get()取出对象</span></span><br><span class="line"></span><br><span class="line">        List&lt;Employee&gt; one = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        one.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;猪八戒&quot;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="number">30000</span>, <span class="number">25000</span>, <span class="literal">null</span>));</span><br><span class="line">        one.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;孙悟空&quot;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="number">25000</span>, <span class="number">1000</span>, <span class="string">&quot;顶撞上司&quot;</span>));</span><br><span class="line">        one.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;沙僧&quot;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="number">20000</span>, <span class="number">20000</span>, <span class="literal">null</span>));</span><br><span class="line">        one.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;小白龙&quot;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="number">20000</span>, <span class="number">25000</span>, <span class="literal">null</span>));</span><br><span class="line"></span><br><span class="line">        List&lt;Employee&gt; two = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        two.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;武松&quot;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="number">15000</span>, <span class="number">9000</span>, <span class="literal">null</span>));</span><br><span class="line">        two.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;李逵&quot;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="number">20000</span>, <span class="number">10000</span>, <span class="literal">null</span>));</span><br><span class="line">        two.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;西门庆&quot;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="number">50000</span>, <span class="number">100000</span>, <span class="string">&quot;被打&quot;</span>));</span><br><span class="line">        two.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;潘金莲&quot;</span>, <span class="string">&#x27;女&#x27;</span>, <span class="number">3500</span>, <span class="number">1000</span>, <span class="string">&quot;被打&quot;</span>));</span><br><span class="line">        two.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;武大郎&quot;</span>, <span class="string">&#x27;女&#x27;</span>, <span class="number">20000</span>, <span class="number">0</span>, <span class="string">&quot;下毒&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.开发一部最高工资的员工</span></span><br><span class="line">        <span class="comment">//指定大小规则，对每个对象进行比较</span></span><br><span class="line"><span class="comment">//        Employee e = one.stream().max((e1 , e2) -&gt; Double.compare(e1.getSalary() + e1.getBonus(), e2.getSalary() + e2.getBonus())).get();</span></span><br><span class="line"><span class="comment">//        System.out.println(e);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//加工方法，将最佳员工加工成一个对象</span></span><br><span class="line">        <span class="type">Topperformer</span> <span class="variable">t</span> <span class="operator">=</span> one.stream().max((e1, e2) -&gt; Double.compare(e1.getSalary() + e1.getBonus(), e2.getSalary() + e2.getBonus()))</span><br><span class="line">                .map(e -&gt; <span class="keyword">new</span> <span class="title class_">Topperformer</span>(e.getName(), e.getSalary() + e.getBonus())).get();</span><br><span class="line">        System.out.println(t);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.统计平均工资：去除最高工资和最低工资</span></span><br><span class="line">        <span class="comment">//开发一部</span></span><br><span class="line">        one.stream().sorted((e1, e2) -&gt; Double.compare(e1.getSalary() + e1.getBonus(), e2.getSalary() + e2.getBonus()))</span><br><span class="line">                .skip(<span class="number">1</span>).limit(one.size() - <span class="number">2</span>).forEach(e -&gt; &#123;</span><br><span class="line">                    <span class="comment">//求综合：剩余员工的工资总和</span></span><br><span class="line">                    allmoney += (e.getSalary() + e.getBonus());</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;开发一部的平均工资是：&quot;</span> + allmoney / (one.size() - <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.合并两个集合流，在统计</span></span><br><span class="line">        Stream&lt;Employee&gt; s1 = one.stream();</span><br><span class="line">        Stream&lt;Employee&gt; s2 = two.stream();</span><br><span class="line">        Stream&lt;Employee&gt; s3 = Stream.concat(s1 , s2);</span><br><span class="line">        s3.sorted((e1, e2) -&gt; Double.compare(e1.getSalary() + e1.getBonus(), e2.getSalary() + e2.getBonus()))</span><br><span class="line">                .skip(<span class="number">1</span>).limit(one.size() + two.size() - <span class="number">2</span>).forEach(e -&gt; &#123;</span><br><span class="line">                    <span class="comment">//求总和：剩余员工的工资总和</span></span><br><span class="line">                    allmoney2 += (e.getSalary() + e.getBonus());</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//可以使用BigDecimal解决精度</span></span><br><span class="line">        System.out.println(<span class="string">&quot;开发部的平均工资是：&quot;</span> + allmoney2 / (one.size() + two.size() - <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-5收集Stream流"><a href="#2-5收集Stream流" class="headerlink" title="2.5收集Stream流"></a>2.5收集Stream流</h4><p><strong>Stream流的收集操作</strong></p><ul><li><p><strong>收集Stream流的含义</strong>：<strong>就是把Stream流操作后的结果数据转回到集合或者数组中去。</strong></p></li><li><p>Stream流：方便操作集合&#x2F;数组的<strong>手段。</strong></p></li><li><p>集合&#x2F;数组：才是开发中的<strong>目的</strong>。</p></li></ul><p><strong>Stream流的收集方法</strong></p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>R collect(Collector collector)</td><td>开始收集Stream流，指定收集器</td></tr></tbody></table><p><strong>Collectors工具类提供了具体的收集方式</strong></p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>public static <T> Collector toList()</td><td>把元素收集到List集合中</td></tr><tr><td>public static <T> Collector toSet()</td><td>把元素收集到Set集合中</td></tr><tr><td>public static Collector toMap(Function keyMapper  , Function valueMapper)</td><td>把元素收集到Map集合中</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="string">&quot;张无忌&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;雷柏&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;帕克&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;凯萨文&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;凯撒&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;迪奥&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//注意：流只能使用一次</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//收集到List集合</span></span><br><span class="line">    Stream&lt;String&gt; s1 = list.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;凯&quot;</span>));</span><br><span class="line">    List&lt;String&gt; kai1 = s1.collect(Collectors.toList());</span><br><span class="line">    System.out.println(kai1);  <span class="comment">//[凯萨文, 凯撒]</span></span><br><span class="line">    <span class="comment">//toList();JDK16可以使用，是不可变集合</span></span><br><span class="line">    List&lt;String&gt; list1 = s1.toList();</span><br><span class="line">    System.out.println(list1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//收集到Set集合</span></span><br><span class="line">    Stream&lt;String&gt; s2 = list.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;凯&quot;</span>));</span><br><span class="line">    Set&lt;String&gt; kai2 = s2.collect(Collectors.toSet());</span><br><span class="line">    System.out.println(kai2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//收集到数组中</span></span><br><span class="line">    Stream&lt;String&gt; s3 = list.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;凯&quot;</span>));</span><br><span class="line">    Object[] arrs1 = s3.toArray(); <span class="comment">//储存任意类型</span></span><br><span class="line">    System.out.println(Arrays.toString(arrs1));</span><br><span class="line"></span><br><span class="line">    String[] arrs2 = s3.toArray(s -&gt; <span class="keyword">new</span> <span class="title class_">String</span>[s]); <span class="comment">//储存String类型</span></span><br><span class="line">    <span class="comment">//String[] arrs2 = s3.toArray(String[s]::new); //简化</span></span><br><span class="line">    System.out.println(Arrays.toString(arrs2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-异常处理"><a href="#3-异常处理" class="headerlink" title="3.异常处理"></a>3.异常处理</h3><h4 id="3-1异常概述、体系"><a href="#3-1异常概述、体系" class="headerlink" title="3.1异常概述、体系"></a>3.1异常概述、体系</h4><p><strong>什么是异常？</strong></p><ul><li><p>异常是程序在“编译”或者“执行”的过程中可能出现的问题，<strong>注意：</strong>语法错误不算在异常体系中。 </p></li><li><p>比如:数组索引越界、空指针异常、 日期格式化异常，等…</p></li></ul><p><strong>为什么要学习异常?</strong></p><ul><li>异常一旦出现了，如果没有提前处理，程序就会退出JVM虚拟机而终止.</li><li>研究异常并且避免异常，然后提前处理异常，体现的是程序的安全, 健壮性。</li></ul><p><strong>异常体系</strong></p><ol><li><strong>Throwable类：</strong> Throwable是Java异常体系的根类，它有两个主要的子类，即Error和Exception。</li><li><strong>Error类：</strong> Error表示系统级别的错误，通常是由于虚拟机运行环境出现了严重问题导致的，例如内存溢出（OutOfMemoryError）、线程死锁等。程序一般无法捕获或处理Error，因为它们通常表示无法恢复的问题。</li><li><strong>Exception类：</strong> Exception是可以被程序捕获和处理的异常类型。Exception分为两类，分别是运行时异常（RuntimeException及其子类）和编译时异常（其他Exception及其子类）。<ul><li><strong>运行时异常（RuntimeException）：</strong> 运行时异常是指在程序运行过程中可能会出现，但不是必然出现的异常，如空指针异常（NullPointerException）、数组下标越界异常（ArrayIndexOutOfBoundsException）、算术异常（ArithmeticException）等。这些异常可以通过编写良好的代码和检查来避免，但在程序运行时可能仍然会发生。</li><li><strong>编译时异常：</strong> 编译时异常是指在编写代码时必须处理的异常，否则代码无法通过编译。这些异常主要是IOException及其子类、SQLException等。处理编译时异常通常需要使用try-catch块或者在方法上声明throws子句来传递异常。</li></ul></li></ol><p><strong>Error：</strong></p><ul><li>系统级别问题、JVM退出等，代码无法控制。</li></ul><p><strong>Exception</strong>：java.lang包下，称为异常类，它表示程序本身可以处理的问题</p><ul><li><p><strong>RuntimeException及其子类</strong>：<strong>运行时异常</strong>，编译阶段不会报错。 (空指针异常，数组索引越界异常) </p></li><li><p><strong>除RuntimeException之外所有的异常</strong>：<strong>编译时异常</strong>，编译期必须处理的，否则程序不能通过编译。 (日期格式化异常)。</p></li></ul><p><strong>编译时异常和运行时异常</strong></p><ol><li><strong>编译时异常（Checked Exception）</strong>： 编译时异常是在编译阶段由编译器强制检查的异常。如果一个方法可能会引发编译时异常，那么该方法的调用者必须在代码中显式处理这些异常，以确保程序在运行时不会出现未处理的异常情况。通常，编译时异常是派生自Exception类（但不是RuntimeException类）的异常。</li><li><strong>运行时异常（Unchecked Exception）</strong>： 运行时异常是在运行时阶段才会被检测到的异常，通常由程序的逻辑错误或bug引起。与编译时异常不同，调用者不需要在代码中显式地处理运行时异常，但仍然可以选择捕获并处理它们。运行时异常通常是派生自RuntimeException类的异常。</li></ol><h4 id="3-2常见运行时异常"><a href="#3-2常见运行时异常" class="headerlink" title="3.2常见运行时异常"></a>3.2常见运行时异常</h4><p><strong>运行时异常</strong></p><ul><li>**直接继承自RuntimeException或者其子类</li><li>编译阶段不会报错，运行时可能出现的错误</li></ul><p><strong>运行时异常示例</strong></p><ul><li><p>数组索引越界异常: ArrayIndexOutOfBoundsException</p></li><li><p>空指针异常 : NullPointerException，直接输出没有问题，但是调用空指针的变量的功能就会报错。</p></li><li><p>数学操作异常：ArithmeticException</p></li><li><p>类型转换异常：ClassCastException</p></li><li><p>数字转换异常： NumberFormatException</p></li></ul><p><strong>运行时异常：一般是程序员业务没有考虑好或者是编程逻辑不严谨引起的程序错误，自己的水平有问题！</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">         <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">         <span class="comment">//1.数组索引越界异常</span></span><br><span class="line"><span class="comment">//        System.out.println(arr[3]);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.空指针异常</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="comment">//        System.out.println(name.length()); //运行出错，程序终止</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.类型转换异常</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="number">23</span>;</span><br><span class="line"><span class="comment">//        String s = (String) o;  //运行出错，程序终止</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.数学操作异常</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">10</span> / <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.数字转化异常</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">num</span> <span class="operator">=</span> <span class="string">&quot;23aabbcc&quot;</span>;</span><br><span class="line"><span class="comment">//        Integer it = Integer.valueOf(num);</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-3常见编译时异常"><a href="#3-3常见编译时异常" class="headerlink" title="3.3常见编译时异常"></a>3.3常见编译时异常</h4><p><strong>编译时异常</strong></p><ul><li><strong>继承自Exception的异常或者其子类</strong></li><li>编译阶就报错，必须处理，否则代码不通过。</li></ul><p><strong>编译时异常的作用是什么：</strong></p><ul><li><p>是担心程序员的技术不行，在编译阶段就爆出一个错误, <strong>目的在于提醒不要出错!</strong></p></li><li><p>编译时异常是可遇不可求。遇到了就遇到了呗。</p></li></ul><p><strong>编译时异常示例</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> <span class="string">&quot;2015-01-12 10:23:21&quot;</span>;</span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"><span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> sdf.parse(date);  <span class="comment">//日期解析异常：ParseException</span></span><br><span class="line">System.out.println(d);</span><br></pre></td></tr></table></figure><h4 id="3-4异常的默认处理流程"><a href="#3-4异常的默认处理流程" class="headerlink" title="3.4异常的默认处理流程"></a>3.4异常的默认处理流程</h4><p><strong>默认异常处理机制</strong></p><ul><li><strong>默认的异常处理机制并不好，一旦真的出现异常，程序立即死亡！</strong></li></ul><p>①默认会在出现异常的代码那里自动的创建一个异常对象：ArithmeticException。</p><p>②异常会从方法中出现的点这里抛出给调用者，调用者最终抛出给JVM虚拟机。</p><p>③虚拟机接收到异常对象后，先在控制台直接输出异常栈信息数据。</p><p>④直接从当前执行的异常点干掉当前程序。</p><p>⑤后续代码没有机会执行了，因为程序已经死亡。</p><h4 id="3-5可干涉的处理机制"><a href="#3-5可干涉的处理机制" class="headerlink" title="3.5可干涉的处理机制"></a>3.5可干涉的处理机制</h4><p>编译时异常是编译阶段就出错的，所以必须处理，否则代码根本无法通过</p><p><strong>编译时异常的处理形式有三种：</strong></p><ul><li><p>出现异常直接抛出去给调用者，调用者也继续抛出去。</p></li><li><p>出现异常自己捕获处理，不麻烦别人。</p></li><li><p>前两者结合，出现异常直接抛出去给调用者，调用者捕获处理。</p></li></ul><h5 id="3-1编译时异常的处理机制"><a href="#3-1编译时异常的处理机制" class="headerlink" title="3..1编译时异常的处理机制"></a>3..1编译时异常的处理机制</h5><p><strong>异常处理方式1 —— throws</strong></p><ul><li><p>throws：用在方法上，可以将方法内部出现的异常抛出去给本方法的调用者处理。</p></li><li><p>这种方式并不好，发生异常的方法自己不处理异常，如果异常最终抛出去给虚拟机将引起程序死亡。</p></li></ul><p><strong>抛出异常格式：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方法 <span class="keyword">throws</span> 异常<span class="number">1</span> ，异常<span class="number">2</span> ，异常<span class="number">3</span> ..&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>规范做法</strong>： </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方法 <span class="keyword">throws</span> Exception&#123;  <span class="comment">//代表可以抛出一切异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>异常处理方式2—— try…catch…</strong></p><ul><li><p>监视捕获异常，用在方法内部，可以将方法内部出现的异常直接捕获处理。</p></li><li><p>这种方式还可以，发生异常的方法自己独立完成异常的处理，程序可以继续往下执行。</p></li></ul><p><strong>格式：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">// 监视可能出现异常的代码！</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span> 变量)&#123;</span><br><span class="line"><span class="comment">// 处理异常</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(异常类型<span class="number">2</span> 变量)&#123;</span><br><span class="line"><span class="comment">// 处理异常</span></span><br><span class="line">&#125;...</span><br></pre></td></tr></table></figure><p><strong>建议格式：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">// 可能出现异常的代码！</span></span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;  <span class="comment">//Exception可以捕获处理一切异常类型！</span></span><br><span class="line">e.printStackTrace(); <span class="comment">// 直接打印异常栈信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**异常处理方式3 **—— <strong>前两者结合</strong></p><ul><li><p>方法直接将异通过throws抛出去给调用者</p></li><li><p>调用者收到异常后直接捕获处理。</p></li></ul><p><strong>异常处理的总结</strong></p><ul><li><p><strong>在开发中按照规范来说第三种方式是最好的：底层的异常抛出去给最外层，最外层集中捕获处理。</strong></p></li><li><p><strong>实际应用中，只要代码能够编译通过，并且功能能完成，那么每一种异常处理方式似乎也都是可以的。</strong></p></li></ul><h5 id="3-5-2运行时异常的处理机制"><a href="#3-5-2运行时异常的处理机制" class="headerlink" title="3.5.2运行时异常的处理机制"></a>3.5.2运行时异常的处理机制</h5><p><strong>运行时异常的处理形式</strong></p><ul><li><p>运行时异常编译阶段不会出错，是运行时才可能出错的，所以编译阶段不处理也可以。</p></li><li><p>按照规范建议还是处理：建议在最外层调用处集中捕获处理即可。</p></li></ul><h4 id="3-6异常处理使代码更稳健的案例"><a href="#3-6异常处理使代码更稳健的案例" class="headerlink" title="3.6异常处理使代码更稳健的案例"></a>3.6异常处理使代码更稳健的案例</h4><p><strong>需求</strong></p><p>键盘录入一个合理的价格为止（必须是数值，值必须大于0）。</p><p><strong>分析</strong></p><p>定义一个死循环，让用户不断的输入价格。</p><h4 id="3-7自定义异常"><a href="#3-7自定义异常" class="headerlink" title="3.7自定义异常"></a>3.7自定义异常</h4><p><strong>自定义异常的必要？</strong></p><ul><li><p>Java无法为这个世界上全部的问题提供异常类。</p></li><li><p>如果企业想通过异常的方式来管理自己的某个业务问题，就需要自定义异常类了。</p></li></ul><p><strong>自定义异常的好处：</strong></p><ul><li><p>可以使用异常的机制管理业务问题，如提醒程序员注意。</p></li><li><p>同时一旦出现bug，可以用异常的形式清晰的指出出错的地方。</p></li></ul><p><strong>自定义异常的分类</strong></p><p><strong>1、自定义编译时异常</strong>    </p><ul><li><p>定义一个异常类继承Exception.</p></li><li><p>重写构造器。</p></li><li><p>在出现异常的地方用throw new 自定义对象抛出，</p></li></ul><p><strong>作用</strong>：编译时异常是编译阶段就报错，提醒更加强烈，一定需要处理！！</p><p><strong>2、自定义运行时异常</strong></p><ul><li><p>定义一个异常类继承RuntimeException.</p></li><li><p>重写构造器。</p></li><li><p>在出现异常的地方用throw new 自定义对象抛出!</p></li></ul><p><strong>作用：</strong>提醒不强烈，编译阶段不报错！！运行时才可能出现！！</p><p>需求：</p><p>创建一个编译异常，判断年龄合法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一步.自定义的编译异常</span></span><br><span class="line"><span class="comment">//1.继承Exception</span></span><br><span class="line"><span class="comment">//2.重写构造器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ItheimaAgeIlleagalException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ItheimaAgeIlleagalException</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ItheimaAgeIlleagalException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);  <span class="comment">//message异常提醒</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第二步</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            checkAge(-<span class="number">35</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ItheimaAgeIlleagalException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//年龄合法的判断方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkAge</span><span class="params">(<span class="type">int</span> age)</span> <span class="keyword">throws</span> ItheimaAgeIlleagalException &#123;</span><br><span class="line">        <span class="keyword">if</span> (age &lt; <span class="number">0</span> || age &gt;<span class="number">200</span>)&#123;</span><br><span class="line">            <span class="comment">//抛出去一个异常对象给调用者</span></span><br><span class="line">            <span class="comment">//throo: 在方法内部直接创建一个异常对象，并从此抛出</span></span><br><span class="line">            <span class="comment">//throos: 用在方法申明上的，抛出方法内部异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ItheimaAgeIlleagalException</span>(age + <span class="string">&quot; is illeagal!&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;年龄合法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> java,面向对象进阶,不可变集合,Stream,异常,日志框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>day15 - 集合</title>
      <link href="/post/4e9f6bc.html"/>
      <url>/post/4e9f6bc.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-Set系列集合"><a href="#1-Set系列集合" class="headerlink" title="1.Set系列集合"></a>1.Set系列集合</h3><h4 id="1-1Set系列集系概述"><a href="#1-1Set系列集系概述" class="headerlink" title="1.1Set系列集系概述"></a>1.1Set系列集系概述</h4><p><strong>Set系列集合特点</strong></p><ul><li><p>无序：存取顺序不一致(只能无序一次)</p></li><li><p>不重复：可以去除重复</p></li><li><p>无索引：没有带索引的方法，所以不能使用普通for循环遍历，也不能通过索引来获取元素。</p></li></ul><p><strong>Set集合 实现类特点</strong></p><ul><li>HashSet : 无序、不重复、无索引。<ul><li>LinkedHashSet：<strong>有序</strong>、不重复、无索引。</li></ul></li><li>TreeSet：<strong>可排序</strong>、不重复、无索引。</li></ul><p><strong>Set集合的功能上基本上与Collection的API一致。</strong></p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//看看Set系列集合的特点： HashSet LinkedHashSet TreeSet</span></span><br><span class="line"><span class="comment">//经典代码写法</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//无序 不重复 无索引</span></span><br><span class="line">    Set&lt;String&gt; sets = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(); </span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 有序 不重复 无索引</span></span><br><span class="line">    Set&lt;String&gt; sets = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(); </span><br><span class="line"></span><br><span class="line"> <span class="comment">// 可排序 不重复 无索引</span></span><br><span class="line">    Set&lt;String&gt; sets = newTreeSet&lt;&gt;(); </span><br></pre></td></tr></table></figure><h4 id="1-2HashSet实现类-无序的底层原理：哈希表"><a href="#1-2HashSet实现类-无序的底层原理：哈希表" class="headerlink" title="1.2HashSet实现类  无序的底层原理：哈希表"></a>1.2HashSet实现类  无序的底层原理：哈希表</h4><p><strong>HashSet底层原理</strong></p><ul><li><p>HashSet集合底层采取<strong>哈希表</strong>存储的数据。</p></li><li><p>哈希表是一种对于增删改查数据性能都较好的结构。</p></li></ul><p><strong>哈希表的组成</strong></p><ul><li><p>JDK8之前的，底层使用<strong>数组+链表</strong>组成</p></li><li><p>JDK8开始后，底层采用<strong>数组+链表+红黑树</strong>组成。</p></li></ul><p>在了解哈希表之前需要先理解哈希值的概念</p><p><strong>哈希值</strong></p><ul><li>是JDK根据对象的<strong>地址</strong>，按照某种规则算出来的int类型的<strong>数值</strong>。</li></ul><p><strong>Object类的API</strong></p><ul><li>public int <strong>hashCode</strong>()：<strong>返回对象的哈希值</strong></li></ul><p><strong>对象的哈希值特点</strong></p><ul><li><p>同一个对象多次调用hashCode()方法返回的哈希值是相同的</p></li><li><p>默认情况下，不同对象的哈希值是不同的。</p></li></ul><p><strong>HashSet1.7版本原理解析：数组 + 链表 +（结合哈希算法）</strong></p><p><img src="C:\Users\廖永森\AppData\Roaming\Typora\typora-user-images\image-20220203172311069.png" alt="image-20220203172311069"></p><ul><li><p>①创建一个默认长度16的数组，数组名table</p></li><li><p>②根据元素的哈<strong>希值跟数组的长度求余</strong>计算出应存入的位置（哈希算法）</p></li><li><p>③判断当前位置是否为null，如果是null直接存入</p></li><li><p>④如果位置不为null，表示有元素，则调用equals方法比较</p></li><li><p>⑤如果一样，则不存，如果不一样，则存入数组，</p><ul><li><p>JDK 7新元素占老元素位置，指向老元素</p></li><li><p>JDK 8中新元素挂在老元素下面</p></li></ul></li><li><p>当数组存满到16\0.75&#x3D;12时，就自动扩容，每次扩容原先的两倍</p></li></ul><p><strong>结论：哈希表是一种对于增删改查数据性能都较好的结构。</strong></p><p><strong>JDK1.8版本开始HashSet原理解析</strong></p><ul><li><p>底层结构：哈希表（<strong>数组、链表、红黑树的结合体</strong>）</p></li><li><p>当挂在元素下面的数据过多时，查询性能降低，从JDK8开始后，当链表长度超过<strong>8</strong>的时候，自动转换为红黑树。</p></li></ul><p><img src="C:\Users\廖永森\AppData\Roaming\Typora\typora-user-images\image-20220203172738241.png" alt="image-20220203172738241"></p><p><img src="C:\Users\廖永森\AppData\Roaming\Typora\typora-user-images\image-20220203172802501.png" alt="image-20220203172802501"></p><p><strong>结论：JDK8开始后，哈希表对于红黑树的引入进一步提高了操作数据的性能。</strong></p><h4 id="1-3HashSet元素去重复的底层原理"><a href="#1-3HashSet元素去重复的底层原理" class="headerlink" title="1.3HashSet元素去重复的底层原理"></a>1.3HashSet元素去重复的底层原理</h4><p><strong>HashSet去重复原理解析</strong></p><p>①创建一个默认长度16的数组，数组名table</p><p>②根据元素的<strong>哈希值</strong>跟<strong>数组的长度求余</strong>计算出应存入的位置<strong>（哈希算法）</strong></p><p>③判断当前位置是否为null，如果是null直接存入</p><p>④如果位置不为null，表示有元素，则调用equals方法比较</p><p>⑤如果一样，则不存，如果不一样，则存入数组</p><p><strong>结论：如果希望Set集合认为2个内容一样的对象是重复的</strong></p><p>​            <strong>必须重写对象的hashCode()和equals()方法</strong></p><p><strong>案例：</strong></p><p>Set集合去重复</p><p><strong>需求：</strong></p><p>创建一个存储学生对象的集合，存储多个学生对象，使用程序实现在控制台遍历该集合，要求：学生对象的成员变量值相同，我们就认为是同一个对象</p><p><strong>分析</strong></p><p>①定义学生类，创建HashSet集合对象, 创建学生对象</p><p>②把学生添加到集合</p><p><strong>③在学生类中重写两个方法，hashCode()和equals()，自动生成即可</strong></p><p>④遍历集合(增强for)</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.定义学生类，重写hashCode()和equals()方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Set集合去重复原因：先判断哈希值算出来的存储位置是否相同 再判断    equals</span></span><br><span class="line">        Set&lt;Student&gt; sets = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;无恙&quot;</span>, <span class="number">20</span>, <span class="string">&#x27;男&#x27;</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;无恙&quot;</span>, <span class="number">20</span>, <span class="string">&#x27;男&#x27;</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;周雄&quot;</span>, <span class="number">21</span>, <span class="string">&#x27;男&#x27;</span>);</span><br><span class="line">        </span><br><span class="line">        sets.add(s1);</span><br><span class="line">        sets.add(s2);</span><br><span class="line">        sets.add(s3);</span><br><span class="line"></span><br><span class="line">        System.out.println(sets);</span><br></pre></td></tr></table></figure><h4 id="1-4实现类：LinkedHashSet"><a href="#1-4实现类：LinkedHashSet" class="headerlink" title="1.4实现类：LinkedHashSet"></a>1.4实现类：LinkedHashSet</h4><p><strong>LinkedHashSet集合概述和特点</strong></p><ul><li><p><strong>有序</strong>、不重复、无索引。</p></li><li><p>这里的有序指的是保证存储和取出的元素顺序一致</p></li><li><p><strong>原理</strong>：底层数据结构是依然<strong>哈希表</strong>，只是每个元素又额外的多了一个<strong>双链表</strong>的机制记录存储的顺序。</p></li></ul><p><img src="C:\Users\廖永森\AppData\Roaming\Typora\typora-user-images\image-20220203175655815.png" alt="image-20220203175655815"></p><h4 id="1-5实现类：TreeSet"><a href="#1-5实现类：TreeSet" class="headerlink" title="1.5实现类：TreeSet"></a>1.5实现类：TreeSet</h4><p><strong>TreeSet集合概述和特点</strong></p><ul><li><p>不重复、无索引、可排序</p></li><li><p>可排序：按照<strong>元素的大小</strong>(如果是字符，按照首字母的ASCII排序)默认升序（由小到大）排序。</p></li><li><p>TreeSet集合底层是基于<strong>红黑树的数据结构</strong>实现排序的，增删改查性能都较好。</p></li></ul><p><strong>注意：TreeSet集合是一定要排序的，默认升序，可以将元素按照指定的规则进行排序。</strong></p><p><strong>TreeSet集合默认的规则</strong></p><ul><li><p>对于数值类型：Integer , Double，官方默认按照大小进行升序排序。</p></li><li><p>对于字符串类型：默认按照首字符的编号升序排序。</p></li><li><p>对于自定义类型如Student对象，TreeSet无法直接排序。</p></li></ul><p><strong>结论：想要使用<em>TreeSet存储自定义类型</em>，需要制定排序规则</strong></p><p><strong>自定义排序规则</strong></p><ul><li>TreeSet集合存储对象的的时候有<strong>2种方式</strong>可以设计自定义比较规则</li></ul><p><strong>方式一</strong></p><ul><li>让自定义的类（如学生类）<strong>实现Comparable接口   重写里面的compareTo方法</strong>来定制比较规则。</li></ul><p><strong>方式二</strong></p><ul><li><strong>TreeSet集合有参数构造器</strong>，可以设置Comparator接口对应的<strong>比较器对象</strong>，来定制比较规则。</li></ul><p><strong>两种方式中，关于返回值的规则：</strong></p><ul><li><p>如果认为第一个元素大于第二个元素返回正整数即可。</p></li><li><p>如果认为第一个元素小于第二个元素返回负整数即可。</p></li><li><p>如果认为第一个元素等于第二个元素返回0即可，此时Treeset集合只会保留一个元素，认为两者重复。</p></li></ul><p><strong>注意：如果<em>TreeSet</em>集合存储的对象有实现比较规则，集合也自带比较器，默认使用集合自带的比较器排序。</strong></p><p><strong>案例：</strong></p><p>TreeSet对象排序练习题</p><p><strong>需求：</strong></p><p>键盘录入3个学生信息(姓名,语文成绩,数学成绩,英语成绩),按照总分从高到低输出到控制台</p><p><strong>分析</strong></p><p>①定义学生类</p><p>②创建TreeSet集合对象，通过比较器排序进行排序</p><p>③创建学生对象</p><p>④把学生对象添加到集合</p><p>⑤遍历集合</p><p><strong>代码：</strong></p><p>方式一：实现Comparable接口，重写方法定义规则</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.创建Apple类并实现接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Apple</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Apple&gt;&#123;  <span class="comment">//实现Comparable接口 ---&gt; implements Comparable</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> price;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> weight;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Apple</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Apple</span><span class="params">(String name, String color, <span class="type">double</span> price, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getColor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setColor</span><span class="params">(String color)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getPrice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPrice</span><span class="params">(<span class="type">double</span> price)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getWeight</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWeight</span><span class="params">(<span class="type">int</span> weight)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Apple&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, color=&#x27;&quot;</span> + color + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, price=&quot;</span> + price +</span><br><span class="line">                <span class="string">&quot;, weight=&quot;</span> + weight +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">//2.方法重写</span></span><br><span class="line"><span class="comment">//  自定义比较规则  o1.compareTo(o2)</span></span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Apple o)</span> &#123;</span><br><span class="line">        <span class="comment">// 按照重量进行比较的</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 去除重量重复的元素</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.weight - o.weight ; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保留重量重复的元素</span></span><br><span class="line">        <span class="comment">// return this.weight - o.weight &gt;= 0 ? 1 : -1; </span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>方式二：集合自带比较器对象，来定制比较规则</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建Apple类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Apple</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> price;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> weight;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Apple</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Apple</span><span class="params">(String name, String color, <span class="type">double</span> price, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getColor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setColor</span><span class="params">(String color)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getPrice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPrice</span><span class="params">(<span class="type">double</span> price)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getWeight</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWeight</span><span class="params">(<span class="type">int</span> weight)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Apple&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, color=&#x27;&quot;</span> + color + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, price=&quot;</span> + price +</span><br><span class="line">                <span class="string">&quot;, weight=&quot;</span> + weight +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2.创建比较器对象</span></span><br><span class="line">Set&lt;Apple&gt; apples = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Apple&gt;() &#123;  <span class="comment">//***直接创建比较器对象***</span></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Apple o1, Apple o2)</span> &#123;</span><br><span class="line">      <span class="comment">// return o1.getWeight() - o2.getWeight(); // 升序 </span></span><br><span class="line">      <span class="comment">// return o2.getWeight() - o1.getWeight(); // 降序</span></span><br><span class="line">          </span><br><span class="line">      <span class="comment">// 注意：浮点型建议直接使用Double.compare进行比较</span></span><br><span class="line">      <span class="comment">// return Double.compare(o1.getPrice(), o2.getPrice()); // 升序</span></span><br><span class="line">      <span class="comment">// return Double.compare(o2.getPrice() , o1.getPrice()); // 降序</span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;);</span><br><span class="line">      <span class="comment">//简化</span></span><br><span class="line">      Set&lt;Apple&gt; apples = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(( o1,  o2) -&gt;  Double.compare(o2.getPrice() , o1.getPrice())  );</span><br><span class="line">      </span><br><span class="line">  apples.add(<span class="keyword">new</span> <span class="title class_">Apple</span>(<span class="string">&quot;红富士&quot;</span>, <span class="string">&quot;红色&quot;</span>, <span class="number">9.9</span>, <span class="number">500</span>));</span><br><span class="line">      apples.add(<span class="keyword">new</span> <span class="title class_">Apple</span>(<span class="string">&quot;青苹果&quot;</span>, <span class="string">&quot;绿色&quot;</span>, <span class="number">15.9</span>, <span class="number">300</span>));</span><br><span class="line">      apples.add(<span class="keyword">new</span> <span class="title class_">Apple</span>(<span class="string">&quot;绿苹果&quot;</span>, <span class="string">&quot;青色&quot;</span>, <span class="number">29.9</span>, <span class="number">400</span>));</span><br><span class="line">      apples.add(<span class="keyword">new</span> <span class="title class_">Apple</span>(<span class="string">&quot;黄苹果&quot;</span>, <span class="string">&quot;黄色&quot;</span>, <span class="number">9.8</span>, <span class="number">500</span>));</span><br><span class="line">      System.out.println(apples);</span><br></pre></td></tr></table></figure><h3 id="2-Collection体系的特点、使用场景总结"><a href="#2-Collection体系的特点、使用场景总结" class="headerlink" title="2.Collection体系的特点、使用场景总结"></a>2.Collection体系的特点、使用场景总结</h3><p>1.如果希望元素可以重复，又有索引，索引查询要快？</p><ul><li><strong>用ArrayList集合，基于数组的。（用的最多）</strong></li></ul><p>2.如果希望元素可以重复，又有索引，增删首尾操作快？</p><ul><li>用LinkedList集合，基于链表的。</li></ul><p>3.如果希望增删改查都快，但是元素不重复、无序、无索引。</p><ul><li>用HashSet集合，基于哈希表的。</li></ul><p>4.如果希望增删改查都快，但是元素不重复、有序、无索引。</p><ul><li>用LinkedHashSet集合，基于哈希表和双链表。</li></ul><p>5.如果要对对象进行排序。</p><ul><li>用TreeSet集合，基于红黑树。后续也可以用List集合实现排序。</li></ul><h3 id="3-补充知识：可变参数"><a href="#3-补充知识：可变参数" class="headerlink" title="3.补充知识：可变参数"></a>3.补充知识：可变参数</h3><p>假如需要定义一个方法求和，该方法可以灵活的完成如下需求：</p><ul><li><p>计算1个数据的和。</p></li><li><p>计算2个数据的和。</p></li><li><p>计算3个数据的和。</p></li><li><p>计算n个数据的和，甚至可以支持不接收参数进行调用。</p></li></ul><p><strong>可变参数</strong></p><ul><li><p>可变参数用在形参中可以接收多个数据。</p></li><li><p>可变参数的格式：数据类型…参数名称</p></li></ul><p><strong>可变参数的作用</strong></p><ul><li><p>传输参数非常灵活，方便。<strong>可以不传输参数，可以传输1个或者多个</strong>，也可以传输一个数组</p></li><li><p><strong>可变参数在方法内部本质上就是一个数组。</strong></p></li></ul><p><strong>可变参数的注意事项：</strong></p><ul><li><p><strong>1.一个形参列表(方法)中可变参数只能有一个</strong></p></li><li><p><strong>2.可变参数必须放在形参列表的最后面</strong></p></li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：可变参数。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    可变参数的格式：数据类型...参数名称</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    可变参数的作用：</span></span><br><span class="line"><span class="comment">         传输参数非常灵活，方便。</span></span><br><span class="line"><span class="comment">         可以不传输参数。</span></span><br><span class="line"><span class="comment">         可以传输一个参数。</span></span><br><span class="line"><span class="comment">         可以传输多个参数。</span></span><br><span class="line"><span class="comment">         可以传输一个数组。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         1.一个形参列表中可变参数只能有一个！！</span></span><br><span class="line"><span class="comment">         2.可变参数必须放在形参列表的最后面！！</span></span><br><span class="line"><span class="comment">     小结：</span></span><br><span class="line"><span class="comment">        记住。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        sum(); <span class="comment">// 1、不传参数</span></span><br><span class="line">        sum(<span class="number">10</span>); <span class="comment">// 2、可以传输一个参数</span></span><br><span class="line">        sum(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>); <span class="comment">// 3、可以传输多个参数</span></span><br><span class="line">        sum(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;); <span class="comment">//4、可以传输一个数组</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">       注意：一个形参列表中只能有一个可变参数,可变参数必须放在形参列表的最后面</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sum</span><span class="params">( <span class="type">int</span>...nums )</span>&#123;</span><br><span class="line">        <span class="comment">// 注意：可变参数在方法内部其实就是一个数组。 nums</span></span><br><span class="line">        System.out.println(<span class="string">&quot;元素个数：&quot;</span> + nums.length);</span><br><span class="line">        System.out.println(<span class="string">&quot;元素内容：&quot;</span> + Arrays.toString(nums));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-补充知识：集合工具类Collections"><a href="#4-补充知识：集合工具类Collections" class="headerlink" title="4.补充知识：集合工具类Collections"></a>4.补充知识：集合工具类Collections</h3><p><strong>Collections集合工具类</strong></p><ul><li><p>java.utils.Collections:是集合工具类</p></li><li><p><strong>作用：Collections并不属于集合，是用来操作集合的工具类。</strong></p></li><li><p>通过<strong>List集合</strong>有序特征  弥补的部分方法</p></li></ul><p><strong>Collections常用的API</strong></p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>public static <T> boolean  <strong>addAll</strong>(Collection&lt;? super T&gt; c, T… elements)</td><td>给集合对象<strong>批量添加元素</strong></td></tr><tr><td>public static void <strong>shuffle</strong>(List&lt;?&gt; list)</td><td><strong>打乱List集合元素的顺序</strong></td></tr></tbody></table><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：Collections工具类的使用。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Collections有几个常用的API:</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">将集合中元素按照指定规则排序。</span></span><br><span class="line"><span class="comment">- public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; c)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; names = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//names.add(&quot;楚留香&quot;);</span></span><br><span class="line">        <span class="comment">//names.add(&quot;胡铁花&quot;);</span></span><br><span class="line">        <span class="comment">//names.add(&quot;张无忌&quot;);</span></span><br><span class="line">        <span class="comment">//names.add(&quot;陆小凤&quot;);</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//1.给集合对象批量添加元素！</span></span><br><span class="line">        Collections.addAll(names, <span class="string">&quot;楚留香&quot;</span>,<span class="string">&quot;胡铁花&quot;</span>, <span class="string">&quot;张无忌&quot;</span>,<span class="string">&quot;陆小凤&quot;</span>);</span><br><span class="line">        System.out.println(names);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.public static void shuffle(List&lt;?&gt; list) :打乱集合顺序。</span></span><br><span class="line">        Collections.shuffle(names);</span><br><span class="line">        System.out.println(names);</span><br></pre></td></tr></table></figure><p><strong>排序方式1：默认排序</strong></p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>public static <T> void <strong>sort</strong>(List<T> list)</td><td>将集合中元素按照<strong>默认规则排序</strong></td></tr></tbody></table><p>注意：本方式不可以直接对自定义类型的List集合排序，除非自定义类型实现了比较规则Comparable接口。</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//public static &lt;T&gt; void sort(List&lt;T&gt; list)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将集合中元素按照默认规则排序。(排值特性的元素)</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(list, <span class="number">12</span>, <span class="number">23</span>, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        System.out.println(list);</span><br></pre></td></tr></table></figure><p><strong>排序方式2：自定义类型排序</strong></p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>public static <T> void <strong>sort</strong>(List<T> list，Comparator&lt;? super T&gt; c)</td><td>将集合中元素<strong>按照指定规则排序</strong></td></tr></tbody></table><p><strong>排自定义类型</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法一</span></span><br><span class="line"><span class="comment">//定义Apple类，实现Comparable接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Apple</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Apple&gt;&#123;</span><br><span class="line">    <span class="comment">//自定义类，内容略</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法重写</span></span><br><span class="line">    <span class="comment">//类自定义比较规则  o1.compareTo(o2)  </span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Apple o)</span> &#123;</span><br><span class="line">        <span class="comment">// 按照重量进行比较的</span></span><br><span class="line">        <span class="comment">// List集存储相同大小的元素 会保留！(List可重复)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.weight - o.weight ;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">//主函数  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Apple&gt; apples = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); </span><br><span class="line">        apples.add(<span class="keyword">new</span> <span class="title class_">Apple</span>(<span class="string">&quot;红富士&quot;</span>, <span class="string">&quot;红色&quot;</span>, <span class="number">9.9</span>, <span class="number">500</span>));</span><br><span class="line">        apples.add(<span class="keyword">new</span> <span class="title class_">Apple</span>(<span class="string">&quot;青苹果&quot;</span>, <span class="string">&quot;绿色&quot;</span>, <span class="number">15.9</span>, <span class="number">300</span>));</span><br><span class="line">        apples.add(<span class="keyword">new</span> <span class="title class_">Apple</span>(<span class="string">&quot;绿苹果&quot;</span>, <span class="string">&quot;青色&quot;</span>, <span class="number">29.9</span>, <span class="number">400</span>));</span><br><span class="line">        apples.add(<span class="keyword">new</span> <span class="title class_">Apple</span>(<span class="string">&quot;黄苹果&quot;</span>, <span class="string">&quot;黄色&quot;</span>, <span class="number">9.8</span>, <span class="number">500</span>));</span><br><span class="line"></span><br><span class="line">        Collections.sort(apples); <span class="comment">//Apple类已经重写了比较规则</span></span><br><span class="line">        System.out.println(apples); <span class="comment">//内容可以重复！</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法二</span></span><br><span class="line"><span class="comment">//sort方法自带比较器对象</span></span><br><span class="line"><span class="comment">//定义类Apple，不需要接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">Collections.sort(apples, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Apple&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Apple o1, Apple o2)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> Double.compare(o1.getPrice() , o2.getPrice()); <span class="comment">// 按照价格排序！！</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//简化</span></span><br><span class="line"><span class="comment">//Collections.sort(apples, (o1 , o2) -&gt; Double.compare(o1.getPrice() , o2.getPrice()) );</span></span><br><span class="line">        </span><br><span class="line">    apples.add(<span class="keyword">new</span> <span class="title class_">Apple</span>(<span class="string">&quot;红富士&quot;</span>, <span class="string">&quot;红色&quot;</span>, <span class="number">9.9</span>, <span class="number">500</span>));</span><br><span class="line">    apples.add(<span class="keyword">new</span> <span class="title class_">Apple</span>(<span class="string">&quot;青苹果&quot;</span>, <span class="string">&quot;绿色&quot;</span>, <span class="number">15.9</span>, <span class="number">300</span>));</span><br><span class="line">    apples.add(<span class="keyword">new</span> <span class="title class_">Apple</span>(<span class="string">&quot;绿苹果&quot;</span>, <span class="string">&quot;青色&quot;</span>, <span class="number">29.9</span>, <span class="number">400</span>));</span><br><span class="line">    apples.add(<span class="keyword">new</span> <span class="title class_">Apple</span>(<span class="string">&quot;黄苹果&quot;</span>, <span class="string">&quot;黄色&quot;</span>, <span class="number">9.8</span>, <span class="number">500</span>));</span><br><span class="line">    System.out.println(apples);</span><br></pre></td></tr></table></figure><h3 id="5-Collection体系的综合案例"><a href="#5-Collection体系的综合案例" class="headerlink" title="5.Collection体系的综合案例"></a>5.Collection体系的综合案例</h3><h4 id="斗地主游戏"><a href="#斗地主游戏" class="headerlink" title="斗地主游戏"></a>斗地主游戏</h4><p><strong>需求：</strong><br> 在启动游戏房间的时候，应该提前准备好54张牌，完成洗牌、发牌、牌排序、逻辑。</p><p><strong>分析：</strong></p><p>①：当系统启动的同时需要准备好数据的时候，就可以用静态代码块了。</p><p>②：洗牌就是打乱牌的顺序。</p><p>③：定义三个玩家、依次发出51张牌</p><p>④：给玩家的牌进行排序(拓展)</p><p>⑤：输出每个玩家的牌数据。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个Card类，储存牌类</span></span><br><span class="line"><span class="comment">//index  牌的真正大小</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Card</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String size;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> index; <span class="comment">// 牌的真正大小</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Card</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Card</span><span class="params">(String size, String color, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.size = size;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">        <span class="built_in">this</span>.index = index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSize</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSize</span><span class="params">(String size)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.size = size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getColor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setColor</span><span class="params">(String color)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getIndex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.index = index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size + color;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：斗地主游戏的案例开发。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    业务需求分析:</span></span><br><span class="line"><span class="comment">        斗地主的做牌, 洗牌, 发牌, 排序（拓展知识）, 看牌。</span></span><br><span class="line"><span class="comment">        业务: 总共有54张牌。</span></span><br><span class="line"><span class="comment">        点数: &quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;10&quot;,&quot;J&quot;,&quot;Q&quot;,&quot;K&quot;,&quot;A&quot;,&quot;2&quot;</span></span><br><span class="line"><span class="comment">        花色: &quot;♠&quot;, &quot;♥&quot;, &quot;♣&quot;, &quot;♦&quot;</span></span><br><span class="line"><span class="comment">        大小王: &quot;👲&quot; , &quot;🃏&quot;</span></span><br><span class="line"><span class="comment">        点数分别要组合4种花色，大小王各一张。</span></span><br><span class="line"><span class="comment">        斗地主：发出51张牌，剩下3张作为底牌。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    功能：</span></span><br><span class="line"><span class="comment">        1.做牌。</span></span><br><span class="line"><span class="comment">        2.洗牌。</span></span><br><span class="line"><span class="comment">        3.定义3个玩家</span></span><br><span class="line"><span class="comment">        4.发牌。</span></span><br><span class="line"><span class="comment">        5.排序（拓展，了解，作业）</span></span><br><span class="line"><span class="comment">        6.看牌</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GameDemo</span> &#123;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//1、定义一个静态的集合存储54张牌对象</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Card&gt; allCards = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">//2、做牌：定义静态代码块初始化牌数据</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 3、定义点数：个数确定，类型确定，使用数组</span></span><br><span class="line">        String[] sizes = &#123;<span class="string">&quot;3&quot;</span>,<span class="string">&quot;4&quot;</span>,<span class="string">&quot;5&quot;</span>,<span class="string">&quot;6&quot;</span>,<span class="string">&quot;7&quot;</span>,<span class="string">&quot;8&quot;</span>,<span class="string">&quot;9&quot;</span>,<span class="string">&quot;10&quot;</span>,<span class="string">&quot;J&quot;</span>,<span class="string">&quot;Q&quot;</span>,<span class="string">&quot;K&quot;</span>,<span class="string">&quot;A&quot;</span>,<span class="string">&quot;2&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">// 4、定义花色：个数确定，类型确定，使用数组</span></span><br><span class="line">        String[] colors = &#123;<span class="string">&quot;♠&quot;</span>, <span class="string">&quot;♥&quot;</span>, <span class="string">&quot;♣&quot;</span>, <span class="string">&quot;♦&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">// 5、组合点数和花色</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 记录牌的大小，计算机可识别的大小</span></span><br><span class="line">        <span class="keyword">for</span> (String size : sizes) &#123;</span><br><span class="line">            index++;  <span class="comment">//给每一个点数赋值</span></span><br><span class="line">            <span class="keyword">for</span> (String color : colors) &#123;</span><br><span class="line">                <span class="comment">// 6、封装成一个牌对象。</span></span><br><span class="line">                <span class="type">Card</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Card</span>(size, color, index);</span><br><span class="line">                <span class="comment">// 7、存入到集合容器中去</span></span><br><span class="line">                allCards.add(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 8 大小王存入到集合对象中去 &quot;👲&quot; , &quot;🃏&quot;</span></span><br><span class="line">        <span class="type">Card</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Card</span>(<span class="string">&quot;&quot;</span> ,  <span class="string">&quot;🃏&quot;</span>, ++index); <span class="comment">//++index给大小王赋值</span></span><br><span class="line">        <span class="type">Card</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Card</span>(<span class="string">&quot;&quot;</span> ,  <span class="string">&quot;👲&quot;</span>,++index);</span><br><span class="line">        Collections.addAll(allCards , c1 , c2);</span><br><span class="line">        System.out.println(<span class="string">&quot;新牌：&quot;</span> + allCards);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;   </span><br><span class="line"><span class="comment">// 9、洗牌</span></span><br><span class="line">        Collections.shuffle(allCards);</span><br><span class="line">        System.out.println(<span class="string">&quot;洗牌后：&quot;</span> + allCards);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 10、发牌（定义三个玩家，每个玩家的牌也是一个集合容器）</span></span><br><span class="line">        List&lt;Card&gt; linhuchong = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Card&gt; jiumozhi = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Card&gt; renyingying = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 11、开始发牌（从牌集合中发出51张牌给三个玩家，剩余3张作为底牌）</span></span><br><span class="line">        <span class="comment">// allCards = [🃏, A♠, 5♥, 2♠, 2♣, Q♣, 👲, Q♠ ...</span></span><br><span class="line">        <span class="comment">//    i         0   1   2   3   4   5   6   7       索引 % 3 </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; allCards.size() - <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="type">Card</span> <span class="variable">c</span> <span class="operator">=</span> allCards.get(i); <span class="comment">// 先拿到当前牌对象</span></span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                linhuchong.add(c); <span class="comment">// 请阿冲接牌</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i % <span class="number">3</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                jiumozhi.add(c);  <span class="comment">// 请阿鸠</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i % <span class="number">3</span> == <span class="number">2</span>)&#123;</span><br><span class="line">                renyingying.add(c); <span class="comment">// 请盈盈接牌</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 12、拿到最后三张底牌(把最后三张牌截取成一个子集合)</span></span><br><span class="line">        List&lt;Card&gt; lastThreeCards = allCards.subList(allCards.size() - <span class="number">3</span> , allCards.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 13、给玩家的牌排序 调用sortCards方法（从大到小）</span></span><br><span class="line">        sortCards(linhuchong);   </span><br><span class="line">        sortCards(jiumozhi);</span><br><span class="line">        sortCards(renyingying);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 14、输出玩家的牌：</span></span><br><span class="line">        System.out.println(<span class="string">&quot;啊冲：&quot;</span> + linhuchong);</span><br><span class="line">        System.out.println(<span class="string">&quot;啊鸠：&quot;</span> + jiumozhi);</span><br><span class="line">        System.out.println(<span class="string">&quot;盈盈：&quot;</span> + renyingying);</span><br><span class="line">        System.out.println(<span class="string">&quot;三张底牌：&quot;</span> + lastThreeCards);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义方法，给牌排序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sortCards</span><span class="params">(List&lt;Card&gt; cards)</span> &#123; </span><br><span class="line">        <span class="comment">// cards = [J♥, A♦, 3♥, 🃏, 5♦, Q♥, 2♥</span></span><br><span class="line">        Collections.sort(cards, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Card&gt;() &#123;   <span class="comment">//使用比较器对象</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Card o1, Card o2)</span> &#123;</span><br><span class="line">                <span class="comment">// 知道牌的大小，才可以指定规则，index是牌的真正大小</span></span><br><span class="line">                <span class="keyword">return</span> o2.getIndex() - o1.getIndex();  <span class="comment">//降序</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//代码简化</span></span><br><span class="line">        <span class="comment">// ollections.sort(cards,(o1 , o2) -&gt;o2.getIndex() - o1.getIndex());</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-Map集合体系"><a href="#6-Map集合体系" class="headerlink" title="6.Map集合体系"></a>6.Map集合体系</h3><h4 id="6-1Map集合的概述"><a href="#6-1Map集合的概述" class="headerlink" title="6.1Map集合的概述"></a>6.1Map集合的概述</h4><p><strong>Map集合概述和使用</strong></p><ul><li><p>Map集合是一种双列集合，<strong>每个元素包含两个数据</strong>。</p></li><li><p>Map集合的每个元素的格式：<strong>key&#x3D;value</strong>(键值对元素)。</p></li><li><p>Map集合也被称为“<strong>键值对集合</strong>”。</p></li></ul><p><strong>Map集合整体格式：</strong></p><ul><li><p>Collection集合的格式: [元素1,元素2,元素3..]</p></li><li><p>Map集合的完整格式：{key1&#x3D;value1 , key2&#x3D;value2 , key3&#x3D;value3 , …}</p></li></ul><p><strong>Map集合的使用场景之一：购物车系统</strong></p><p><strong>分析</strong></p><ul><li><p>购物车提供的四个商品和购买的数量在后台需要容器存储。</p></li><li><p>每个商品对象都一一对应一个购买数量。</p></li><li><p>把商品对象看成是Map集合的建，购买数量看成Map集合的值。</p></li></ul><p><strong>{商品1&#x3D;2  ,  商品2&#x3D;3 ，商品3 &#x3D; 2  , 商品4&#x3D; 3}</strong></p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1、创建一个Map集合对象</span></span><br><span class="line"><span class="comment">// Map&lt;String, Integer&gt; maps = new HashMap&lt;&gt;();//一行经典代码</span></span><br><span class="line">        Map&lt;String, Integer&gt; maps = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">        maps.put(<span class="string">&quot;鸿星尔克&quot;</span>, <span class="number">3</span>);</span><br><span class="line">        maps.put(<span class="string">&quot;Java&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        maps.put(<span class="string">&quot;枸杞&quot;</span>, <span class="number">100</span>);</span><br><span class="line">        maps.put(<span class="string">&quot;Java&quot;</span>, <span class="number">100</span>); <span class="comment">// 覆盖前面的数据</span></span><br><span class="line">        maps.put(<span class="literal">null</span>, <span class="literal">null</span>);  <span class="comment">// 可以添加null</span></span><br><span class="line">        System.out.println(maps);</span><br></pre></td></tr></table></figure><h4 id="6-2Map集合体系特点"><a href="#6-2Map集合体系特点" class="headerlink" title="6.2Map集合体系特点"></a>6.2Map集合体系特点</h4><p><strong>Map集合体系</strong></p><p><img src="C:\Users\廖永森\AppData\Roaming\Typora\typora-user-images\image-20220204162909691.png" alt="image-20220204162909691"></p><p><strong>Map集合体系特点</strong></p><ul><li><p>Map集合的特点都是由<strong>键决定</strong>的。</p></li><li><p>Map集合的<strong>键是无序，不重复的，无索引的</strong>，<strong>值不做要求</strong>（可以重复）。</p></li><li><p><strong>Map集合后面重复的键对应的值会覆盖前面重复键的值。</strong></p></li><li><p>Map集合的键值对都可以为null。</p></li></ul><p><strong>Map集合实现类特点</strong></p><ul><li><p>HashMap:元素按照键是<strong>无序</strong>，不重复，无索引，值不做要求。（与Map体系一致）</p></li><li><p>LinkedHashMap:元素按照键是<strong>有序</strong>，不重复，无索引，值不做要求。</p></li><li><p>TreeMap：元素按照建是<strong>排序</strong>，不重复，无索引的，值不做要求。</p></li></ul><h4 id="6-3Map集合常用API"><a href="#6-3Map集合常用API" class="headerlink" title="6.3Map集合常用API"></a>6.3Map集合常用API</h4><p><strong>Map集合</strong> </p><ul><li>Map是双列集合的祖宗接口，它的功能是全部双列集合都可以继承使用的。</li></ul><p><strong>Map  API如下:</strong></p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>V  **put(**K key,V value)</td><td>添加元素</td></tr><tr><td>V  <strong>remove</strong>(Object key)</td><td>根据键删除键值对元素</td></tr><tr><td>void  <strong>clear</strong>()</td><td>移除所有的键值对元素</td></tr><tr><td>boolean <strong>containsKey</strong>(Object key)</td><td>判断集合是否包含指定的键</td></tr><tr><td>boolean <strong>containsValue</strong>(Object value)</td><td>判断集合是否包含指定的值</td></tr><tr><td>boolean <strong>isEmpty</strong>()</td><td>判断集合是否为空</td></tr><tr><td>int  <strong>size</strong>()</td><td>集合的长度，也就是集合中键值对的个数</td></tr></tbody></table><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：Map集合的常用API(重点中的重点)</span></span><br><span class="line"><span class="comment">     - public V put(K key, V value):  把指定的键与指定的值添加到Map集合中。</span></span><br><span class="line"><span class="comment">     - public V remove(Object key): 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。</span></span><br><span class="line"><span class="comment">     - public V get(Object key) 根据指定的键，在Map集合中获取对应的值。</span></span><br><span class="line"><span class="comment">     - public Set&lt;K&gt; keySet(): 获取Map集合中所有的键，存储到Set集合中。</span></span><br><span class="line"><span class="comment">     - public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet(): 获取到Map集合中所有的键值对对象的集合(Set集合)。</span></span><br><span class="line"><span class="comment">     - public boolean containKey(Object key):判断该集合中是否有此键。</span></span><br><span class="line"><span class="comment">     - public boolean containValue(Object value):判断该集合中是否有此值。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.添加元素: 无序，不重复，无索引。</span></span><br><span class="line">        Map&lt;String , Integer&gt; maps = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        maps.put(<span class="string">&quot;iphoneX&quot;</span>,<span class="number">10</span>);</span><br><span class="line">        maps.put(<span class="string">&quot;娃娃&quot;</span>,<span class="number">20</span>);</span><br><span class="line">        maps.put(<span class="string">&quot;iphoneX&quot;</span>,<span class="number">100</span>);<span class="comment">//  Map集合后面重复的键对应的元素会覆盖前面重复的整个元素！</span></span><br><span class="line">        maps.put(<span class="string">&quot;huawei&quot;</span>,<span class="number">100</span>);</span><br><span class="line">        maps.put(<span class="string">&quot;生活用品&quot;</span>,<span class="number">10</span>);</span><br><span class="line">        maps.put(<span class="string">&quot;手表&quot;</span>,<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// &#123;huawei=100, 手表=10, 生活用品=10, iphoneX=100, 娃娃=20&#125;</span></span><br><span class="line">        System.out.println(maps);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.清空集合</span></span><br><span class="line"><span class="comment">//        maps.clear();</span></span><br><span class="line"><span class="comment">//        System.out.println(maps);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.判断集合是否为空，为空返回true ,反之！</span></span><br><span class="line">        System.out.println(maps.isEmpty());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.根据键获取对应值:public V get(Object key)</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">key</span> <span class="operator">=</span> maps.get(<span class="string">&quot;huawei&quot;</span>);</span><br><span class="line">        System.out.println(key);</span><br><span class="line">        System.out.println(maps.get(<span class="string">&quot;生活用品&quot;</span>)); <span class="comment">// 10</span></span><br><span class="line">        System.out.println(maps.get(<span class="string">&quot;生活用品2&quot;</span>)); <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.根据键删除整个元素。(删除键会返回键的值)</span></span><br><span class="line">        System.out.println(maps.remove(<span class="string">&quot;iphoneX&quot;</span>));  <span class="comment">//100</span></span><br><span class="line">        System.out.println(maps);  <span class="comment">//// &#123;huawei=100, 手表=10, 生活用品=10, 娃娃=20&#125; </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.判断是否包含某个键 ，包含返回true ,反之</span></span><br><span class="line">        System.out.println(maps.containsKey(<span class="string">&quot;娃娃&quot;</span>));  <span class="comment">// true</span></span><br><span class="line">        System.out.println(maps.containsKey(<span class="string">&quot;娃娃2&quot;</span>));  <span class="comment">// false</span></span><br><span class="line">        System.out.println(maps.containsKey(<span class="string">&quot;iphoneX&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7.判断是否包含某个值。</span></span><br><span class="line">        System.out.println(maps.containsValue(<span class="number">100</span>));  <span class="comment">// ture</span></span><br><span class="line">        System.out.println(maps.containsValue(<span class="number">10</span>));   <span class="comment">// ture</span></span><br><span class="line">        System.out.println(maps.containsValue(<span class="number">22</span>));   <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// &#123;huawei=100, 手表=10, 生活用品=10, 娃娃=20&#125;</span></span><br><span class="line">        <span class="comment">// 8.获取全部键的集合：public Set&lt;K&gt; keySet()  </span></span><br><span class="line">           <span class="comment">//Set也是不重复的，所以使用Set集合</span></span><br><span class="line">        Set&lt;String&gt; keys = maps.keySet();  </span><br><span class="line">        System.out.println(keys); <span class="comment">// [huawei, 手表, 生活用品, 娃娃]</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;------------------------------&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 9.获取全部值的集合：Collection&lt;V&gt; values();</span></span><br><span class="line">           <span class="comment">//值不需要考虑重复的问题，所以用Collection集合</span></span><br><span class="line">        Collection&lt;Integer&gt; values = maps.values();</span><br><span class="line">        System.out.println(values); <span class="comment">// [100, 10, 10, 20]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 10.集合的大小</span></span><br><span class="line">        System.out.println(maps.size()); <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 11.合并其他Map集合。(拓展)</span></span><br><span class="line">        Map&lt;String , Integer&gt; map1 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map1.put(<span class="string">&quot;java1&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        map1.put(<span class="string">&quot;java2&quot;</span>, <span class="number">100</span>);</span><br><span class="line">        Map&lt;String , Integer&gt; map2 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map2.put(<span class="string">&quot;java2&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        map2.put(<span class="string">&quot;java3&quot;</span>, <span class="number">100</span>);</span><br><span class="line">        map1.putAll(map2); <span class="comment">// 把集合map2的元素拷贝一份到map1中去</span></span><br><span class="line">        System.out.println(map1); </span><br><span class="line">        System.out.println(map2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-4Map集合的遍历"><a href="#6-4Map集合的遍历" class="headerlink" title="6.4Map集合的遍历"></a>6.4Map集合的遍历</h4><p><strong>Map集合的遍历方式有：3种。</strong></p><ul><li><p>方式一：键找值的方式遍历：先获取Map集合全部的键，再根据遍历键找值。</p></li><li><p>方式二：键值对的方式遍历，把“键值对“看成一个整体，难度较大。</p></li><li><p>方式三：JDK 1.8开始之后的新技术：Lambda表达式。（暂时了解）</p></li></ul><h5 id="6-4-1方式一：键找值"><a href="#6-4-1方式一：键找值" class="headerlink" title="6.4.1方式一：键找值"></a>6.4.1方式一：键找值</h5><p><strong>键找值流程</strong></p><p><img src="C:\Users\廖永森\AppData\Roaming\Typora\typora-user-images\image-20220204164759590.png" alt="image-20220204164759590"></p><ul><li><p>先获取Map集合的全部键的Set集合。</p></li><li><p>遍历键的Set集合，然后通过键提取对应值。</p></li></ul><p><strong>键找值涉及到的API:</strong></p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>Set<K>  keySet()</td><td>获取所有键的集合</td></tr><tr><td>V  get(Object key)</td><td>根据键获取值</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：Map集合的遍历方式一：键找值</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">        1.先获取Map集合的全部键的Set集合。</span></span><br><span class="line"><span class="comment">        2.遍历键的Set集合，然后通过键找值。</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">    小结：</span></span><br><span class="line"><span class="comment">        代码简单，需要记住!</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;String , Integer&gt; maps = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 添加元素: 无序，不重复，无索引。</span></span><br><span class="line">        maps.put(<span class="string">&quot;娃娃&quot;</span>,<span class="number">30</span>);</span><br><span class="line">        maps.put(<span class="string">&quot;iphoneX&quot;</span>,<span class="number">100</span>);</span><br><span class="line">        maps.put(<span class="string">&quot;huawei&quot;</span>,<span class="number">1000</span>);</span><br><span class="line">        maps.put(<span class="string">&quot;生活用品&quot;</span>,<span class="number">10</span>);</span><br><span class="line">        maps.put(<span class="string">&quot;手表&quot;</span>,<span class="number">10</span>);</span><br><span class="line">        System.out.println(maps);</span><br><span class="line">        <span class="comment">// maps = &#123;huawei=1000, 手表=10, 生活用品=10, iphoneX=100, 娃娃=30&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、键找值：第一步：keySet方法拿到集合的全部键</span></span><br><span class="line">        Set&lt;String&gt; keys = maps.keySet();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2、第二步：遍历每个键，根据键提取值</span></span><br><span class="line">        <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> maps.get(key);  </span><br><span class="line">            System.out.println(key + <span class="string">&quot;===&gt;&quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="6-4-2方式二：键值对"><a href="#6-4-2方式二：键值对" class="headerlink" title="6.4.2方式二：键值对"></a>6.4.2方式二：键值对</h5><ul><li><p>先把Map集合转换成Set集合，Set集合中每个元素都是键值对实体类型了。</p></li><li><p>遍历Set集合，然后提取键以及提取值。</p></li></ul><p><strong>键值对涉及到的API:</strong></p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</td><td>获取所有键值对对象的集合</td></tr><tr><td>K getKey()</td><td>获得键</td></tr><tr><td>V getValue()</td><td>获取值</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">目标：Map集合的遍历方式二：键值对</span></span><br><span class="line"><span class="comment">    1.先把Map集合转换成Set集合，Set集合中每个元素都是键值对实体类型了。</span></span><br><span class="line"><span class="comment">     2.遍历Set集合，然后提取键以及提取值。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">目标集合 maps = &#123;huawei = 1000, 手表 = 10, 生活用品 = 10 , phoneX = 100 , 娃娃 = 30&#125;</span></span><br><span class="line"><span class="comment">                👇</span></span><br><span class="line"><span class="comment">            使用foreach遍历map集合.发现Map集合的键值对元素直接是没有类型的。所以不可以直接foreach遍历集合。</span></span><br><span class="line"><span class="comment">                👇</span></span><br><span class="line"><span class="comment">            可以通过调用Map的方法 entrySet把Map集合转换成Set集合形式(键值对为整体)  maps.entrySet();</span></span><br><span class="line"><span class="comment">                👇  </span></span><br><span class="line"><span class="comment">            Set&lt;Map.Entry&lt;String,Integer&gt;&gt; entries =  maps.entrySet();</span></span><br><span class="line"><span class="comment">             [(huawei=1000), (手表=10), (生活用品=10), (iphoneX=100), (娃娃=30)]       </span></span><br><span class="line"><span class="comment">                👇</span></span><br><span class="line"><span class="comment">            此时可以使用foreach遍历</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;String , Integer&gt; maps = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 添加元素: 无序，不重复，无索引。</span></span><br><span class="line">        maps.put(<span class="string">&quot;娃娃&quot;</span>,<span class="number">30</span>);</span><br><span class="line">        maps.put(<span class="string">&quot;iphoneX&quot;</span>,<span class="number">100</span>);</span><br><span class="line">        maps.put(<span class="string">&quot;huawei&quot;</span>,<span class="number">1000</span>);</span><br><span class="line">        maps.put(<span class="string">&quot;生活用品&quot;</span>,<span class="number">10</span>);</span><br><span class="line">        maps.put(<span class="string">&quot;手表&quot;</span>,<span class="number">10</span>);</span><br><span class="line">        System.out.println(maps);</span><br><span class="line">        <span class="comment">// maps = &#123;huawei=1000, 手表=10, 生活用品=10, iphoneX=100, 娃娃=30&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、把Map集合转换成Set集合</span></span><br><span class="line">        Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entries = maps.entrySet();  <span class="comment">//maps.entrySet() V快捷键补全</span></span><br><span class="line">        <span class="comment">// 2、开始遍历</span></span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;String, Integer&gt; entry : entries)&#123;  <span class="comment">// maps.entrySet() 快捷键补全</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">            System.out.println(key + <span class="string">&quot;====&gt;&quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="6-4-3方式三：lambda表达式"><a href="#6-4-3方式三：lambda表达式" class="headerlink" title="6.4.3方式三：lambda表达式"></a>6.4.3方式三：lambda表达式</h5><ul><li>得益于JDK 8开始的新技术Lambda表达式，提供了一种更简单、更直接的遍历集合的方式。</li></ul><p><strong>Map结合Lambda遍历的API</strong></p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>default void <strong>forEach</strong>(BiConsumer&lt;?  super  K,  ? super  V&gt;  action)</td><td>结合lambda遍历Map集合</td></tr></tbody></table><p><strong>流程</strong></p><p><img src="C:\Users\廖永森\AppData\Roaming\Typora\typora-user-images\image-20220204170016594.png" alt="image-20220204170016594"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：Map集合的遍历方式。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    c.JDK 1.8开始之后的新技术：Lambda表达式。（暂时了解）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapDemo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;String , Integer&gt; maps = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 1.添加元素: 无序，不重复，无索引。</span></span><br><span class="line">        maps.put(<span class="string">&quot;娃娃&quot;</span>,<span class="number">30</span>);</span><br><span class="line">        maps.put(<span class="string">&quot;iphoneX&quot;</span>,<span class="number">100</span>);</span><br><span class="line">        maps.put(<span class="string">&quot;huawei&quot;</span>,<span class="number">1000</span>);</span><br><span class="line">        maps.put(<span class="string">&quot;生活用品&quot;</span>,<span class="number">10</span>);</span><br><span class="line">        maps.put(<span class="string">&quot;手表&quot;</span>,<span class="number">10</span>);</span><br><span class="line">        System.out.println(maps);</span><br><span class="line"><span class="comment">//  maps = &#123;huawei=1000, 手表=10, 生活用品=10, iphoneX=100, 娃娃=30&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        maps.forEach(new BiConsumer&lt;String, Integer&gt;() &#123;     // maps.forEach(new Bi...) 快捷键补全</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public void accept(String key, Integer value) &#123;</span></span><br><span class="line"><span class="comment">//                System.out.println(key + &quot;---&gt;&quot; + value);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//简化</span></span><br><span class="line">        maps.forEach((k, v) -&gt; &#123;</span><br><span class="line">                System.out.println(k + <span class="string">&quot;---&gt;&quot;</span> + v);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-5Map集合案例"><a href="#6-5Map集合案例" class="headerlink" title="6.5Map集合案例"></a>6.5Map集合案例</h4><p>统计投票人数</p><p><strong>需求</strong></p><p>某个班级80名学生，现在需要组成秋游活动，班长提供了四个景点依次是（A、B、C、D）,每个学生只能选择一个景点，请统计出最终哪个景点想去的人数最多。</p><p><strong>分析</strong></p><ul><li><p>将80个学生选择的数据拿到程序中去。</p></li><li><p>定义Map集合用于存储最终统计的结果。</p></li><li><p>遍历80个学生选择的数据，看Map集合中是否存在，不存在存入“数据&#x3D;1“，存在则其对应值+1,</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   需求：统计投票人数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">         <span class="comment">// 1、把80个学生选择的数据拿进来。</span></span><br><span class="line">        String[] selects = &#123;<span class="string">&quot;A&quot;</span> , <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>&#125;;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">80</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> r.nextInt(<span class="number">0</span>,<span class="number">4</span>);</span><br><span class="line">            sb.append(selects[index]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sb);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、定义一个Map集合记录最终统计的结果： A=30 B=20 C=20 D=10  键是景点 值是选择的数量</span></span><br><span class="line">        Map&lt;Character, Integer&gt; infos = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、遍历80个学生选择的数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sb.length(); i++) &#123;</span><br><span class="line">            <span class="comment">// 4、提取当前选择景点字符</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> sb.charAt(i);</span><br><span class="line">            <span class="comment">// 5、判断Map集合中是否存在这个键</span></span><br><span class="line">            <span class="keyword">if</span>(infos.containsKey(ch))&#123;  <span class="comment">//集合infos中存在ch</span></span><br><span class="line">                 <span class="comment">// 让其值 + 1</span></span><br><span class="line">                infos.put(ch , infos.get(ch) + <span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123; <span class="comment">//集合infos中不存在ch   </span></span><br><span class="line">                <span class="comment">// 说明此景点是第一次被选</span></span><br><span class="line">                infos.put(ch , <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、输出集合</span></span><br><span class="line">        System.out.println(infos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-6Map集合的实现类HashMap"><a href="#6-6Map集合的实现类HashMap" class="headerlink" title="6.6Map集合的实现类HashMap"></a>6.6Map集合的实现类HashMap</h4><p><img src="C:\Users\廖永森\AppData\Roaming\Typora\typora-user-images\image-20220205125149183.png" alt="image-20220205125149183"></p><p><strong>HashMap的特点</strong></p><ul><li><p>HashMap是Map里面的一个实现类。<strong>特点都是由键决定的：无序、不重复、无索引</strong></p></li><li><p>依赖<strong>hashCode</strong>方法和<strong>equals</strong>方法保证<strong>键</strong>的唯一。</p><p>如果<strong>键</strong>要存储的是<strong>自定义对象</strong>，需要重写hashCode和equals方法。</p></li><li><p>HashMap跟HashSet底层原理是一模一样的，都是<strong>哈希表结构</strong>，只是HashMap的每个元素包含两个值而已。</p></li><li><p>没有额外需要学习的特有方法，直接使用Map里面的方法就可以了。</p></li></ul><p><strong>实际上：Set系列集合的底层就是Map实现的，只是Set集合中的元素只要键数据，不要值数据而已。</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//底层</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span> &#123;</span><br><span class="line">map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>案例：</strong></p><p><strong>HashMap集合存储自定义对象并遍历</strong></p><p><strong>需求：</strong></p><p>创建一个HashMap集合，键是学生对象(Student)，值是籍贯(String)。存储三个键值对元素，并遍历</p><p><strong>思路：</strong></p><p>①定义学生类</p><p>②创建HashMap集合对象</p><p>③创建学生对象</p><p>④把学生添加到集合</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Map集合是根据键去除重复元素</span></span><br><span class="line">        Map&lt;Student, String&gt; maps = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;无恙&quot;</span>, <span class="number">20</span>, <span class="string">&#x27;男&#x27;</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;无恙&quot;</span>, <span class="number">20</span>, <span class="string">&#x27;男&#x27;</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;周雄&quot;</span>, <span class="number">21</span>, <span class="string">&#x27;男&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        maps.put(s1, <span class="string">&quot;北京&quot;</span>);</span><br><span class="line">        maps.put(s2, <span class="string">&quot;上海&quot;</span>);</span><br><span class="line">        maps.put(s3, <span class="string">&quot;广州&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(maps); <span class="comment">//学生信息是键，地址是值</span></span><br></pre></td></tr></table></figure><h4 id="6-7Map集合的实现类LinkedHashMap"><a href="#6-7Map集合的实现类LinkedHashMap" class="headerlink" title="6.7Map集合的实现类LinkedHashMap"></a>6.7Map集合的实现类LinkedHashMap</h4><p><strong>LinkedHashMap集合概述和特点</strong></p><ul><li><p><strong>由键决定：有序、不重复、无索引。</strong></p></li><li><p>这里的有序指的是<strong>保证存储和取出的元素顺序一致</strong></p></li><li><p><strong>原理</strong>：底层数据结构是依然<strong>哈希表</strong>，只是每个键值对元素又额外的多了一个<strong>双链表</strong>的机制记录存储的顺序。</p></li></ul><p><img src="C:\Users\廖永森\AppData\Roaming\Typora\typora-user-images\image-20220205125949298.png" alt="image-20220205125949298"></p><h4 id="6-8Map集合的实现类TreeMap"><a href="#6-8Map集合的实现类TreeMap" class="headerlink" title="6.8Map集合的实现类TreeMap"></a>6.8Map集合的实现类TreeMap</h4><p><strong>TreeMap集合概述和特点</strong></p><ul><li><p><strong>由键决定特性：可排序、不重复、无索引</strong></p></li><li><p>可排序：按照键数据的大小默认升序（有小到大）排序。<strong>只能对键排序。</strong></p></li><li><p><strong>注意：TreeMap集合是一定要排序的，可以默认排序，也可以将键按照指定的规则进行排序</strong></p></li><li><p>TreeMap跟TreeSet一样底层原理是一样的(基于红黑树)。</p></li></ul><p><strong>TreeMap集合自定义排序规则有2种</strong></p><ul><li><p>类实现Comparable接口，重写比较规则。</p></li><li><p>集合自定义Comparator比较器对象，重写比较规则。</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Comparator比较器对象</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// TreeMap集合自带排序。  可排序 不重复（只要大小规则一样就认为重复）  无索引</span></span><br><span class="line">Map&lt;Apple, String&gt; maps2 = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Apple&gt;() &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Apple o1, Apple o2)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> Double.compare(o2.getPrice() , o1.getPrice()); <span class="comment">// 按照价格降序排序！</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">   maps2.put(<span class="keyword">new</span> <span class="title class_">Apple</span>(<span class="string">&quot;红富士&quot;</span>, <span class="string">&quot;红色&quot;</span>, <span class="number">9.9</span>, <span class="number">500</span>), <span class="string">&quot;山东&quot;</span> );</span><br><span class="line">   maps2.put(<span class="keyword">new</span> <span class="title class_">Apple</span>(<span class="string">&quot;青苹果&quot;</span>, <span class="string">&quot;绿色&quot;</span>, <span class="number">15.9</span>, <span class="number">300</span>), <span class="string">&quot;广州&quot;</span>);</span><br><span class="line">   maps2.put(<span class="keyword">new</span> <span class="title class_">Apple</span>(<span class="string">&quot;绿苹果&quot;</span>, <span class="string">&quot;青色&quot;</span>, <span class="number">29.9</span>, <span class="number">400</span>), <span class="string">&quot;江西&quot;</span>);</span><br><span class="line">   maps2.put(<span class="keyword">new</span> <span class="title class_">Apple</span>(<span class="string">&quot;黄苹果&quot;</span>, <span class="string">&quot;黄色&quot;</span>, <span class="number">9.8</span>, <span class="number">500</span>), <span class="string">&quot;湖北&quot;</span>);</span><br><span class="line"></span><br><span class="line">   System.out.println(maps2);</span><br></pre></td></tr></table></figure><h3 id="7-补充知识：集合的嵌套"><a href="#7-补充知识：集合的嵌套" class="headerlink" title="7.补充知识：集合的嵌套"></a>7.补充知识：集合的嵌套</h3><p><strong>Map集合案例</strong></p><p>统计投票人数</p><p><strong>需求</strong></p><ul><li>某个班级多名学生，现在需要组成秋游活动，班长提供了四个景点依次是（A、B、C、D）,每个学生可以选择多个景点，请统计出最终哪个景点想去的人数最多。</li></ul><p><strong>分析</strong></p><ul><li><p>将80个学生选择的数据拿到程序中去，需要记住每个学生选择的情况。</p></li><li><p>定义Map集合用于存储最终统计的结果。</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   需求：统计投票人数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapTest4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、要求程序记录每个学生选择的情况。</span></span><br><span class="line">        <span class="comment">// 使用一个Map集合存储。</span></span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; data = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、把学生选择的数据存入进去。</span></span><br><span class="line">        List&lt;String&gt; selects = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(selects, <span class="string">&quot;A&quot;</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">        data.put(<span class="string">&quot;罗勇&quot;</span>, selects);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; selects1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(selects1, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span> , <span class="string">&quot;D&quot;</span>);</span><br><span class="line">        data.put(<span class="string">&quot;胡涛&quot;</span>, selects1);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; selects2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(selects2 , <span class="string">&quot;A&quot;</span>,  <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span> , <span class="string">&quot;D&quot;</span>);</span><br><span class="line">        data.put(<span class="string">&quot;刘军&quot;</span>, selects2);</span><br><span class="line"></span><br><span class="line">        System.out.println(data);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、统计每个景点选择的人数。</span></span><br><span class="line">        <span class="comment">//  &lt;ABCD选项，出现的次数&gt;</span></span><br><span class="line">        Map&lt;String, Integer&gt; infos = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(); <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、提取所有人选择的景点的信息。</span></span><br><span class="line">         <span class="comment">// 提取data的值 --&gt; &lt;List&lt;String&gt;</span></span><br><span class="line">        Collection&lt;List&lt;String&gt;&gt; values = data.values();</span><br><span class="line">        System.out.println(values);</span><br><span class="line">        <span class="comment">// values = [[A, B, C, D], [B, C, D], [A, C]]</span></span><br><span class="line">        <span class="comment">//              value</span></span><br><span class="line">        <span class="comment">//            s</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (List&lt;String&gt; value : values) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String s : value) &#123;</span><br><span class="line">                <span class="comment">// 有没有包含这个景点</span></span><br><span class="line">                <span class="keyword">if</span>(infos.containsKey(s))&#123;</span><br><span class="line">                    infos.put(s, infos.get(s) + <span class="number">1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    infos.put(s , <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(infos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> java,面向对象进阶,Set,Collections,Map,集合嵌套 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>day14 - 集合</title>
      <link href="/post/eb2b9d82.html"/>
      <url>/post/eb2b9d82.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-集合的概述"><a href="#1-集合的概述" class="headerlink" title="1.集合的概述"></a>1.集合的概述</h3><p>集合和数组都是容器。</p><p><strong>数组的特点</strong></p><ul><li><p>数组定义完成并启动后，<strong>类型确定、长度固定</strong>。</p></li><li><p>适合元素的个数和类型确定的业务场景，不适合做需要增删数据操作。</p></li></ul><p>1、数组和集合的元素存储的个数问题。</p><ul><li><p><strong>数组</strong>定义后类型确定，长度固定</p></li><li><p><strong>集合</strong>类型可以不固定，大小是可变的。</p></li></ul><p>2、数组和集合存储元素的类型问题。</p><ul><li><p><strong>数组</strong>可以存储基本类型和引用类型的数据。</p></li><li><p><strong>集合</strong>只能存储引用数据类型的数据。</p></li></ul><p>3、数组和集合适合的场景</p><ul><li><p><strong>数组</strong>适合做数据个数和类型确定的场景。</p></li><li><p><strong>集合</strong>适合做数据个数不确定，且要做增删元素的场景。</p></li></ul><h3 id="2-集合的体系特点"><a href="#2-集合的体系特点" class="headerlink" title="2.集合的体系特点"></a>2.集合的体系特点</h3><p><strong>集合的代表</strong></p><ul><li><strong>Collection接口。</strong></li></ul><p><strong>集合类体系结构</strong></p><ul><li><p>Collection单列集合，每个元素（数据）只包含一个值。</p></li><li><p>Map双列集合，每个元素包含两个值（键值对）。</p></li><li><p><strong>注意：前期先掌握Collection集合体系的使用。</strong></p></li></ul><p><strong>Collection集合体系</strong></p><ol><li><strong>Collection 接口</strong>：<code>Collection</code> 接口是所有集合类的根接口，它定义了基本的集合操作，如添加、删除、遍历等。<code>Collection</code> 接口又分为以下几种常见的子接口和实现类：<ul><li><code>List</code>：有序的集合，允许重复元素。常见的实现类有 <code>ArrayList</code>、<code>LinkedList</code> 和 <code>Vector</code>。</li><li><code>Set</code>：不允许重复元素的集合。常见的实现类有 <code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code>。</li><li><code>Queue</code>：队列集合，支持在一端插入元素，在另一端删除元素。常见的实现类有 <code>LinkedList</code> 和 <code>PriorityQueue</code>。</li></ul></li><li><strong>Map 接口</strong>：<code>Map</code> 接口用于存储键-值对，每个键映射到一个值。<code>Map</code> 接口提供了以键为索引进行访问的功能。常见的实现类有：<ul><li><code>HashMap</code>：基于哈希表实现，无序。</li><li><code>LinkedHashMap</code>：基于链表和哈希表实现，保持插入顺序。</li><li><code>TreeMap</code>：基于红黑树实现，按照键的自然顺序或自定义顺序排序。</li><li><code>Hashtable</code>：类似于 <code>HashMap</code>，但是线程安全（不推荐使用，因为性能相对较差）。</li></ul></li></ol><p><strong>Collection集合特点</strong></p><ul><li><p><strong>List系列集合</strong>：添加的元素是有序、可重复、有索引。</p><ul><li>ArrayList、LinekdList ：<strong>有序、可重复、有索引。</strong></li></ul></li><li><p><strong>Set系列集合</strong>：添加的元素是无序、不重复、无索引。</p><ul><li>HashSet: 无序、不重复、无索引；LinkedHashSet: <strong>有序、不重复、无索引。</strong></li><li>TreeSet：<strong>按照大小默认升序排序、不重复、无索引。</strong></li></ul></li></ul><p><strong>集合对于泛型的支持</strong></p><ul><li>集合都是支持泛型的，可以在编译阶段约束集合只能操作某种数据类型</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection&lt;String&gt; lists = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">Collection&lt;String&gt; lists = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); </span><br><span class="line"><span class="comment">// JDK 1.7开始后面的泛型类型申明可以省略不写</span></span><br></pre></td></tr></table></figure><p><strong>注意：集合和泛型都只能支持引用数据类型，不支持基本数据类型，所以集合中存储的元素都认为是对象。</strong></p><h3 id="3-Collection的常用API"><a href="#3-Collection的常用API" class="headerlink" title="3.Collection的常用API"></a>3.Collection的常用API</h3><p><strong>Collection集合</strong> </p><ul><li>Collection是单列集合的祖宗接口，它的功能是全部单列集合都可以继承使用的。</li></ul><p><strong>Collection API如下:</strong></p><table><thead><tr><th>方法名称</th><th align="left">说明</th></tr></thead><tbody><tr><td>public  boolean add(E e)</td><td align="left">把给定的对象添加到当前集合中</td></tr><tr><td>public  void clear()</td><td align="left">清空集合中所有的元素</td></tr><tr><td>public  boolean remove(E e)</td><td align="left">把给定的对象在当前集合中删除</td></tr><tr><td>public  boolean contains(Object obj)</td><td align="left">判断当前集合中是否包含给定的对象(使用<strong>多态Collection和Set系列</strong>创建对象,不支持索引)</td></tr><tr><td>public  boolean isEmpty()</td><td align="left">判断当前集合是否为空</td></tr><tr><td>public  int size()</td><td align="left">返回集合中元素的个数。</td></tr><tr><td>public  Object[] toArray()</td><td align="left">把集合中的元素，存储到数组中  (需要使用Object[]  类来接，否则报错)</td></tr></tbody></table><h3 id="4-集合的遍历方式"><a href="#4-集合的遍历方式" class="headerlink" title="4.集合的遍历方式"></a>4.集合的遍历方式</h3><h4 id="4-1迭代器"><a href="#4-1迭代器" class="headerlink" title="4.1迭代器"></a>4.1迭代器</h4><p><strong>迭代器遍历概述</strong></p><ul><li><p>遍历就是一个一个的把容器中的元素访问一遍。 </p></li><li><p>迭代器在Java中的代表是<strong>Iterator</strong>，迭代器是集合的专用遍历方式。</p><p>*Iterator<E> iterator()*：得到迭代器对象</p></li></ul><p><strong>Collection集合获取迭代器</strong></p><table><thead><tr><th align="left">方法名称</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><strong>Iterator<E></strong>  <strong>iterator()</strong></td><td align="left">返回集合中的迭代器对象，该迭代器对象默认指向当前集合的0索引</td></tr></tbody></table><p><strong>Iterator中的常用方法</strong></p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>boolean <strong>hasNext</strong>()</td><td>询问当前位置是否有元素存在，存在返回true(循环继续),不存在返回false(循环结束)</td></tr><tr><td>E  <strong>next</strong>()</td><td>获取当前位置的元素，并同时将迭代器对象移向下一个位置，注意防止取出越界。</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;String&gt; it = lists.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;  <span class="comment">//使用hasNext判断是否有元素存在，循环遍历</span></span><br><span class="line"><span class="type">String</span> <span class="variable">ele</span> <span class="operator">=</span> it.next();</span><br><span class="line">System.out.println(ele);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代器如果取元素越界会出现什么问题</p><ul><li><strong>会出现NoSuchElementException异常。</strong></li></ul><h4 id="4-2foreach-增强for循环"><a href="#4-2foreach-增强for循环" class="headerlink" title="4.2foreach&#x2F;增强for循环"></a>4.2foreach&#x2F;增强for循环</h4><p><strong>增强fo循环</strong></p><p>for(<strong>元素数据类型</strong> <strong>变量名</strong> : <strong>数组或者Collection集合对象</strong>) {</p><p>​     &#x2F;&#x2F;在此处使用变量即可，该变量就是元素</p><p>}</p><ul><li>增强for循环：既可以<strong>遍历集合</strong>也可以<strong>遍历数组</strong>。（ Iterator 迭代器 ，只能遍历集合）</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span>(String ele : list) &#123;</span><br><span class="line">System.out.println(ele);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>快捷键：变量名.for回车</p><p><strong>修改第三方变量的值不会影响到集合中的元素</strong></p><h4 id="4-3lambda表达式"><a href="#4-3lambda表达式" class="headerlink" title="4.3lambda表达式"></a>4.3lambda表达式</h4><p><strong>Lambda表达式遍历集合</strong></p><ul><li>得益于JDK 8开始的新技术Lambda表达式，提供了一种更简单、更直接的遍历集合的方式。</li></ul><p><strong>Collection结合Lambda遍历的API</strong></p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>default void <strong>forEach</strong>(Consumer&lt;? super T&gt; action):</td><td>结合lambda遍历集合</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection&lt;String&gt; lists = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">...</span><br><span class="line">lists.forEach(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span> &#123;</span><br><span class="line">System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//简化</span></span><br><span class="line">   lists.forEach(s -&gt; &#123;</span><br><span class="line">       System.out.println(s);</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//简化</span></span><br><span class="line">lists.forEach(s -&gt; System.out.println(s));</span><br><span class="line"></span><br><span class="line"><span class="comment">//再简化</span></span><br><span class="line">lists.forEach(System.out::println);</span><br></pre></td></tr></table></figure><h3 id="5-集合存储自定义类型的对象"><a href="#5-集合存储自定义类型的对象" class="headerlink" title="5.集合存储自定义类型的对象"></a>5.集合存储自定义类型的对象</h3><p><strong>案例：</strong></p><p>影片信息在程序中的表示</p><p><strong>需求</strong></p><ul><li>某影院系统需要在后台存储上述三部电影，然后依次展示出来。</li></ul><p><strong>分析</strong></p><p>①：定义一个电影类，定义一个集合存储电影对象。</p><p>②：创建3个电影对象，封装相关数据，把3个对象存入到集合中去。</p><p>③：遍历集合中的3个对象，输出相关信息。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1、定义一个电影类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、定义一个集合对象存储3部电影对象</span></span><br><span class="line">        Collection&lt;Movie&gt; movies = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        movies.add(<span class="keyword">new</span> <span class="title class_">Movie</span>(<span class="string">&quot;《你好，李焕英》&quot;</span>, <span class="number">9.5</span>, <span class="string">&quot;张小斐,贾玲,沈腾,陈赫&quot;</span>));</span><br><span class="line">        movies.add(<span class="keyword">new</span> <span class="title class_">Movie</span>(<span class="string">&quot;《唐人街探案》&quot;</span>, <span class="number">8.5</span>, <span class="string">&quot;王宝强,刘昊然&quot;</span>));</span><br><span class="line">        movies.add(<span class="keyword">new</span> <span class="title class_">Movie</span>(<span class="string">&quot;《刺杀小说家》&quot;</span>,<span class="number">8.6</span>, <span class="string">&quot;雷佳音,杨幂&quot;</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(movies);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、遍历集合容器中的每个电影对象</span></span><br><span class="line">        <span class="keyword">for</span> (Movie movie : movies) &#123;  <span class="comment">//增强for</span></span><br><span class="line">            System.out.println(<span class="string">&quot;片名：&quot;</span> + movie.getName());</span><br><span class="line">            System.out.println(<span class="string">&quot;得分：&quot;</span> + movie.getScore());</span><br><span class="line">            System.out.println(<span class="string">&quot;主演：&quot;</span> + movie.getActor());</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><strong>集合中存储的是元素的什么信息?</strong></p><ul><li><strong>集合中存储的是元素对象的地址。</strong></li></ul><h3 id="6-常见数据结构"><a href="#6-常见数据结构" class="headerlink" title="6.常见数据结构"></a>6.常见数据结构</h3><h4 id="6-1数据结构概述、栈、队列"><a href="#6-1数据结构概述、栈、队列" class="headerlink" title="6.1数据结构概述、栈、队列,"></a>6.1数据结构概述、栈、队列,</h4><p><strong>数据结构概述</strong></p><ul><li><p>数据结构是计算机底层存储、组织数据的方式。是指数据相互之间是以什么方式排列在一起的。</p></li><li><p>通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率</p></li></ul><p><strong>常见的数据结构</strong></p><ul><li><p>栈</p></li><li><p>队列</p></li><li><p>数组</p></li><li><p>链表</p></li><li><p>二叉树</p></li><li><p>二叉查找树</p></li><li><p>平衡二叉树</p></li><li><p>红黑树</p></li><li><p>……</p></li></ul><p><strong>栈数据结构的执行特点</strong></p><ul><li>后进先出，先进后出</li></ul><p><strong>数据进入栈模型的过程称为：压&#x2F;进栈</strong></p><p><strong>数据离开栈模型的过程称为：弹&#x2F;出栈</strong></p><p><strong>常见数据结构之队列</strong></p><ul><li>先进先出，后进后出</li></ul><p><strong>数据从后端进入队列模型的过程称为：入队列</strong></p><p><strong>数据从前端离开队列模型的过程称为：出队列</strong></p><p><strong>常见数据结构之数组</strong></p><ul><li><p><strong>查询速度快：</strong>查询数据通过地址值和索引定位，查询任意数据耗时相同<strong>。</strong>（元素在内存中是连续存储的）</p></li><li><p><strong>删除效率低：</strong>要将原始数据删除，同时后面每个数据前移。</p></li><li><p><strong>添加效率极低：</strong>添加位置后的每个数据后移，再添加元素。</p></li></ul><h4 id="6-3链表"><a href="#6-3链表" class="headerlink" title="6.3链表"></a>6.3链表</h4><p><strong>链表的特点</strong></p><ul><li>链表中的元素是在内存中不连续存储的，每个元素节点包含数据值和下一个元素的地址。</li></ul><p><strong>链表的特点</strong></p><ul><li><p>链表中的元素是<strong>游离存储</strong>的，每个元素节点包含<strong>数据值和下一个元素的地址</strong>。</p></li><li><p><strong>链表查询慢</strong>，无论查询哪个数据都要从头开始找。</p></li><li><p><strong>链表增删相对快</strong></p></li><li><p><strong>链表查询首位元素极快</strong></p></li></ul><p><strong>链表是一种增删快的模型(对比数组）</strong></p><p><strong>链表是一种查询慢的模型(对比数组）</strong></p><p><strong>链表的种类</strong></p><ol><li><strong>单向链表（Singly Linked List）</strong>：在单向链表中，每个元素包含一个值和一个指向下一个元素的指针。链表的第一个元素称为头节点，最后一个元素的指针为空。这种链表只能从头节点开始遍历，每个元素只能访问下一个元素。</li><li><strong>双向链表（Doubly Linked List）</strong>：在双向链表中，每个元素包含一个值、一个指向下一个元素的指针和一个指向前一个元素的指针。这种链表可以从头节点或尾节点开始遍历，每个元素都可以访问前一个和下一个元素。</li><li><strong>循环链表（Circular Linked List）</strong>：循环链表是一种特殊类型的链表，最后一个元素的指针指向头节点，形成一个循环。这种链表可以通过任何元素开始遍历，可以在某个方向上一直遍历下去。</li><li><strong>双向循环链表（Doubly Circular Linked List）</strong>：结合了双向链表和循环链表的特性，每个元素包含一个指向前一个元素和一个指向下一个元素的指针，而最后一个元素的指针指向头节点。</li><li><strong>跳表（Skip List）</strong>：跳表是一种允许快速查找的数据结构，它是基于多层链表的结构，每一层都是一个有序链表，而最底层的链表包含所有元素。跳表的设计允许快速地进行元素查找和插入操作，类似于平衡树的操作效率。</li></ol><h4 id="6-4二叉树、-二叉查找树"><a href="#6-4二叉树、-二叉查找树" class="headerlink" title="6.4二叉树、 二叉查找树"></a>6.4二叉树、 二叉查找树</h4><p><strong>二叉树概述</strong></p><ol><li><strong>根节点和子节点</strong>：二叉树的顶部节点称为根节点。每个节点可以有零、一个或两个子节点。节点的子节点分为左子节点和右子节点，这两个子节点的相对顺序是重要的。</li><li><strong>节点关系</strong>：对于一个节点，它的子节点是通过指针或引用与之相连的。节点与其子节点的连接关系定义了树的结构。</li><li><strong>深度和高度</strong>：节点的深度是指从根节点到该节点的路径长度，根节点的深度为0。二叉树的高度是树中从根节点到最远叶子节点的最长路径的长度。</li><li><strong>叶子节点</strong>：叶子节点是指没有子节点的节点，也称为终端节点。它们位于树的末端。</li><li><strong>满二叉树</strong>：在满二叉树中，除了叶子节点，每个节点都有两个子节点。每一层都被完全填满。</li><li><strong>完全二叉树</strong>：完全二叉树是指除了最后一层外，其他层都被完全填满，而且最后一层的节点靠左排列。</li><li><strong>二叉搜索树（BST）</strong>：二叉搜索树是一种特殊的二叉树，其中每个节点的值大于其左子树中的所有节点的值，小于其右子树中的所有节点的值。这种特性使得在BST中进行搜索、插入和删除操作的效率较高。</li><li><strong>平衡二叉树（AVL树）</strong>：平衡二叉树是一种特殊的BST，它保持了左子树和右子树的高度差不超过1，从而保证了树的高度较低，提高了各种操作的效率。</li><li><strong>二叉树的遍历</strong>：遍历是指按照一定顺序访问树中的所有节点。常见的二叉树遍历方式有前序遍历（根-左-右）、中序遍历（左-根-右）、后序遍历（左-右-根）和层序遍历（逐层遍历节点）。</li></ol><p><strong>二叉树的特点</strong></p><ul><li><p><strong>只能有一个根节点</strong>，每个节点最多支持2个直接子节点。</p></li><li><p><strong>节点的度：</strong> 节点拥有的子树的个数，二叉树的度不大于2 叶子节点 度为0的节点，也称之为终端结点。</p></li><li><p><strong>高度：</strong>叶子结点的高度为1，叶子结点的父节点高度为2，以此类推，根节点的高度最高。</p></li><li><p><strong>层：</strong>根节点在第一层，以此类推</p></li><li><p><strong>兄弟节点 ：</strong>拥有共同父节点的节点互称为兄弟节点</p></li></ul><p><strong>二叉查找树又称二叉排序树或者二叉搜索树</strong></p><p><strong>特点：</strong></p><ul><li><p>1，每一个节点上最多有两个子节点</p></li><li><p>2，左子树上所有节点的值都小于根节点的值</p></li><li><p>3，右子树上所有节点的值都大于根节点的值</p></li></ul><p><strong>目的：提高检索数据的性能</strong>。</p><p><strong>二叉树查找树添节点:</strong></p><p><strong>规则：</strong> <strong>小的存左边</strong> <strong>大的存右边</strong> <strong>一样的不存</strong></p><h4 id="6-5平衡二叉树"><a href="#6-5平衡二叉树" class="headerlink" title="6.5平衡二叉树"></a>6.5平衡二叉树</h4><p><strong>问题：二叉树查找出现瘸子现象，导致查询的性能与单链表一样，查询速度变慢！</strong></p><p><strong>数据结构–平衡二叉树</strong></p><ul><li>平衡二叉树是在满足查找二叉树的大小规则下，让树尽可能矮小，以此提高查数据的性能。</li></ul><p><strong>平衡二叉树的要求</strong></p><ul><li>任意节点的左右两个子树的高度差不超过1，任意节点的左右两个子树都是一颗平衡二叉树</li></ul><p><strong>平衡二叉树在添加元素后可能导致不平衡</strong></p><ul><li>基本策略是进行<strong>左旋</strong>，或者<strong>右旋</strong>保证平衡。</li></ul><p><strong>平衡二叉树旋转的四种情况</strong></p><ul><li><p>左左</p><p> 当根节点左子树的左子树有节点插入，导致二叉树不平衡（右旋）</p></li><li><p>左右</p><p>当根节点左子树的右子树有节点插入，导致二叉树不平衡</p><p><strong>仅仅做一个右旋还是不行</strong></p><p><strong>第二层及以上先左旋，整体再右旋</strong></p></li><li><p>右右</p><p> 当根节点右子树的右子树有节点插入，导致二叉树不平衡</p></li><li><p>右左</p><p>当根节点右子树的左子树有节点插入，导致二叉树不平衡</p><p><strong>仅仅做一个左旋还是不行</strong></p><p><strong>第二层及以上先右旋，整体再左旋</strong></p></li></ul><h4 id="6-6红黑树"><a href="#6-6红黑树" class="headerlink" title="6.6红黑树"></a>6.6红黑树</h4><p><strong>红黑树概述</strong></p><ul><li><p>红黑树是一种自平衡的二叉查找树，是计算机科学中用到的一种数据结构。</p></li><li><p>1972年出现，当时被称之为平衡二叉B树。1978年被修改为如今的”红黑树”。</p></li><li><p>每一个节点可以是红或者黑；<strong>红黑树不是通过高度平衡的</strong>，它的平衡是通过“红黑规则”进行实现的。</p></li></ul><p><strong>红黑规则</strong></p><ul><li><p>每一个节点或是红色的，或者是黑色的，<strong>根节点必须是黑色。</strong></p></li><li><p>如果某一个节点是红色，那么它的子节点必须是黑色(<strong>不能出现两个红色节点相连的情况</strong>)。</p></li><li><p><strong>对每一个节点，从该节点到其所有后代叶节点的简单路径上，均包含相同数目的黑色节点。</strong></p></li></ul><p><strong>添加节点</strong></p><ul><li><p>添加的节点的颜色，可以是红色的，也可以是黑色的。</p></li><li><p>如果一个节点没有子节点或者父节点，则该节点相应的指针属性值为Nil，这些Nil视为叶节点，每个叶节点(Nil)是黑色的；</p></li><li><p><strong>默认用红色效率高。</strong></p></li></ul><p><strong>红黑树增删改查的性能都很好</strong></p><h3 id="7-List系列集合"><a href="#7-List系列集合" class="headerlink" title="7.List系列集合"></a>7.List系列集合</h3><h4 id="7-1List集合特点、特有API"><a href="#7-1List集合特点、特有API" class="headerlink" title="7.1List集合特点、特有API"></a>7.1List集合特点、特有API</h4><p><strong>Collection集合体系</strong></p><ol><li><strong>Collection 接口</strong>：<code>Collection</code> 接口是所有集合类的根接口，它定义了基本的集合操作，如添加、删除、遍历等。<code>Collection</code> 接口又分为以下几种常见的子接口和实现类：<ul><li><code>List</code>：有序的集合，允许重复元素。常见的实现类有 <code>ArrayList</code>、<code>LinkedList</code> 和 <code>Vector</code>。</li><li><code>Set</code>：不允许重复元素的集合。常见的实现类有 <code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code>。</li><li><code>Queue</code>：队列集合，支持在一端插入元素，在另一端删除元素。常见的实现类有 <code>LinkedList</code> 和 <code>PriorityQueue</code>。</li></ul></li><li><strong>Map 接口</strong>：<code>Map</code> 接口用于存储键-值对，每个键映射到一个值。<code>Map</code> 接口提供了以键为索引进行访问的功能。常见的实现类有：<ul><li><code>HashMap</code>：基于哈希表实现，无序。</li><li><code>LinkedHashMap</code>：基于链表和哈希表实现，保持插入顺序。</li><li><code>TreeMap</code>：基于红黑树实现，按照键的自然顺序或自定义顺序排序。</li><li><code>Hashtable</code>：类似于 <code>HashMap</code>，但是线程安全（不推荐使用，因为性能相对较差）。</li></ul></li></ol><p><strong>List系列集合特点</strong></p><ul><li><p>ArrayList、LinekdList ：有序，可重复，有索引。</p></li><li><p>有序：存储和取出的元素顺序一致</p></li><li><p>有索引：可以通过索引操作元素</p></li><li><p>可重复：存储的元素可以重复</p></li></ul><p><strong>List集合特有方法</strong></p><ul><li>List集合因为支持索引，所以多了很多索引操作的独特api，其他Collection的功能List也都继承了。</li></ul><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>void add(int  index,E element)</td><td>在此集合中的指定位置插入指定的元素</td></tr><tr><td>E remove(int  index)</td><td>删除指定索引处的元素，返回被删除的元素</td></tr><tr><td>E set(int index,E  element)</td><td>修改指定索引处的元素，返回被修改的元素</td></tr><tr><td>E get(int  index)</td><td>返回指定索引处的元素</td></tr><tr><td>indexOf</td><td>去集合中取已知元素的索引</td></tr></tbody></table><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.创建一个ArrayList集合对象：</span></span><br><span class="line">       <span class="comment">// List:有序，可重复，有索引的。</span></span><br><span class="line">       ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 一行经典代码！</span></span><br><span class="line">       list.add(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">       list.add(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">       list.add(<span class="string">&quot;HTML&quot;</span>);</span><br><span class="line">       list.add(<span class="string">&quot;HTML&quot;</span>);</span><br><span class="line">       list.add(<span class="string">&quot;MySQL&quot;</span>);</span><br><span class="line">       list.add(<span class="string">&quot;MySQL&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 2.在某个索引位置插入元素。</span></span><br><span class="line">       list.add(<span class="number">2</span>, <span class="string">&quot;黑马&quot;</span>);</span><br><span class="line">       System.out.println(list);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 3.根据索引删除元素,返回被删除元素</span></span><br><span class="line">       System.out.println(list.remove(<span class="number">1</span>));</span><br><span class="line">       System.out.println(list);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 4.根据索引获取元素:public E get(int index):返回集合中指定位置的元素。</span></span><br><span class="line">       System.out.println(list.get(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 5.修改索引位置处的元素: public E set(int index, E element)</span></span><br><span class="line">       System.out.println(list.set(<span class="number">1</span>, <span class="string">&quot;传智教育&quot;</span>));</span><br><span class="line">       System.out.println(list);</span><br></pre></td></tr></table></figure><p><strong>List的实现类的底层原理</strong></p><ul><li><p>ArrayList底层是基于数组实现的，根据查询元素快，增删相对慢。</p></li><li><p>LinkedList底层基于双链表实现的，查询元素慢，增删首尾元素是非常快的。</p></li></ul><h4 id="7-2List集合的遍历方式小结"><a href="#7-2List集合的遍历方式小结" class="headerlink" title="7.2List集合的遍历方式小结"></a>7.2List集合的遍历方式小结</h4><p><strong>List集合的遍历方式有4种</strong></p><ul><li><p>①迭代器 </p></li><li><p>②增强for循环</p></li><li><p>③Lambda表达式</p></li><li><p>④for循环（因为List集合存在索引）</p></li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    拓展：List系列集合的遍历方式有：4种。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    List系列集合多了索引，所以多了一种按照索引遍历集合的for循环。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    List遍历方式：</span></span><br><span class="line"><span class="comment">        （1）for循环。(独有的，因为List有索引)。</span></span><br><span class="line"><span class="comment">        （2）迭代器。</span></span><br><span class="line"><span class="comment">        （3）foreach。</span></span><br><span class="line"><span class="comment">        （4）JDK 1.8新技术Lambda表达式,(JDK 1.8新技术)。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; lists = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        lists.add(<span class="string">&quot;java1&quot;</span>);</span><br><span class="line">        lists.add(<span class="string">&quot;java2&quot;</span>);</span><br><span class="line">        lists.add(<span class="string">&quot;java3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** （1）for循环。 */</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lists.size(); i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">ele</span> <span class="operator">=</span> lists.get(i);</span><br><span class="line">            System.out.println(ele);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/** （2）迭代器。 */</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------&quot;</span>);</span><br><span class="line">        Iterator&lt;String&gt; it = lists.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">ele</span> <span class="operator">=</span> it.next();</span><br><span class="line">            System.out.println(ele);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** （3）foreach */</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String ele : lists) &#123;</span><br><span class="line">            System.out.println(ele);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** （4）JDK 1.8开始之后的Lambda表达式  */</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------&quot;</span>);</span><br><span class="line">        lists.forEach(s -&gt; &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><h4 id="7-3ArrayList集合的底层原理"><a href="#7-3ArrayList集合的底层原理" class="headerlink" title="7.3ArrayList集合的底层原理"></a>7.3ArrayList集合的底层原理</h4><p><strong>ArrayList集合底层原理</strong></p><ul><li><p>ArrayList底层是基于数组实现的：根据索引定位元素快，增删需要做元素的移位操作。</p></li><li><p>第一次创建集合并添加第一个元素的时候，在底层创建一个默认长度为10的数组。</p></li></ul><p><strong>List集合存储的元素要超过容量怎么办？</strong></p><ul><li>会以自身长度的1.5倍扩容</li></ul><h4 id="7-4LinkedList集合的底层原理"><a href="#7-4LinkedList集合的底层原理" class="headerlink" title="7.4LinkedList集合的底层原理"></a>7.4LinkedList集合的底层原理</h4><p><strong>LinkedList的特点</strong></p><ul><li>底层数据结构是<strong>双链表</strong>，<strong>查询慢</strong>，<strong>首尾操作的速度是极快的</strong>，所以多了很多首尾操作的特有API。</li></ul><p><strong>LinkedList集合的特有功能</strong></p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>public  void <strong>addFirst</strong>(E e)栈结构:或push</td><td>在该列表开头插入指定的元素(入栈)</td></tr><tr><td>public  void <strong>addLast</strong>(E e)</td><td>将指定的元素追加到此列表的末尾(入队)</td></tr><tr><td>public  E <strong>getFirst</strong>()</td><td>返回此列表中的第一个元素</td></tr><tr><td>public  E <strong>getLast</strong>()</td><td>返回此列表中的最后一个元素</td></tr><tr><td>public  E <strong>removeFirst</strong>()  栈结构:或pop</td><td>从此列表中删除并返回第一个元素(出栈，出队)</td></tr><tr><td>public  E <strong>removeLast</strong>()</td><td>从此列表中删除并返回最后一个元素</td></tr></tbody></table><p>(栈结构:先进后出）  (队列结构:先进先出）</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// LinkedList可以完成队列结构，和栈结构 （双链表）</span></span><br><span class="line">        <span class="comment">// 1、做一个队列：</span></span><br><span class="line">        LinkedList&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 入队</span></span><br><span class="line">        queue.addLast(<span class="string">&quot;1号&quot;</span>);</span><br><span class="line">        queue.addLast(<span class="string">&quot;2号&quot;</span>);</span><br><span class="line">        queue.addLast(<span class="string">&quot;3号&quot;</span>);</span><br><span class="line">        System.out.println(queue);</span><br><span class="line">        <span class="comment">// 出队</span></span><br><span class="line">        <span class="comment">// System.out.println(queue.getFirst());</span></span><br><span class="line">        System.out.println(queue.removeFirst());</span><br><span class="line">        System.out.println(queue.removeFirst());</span><br><span class="line">        System.out.println(queue);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、做一个栈</span></span><br><span class="line">        LinkedList&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 入栈 压栈 (push)</span></span><br><span class="line">        stack.push(<span class="string">&quot;第1颗子弹&quot;</span>);</span><br><span class="line">        stack.push(<span class="string">&quot;第2颗子弹&quot;</span>);</span><br><span class="line">        stack.push(<span class="string">&quot;第3颗子弹&quot;</span>);</span><br><span class="line">        stack.push(<span class="string">&quot;第4颗子弹&quot;</span>);</span><br><span class="line">        System.out.println(stack);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 出栈  弹栈 pop</span></span><br><span class="line">        System.out.println(stack.pop());</span><br><span class="line">        System.out.println(stack.pop());</span><br><span class="line">        System.out.println(stack.pop());</span><br><span class="line">        System.out.println(stack);</span><br></pre></td></tr></table></figure><h3 id="8-补充知识：集合的并发修改异常问题"><a href="#8-补充知识：集合的并发修改异常问题" class="headerlink" title="8.补充知识：集合的并发修改异常问题"></a>8.补充知识：集合的并发修改异常问题</h3><p><strong>从集合中的一批元素中找出某些数据并删除，如何操作？是否存在问题呢 ？</strong></p><ul><li>当我们从集合中<strong>找出某个元素并删除</strong>的时候可能出现一种<strong>并发修改异常</strong>问题。</li></ul><p><strong>哪些遍历存在问题？</strong></p><ul><li><p><strong>迭代器</strong>遍历集合且直接用集合删除元素的时候可能出现。</p></li><li><p><strong>增强for循环</strong>遍历集合且直接用集合删除元素的时候可能出现。</p></li></ul><p><strong>哪种遍历且删除元素不出问题</strong></p><ul><li><p><strong>迭代器</strong>遍历集合但是用迭代器自己的删除方法操作可以解决。</p></li><li><p><strong>普通for循环</strong>遍历并删除元素不会存在这个问题。</p></li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：研究集合遍历并删除元素可能出现的：并发修改异常问题。</span></span><br><span class="line"><span class="comment">    需求：删除全部的Java信息。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、准备数据</span></span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;黑马&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;赵敏&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;赵敏&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;素素&quot;</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="comment">// [黑马, Java, Java, 赵敏, 赵敏, 素素]</span></span><br><span class="line">        <span class="comment">//        it</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// a、迭代器遍历删除</span></span><br><span class="line">       Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line"><span class="comment">//       while (it.hasNext())&#123;</span></span><br><span class="line"><span class="comment">//         String ele = it.next();</span></span><br><span class="line"><span class="comment">//         if(&quot;Java&quot;.equals(ele))&#123; //判断是否是Java    </span></span><br><span class="line"><span class="comment">//           list.remove(ele); //删除Java,集合删除会出毛病</span></span><br><span class="line"><span class="comment">//           it.remove(); // 删除迭代器所在位置的元素值（没毛病）</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        System.out.println(list);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// b、foreach遍历删除 (会出现问题，这种无法解决的，foreach不能边遍历边删除，会出bug)</span></span><br><span class="line"><span class="comment">//        for (String s : list) &#123;</span></span><br><span class="line"><span class="comment">//            if(&quot;Java&quot;.equals(s))&#123;</span></span><br><span class="line"><span class="comment">//                list.remove(s);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// c、lambda表达式(会出现问题，这种无法解决的，Lambda遍历不能边遍历边删除，会出bug)</span></span><br><span class="line"><span class="comment">//        list.forEach(s -&gt; &#123;</span></span><br><span class="line"><span class="comment">//            if(&quot;Java&quot;.equals(s))&#123;</span></span><br><span class="line"><span class="comment">//                list.remove(s);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// d、for循环(边遍历边删除集合没毛病，但是必须从后面开始遍历删除才不会出现漏掉应该删除的元素)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> list.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span> ; i--) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">ele</span> <span class="operator">=</span> list.get(i);</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;Java&quot;</span>.equals(ele))&#123;</span><br><span class="line">                list.remove(ele);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="9-补充知识：泛型深入"><a href="#9-补充知识：泛型深入" class="headerlink" title="9.补充知识：泛型深入"></a>9.补充知识：泛型深入</h3><h4 id="9-1泛型的概述和优势"><a href="#9-1泛型的概述和优势" class="headerlink" title="9.1泛型的概述和优势"></a>9.1泛型的概述和优势</h4><p><strong>泛型概述</strong></p><ul><li><p>泛型：是JDK5中引入的特性，可以在编译阶段约束操作的数据类型，并进行检查。</p></li><li><p>泛型的格式：&lt;数据类型&gt;; </p></li><li><p>集合体系的全部接口和实现类都是支持泛型的使用的;</p></li><li><p>注意：<strong>泛型只能支持引用数据类型。</strong></p></li></ul><p><strong>泛型的好处：</strong></p><ul><li><p>统一数据类型。</p></li><li><p>把运行时期的问题提前到了编译期间，避免了强制类型转换可能出现的异常，因为编译阶段类型就能确定下来。</p></li></ul><p><strong>泛型可以在很多地方进行定义:</strong></p><p> 类后面             ——————&gt;   泛型类</p><p> 方法申明上     ——————&gt;   泛型方法</p><p> 接口后面         ——————&gt;   泛型接口</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：泛型的概述。</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    泛型就是一个标签：&lt;数据类型&gt;</span></span><br><span class="line"><span class="comment">    泛型可以在编译阶段约束只能操作某种数据类型。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    注意：</span></span><br><span class="line"><span class="comment">        JDK 1.7开始之后后面的泛型申明可以省略不写</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//添加String类型元素</span></span><br><span class="line"> List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;中国&quot;</span>);</span><br><span class="line">        <span class="comment">// list.add(23); //报错</span></span><br><span class="line">        <span class="comment">//list1.add(23.3); //报错</span></span><br><span class="line">        <span class="comment">//list1.add(false); //报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//添加任意类型的元素</span></span><br><span class="line">        List&lt;Object&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;中国&quot;</span>);</span><br><span class="line">list2.add(<span class="number">23</span>);</span><br><span class="line">        list2.add(<span class="number">23.3</span>);</span><br></pre></td></tr></table></figure><h4 id="9-2自定义泛型类"><a href="#9-2自定义泛型类" class="headerlink" title="9.2自定义泛型类"></a>9.2自定义泛型类</h4><p><strong>泛型类的概述</strong></p><ul><li><p>定义类时同时定义了泛型的类就是泛型类。</p></li><li><p>泛型类的格式：修饰符 class 类名&lt;泛型变量&gt;{ }</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">范例：<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyArrayList</span>&lt;T&gt; &#123;  &#125;</span><br></pre></td></tr></table></figure><ul><li><p>此处泛型变量<strong>T</strong>可以随便写为任意标识，常见的如<strong>E、T、K、V</strong>等。</p></li><li><p><strong>作用</strong>：编译阶段可以指定数据类型，类似于集合的作用。</p></li></ul><p><strong>泛型类的核心思想：</strong></p><ul><li>把出现泛型变量的地方全部替换成传输的真实数据类型。</li></ul><p><strong>泛型类的作用</strong></p><ul><li>编译阶段约定操作的数据的类型，类似于集合的作用。</li></ul><p><strong>课程案例导学</strong></p><ul><li>模拟ArrayList集合自定义一个MyArrayList泛型类,完成添加和删除功能的泛型设计即可。</li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 需求：模拟ArrayList定义一个MyArrayList ，关注泛型设计</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义一个MyArrayList泛型类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyArrayList</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">ArrayList</span> <span class="variable">lists</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e)</span>&#123;</span><br><span class="line">        lists.add(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(E e)</span>&#123;</span><br><span class="line">        lists.remove(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lists.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用MyArrayList泛型类创建对象</span></span><br><span class="line">MyArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">MyArrayList</span>&lt;&gt;();</span><br><span class="line">MyArrayList&lt;Integer&gt; list2 = <span class="keyword">new</span> <span class="title class_">MyArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><h4 id="9-3自定义泛型方法"><a href="#9-3自定义泛型方法" class="headerlink" title="9.3自定义泛型方法"></a>9.3自定义泛型方法</h4><p><strong>泛型方法的概述</strong></p><ul><li><p>定义方法时同时定义了泛型的方法就是泛型方法。</p></li><li><p>泛型方法的格式：修饰符 &lt;泛型变量&gt; 方法返回值 方法名称(形参列表){}</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">范例： <span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(T t)</span> &#123;  &#125;</span><br></pre></td></tr></table></figure><ul><li><strong>作用</strong>：方法中可以使用泛型接收一切实际类型的参数，方法更具备通用性。</li></ul><p><strong>泛型方法的核心思想：</strong></p><ul><li>把出现泛型变量的地方全部替换成传输的真实数据类型。</li></ul><p><strong>课程案例导学</strong></p><ul><li>给你任何一个类型的数组，都能返回它的内容。也就是实现Arrays.toString(数组)的功能！</li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：自定义泛型方法。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    定义了泛型的方法就是泛型方法。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    注意：方法定义了是什么泛型变量，后面就只能用什么泛型变量。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    小结：</span></span><br><span class="line"><span class="comment">        泛型方法可以让方法更灵活的接收数据，可以做通用技术！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//需求：给你任何一个类型的数组，都能返回它的内容。Arrays.toString(数组)的功能！</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] names = &#123;<span class="string">&quot;小璐&quot;</span>, <span class="string">&quot;蓉容&quot;</span>, <span class="string">&quot;小何&quot;</span>&#125;;</span><br><span class="line">        printArray(names);</span><br><span class="line"></span><br><span class="line">        Integer[] ages = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line">        printArray(ages);</span><br><span class="line">      </span><br><span class="line">        String[]  names2 = getArr(names);</span><br><span class="line">        Integer[] ages2 = getArr(ages);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自定义泛型方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] getArr(T[] arr)&#123; <span class="comment">//T[]为定义时万能类型标记</span></span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">(T[] arr)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;[&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">                sb.append(arr[i]).append(i == arr.length - <span class="number">1</span> ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;, &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">            System.out.println(sb);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(arr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-4自定义泛型接口"><a href="#9-4自定义泛型接口" class="headerlink" title="9.4自定义泛型接口"></a>9.4自定义泛型接口</h4><p><strong>泛型接口的概述</strong></p><ul><li><p>使用了泛型定义的接口就是泛型接口。</p></li><li><p>泛型接口的格式：修饰符 interface 接口名称&lt;泛型变量&gt;{}</p></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">范例： public interface Data&lt;E&gt;&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>作用：泛型接口可以约束实现类，实现类可以在实现接口的时候传入自己操作的数据类型这样重写的方法都将是针对于该类型的操作。</strong></li></ul><p><strong>泛型接口的核心思想：</strong></p><ul><li>实现类可以在实现接口的时候传入自己操作的数据类型，这样重写的方法都将是针对于该类型的操作。</li></ul><p><strong>课程案例导学</strong></p><ul><li>教务系统，提供一个接口可约束一定要完成数据（学生，老师）的增删改查操作</li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义学生类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义泛型接口类Data，给出抽象方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Data</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(E e)</span>;</span><br><span class="line">    E <span class="title function_">queryById</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现类StudentData 继承 泛型接口类Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentData</span> <span class="keyword">implements</span> <span class="title class_">Data</span>&lt;Student&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Student student)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Student student)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Student <span class="title function_">queryById</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-5泛型通配符、上下限"><a href="#9-5泛型通配符、上下限" class="headerlink" title="9.5泛型通配符、上下限"></a>9.5泛型通配符、上下限</h4><p><strong>通配</strong>  <strong>?</strong></p><ul><li><p><strong>?</strong> 可以在<strong>使用</strong>泛型的时候代表一切类型。</p></li><li><p><strong>E T K V</strong> 是在<strong>定义</strong>泛型的时候使用的。</p></li></ul><p><strong>注意：</strong></p><ul><li>虽然BMW和BENZ都继承了Car但是ArrayList<BMW>和ArrayList<BENZ>与ArrayList<Car>没有关系的！!</li></ul><p><strong>泛型的上下限：</strong></p><ul><li><p>? <strong>extends</strong> <strong>Car</strong>      必须是Car或者其子类  泛型上限</p></li><li><p>? <strong>super</strong> <strong>Car</strong>          必须是Car或者其父类  泛型下限</p></li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：泛型通配符。?</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    注意：</span></span><br><span class="line"><span class="comment">        虽然BMW和BENZ都继承了Car</span></span><br><span class="line"><span class="comment">        但是ArrayList&lt;BMW&gt;和ArrayList&lt;BENZ&gt;与ArrayList&lt;Car&gt;没有关系的！!</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    小结：</span></span><br><span class="line"><span class="comment">        通配符：？</span></span><br><span class="line"><span class="comment">        ？可以在“使用泛型”的时候代表一切类型。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">//需求：开发一个极品飞车的游戏，所有的汽车都能一起参与比赛。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;BMW&gt; bmws = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        bmws.add(<span class="keyword">new</span> <span class="title class_">BMW</span>());</span><br><span class="line">        bmws.add(<span class="keyword">new</span> <span class="title class_">BMW</span>());</span><br><span class="line">        bmws.add(<span class="keyword">new</span> <span class="title class_">BMW</span>());</span><br><span class="line">        go(bmws);</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;BENZ&gt; benzs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        benzs.add(<span class="keyword">new</span> <span class="title class_">BENZ</span>());</span><br><span class="line">        benzs.add(<span class="keyword">new</span> <span class="title class_">BENZ</span>());</span><br><span class="line">        benzs.add(<span class="keyword">new</span> <span class="title class_">BENZ</span>());</span><br><span class="line">        go(benzs);</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Dog&gt; dogs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dogs.add(<span class="keyword">new</span> <span class="title class_">Dog</span>());</span><br><span class="line">        dogs.add(<span class="keyword">new</span> <span class="title class_">Dog</span>());</span><br><span class="line">        dogs.add(<span class="keyword">new</span> <span class="title class_">Dog</span>());</span><br><span class="line">        <span class="comment">// go(dogs); //没有继承父类Car，会报错</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">       所有车比赛</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">(ArrayList&lt;? extends Car&gt; cars)</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BENZ</span> <span class="keyword">extends</span> <span class="title class_">Car</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BMW</span> <span class="keyword">extends</span> <span class="title class_">Car</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> java,面向对象进阶,Collection,数据结构,List,泛型深入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>day13 - 常用API、正则表达式、Lambda、算法</title>
      <link href="/post/19124d20.html"/>
      <url>/post/19124d20.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-日期与时间（old）"><a href="#1-日期与时间（old）" class="headerlink" title="1.日期与时间（old）"></a><strong>1</strong>.日期与时间（old）</h3><h4 id="1-1Date"><a href="#1-1Date" class="headerlink" title="1.1Date"></a>1.1Date</h4><p><strong>Date 类概述</strong></p><ul><li>Date类代表当前所在系统的日期时间信息。</li></ul><p><strong>Date的构造器</strong></p><table><thead><tr><th align="center">名称</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><strong>public Date()</strong></td><td align="center"><strong>创建一个Date对象，代表的是系统当前此刻日期时间。</strong></td></tr><tr><td align="center"><strong>public Date(long time)</strong></td><td align="center"><strong>把时间毫秒值转换成Date日期对象。</strong></td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1、创建一个Date类的对象：代表系统此刻日期时间对象</span></span><br><span class="line">       <span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">       System.out.println(d);</span><br></pre></td></tr></table></figure><p><strong>Date的常用方法</strong></p><table><thead><tr><th align="center">名称</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><strong>public long getTime()</strong></td><td align="center"><strong>返回从1970年1月1日   00:00:00走到此刻的总的毫秒数</strong></td></tr><tr><td align="center"><strong>public void setTime(long time)</strong></td><td align="center"><strong>设置日期对象的时间为当前时间毫秒值对应的时间</strong></td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2、获取时间毫秒值</span></span><br><span class="line"> <span class="comment">//方法一:getTime</span></span><br><span class="line">          <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> d.getTime();</span><br><span class="line">          System.out.println(time);</span><br><span class="line">      </span><br><span class="line"> <span class="comment">//方法二:System</span></span><br><span class="line">          <span class="type">long</span> <span class="variable">time1</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">          System.out.println(time1);</span><br></pre></td></tr></table></figure><p><strong>案例：</strong></p><ul><li>请计算出当前时间往后走1小时121秒之后的时间是多少。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1、得到当前时间</span></span><br><span class="line">   <span class="type">Date</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">   System.out.println(d1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、当前时间往后走 1小时  121s</span></span><br><span class="line">   <span class="type">long</span> <span class="variable">time2</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">   time2 += (<span class="number">60</span> * <span class="number">60</span> + <span class="number">121</span>) * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、把时间毫秒值转换成对应的日期对象。</span></span><br><span class="line">   <span class="type">Date</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(time2);</span><br><span class="line">   System.out.println(d2);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//或使用setTime</span></span><br><span class="line">   <span class="comment">//Date d3 = new Date();</span></span><br><span class="line">   <span class="comment">//d3.setTime(time2);</span></span><br><span class="line">   <span class="comment">//System.out.println(d3);</span></span><br></pre></td></tr></table></figure><h4 id="1-2SimpleDateFormat-时间格式化"><a href="#1-2SimpleDateFormat-时间格式化" class="headerlink" title="1.2SimpleDateFormat(时间格式化)"></a>1.2SimpleDateFormat(时间格式化)</h4><h5 id="1-2-1SimpleDateFormat类作用"><a href="#1-2-1SimpleDateFormat类作用" class="headerlink" title="1.2.1SimpleDateFormat类作用"></a><strong>1.2.1SimpleDateFormat类作用</strong></h5><p><strong>格式化：</strong></p><p> Date对象             —————&gt;    2099年11月11日 11:11:</p><p> 时间毫秒值          —————&gt;    2099年11月11日 11:11:</p><p><strong>构造器</strong></p><table><thead><tr><th align="center">构造器</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><strong>public SimpleDateFormat(String pattern)</strong></td><td align="center"><strong>构造一个SimpleDateFormat，使用指定的格式</strong></td></tr></tbody></table><p><strong>格式化方法(日期格式、时间毫秒值通用)</strong></p><table><thead><tr><th align="left">格式化方法</th><th>说明</th></tr></thead><tbody><tr><td align="left">public final String format(Date date)</td><td><strong>将日期格式化成日期&#x2F;时间字符串</strong></td></tr><tr><td align="left">public final Stringformat(Object time)</td><td><strong>将时间毫秒值格式化成日期&#x2F;时间字符串</strong></td></tr></tbody></table><ul><li><p>y 年                                  </p></li><li><p>M 月                                   </p></li><li><p>d 日</p></li><li><p>H 时</p></li><li><p>m 分</p></li><li><p>s 秒</p></li></ul><p>2020-11-11 13:27:06    ——–&gt; yyyy-MM-dd HH:mm:ss </p><p> 2020年11月11日 13时27分06秒 周* 上&#x2F;下午 ——–&gt; </p><p>yyyy年MM月dd日 HH时mm分ss秒 EEE a</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    SimpleDateFormat简单日期格式化类的使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//目标一:格式化时间</span></span><br><span class="line">        <span class="comment">// 1、日期对象</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        System.out.println(d);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、格式化这个日期对象 (指定最终格式化的形式)</span></span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy年MM月dd日 HH:mm:ss EEE a&quot;</span>);</span><br><span class="line">        <span class="comment">// 3、开始格式化日期对象成为喜欢的字符串形式</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> sdf.format(d);  </span><br><span class="line">        System.out.println(rs);   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//目标二：格式化时间毫秒值</span></span><br><span class="line"><span class="comment">// 需求：请问121秒后的时间是多少</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">time1</span> <span class="operator">=</span> System.currentTimeMillis() + <span class="number">121</span> * <span class="number">1000</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">rs2</span> <span class="operator">=</span> sdf.format(time1);</span><br><span class="line">        System.out.println(rs2);</span><br></pre></td></tr></table></figure><h5 id="1-2-2parse-解析字符串时间，成为日期对象"><a href="#1-2-2parse-解析字符串时间，成为日期对象" class="headerlink" title="1.2.2parse:解析字符串时间，成为日期对象"></a><strong>1.2.2parse:解析字符串时间，成为日期对象</strong></h5><table><thead><tr><th>解析方法</th><th>说明</th></tr></thead><tbody><tr><td>public Date <strong>parse(String source)</strong></td><td>从给定字符串的开始解析文本以生成日期</td></tr></tbody></table><p><strong>解析字符串时间成为日期对象：</strong></p><p> 2011-11-11 11:11:22  -&gt;  计算机可识别的Date日期对象</p><p><strong>案例</strong></p><ul><li>请计算出 2021年08月06日11点11分11秒，往后走2天14小时49分06秒后的时间是多少。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 目标: 学会使用SimpleDateFormat解析字符串时间成为日期对象。</span></span><br><span class="line"><span class="comment">// 有一个时间 2021年08月06日 11:11:11 往后 2天 14小时 49分 06秒后的时间是多少。</span></span><br><span class="line"><span class="comment">// 1、把字符串时间拿到程序中来</span></span><br><span class="line"><span class="type">String</span> <span class="variable">dateStr</span> <span class="operator">=</span> <span class="string">&quot;2021年08月06日 11:11:11&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、把字符串时间解析成日期对象（本节的重点）: </span></span><br><span class="line"><span class="comment">//    形式必须与被解析时间的形式完全一样，否则运行时解析报错！</span></span><br><span class="line">   <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy年MM月dd日 HH:mm:ss&quot;</span>);    <span class="comment">//创建SimpleDateFormat</span></span><br><span class="line">   <span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> sdf.parse(dateStr); <span class="comment">//使用parse方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、往后走2天 14小时 49分 06秒</span></span><br><span class="line">   <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> d.getTime() + (<span class="number">2L</span>*<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span> + <span class="number">14</span>*<span class="number">60</span>*<span class="number">60</span> + <span class="number">49</span>*<span class="number">60</span> + <span class="number">6</span>) * <span class="number">1000</span>;  <span class="comment">//计算时间毫秒值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4、格式化这个时间毫秒值就是结果</span></span><br><span class="line">   System.out.println(sdf.format(time));<span class="comment">//使用format方法</span></span><br></pre></td></tr></table></figure><p><strong>案例：秒杀活动</strong></p><p><strong>需求</strong></p><ul><li><p>某购物网站举办秒杀活动，开始时间和结束时间如左图所示，当前活动结束后，系统记录到2位用户的付款时间分别如下：</p></li><li><ul><li>小贾下单并付款的时间为：2020年11月11日 0:03:47</li><li>小皮下单并付款的时间为：2020年11月11日 0:10:11</li></ul></li><li><p>规则：顾客的付款时间必须在秒杀时间之内，请判断出两位顾客是否秒杀成功。</p></li></ul><p><strong>分析</strong></p><ul><li><p>把4个字符串形式的时间解析成日期对象。</p></li><li><p>判断小贾和小皮的时间是否在秒杀时间范围之内，并给出相应的提示。</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 1、创建开始和结束时间</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">startTime</span> <span class="operator">=</span> <span class="string">&quot;2021-11-11 00:00:00&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">endTime</span> <span class="operator">=</span> <span class="string">&quot;2021-11-11 00:10:00&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、创建小贾和小皮下单时间</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">xiaoJia</span> <span class="operator">=</span>  <span class="string">&quot;2021-11-11 00:03:47&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">xiaoPi</span> <span class="operator">=</span>  <span class="string">&quot;2021-11-11 00:10:11&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、使用parse方法，解析所有时间</span></span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">d1</span> <span class="operator">=</span> sdf.parse(startTime);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">d2</span> <span class="operator">=</span> sdf.parse(endTime);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">d3</span> <span class="operator">=</span> sdf.parse(xiaoJia);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">d4</span> <span class="operator">=</span> sdf.parse(xiaoPi);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4、使用after(在...之后)和before(在...之前)判断</span></span><br><span class="line">        <span class="keyword">if</span>(d3.after(d1) &amp;&amp; d3.before(d2))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;小贾秒杀成功，可以发货了！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;小贾秒杀失败！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(d4.after(d1) &amp;&amp; d4.before(d2))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;小皮秒杀成功，可以发货了！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;小皮秒杀失败！&quot;</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h4 id="1-3Calendar-日历"><a href="#1-3Calendar-日历" class="headerlink" title="1.3Calendar(日历)"></a>1.3Calendar(日历)</h4><p><strong>Calendar概述</strong></p><ul><li><p>Calendar代表了系统此刻日期对应的日历对象。</p></li><li><p>Calendar是一个<strong>抽象类</strong>，<strong>不能直接创建对象</strong>。</p></li></ul><p><strong>Calendar日历类创建日历对象的方法：</strong></p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td><strong>public  static Calendar getInstance()</strong></td><td><strong>获取当前日历对象</strong></td></tr></tbody></table><p><strong>Calendar常用方法</strong></p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public int get(int field)</td><td>取日期中的某个字段信息。</td></tr><tr><td>public void set(int field,int value)</td><td>修改日历的某个字段信息。</td></tr><tr><td>public void add(int field,int amount)</td><td>为某个字段增加&#x2F;减少指定的值</td></tr><tr><td>public final Date getTime()</td><td>拿到此刻日期对象。</td></tr><tr><td>public long getTimeInMillis()</td><td>拿到此刻时间毫秒值</td></tr></tbody></table><p><strong>注意：calendar是可变日期对象，一旦修改后其对象本身表示的时间将产生变化。</strong></p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 1、拿到系统此刻日历对象</span></span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">cal</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        System.out.println(cal);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、获取日历的信息:public int get(int field)：</span></span><br><span class="line">取日期中的某个字段信息。</span><br><span class="line">        <span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> cal.get(Calendar.YEAR);</span><br><span class="line">        System.out.println(year);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">mm</span> <span class="operator">=</span> cal.get(Calendar.MONTH) + <span class="number">1</span>;</span><br><span class="line">        System.out.println(mm);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">days</span> <span class="operator">=</span> cal.get(Calendar.DAY_OF_YEAR) ;</span><br><span class="line">        System.out.println(days);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、public void set(int field,int value)：</span></span><br><span class="line"><span class="comment">//修改日历的某个字段信息。(很少使用)</span></span><br><span class="line"><span class="comment">// cal.set(Calendar.HOUR , 12);</span></span><br><span class="line"><span class="comment">// System.out.println(cal);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.public void add(int field,int amount)：为某个字段增加/减少指定的值</span></span><br><span class="line"><span class="comment">// 请问64天后是什么时间</span></span><br><span class="line">        cal.add(Calendar.DAY_OF_YEAR , <span class="number">64</span>);</span><br><span class="line">        <span class="comment">//请问59分钟后是什么时间</span></span><br><span class="line">        cal.add(Calendar.MINUTE , <span class="number">59</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  5.public final Date getTime(): 拿到此刻日期对象。</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> cal.getTime();</span><br><span class="line">        System.out.println(d);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  6.public long getTimeInMillis(): 拿到此刻时间毫秒值</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> cal.getTimeInMillis();</span><br><span class="line">        System.out.println(time);</span><br></pre></td></tr></table></figure><h3 id="2-JDK8新增日期类（new）"><a href="#2-JDK8新增日期类（new）" class="headerlink" title="2.JDK8新增日期类（new）"></a>2.JDK8新增日期类（new）</h3><h4 id="2-1概述"><a href="#2-1概述" class="headerlink" title="2.1概述"></a>2.1概述</h4><ul><li><p>从Java 8开始，java.time包提供了新的日期和时间API，主要涉及的类型有：</p><p>​                                <strong>LocalDate</strong>：不包含具体时间的日期。</p><p>​                            <strong>LocalTime</strong>：不含日期的时间。</p><p>​                            <strong>LocalDateTime</strong>：包含了日期及时间。</p></li></ul><p><strong>JDK8新增日期类</strong>   <strong>Instant</strong>：代表的是时间戳。</p><p>  ​                                 <strong>DateTimeFormatter</strong> 用于做时间的格式化和解析的</p><p>  ​                                 <strong>Duration</strong>:用于计算两个“时间”间隔</p><p>  ​                                 <strong>Period</strong>:用于计算两个“日期”间隔</p><ul><li><p>新增的API严格区分了<strong>时刻、本地日期、本地时间</strong>，并且，对日期和时间进行运算更加方便。</p></li><li><p>其次，新API的类型几乎全部是<strong>不变类型</strong>（和String的使用类似），可以放心使用不必担心被修改。</p></li></ul><h4 id="2-2LocalDate、LocalTime、LocalDateTime"><a href="#2-2LocalDate、LocalTime、LocalDateTime" class="headerlink" title="2.2LocalDate、LocalTime、LocalDateTime"></a>2.2LocalDate、LocalTime、LocalDateTime</h4><ul><li><p>他们 分别表示日期，时间，日期时间对象，他们的类的实例是不可变的对象。</p></li><li><p><strong>他们三者构建对象和API都是通用的</strong>。</p></li></ul><p><strong>构建对象的方式如下：</strong></p><table><thead><tr><th align="left">方法名</th><th align="center">说明</th><th align="left"></th></tr></thead><tbody><tr><td align="left">public static Xxxx now();</td><td align="center">静态方法，根据当前时间创建对象</td><td align="left">LocaDate localDate &#x3D; LocalDate.now();     LocalTime llocalTime &#x3D; LocalTime.<em>now</em>();     LocalDateTime localDateTime &#x3D; LocalDateTime.<em>now</em>();</td></tr><tr><td align="left">public static Xxxx of(…);</td><td align="center">静态方法，指定日期&#x2F;时间创建对象</td><td align="left">LocalDate  localDate1 &#x3D;  LocalDate.<em>of</em>(2099  ,  11,11);                                                           LocalTime  localTime1 &#x3D;  LocalTime.<em>of</em>(11, 11, 11);                             LocalDateTime  localDateTime1 &#x3D;  LocalDateTime.<em>of</em>(2020, 10, 6, 13, 23, 43);</td></tr></tbody></table><p><strong>LocalDate、LocalTime、LocalDateTime获取信息的API.</strong></p><table><thead><tr><th align="left">方法名</th><th>说明</th></tr></thead><tbody><tr><td align="left">public int getYear()</td><td>获取年</td></tr><tr><td align="left">public int getMonthValue()</td><td>获取月份（1-12）</td></tr><tr><td align="left">Public int getDayOfMonth()</td><td>获取月中第几天</td></tr><tr><td align="left">Public int getDayOfYear()</td><td>获取年中第几天</td></tr><tr><td align="left">Public DayOfWeek getDayOfWeek()</td><td>获取星期</td></tr></tbody></table><p><strong>转换相关的API</strong></p><p>*<strong>LocalDateTime 包括了</strong> <em><strong>LocalDate和LocalTime</strong></em></p><p><strong>LocalDateTime的转换API</strong></p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td><strong>public LocalDate toLocalDate()</strong></td><td><strong>转换成一个LocalDate对象</strong></td></tr><tr><td><strong>public LocalTime toLocalTime()</strong></td><td><strong>转换成一个LocalTime对象</strong></td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取当前时间对象</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">ld</span> <span class="operator">=</span> nowDateTime.toLocalDate();</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用toLocalTime方法，将nowDateTime转换成LocalTime</span></span><br><span class="line"><span class="type">LocalTime</span> <span class="variable">lt</span> <span class="operator">=</span> nowDateTime.toLocalTime();</span><br><span class="line">System.out.println(lt.getHour());<span class="comment">//获取小时</span></span><br><span class="line">System.out.println(lt.getMinute());<span class="comment">//获取分钟</span></span><br><span class="line">System.out.println(lt.getSecond());<span class="comment">//获取秒</span></span><br></pre></td></tr></table></figure><p><strong>修改相关的API</strong></p><ul><li><p>LocalDateTime 综合了 LocalDate 和 LocalTime 里面的方法，所以下面只用 LocalDate 和 LocalTime 来举例。</p></li><li><p>这些方法返回的是一个新的实例引用，因为LocalDateTime 、LocalDate 、LocalTime 都是不可变的。</p></li></ul><table><thead><tr><th align="left">方法名</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">plusDays                       plusWeeks               plusMonths                  plusYears</td><td align="left">向当前 LocalDate 对象添加几天、 几周、几个月、几年</td></tr><tr><td align="left">minusDays                minusWeeks         minusMonths           minusYears</td><td align="left">从当前 LocalDate 对象减去几天、 几周、几个月、几年</td></tr><tr><td align="left">withDayOfMonth withDayOfYear          withMonth                      withYear</td><td align="left">将月份天数、年份天数、月份、年 份 修 改 为 指 定 的 值 并 返 回 新  的 LocalDate 对象</td></tr><tr><td align="left">isBefore                             isAfter</td><td align="left">比较两个 LocalDate</td></tr></tbody></table><p><strong>修改相关的API代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当前时间</span></span><br><span class="line"><span class="type">LocalTime</span> <span class="variable">nowTime</span> <span class="operator">=</span> LocalTime.now();</span><br><span class="line">System.out.println(nowTime);</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.plus方法</span></span><br><span class="line">System.out.println(nowTime.plusHours(<span class="number">1</span>));<span class="comment">//一小时后</span></span><br><span class="line">System.out.println(nowTime.plusMinutes(<span class="number">1</span>));<span class="comment">//一分钟后</span></span><br><span class="line">System.out.println(nowTime.plusSeconds(<span class="number">1</span>));<span class="comment">//一秒后</span></span><br><span class="line">System.out.println(nowTime.plusNanos(<span class="number">1</span>));<span class="comment">//一纳秒后</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.minus方法</span></span><br><span class="line">System.out.println(nowTime.minusHours(<span class="number">1</span>));<span class="comment">//一小时前</span></span><br><span class="line">System.out.println(nowTime.minusMinutes(<span class="number">1</span>));<span class="comment">//一分钟前</span></span><br><span class="line">System.out.println(nowTime.minusSeconds(<span class="number">1</span>));<span class="comment">//一秒前</span></span><br><span class="line">System.out.println(nowTime.minusNanos(<span class="number">1</span>));<span class="comment">//一纳秒前</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">birDate</span> <span class="operator">=</span> LocalDate.of(<span class="number">1996</span>, <span class="number">8</span>, <span class="number">5</span>);<span class="comment">//生日日期对象</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">nowDate1</span> <span class="operator">=</span> LocalDate.now();<span class="comment">//当前日期对象</span></span><br><span class="line"></span><br><span class="line"><span class="type">MonthDay</span> <span class="variable">birMd</span> <span class="operator">=</span> MonthDay.of(birDate.getMonthValue(), birDate.getDayOfMonth());<span class="comment">//获取生日日期对象中的月 日</span></span><br><span class="line"><span class="type">MonthDay</span> <span class="variable">nowMd</span> <span class="operator">=</span> MonthDay.from(nowDate1);<span class="comment">//使用MonthDay方法获取当前日期对象中的月 日</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;今天是你的生日吗？&quot;</span>+birMd.equals(nowMd));</span><br><span class="line"><span class="comment">//今天是你的生日吗？ false</span></span><br></pre></td></tr></table></figure><p><strong>LocalData代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1、获取本地日期对象。</span></span><br><span class="line">        <span class="comment">//今天的日期：</span></span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">nowDate</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">        System.out.println(<span class="string">&quot;今天的日期：&quot;</span> + nowDate);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取年</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> nowDate.getYear();</span><br><span class="line">        System.out.println(<span class="string">&quot;year：&quot;</span> + year);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取月</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> nowDate.getMonthValue();</span><br><span class="line">        System.out.println(<span class="string">&quot;month：&quot;</span> + month);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取日</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> nowDate.getDayOfMonth();</span><br><span class="line">        System.out.println(<span class="string">&quot;day：&quot;</span> + day);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当年的第几天</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">dayOfYear</span> <span class="operator">=</span> nowDate.getDayOfYear();</span><br><span class="line">        System.out.println(<span class="string">&quot;dayOfYear：&quot;</span> + dayOfYear);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//星期</span></span><br><span class="line">        System.out.println(nowDate.getDayOfWeek());</span><br><span class="line">           System.out.println(nowDate.getDayOfWeek().getValue());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//月份</span></span><br><span class="line">        System.out.println(nowDate.getMonth());<span class="comment">//AUGUST</span></span><br><span class="line">        System.out.println(nowDate.getMonth().getValue());<span class="comment">//8</span></span><br><span class="line"></span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">bt</span> <span class="operator">=</span> LocalDate.of(<span class="number">1991</span>, <span class="number">11</span>, <span class="number">11</span>);</span><br><span class="line">        System.out.println(bt);<span class="comment">//直接传入对应的年月日</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//相对上面只是把月换成了枚举</span></span><br><span class="line">System.out.println(LocalDate.of(<span class="number">1991</span>, Month.NOVEMBER, <span class="number">11</span>));</span><br></pre></td></tr></table></figure><p><strong>LocalTime</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1、获取本地时间对象。</span></span><br><span class="line">        <span class="type">LocalTime</span> <span class="variable">nowTime</span> <span class="operator">=</span> LocalTime.now();</span><br><span class="line">        System.out.println(<span class="string">&quot;今天的时间：&quot;</span> + nowTime);<span class="comment">//今天的时间：</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">hour</span> <span class="operator">=</span> nowTime.getHour();<span class="comment">//时</span></span><br><span class="line">        System.out.println(<span class="string">&quot;hour：&quot;</span> + hour);<span class="comment">//hour：</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">minute</span> <span class="operator">=</span> nowTime.getMinute();<span class="comment">//分</span></span><br><span class="line">        System.out.println(<span class="string">&quot;minute：&quot;</span> + minute);<span class="comment">//minute：</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">second</span> <span class="operator">=</span> nowTime.getSecond();<span class="comment">//秒</span></span><br><span class="line">        System.out.println(<span class="string">&quot;second：&quot;</span> + second);<span class="comment">//second：</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">nano</span> <span class="operator">=</span> nowTime.getNano();<span class="comment">//纳秒</span></span><br><span class="line">        System.out.println(<span class="string">&quot;nano：&quot;</span> + nano);<span class="comment">//nano：</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建Time</span></span><br><span class="line">        System.out.println(LocalTime.of(<span class="number">8</span>, <span class="number">20</span>));<span class="comment">//时分</span></span><br><span class="line">        System.out.println(LocalTime.of(<span class="number">8</span>, <span class="number">20</span>, <span class="number">30</span>));<span class="comment">//时分秒</span></span><br><span class="line">        System.out.println(LocalTime.of(<span class="number">8</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">150</span>));</span><br><span class="line">        <span class="comment">//时分秒纳秒       </span></span><br></pre></td></tr></table></figure><p><strong>LocalDataTime代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 日期 时间</span></span><br><span class="line">        <span class="comment">//创建现在日期 时间</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">nowDateTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        System.out.println(<span class="string">&quot;今天是：&quot;</span> + nowDateTime);<span class="comment">//今天是：</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(nowDateTime.getYear());<span class="comment">//获取年</span></span><br><span class="line">        System.out.println(nowDateTime.getMonthValue());<span class="comment">//月</span></span><br><span class="line">        System.out.println(nowDateTime.getDayOfMonth());<span class="comment">//日</span></span><br><span class="line">        System.out.println(nowDateTime.getHour());<span class="comment">//时</span></span><br><span class="line">        System.out.println(nowDateTime.getMinute());<span class="comment">//分</span></span><br><span class="line">        System.out.println(nowDateTime.getSecond());<span class="comment">//秒</span></span><br><span class="line">        System.out.println(nowDateTime.getNano());<span class="comment">//纳秒</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//日：当年的第几天</span></span><br><span class="line">System.out.println(<span class="string">&quot;dayOfYear：&quot;</span> + nowDateTime.getDayOfYear());<span class="comment">//dayOfYear：249</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//星期</span></span><br><span class="line"><span class="comment">//THURSDAY </span></span><br><span class="line">System.out.println(nowDateTime.getDayOfWeek());</span><br><span class="line"><span class="comment">//4</span></span><br><span class="line">System.out.println(nowDateTime.getDayOfWeek().getValue());</span><br><span class="line"></span><br><span class="line"><span class="comment">//月份</span></span><br><span class="line"><span class="comment">//SEPTEMBER   </span></span><br><span class="line">System.out.println(nowDateTime.getMonth()); </span><br><span class="line"><span class="comment">//9</span></span><br><span class="line">System.out.println(nowDateTime.getMonth().getValue());</span><br></pre></td></tr></table></figure><h4 id="2-3Instant（时间戳，了解）"><a href="#2-3Instant（时间戳，了解）" class="headerlink" title="2.3Instant（时间戳，了解）"></a>2.3Instant（时间戳，了解）</h4><p><strong>Instant时间戳</strong></p><ul><li>JDK8获取时间戳特别简单，且功能更丰富。Instant类由一个静态的工厂方法now()可以返回当前时间戳。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Instant</span> <span class="variable">instant</span> <span class="operator">=</span> Instant.now();</span><br><span class="line">System.out.println(<span class="string">&quot;当前时间戳是：&quot;</span> + instant);</span><br><span class="line"></span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> Date.from(instant);</span><br><span class="line">System.out.println(<span class="string">&quot;当前时间戳是：&quot;</span> + date);</span><br><span class="line"></span><br><span class="line">instant = date.toInstant();</span><br><span class="line">System.out.println(instant);</span><br></pre></td></tr></table></figure><ul><li><p><strong>时间戳是包含日期和时间的</strong>，与java.util.Date很类似，事实上Instant就是类似JDK8 以前的Date。</p></li><li><p><strong>Instant和Date这两个类可以进行转换。</strong></p></li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1、得到一个Instant时间戳对象</span></span><br><span class="line"><span class="type">Instant</span> <span class="variable">instant</span> <span class="operator">=</span> Instant.now();</span><br><span class="line">System.out.println(instant);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、系统此刻的时间戳&gt;&gt;&gt;转换为此刻的时间对象</span></span><br><span class="line"><span class="type">Instant</span> <span class="variable">instant1</span> <span class="operator">=</span> Instant.now();      </span><br><span class="line">System.out.println(instant1.atZone(ZoneId.systemDefault()));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、如何去返回Date对象</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> Date.from(instant);</span><br><span class="line">System.out.println(date);</span><br><span class="line"></span><br><span class="line"><span class="type">Instant</span> <span class="variable">i2</span> <span class="operator">=</span> date.toInstant();</span><br><span class="line">System.out.println(i2);</span><br></pre></td></tr></table></figure><h4 id="2-4DateTimeFormatter（日期时间格式化）"><a href="#2-4DateTimeFormatter（日期时间格式化）" class="headerlink" title="2.4DateTimeFormatter（日期时间格式化）"></a>2.4DateTimeFormatter（日期时间格式化）</h4><ul><li><p>在JDK8中，引入了一个全新的日期与时间格式器DateTimeFormatter。</p></li><li><p>正反都能调用format方法。</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取当前日期时间</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">ldt</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">System.out.println(ldt);<span class="comment">//2021-03-01T15:09:17.444190900</span></span><br><span class="line"></span><br><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">dtf</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">ldtStr</span> <span class="operator">=</span> ldt.format(dtf);</span><br><span class="line">System.out.println(ldtStr);<span class="comment">//2021-03-01 15:09:17</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">ldtStr1</span> <span class="operator">=</span> dtf.format(ldt);</span><br><span class="line">System.out.println(ldtStr1);<span class="comment">//2021-03-01 15:09:17</span></span><br></pre></td></tr></table></figure><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一:解析本地此刻 </span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">ldt</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">System.out.println(ldt);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 解析/格式化器&gt;&gt;&gt;DateTimeFormatter</span></span><br><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">dtf</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss EEE a&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//格式化方法&gt;&gt;&gt;format</span></span><br><span class="line">/ 正向格式化</span><br><span class="line">System.out.println(dtf.format(ldt));</span><br><span class="line">/ 逆向格式化</span><br><span class="line">System.out.println(ldt.format(dtf));</span><br><span class="line">————————————————————————————————————————————————————————————</span><br><span class="line"><span class="comment">// 二:解析字符串时间</span></span><br><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">dtf1</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"><span class="comment">// parse方法，解析当前字符串时间成为本地日期时间对象</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">ldt1</span> <span class="operator">=</span> LocalDateTime.parse(<span class="string">&quot;2019-11-11 11:11:11&quot;</span> ,  dtf1);</span><br><span class="line">System.out.println(ldt1);</span><br></pre></td></tr></table></figure><h4 id="2-5Duration-Period（计算时间-日期间隔）"><a href="#2-5Duration-Period（计算时间-日期间隔）" class="headerlink" title="2.5Duration&#x2F;Period（计算时间&#x2F;日期间隔）"></a>2.5Duration&#x2F;Period（计算时间&#x2F;日期间隔）</h4><p><strong>Duration</strong></p><ul><li><p>在Java8中，我们可以使用以下类来计算<strong>时间间隔</strong>差异：java.time.Duration</p></li><li><p>提供了使用基于时间的值测量时间量的方法。</p></li><li><p>用于 <strong>LocalDateTime</strong> 之间的比较。也可用于 <strong>Instant</strong> 之间的比较。</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 本地日期时间对象。</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">today</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">System.out.println(today);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出生的日期时间对象</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">birthDate</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">1990</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">50</span>,<span class="number">30</span>);</span><br><span class="line">System.out.println(birthDate);</span><br><span class="line"></span><br><span class="line"><span class="type">Duration</span> <span class="variable">duration</span> <span class="operator">=</span> Duration.between(birthDate, today);<span class="comment">//第二个参数减第一个参数</span></span><br><span class="line">System.out.println(duration.toDays());<span class="comment">//两个时间差的天数</span></span><br><span class="line">System.out.println(duration.toHours());<span class="comment">//两个时间差的小时数System.out.println(duration.toMinutes());//两个时间差的分钟数System.out.println(duration.toMillis());//两个时间差的毫秒数System.out.println(duration.toNanos());//两个时间差的纳秒数</span></span><br></pre></td></tr></table></figure><p><strong>Period</strong></p><ul><li><p>在Java8中，我们可以使用以下类来计算<strong>日期间隔</strong>差异：java.time.Period</p></li><li><p>主要是 **Period 类方法 getYears()，getMonths() 和 getDays() **来计算,只能精确到年月日。</p></li><li><p>用于 <strong>LocalDate</strong> 之间的比较。</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LocalDate</span> <span class="variable">today</span> <span class="operator">=</span> LocalDate.now();<span class="comment">//获取当前日期对象</span></span><br><span class="line">System.out.println(today);        <span class="comment">// 2021-03-01</span></span><br><span class="line"></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">birthDate</span> <span class="operator">=</span> LocalDate.of(<span class="number">1995</span>, <span class="number">1</span>, <span class="number">11</span>);</span><br><span class="line">System.out.println(birthDate);    <span class="comment">// 1995-01-11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//调用Period.between方法</span></span><br><span class="line"><span class="type">Period</span> <span class="variable">period</span> <span class="operator">=</span> Period.between(birthDate, today);</span><br><span class="line"><span class="comment">//第二个参数减第一个参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//比较日期间隔</span></span><br><span class="line">System.out.printf(<span class="string">&quot;年龄 : %d 年 %d 月 %d 日&quot;</span>, </span><br><span class="line">period.getYears(), period.getMonths(), period.getDays());</span><br></pre></td></tr></table></figure><h4 id="2-6ChronoUnit（计算时间日期间隔-更全面）"><a href="#2-6ChronoUnit（计算时间日期间隔-更全面）" class="headerlink" title="2.6ChronoUnit（计算时间日期间隔&gt;&gt;&gt;更全面）"></a>2.6ChronoUnit（计算时间日期间隔&gt;&gt;&gt;更全面）</h4><p><strong>java.time.temporal.ChronoUnit</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 本地日期时间对象：此刻的</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">today</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">System.out.println(today);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生日时间</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">birthDate</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">1990</span>,<span class="number">10</span>,<span class="number">1</span>,</span><br><span class="line"><span class="number">10</span>,<span class="number">50</span>,<span class="number">59</span>);</span><br><span class="line">System.out.println(birthDate);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;相差的年数：&quot;</span> + ChronoUnit.YEARS.between(birthDate, today));</span><br><span class="line">System.out.println(<span class="string">&quot;相差的月数：&quot;</span> + ChronoUnit.MONTHS.between(birthDate, today));</span><br><span class="line">System.out.println(<span class="string">&quot;相差的周数：&quot;</span> + ChronoUnit.WEEKS.between(birthDate, today));</span><br><span class="line">System.out.println(<span class="string">&quot;相差的天数：&quot;</span> + ChronoUnit.DAYS.between(birthDate, today));</span><br><span class="line">System.out.println(<span class="string">&quot;相差的时数：&quot;</span> + ChronoUnit.HOURS.between(birthDate, today));</span><br><span class="line">System.out.println(<span class="string">&quot;相差的分数：&quot;</span> + ChronoUnit.MINUTES.between(birthDate, today));</span><br><span class="line">System.out.println(<span class="string">&quot;相差的秒数：&quot;</span> + ChronoUnit.SECONDS.between(birthDate, today));</span><br><span class="line">System.out.println(<span class="string">&quot;相差的毫秒数：&quot;</span> + ChronoUnit.MILLIS.between(birthDate, today));</span><br><span class="line">System.out.println(<span class="string">&quot;相差的微秒数：&quot;</span> + ChronoUnit.MICROS.between(birthDate, today));</span><br><span class="line">System.out.println(<span class="string">&quot;相差的纳秒数：&quot;</span> + ChronoUnit.NANOS.between(birthDate, today));</span><br><span class="line">System.out.println(<span class="string">&quot;相差的半天数：&quot;</span> + ChronoUnit.HALF_DAYS.between(birthDate, today));</span><br><span class="line">System.out.println(<span class="string">&quot;相差的十年数：&quot;</span> + ChronoUnit.DECADES.between(birthDate, today));</span><br><span class="line">System.out.println(<span class="string">&quot;相差的世纪（百年）数：&quot;</span> + ChronoUnit.CENTURIES.between(birthDate, today));</span><br><span class="line">System.out.println(<span class="string">&quot;相差的千年数：&quot;</span> + ChronoUnit.MILLENNIA.between(birthDate, today));</span><br><span class="line">System.out.println(<span class="string">&quot;相差的纪元数：&quot;</span> + ChronoUnit.ERAS.between(birthDate, today));</span><br></pre></td></tr></table></figure><h3 id="3-包装类（-引用数据类型-）"><a href="#3-包装类（-引用数据类型-）" class="headerlink" title="3.包装类（ 引用数据类型  ）"></a>3.包装类（ 引用数据类型  ）</h3><ul><li>其实就是8种基本数据类型对应的引用类型。</li></ul><table><thead><tr><th align="center">基本数据类型</th><th align="center">引用数据类型</th></tr></thead><tbody><tr><td align="center"><strong>byte</strong></td><td align="center"><strong>Byte</strong></td></tr><tr><td align="center"><strong>short</strong></td><td align="center"><strong>Short</strong></td></tr><tr><td align="center"><strong>int</strong></td><td align="center"><strong>Integer</strong></td></tr><tr><td align="center"><strong>long</strong></td><td align="center"><strong>Long</strong></td></tr><tr><td align="center"><strong>char</strong></td><td align="center"><strong>Character</strong></td></tr><tr><td align="center"><strong>float</strong></td><td align="center"><strong>Float</strong></td></tr><tr><td align="center"><strong>double</strong></td><td align="center"><strong>Double</strong></td></tr><tr><td align="center"><strong>boolean</strong></td><td align="center"><strong>Boolean</strong></td></tr></tbody></table><p><strong>为什么提供包装类？</strong></p><ul><li><p>Java为了实现一切皆对象，为<strong>8种基本类型提供了对应的引用类型</strong>。</p></li><li><p>后面的<strong>集合和泛型其实也只能支持包装类型</strong>，不支持基本数据类型。</p></li></ul><p><strong>自动装箱</strong>：基本类型的数据和变量可以直接赋值给包装类型的变量。</p><p><strong>自动拆箱：</strong>包装类型的变量可以直接赋值给基本数据类型的变量。</p><p><strong>包装类的特有功能</strong></p><ul><li><p>包装类的变量的默认值可以是null，容错率更高。</p></li><li><p>可以把基本类型的数据转换成字符串类型(用处不大)</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1、包装类可以把基本类型的数据转换成字符串形式。（没啥用）</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">23</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">i2</span> <span class="operator">=</span> i1.toString();</span><br><span class="line">        System.out.println(i2 + <span class="number">1</span>);  <span class="comment">//231</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">23</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">i2</span> <span class="operator">=</span> Integer.toString(i1);</span><br><span class="line">        System.out.println(i2 + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以直接+字符串得到字符串类型 (更常用)</span></span><br><span class="line"><span class="type">String</span> <span class="variable">rs2</span> <span class="operator">=</span> i3 + <span class="string">&quot;&quot;</span>;</span><br><span class="line">System.out.println(rs2 + <span class="number">1</span>);</span><br></pre></td></tr></table></figure><ul><li>可以把字符串类型的数值转换成真实的数据类型<strong>（真的很有用）</strong></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2、可以把字符串类型的数值转换成真实的数据类型（实用）</span></span><br><span class="line"><span class="comment">//转换成整数</span></span><br><span class="line"><span class="type">String</span> <span class="variable">number1</span> <span class="operator">=</span> <span class="string">&quot;23&quot;</span>;</span><br><span class="line"><span class="comment">// int age = Integer.parseInt(number1);</span></span><br><span class="line"><span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> Integer.valueOf(number1); <span class="comment">//valueOf方法更常用</span></span><br><span class="line">System.out.println(age + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//转换成小数</span></span><br><span class="line"><span class="type">String</span> <span class="variable">number2</span> <span class="operator">=</span> <span class="string">&quot;99.9&quot;</span>;</span><br><span class="line"><span class="comment">//double score = Double.parseDouble(number2);</span></span><br><span class="line"><span class="type">double</span> <span class="variable">score</span> <span class="operator">=</span> Double.valueOf(number2);<span class="comment">//valueOf方法更常用</span></span><br><span class="line">System.out.println(score + <span class="number">0.1</span>);</span><br></pre></td></tr></table></figure><h3 id="4-正则表达式"><a href="#4-正则表达式" class="headerlink" title="4.正则表达式"></a>4.正则表达式</h3><h4 id="4-1正则表达式概述、初体验"><a href="#4-1正则表达式概述、初体验" class="headerlink" title="4.1正则表达式概述、初体验"></a>4.1正则表达式概述、初体验</h4><p><strong>正则表示</strong></p><ul><li>正则表达式可以用一些规定的字符来制定规则，并用来校验数据格式的合法性。</li></ul><p><strong>正则表达式初体验</strong></p><ul><li><p>需求：假如现在要求校验一个qq号码是否正确，6位及20位之内，必须全部是数字 。</p></li><li><p>先使用目前所学知识完成校验需求；然后体验一下正则表达式检验。</p></li></ul><h4 id="4-2正则表达式的匹配规则"><a href="#4-2正则表达式的匹配规则" class="headerlink" title="4.2正则表达式的匹配规则"></a>4.2正则表达式的匹配规则</h4><p><strong>字符串对象提供了匹配正则表达式的方法】</strong>【String】</p><p>​public boolean matches(<a href="file:///D:/course/%E5%9F%BA%E7%A1%80%E9%98%B6%E6%AE%B5/API%E6%96%87%E6%A1%A3/docs/api/java.base/java/lang/String.html">String</a> regex): 判断是否匹配正则表达式</p><p>​匹配返回true，不匹配返回false。</p><p><strong>字符类(默认匹配一个字符)</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[abc]       只能是a, b, 或c</span><br><span class="line">[^abc]       除了a, b, c之外的任何字符</span><br><span class="line">[a-zA-Z]                a到z A到Z，包括（范围）</span><br><span class="line">[a-d[m-p]]       a到d，或m通过p：（[a-dm-p]联合）</span><br><span class="line">[a-z&amp;&amp;[def]]        d, e, 或f(交集)</span><br><span class="line">[a-z&amp;&amp;[^bc]]        a到z，除了b和c：（[ad-z]减法）</span><br><span class="line">[a-z&amp;&amp;[^m-p]]           a到z，除了m到p：（[a-lq-z]减法）</span><br></pre></td></tr></table></figure><p><strong>预定义的字符类(默认匹配一个字符)</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.任何字符</span><br><span class="line">\d一个数字： [<span class="number">0</span>-<span class="number">9</span>]</span><br><span class="line">\D非数字： [^<span class="number">0</span>-<span class="number">9</span>]</span><br><span class="line">\s一个空白字符： [ \t\n\x0B\f\r]</span><br><span class="line">\S非空白字符： [^\s]</span><br><span class="line">\w[a-zA-Z_0-<span class="number">9</span>] 英文、数字、下划线</span><br><span class="line">\W [^\w] 一个非单词字符</span><br></pre></td></tr></table></figure><p><strong>贪婪的量词（配合匹配多个字符）</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">X?X , 一次或根本不</span><br><span class="line">X*X，零次或多次</span><br><span class="line">X+X , 一次或多次</span><br><span class="line">X&#123;n&#125;X，正好n次</span><br><span class="line">X&#123;n, &#125;X，至少n次</span><br><span class="line">X&#123;n,m&#125;X，至少n但不超过m次</span><br></pre></td></tr></table></figure><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//只能是 a  b  c  正则匹配只能校验单个字符。</span></span><br><span class="line">System.out.println(<span class="string">&quot;a&quot;</span>.matches(<span class="string">&quot;[abc]&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">System.out.println(<span class="string">&quot;z&quot;</span>.matches(<span class="string">&quot;[abc]&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不能出现a  b  c</span></span><br><span class="line">System.out.println(<span class="string">&quot;a&quot;</span>.matches(<span class="string">&quot;[^abc]&quot;</span>)); <span class="comment">// false</span></span><br><span class="line">System.out.println(<span class="string">&quot;z&quot;</span>.matches(<span class="string">&quot;[^abc]&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;a&quot;</span>.matches(<span class="string">&quot;\\d&quot;</span>)); <span class="comment">// false</span></span><br><span class="line">System.out.println(<span class="string">&quot;3&quot;</span>.matches(<span class="string">&quot;\\d&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">System.out.println(<span class="string">&quot;333&quot;</span>.matches(<span class="string">&quot;\\d&quot;</span>)); <span class="comment">// false</span></span><br><span class="line">System.out.println(<span class="string">&quot;z&quot;</span>.matches(<span class="string">&quot;\\w&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">System.out.println(<span class="string">&quot;2&quot;</span>.matches(<span class="string">&quot;\\w&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">System.out.println(<span class="string">&quot;21&quot;</span>.matches(<span class="string">&quot;\\w&quot;</span>)); <span class="comment">// false</span></span><br><span class="line">System.out.println(<span class="string">&quot;你&quot;</span>.matches(<span class="string">&quot;\\w&quot;</span>)); <span class="comment">//false</span></span><br><span class="line">System.out.println(<span class="string">&quot;你&quot;</span>.matches(<span class="string">&quot;\\W&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="comment">// 校验密码</span></span><br><span class="line"><span class="comment">// 必须是数字 字母 下划线 至少 6位</span></span><br><span class="line">System.out.println(<span class="string">&quot;2442fsfsf&quot;</span>.matches(<span class="string">&quot;\\w&#123;6,&#125;&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;244f&quot;</span>.matches(<span class="string">&quot;\\w&#123;6,&#125;&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证码 必须是数字和字符  必须是4位</span></span><br><span class="line">System.out.println(<span class="string">&quot;23dF&quot;</span>.matches(<span class="string">&quot;[a-zA-Z0-9]&#123;4&#125;&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;23_F&quot;</span>.matches(<span class="string">&quot;[a-zA-Z0-9]&#123;4&#125;&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;23dF&quot;</span>.matches(<span class="string">&quot;[\\w&amp;&amp;[^_]]&#123;4&#125;&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;23_F&quot;</span>.matches(<span class="string">&quot;[\\w&amp;&amp;[^_]]&#123;4&#125;&quot;</span>));</span><br></pre></td></tr></table></figure><h4 id="4-3正则表达式的常见案例"><a href="#4-3正则表达式的常见案例" class="headerlink" title="4.3正则表达式的常见案例"></a>4.3正则表达式的常见案例</h4><p><strong>请使用正则表达式完成如下需求:</strong></p><p><strong>需求</strong></p><ul><li><p>①请编写程序模拟用户输入手机号码、验证格式正确，并给出提示，直到格式输入正确为止。</p></li><li><p>②请编写程序模拟用户输入邮箱号码、验证格式正确，并给出提示，直到格式输入正确为止。</p></li><li><p>③请编写程序模拟用户输入电话号码、验证格式正确，并给出提示，直到格式输入正确为止。</p></li></ul><p><strong>分析</strong></p><ul><li>定义方法，接收用户输入的数据，使用正则表达式完成检验，并给出提示。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 目标：校验 手机号码 邮箱  电话号码</span></span><br><span class="line"><span class="comment">// checkPhone();</span></span><br><span class="line"><span class="comment">// checkEmail();</span></span><br><span class="line"><span class="comment">// checkTel();</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkTel</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请您输入您的电话号码：&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">tel</span> <span class="operator">=</span> sc.next();</span><br><span class="line">            <span class="comment">// 判断邮箱格式是否正确   027-3572457  0273572457</span></span><br><span class="line">            <span class="keyword">if</span>(tel.matches(<span class="string">&quot;0\\d&#123;2,6&#125;-?\\d&#123;5,20&#125;&quot;</span>))&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;格式正确，注册完成！&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;格式有误！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkEmail</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请您输入您的注册邮箱：&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">email</span> <span class="operator">=</span> sc.next();</span><br><span class="line">            <span class="comment">// 判断邮箱格式是否正确   3268847878@qq.com</span></span><br><span class="line">            <span class="comment">// 判断邮箱格式是否正确   3268847dsda878@163.com</span></span><br><span class="line">            <span class="comment">// 判断邮箱格式是否正确   3268847dsda878@pci.com.cn</span></span><br><span class="line">            <span class="keyword">if</span>(email.matches(<span class="string">&quot;\\w&#123;1,30&#125;@[a-zA-Z0-9]&#123;2,20&#125;(\\.[a-zA-Z0-9]&#123;2,20&#125;)&#123;1,2&#125;&quot;</span>))&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;邮箱格式正确，注册完成！&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;格式有误！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkPhone</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请您输入您的注册手机号码：&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> sc.next();</span><br><span class="line">            <span class="comment">// 判断手机号码的格式是否正确</span></span><br><span class="line">            <span class="keyword">if</span>(phone.matches(<span class="string">&quot;1[3-9]\\d&#123;9&#125;&quot;</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;手机号码格式正确，注册完成！&quot;</span>);</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;格式有误！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="4-4正则表达式在方法中的应用"><a href="#4-4正则表达式在方法中的应用" class="headerlink" title="4.4正则表达式在方法中的应用"></a>4.4正则表达式在方法中的应用</h4><p><strong>正则表达式在字符串方法中的使用</strong></p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public String replaceAll(String regex,String newStr)</td><td>按照正则表达式匹配的内容进行替换</td></tr><tr><td>public String[] split(String regex)：</td><td>按照正则表达式匹配的内容进行分割字符串，反回一个字符串数组。</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：正则表达式在方法中的应用。</span></span><br><span class="line"><span class="comment">        public String[] split(String regex)：</span></span><br><span class="line"><span class="comment">            -- 按照正则表达式匹配的内容进行分割字符串，反回一个字符串数组。</span></span><br><span class="line"><span class="comment">        public String replaceAll(String regex,String newStr)</span></span><br><span class="line"><span class="comment">            -- 按照正则表达式匹配的内容进行替换</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">      <span class="type">String</span> <span class="variable">names</span> <span class="operator">=</span> <span class="string">&quot;小路dhdfhdf342蓉儿43fdffdfbjdfaf小何&quot;</span>;</span><br><span class="line"></span><br><span class="line">      String[] arrs = names.split(<span class="string">&quot;\\w+&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arrs.length; i++) &#123;</span><br><span class="line">          System.out.println(arrs[i]); </span><br><span class="line">      &#125; <span class="comment">//小路 </span></span><br><span class="line"><span class="comment">//蓉儿 </span></span><br><span class="line">    <span class="comment">//小何</span></span><br><span class="line"></span><br><span class="line">      <span class="type">String</span> <span class="variable">names2</span> <span class="operator">=</span> names.replaceAll(<span class="string">&quot;\\w+&quot;</span>, <span class="string">&quot;  &quot;</span>);</span><br><span class="line">      System.out.println(names2);  <span class="comment">//小路  蓉儿  小何</span></span><br></pre></td></tr></table></figure><h4 id="4-5正则表达式爬取信息"><a href="#4-5正则表达式爬取信息" class="headerlink" title="4.5正则表达式爬取信息"></a>4.5正则表达式爬取信息</h4><p><strong>正则表达式支持爬取信息</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    拓展：正则表达式爬取信息中的内容。(了解)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="string">&quot;来黑马程序学习Java,电话020-43422424，或者联系邮箱&quot;</span> +</span><br><span class="line">            <span class="string">&quot;itcast@itcast.cn,电话18762832633，0203232323&quot;</span> +</span><br><span class="line">            <span class="string">&quot;邮箱bozai@itcast.cn，400-100-3233 ，4001003232&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需求：从上面的内容中爬取出 电话号码和邮箱。</span></span><br><span class="line"><span class="comment">// 1、定义爬取规则，字符串形式</span></span><br><span class="line"><span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;(\\w&#123;1,30&#125;@[a-zA-Z0-9]&#123;2,20&#125;(\\.[a-zA-Z0-9]&#123;2,20&#125;)&#123;1,2&#125;)|(1[3-9]\\d&#123;9&#125;)&quot;</span> +</span><br><span class="line"><span class="string">&quot;|(0\\d&#123;2,6&#125;-?\\d&#123;5,20&#125;)|(400?\\d&#123;3,9&#125;-?\\d&#123;3,9&#125;)&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、把这个爬取规则编译成匹配对象。</span></span><br><span class="line"><span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(regex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、得到一个内容匹配器对象</span></span><br><span class="line"><span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(rs);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4、开始找了</span></span><br><span class="line"><span class="keyword">while</span> (matcher.find()) &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">rs1</span> <span class="operator">=</span> matcher.group();</span><br><span class="line">System.out.println(rs1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//金额判断</span></span><br><span class="line"> <span class="keyword">if</span> (num.matches(<span class="string">&quot;([0]?|[1-9]&#123;1,&#125;\\d*)(\\.?[0-9]&#123;1,2&#125;)&quot;</span>) </span><br></pre></td></tr></table></figure><h3 id="5-Arrays类-数组操作"><a href="#5-Arrays类-数组操作" class="headerlink" title="5.Arrays类(数组操作)"></a>5.Arrays类(数组操作)</h3><h4 id="5-1Arrays类概述，常用功能演示"><a href="#5-1Arrays类概述，常用功能演示" class="headerlink" title="5.1Arrays类概述，常用功能演示"></a>5.1Arrays类概述，常用功能演示</h4><p><strong>Arrays类概述</strong></p><ul><li><strong>数组操作</strong>工具类，专门用于操作数组元素的。</li></ul><p><strong>Arrays类的常用API</strong></p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public static <a href="mk:@MSITStore:C:\course\API文档\jdk-9_google.CHM::/java/lang/String.html">String</a> <strong>toString</strong>(类型[] a)</td><td>返回<strong>数组的内容</strong>（字符串形式）</td></tr><tr><td>public  static void <strong>sort</strong>(类型[] a)</td><td>对数组进行<strong>默认升序排序</strong></td></tr><tr><td>public  static <T> void <strong>sort</strong>(类型[] a, <a href="mk:@MSITStore:C:\course\API文档\jdk-9_google.CHM::/java/util/Comparator.html">Comparator</a>&lt;?  super T&gt; c)</td><td>使用比较器对象<strong>自定义排序</strong></td></tr><tr><td>public  static int <strong>binarySearch</strong>(int[] a,  int key)</td><td><strong>二分搜索</strong>数组中的数据，存在返回索引，不存在返回-1 （前提数组必须排好序才支持，否则出bug）</td></tr></tbody></table><p><strong>Arrays类<em>toString</em>(数组)和<em>binarySearch</em>二分搜索</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 目标：学会使用Arrays类的常用API ,并理解其原理</span></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">10</span>, <span class="number">2</span>, <span class="number">55</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">100</span>&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、返回数组内容的 toString(数组)</span></span><br><span class="line">        <span class="comment">//String rs = Arrays.toString(arr);//String接</span></span><br><span class="line">        <span class="comment">//System.out.println(rs);</span></span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(arr));<span class="comment">//直接输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、二分搜索技术（前提数组必须排好序才支持，否则出bug）</span></span><br><span class="line">        <span class="comment">// 排序的API(默认自动对数组元素进行升序排序)</span></span><br><span class="line">        Arrays.sort(arr); </span><br><span class="line">  </span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Arrays.binarySearch(arr, <span class="number">55</span>);<span class="comment">//检索字符55</span></span><br><span class="line">        System.out.println(index);<span class="comment">//返回索引</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回不存在元素索引的规律： - （应该插入的位置索引 + 1）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index2</span> <span class="operator">=</span> Arrays.binarySearch(arr, <span class="number">22</span>);</span><br><span class="line">        System.out.println(index2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：数组如果没有排好序，可能会找不到存在的元素，从而出现bug!!</span></span><br><span class="line">        <span class="type">int</span>[] arr2 = &#123;<span class="number">12</span>, <span class="number">36</span>, <span class="number">34</span>, <span class="number">25</span> , <span class="number">13</span>,  <span class="number">24</span>,  <span class="number">234</span>, <span class="number">100</span>&#125;;</span><br><span class="line">        System.out.println(Arrays.binarySearch(arr2 , <span class="number">36</span>));</span><br></pre></td></tr></table></figure><h4 id="5-2Arrays类对于Comparator比较器的支持"><a href="#5-2Arrays类对于Comparator比较器的支持" class="headerlink" title="5.2Arrays类对于Comparator比较器的支持"></a>5.2Arrays类对于Comparator比较器的支持</h4><p><strong>Arrays类的排序方法</strong></p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public  static void sort(类型[] a)</td><td>对数组进行<strong>默认升序排序</strong></td></tr><tr><td>public  static <T> void sort(类型[] a, <a href="mk:@MSITStore:C:\course\API文档\jdk-9_google.CHM::/java/util/Comparator.html">Comparator</a>&lt;?  super T&gt; c)</td><td>使用比较器对象<strong>自定义排序</strong></td></tr></tbody></table><p><strong>自定义排序规则</strong></p><p><strong>设置Comparator接口对应的比较器对象，来定制比较规则。</strong></p><p>如果认为左边数据 大于 右边数据 返回正整数    </p><p>如果认为左边数据 小于 右边数据 返回负整数    </p><p>如果认为左边数据 等于 右边数据 返回0             </p><p>o1 – o2 升序        o2 –o1降序        o1 &#x3D; o2 不变</p><p><strong>注意：比较浮点类型只能调用Double.compare</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 目标：自定义数组的排序规则：Comparator比较器对象。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、排序的API(默认自动对数组元素进行升序排序)</span></span><br><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">34</span>, <span class="number">12</span>, <span class="number">42</span>, <span class="number">23</span>&#125;;</span><br><span class="line">        Arrays.sort(arr); <span class="comment">//先调用方法，传入数组</span></span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、需求：降序排序！(自定义比较器对象，**只能支持引用类型的排序！！)</span></span><br><span class="line"> Integer[] arr = &#123;<span class="number">34</span>, <span class="number">12</span>, <span class="number">42</span>, <span class="number">23</span>&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">参数一：被排序的数组 必须是引用类型的元素</span></span><br><span class="line"><span class="comment">参数二：匿名内部类对象，代表了一个比较器对象。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        Arrays.sort(ages1, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">            <span class="comment">// 指定比较规则,if判断代码冗余</span></span><br><span class="line">            <span class="comment">//    if(o1 &gt; o2)&#123;</span></span><br><span class="line">            <span class="comment">//        return 1;</span></span><br><span class="line">            <span class="comment">//    &#125;else if(o1 &lt; o2)&#123;</span></span><br><span class="line">            <span class="comment">//        return -1;</span></span><br><span class="line">            <span class="comment">//      &#125;</span></span><br><span class="line">              <span class="comment">//一般直接return  </span></span><br><span class="line">                  <span class="keyword">return</span> o1 - o2; <span class="comment">// 默认升序</span></span><br><span class="line">                  <span class="comment">//或</span></span><br><span class="line">                  <span class="keyword">return</span> o2 - o1; <span class="comment">//  降序</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p><strong>案例：</strong></p><ul><li>已知一个Student类</li><li>类中已定义姓名name,年龄age,身高height，并提供有参无参构造器，set、get方法</li><li>使用Comparator自定义排序实现功能</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Student[] students = <span class="keyword">new</span> <span class="title class_">Student</span>[<span class="number">3</span>];</span><br><span class="line">students[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;吴磊&quot;</span>,<span class="number">23</span> , <span class="number">175.5</span>);</span><br><span class="line">students[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;谢鑫&quot;</span>,<span class="number">18</span> , <span class="number">185.5</span>);</span><br><span class="line">students[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;王亮&quot;</span>,<span class="number">20</span> , <span class="number">195.5</span>);</span><br><span class="line">System.out.println(Arrays.toString(students));<span class="comment">//可打印确认</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Arrays.sort(students);//直接运行奔溃,原因:自定义对象不支持默认排序</span></span><br><span class="line">Arrays.sort(students, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1, Student o2)</span> &#123;</span><br><span class="line"><span class="comment">// 自己指定比较规则</span></span><br><span class="line">  <span class="comment">//按照年龄</span></span><br><span class="line">  <span class="comment">// return o1.getAge() - o2.getAge();// 按照年龄升序排序！</span></span><br><span class="line">  <span class="comment">// return o2.getAge() - o1.getAge();// 按照年龄降序排序！</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//按照身高 上述方法只能返回int类型，由于身高为double类型</span></span><br><span class="line">  <span class="comment">// return Double.compare(o1.getHeight(), o2.getHeight());   // 比较浮点型 升序</span></span><br><span class="line">  <span class="comment">// return Double.compare(o2.getHeight(), o1.getHeight()); </span></span><br><span class="line">  <span class="comment">// 比较浮点型 降序</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">     System.out.println(Arrays.toString(students));</span><br></pre></td></tr></table></figure><h3 id="6-常见算法"><a href="#6-常见算法" class="headerlink" title="6.常见算法"></a>6.常见算法</h3><h4 id="6-1冒泡排序"><a href="#6-1冒泡排序" class="headerlink" title="6.1冒泡排序"></a>6.1冒泡排序</h4><p><strong>冒泡排序的思想</strong></p><ul><li>每次从数组中找出最大值放在数组的后面去。</li></ul><p><strong>实现冒泡排序的关键步骤分析</strong></p><ul><li><p>确定总共需要做几轮： 数组的长度-1.</p></li><li><p>每轮比较几次:</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">i(轮数)   次数      <span class="comment">//次数规律:  数组的长度 - i</span></span><br><span class="line"><span class="number">1</span>          <span class="number">3</span></span><br><span class="line"><span class="number">2</span>          <span class="number">2</span></span><br><span class="line"><span class="number">3</span>          <span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>当前位置大于后一个位置则交换数据</li></ul><h4 id="6-2选择排序"><a href="#6-2选择排序" class="headerlink" title="6.2选择排序"></a>6.2选择排序</h4><p><strong>选择排序的思想</strong></p><ul><li><p>每轮选择当前位置，开始找出后面的较小值与该位置交换</p><p>(每一轮第一个元素与他后面的每一个元素比较)</p></li></ul><p><strong>选择排序的关键</strong></p><ul><li><p>确定总共需要选择几轮： 数组的长度-1.</p></li><li><p>控制每轮从以前位置为基准，与后面元素选择几次。</p></li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：学会使用选择排序的方法对数组进行排序。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        <span class="comment">// 1、定义数组</span></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        <span class="comment">//           0  1  2  3</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、定义一个循环控制选择几轮： arr.length - 1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// i = 0   j =  1  2  3</span></span><br><span class="line">            <span class="comment">// i = 1   j =  2  3</span></span><br><span class="line">            <span class="comment">// i = 2   j =  3</span></span><br><span class="line">            <span class="comment">// 3、定义内部循环，控制选择几次</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="comment">// 当前位：arr[i]</span></span><br><span class="line">                <span class="comment">// 如果有比当前位数据更小的，则交换</span></span><br><span class="line">                <span class="keyword">if</span>(arr[i] &gt; arr[j]) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">                    arr[i] = arr[j];</span><br><span class="line">                    arr[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br></pre></td></tr></table></figure><h4 id="6-3二分查找"><a href="#6-3二分查找" class="headerlink" title="6.3二分查找"></a>6.3二分查找</h4><p><strong>二分查找</strong></p><ul><li>二分查询性能好，二分查找的前提是必须是排好序的数据。</li><li>二分查找相当于每次去掉一半的查找范围</li><li><strong>结论：二分查找正常的检索条件应该是  开始位置min &lt;&#x3D;  结束位置max</strong></li></ul><p><strong>min</strong>和<strong>max</strong>表示查找的范围</p><p>数组的二分查找的实现步骤是什么样的?</p><ul><li><p><strong>定义变量记录左边和右边位置。</strong></p></li><li><p>使用<strong>while循环控制查询</strong>（条件是左边位置&lt;&#x3D;右边位置）</p></li><li><p>循环内部<strong>获取中间元素索引</strong></p></li><li><p>判断当前要找的元素如果<strong>大于中间元素，左边位置 &#x3D; 中间索引+1</strong></p></li><li><p>判断当前要找的元素如果<strong>小于中间元素，右边位置 &#x3D;  中间索引-1</strong></p></li><li><p>判断当前要找的元素如果<strong>等于中间元素，返回当前中间元素索引。</strong></p></li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：理解二分搜索的原理并实现。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、定义数组</span></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">10</span>, <span class="number">14</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">28</span>, <span class="number">30</span>, <span class="number">35</span>, <span class="number">88</span>, <span class="number">100</span>&#125;;</span><br><span class="line">     </span><br><span class="line">        System.out.println(binarySearch(arr , <span class="number">35</span>));</span><br><span class="line">        System.out.println(binarySearch(arr , <span class="number">350</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 二分查找算法的方法实现</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr  排序的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data 要找的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  索引，如果元素不存在，直接返回-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> data)</span>&#123;</span><br><span class="line">        <span class="comment">// 1、定义左边位置  和 右边位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、开始循环，折半查询。</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">            <span class="comment">// 取中间索引</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">middleIndex</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 3、判断当前中间位置的元素和要找的元素的大小情况</span></span><br><span class="line">            <span class="keyword">if</span>(data &gt; arr[middleIndex]) &#123;</span><br><span class="line">                <span class="comment">// 往右边找，左位置更新为 = 中间索引+1</span></span><br><span class="line">                left = middleIndex + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(data &lt; arr[middleIndex]) &#123;</span><br><span class="line">                <span class="comment">// 往左边找，右边位置 = 中间索引 - 1</span></span><br><span class="line">                right = middleIndex - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> middleIndex;  <span class="comment">//左右索引相等，返回本索引</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// left &gt; right查无此元素</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="7-Lambda表达式"><a href="#7-Lambda表达式" class="headerlink" title="7.Lambda表达式"></a>7.Lambda表达式</h3><h4 id="7-1Lambda概述"><a href="#7-1Lambda概述" class="headerlink" title="7.1Lambda概述"></a>7.1Lambda概述</h4><p><strong>Lambda概述</strong></p><ul><li><p>Lambda表达式是JDK 8开始后的一种新语法形式。</p></li><li><p><strong>作用：简化匿名内部类的代码写法。</strong></p></li></ul><p><strong>Lambda表达式的简化格式</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(匿名内部类被重写方法的形参列表) -&gt; &#123;</span><br><span class="line">被重写方法的方法体代码。</span><br><span class="line">&#125;</span><br><span class="line">注：-&gt; 是语法形式，无实际含义</span><br></pre></td></tr></table></figure><p><strong>注意：Lambda表达式只能简化【函数式接口】的匿名内部类的写法形式</strong></p><p><strong>什么是函数式接口？</strong></p><ul><li>首先必须是<strong>【接口】</strong>、其次<strong>【接口中有且仅有一个抽象方法】</strong>的形式</li></ul><h4 id="7-2Lambda实战-简化常见函数式接口"><a href="#7-2Lambda实战-简化常见函数式接口" class="headerlink" title="7.2Lambda实战-简化常见函数式接口"></a>7.2Lambda实战-简化常见函数式接口</h4><p><strong>Lambda表达式简化Comparator接口的匿名形式</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">Integer[] ages = &#123;<span class="number">66</span>, <span class="number">33</span>, <span class="number">22</span>, <span class="number">55</span>, <span class="number">88</span>&#125;;</span><br><span class="line">Arrays.sort(ages, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;()&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> o2 - o1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;内容:&quot;</span> + Arrays.toString(ages));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//简化后结果</span></span><br><span class="line"></span><br><span class="line">Arrays.sort(ages, (Integer o1, Integer o2) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> o2 - o1;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>注意：通常我们见到的函数式接口上都有一个*@FunctionalInterface*注解，标记该接口必须是满足函数式接口。</strong></p><p><strong>Lambda表达式简化按钮监听器ActionListener的匿名内部类形式</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">JButton</span> <span class="variable">btn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;登录&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给登录按钮绑定点击事件监听器</span></span><br><span class="line">btn.addActionListener(<span class="keyword">new</span> <span class="title class_">ActionListener</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent e)</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;登录一下~~~&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//简化后结果</span></span><br><span class="line"></span><br><span class="line">btn.addActionListener( (ActionEvent e) -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;登录一下~~~&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>做法：</strong>去掉new的对象、重写的方法名以及括号，加上箭头，其余保留</p><h4 id="7-3Lambda表达式的省略规则（进一步省略）"><a href="#7-3Lambda表达式的省略规则（进一步省略）" class="headerlink" title="7.3Lambda表达式的省略规则（进一步省略）"></a>7.3Lambda表达式的省略规则（进一步省略）</h4><p><strong>Lambda表达式的省略写法（进一步在Lambda表达式的基础上继续简化）</strong></p><ul><li><p><strong>参数类型可以省略不写。</strong></p></li><li><p>如果<strong>只有一个参数</strong>，参数类型可以省略，同时()也可以省略。</p></li><li><p>如果Lambda表达式的<strong>方法体代码只有一行代码</strong>。可以省略大括号不写,同时要省略大括号里面的”;”</p></li><li><p>如果Lambda表达式的<strong>方法体代码只有一行代码</strong>。可以省略大括号不写。此时，如果这行代码是return语句，必须省略return不写，同时也必须省略大括号里面的”;”不写</p></li></ul><p><strong>代码:</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] ages1 = &#123;<span class="number">34</span>, <span class="number">12</span>, <span class="number">42</span>, <span class="number">23</span>&#125;;</span><br><span class="line">      </span><br><span class="line">Arrays.sort(ages1, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> o2 - o1; <span class="comment">//  降序</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//简化</span></span><br><span class="line">Arrays.sort(ages1, (Integer o1, Integer o2) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> o2 - o1; <span class="comment">//  降序</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//再简化</span></span><br><span class="line">Arrays.sort(ages1, ( o1,  o2) -&gt; &#123;</span><br><span class="line"><span class="keyword">return</span> o2 - o1; <span class="comment">//  降序</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//最简</span></span><br><span class="line">Arrays.sort(ages1, ( o1,  o2 ) -&gt;  o2 - o1 );</span><br><span class="line"></span><br><span class="line">System.out.println(Arrays.toString(ages1));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">JFrame</span> <span class="variable">win</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JFrame</span>(<span class="string">&quot;登录界面&quot;</span>);</span><br><span class="line">        <span class="type">JButton</span> <span class="variable">btn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;我是按钮&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//      btn.addActionListener(new ActionListener() &#123;</span></span><br><span class="line"><span class="comment">//          @Override</span></span><br><span class="line"><span class="comment">//          public void actionPerformed(ActionEvent e) &#123;</span></span><br><span class="line"><span class="comment">//              System.out.println(&quot;点我，点我！！&quot;);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//简化</span></span><br><span class="line"><span class="comment">//        btn.addActionListener((ActionEvent e) -&gt; &#123;</span></span><br><span class="line"><span class="comment">//              System.out.println(&quot;点我，点我！！&quot;);</span></span><br><span class="line"><span class="comment">//        &#125;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//再简化</span></span><br><span class="line"><span class="comment">//        btn.addActionListener(( e) -&gt; &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;点我，点我！！&quot;);</span></span><br><span class="line"><span class="comment">//        &#125;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//更简化</span></span><br><span class="line"><span class="comment">//        btn.addActionListener( e -&gt; &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;点我！！&quot;);</span></span><br><span class="line"><span class="comment">//        &#125;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//最简</span></span><br><span class="line">btn.addActionListener( e -&gt; System.out.println(<span class="string">&quot;点我！！&quot;</span>) );</span><br><span class="line"></span><br><span class="line">        win.add(btn);</span><br><span class="line">        win.setSize(<span class="number">400</span>, <span class="number">300</span>);</span><br><span class="line">        win.setVisible(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> java,面向对象进阶,常用API,正则表达式,Lambda,算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>day12 - 多态、内部类、常用API</title>
      <link href="/post/1d32812b.html"/>
      <url>/post/1d32812b.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-面向对象三大特征之三：多态"><a href="#1-面向对象三大特征之三：多态" class="headerlink" title="1.面向对象三大特征之三：多态"></a>1.面向对象三大特征之三：多态</h3><h4 id="1-1多态的概述，多态的形式"><a href="#1-1多态的概述，多态的形式" class="headerlink" title="1.1多态的概述，多态的形式"></a>1.1多态的概述，多态的形式</h4><p><strong>什么是多态？</strong></p><ul><li>同类型的对象，执行同一个行为，会表现出不同的行为特征。</li></ul><p><strong>多态的常见形式</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">父类类型 对象名称 = <span class="keyword">new</span> 子类构造器;</span><br><span class="line">接口     对象名称 = <span class="keyword">new</span> 实现类构造器;</span><br></pre></td></tr></table></figure><p><strong>多态中成员访问特点</strong></p><ul><li><p>方法调用：编译看左边，运行看右边。</p></li><li><p>变量调用：编译看左边，运行也看左边。（<strong>多态侧重行为多态</strong>）</p></li></ul><p><strong>多态的前提</strong></p><ul><li><strong>有继承&#x2F;实现关系；有父类引用指向子类对象；有方法重写。</strong></li></ul><h4 id="1-2多态的优势"><a href="#1-2多态的优势" class="headerlink" title="1.2多态的优势"></a>1.2多态的优势</h4><p> <strong>优势</strong></p><ul><li>在多态形式下，右边对象可以实现解耦合，便于扩展和维护。(方便于更换对象)</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">a.run(); <span class="comment">// 后续业务行为随对象而变，后续代码无需修改</span></span><br></pre></td></tr></table></figure><ul><li>定义方法的时候，使用父类型作为参数，该方法就可以接收这父类的一切子类对象，体现出多态的扩展性与便利。</li></ul><p><strong>多态下会产生的一个问题:</strong></p><ul><li>多态下不能使用子类的独有功能</li></ul><h4 id="1-3多态下引用数据类型的类型转换-实现调用子类独有功能"><a href="#1-3多态下引用数据类型的类型转换-实现调用子类独有功能" class="headerlink" title="1.3多态下引用数据类型的类型转换(实现调用子类独有功能)"></a>1.3多态下引用数据类型的类型转换(实现调用子类独有功能)</h4><p><strong>自动类型转换(从子到父—&gt;小转大)：</strong>子类对象赋值给父类类型的变量指向。</p><p><strong>强制类型转换(从父到子—&gt;大转小)</strong></p><ul><li><p>此时必须进行强制类型转换：子类 对象变量 &#x3D;  (子类)父类类型的变量</p></li><li><p>作用：可以解决多态下的劣势，可以<strong>实现调用子类独有的功能</strong>。</p></li><li><p>注意： 如果<strong>转型后的类型和对象真实类型不是同一种类型</strong>，那么在转换的时候就会出现<strong>ClassCastException</strong>。</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tortoise</span>(); <span class="comment">//new一个乌龟对象</span></span><br><span class="line"><span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> (Dog)t; <span class="comment">//将乌龟对象 强转为 狗对象</span></span><br><span class="line"><span class="comment">// 此时出现异常 ClassCastException</span></span><br></pre></td></tr></table></figure><p><strong>Java建议强转转换前使用【instanceof】判断当前对象的真实类型，再进行强制转换</strong></p><p><strong>变量名 <em>instanceof</em> 真实类型</strong></p><p>判断关键字左边的变量指向的对象的真实类型，是否是右边的类型或者是其子类类型，是则返回true，反之。</p><p><strong>强制类型转换:可以实现调用子类独有功能的</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意：多态下直接强制类型转换，可能出现类型转换异常</span></span><br><span class="line"><span class="comment">// 规定：有继承或者实现关系的2个类型就可以强制类型转换，运行时可能出现问题。</span></span><br><span class="line"><span class="comment">// Tortoise t1 = (Tortoise) a;</span></span><br><span class="line"><span class="comment">// 建议强制转换前，先判断变量指向对象的真实类型，再强制类型转换。</span></span><br><span class="line"><span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(a <span class="keyword">instanceof</span> Tortoise)&#123;   <span class="comment">//false</span></span><br><span class="line">     <span class="type">Tortoise</span> <span class="variable">t</span> <span class="operator">=</span> (Tortoise) a;</span><br><span class="line">     t.layEggs();   </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a <span class="keyword">instanceof</span> Dog)&#123;  <span class="comment">//true</span></span><br><span class="line">     <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> (Dog) a;</span><br><span class="line">     d.lookDoor();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-4多态的综合案例"><a href="#1-4多态的综合案例" class="headerlink" title="1.4多态的综合案例"></a>1.4多态的综合案例</h4><p><strong>多态综合案例</strong></p><p><strong>需求：</strong></p><ul><li><p>使用面向对象编程模拟：设计一个电脑对象，可以安装2个USB设备</p></li><li><p>鼠标：被安装时可以完成接入、调用点击功能、拔出功能。</p></li><li><p>键盘：被安装时可以完成接入、调用打字功能、拔出功能。</p></li></ul><p><strong>分析</strong></p><p>①定义一个USB的接口（申明USB设备的规范必须是：可以接入和拔出）。</p><p>②提供2个USB实现类代表鼠标和键盘，让其实现USB接口，并分别定义独有功能。</p><p>③创建电脑对象，创建2个USB实现类对象，分别安装到电脑中并触发功能的执行。</p><h3 id="2-内部类"><a href="#2-内部类" class="headerlink" title="2.内部类"></a>2.内部类</h3><h4 id="2-1内部类概述"><a href="#2-1内部类概述" class="headerlink" title="2.1内部类概述"></a>2.1内部类概述</h4><p><strong>内部类</strong></p><ul><li>内部类就是定义在一个类里面的类，里面的类可以理解成（寄生），外部类可以理解成（宿主）。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">People</span>&#123;</span><br><span class="line"><span class="comment">// 内部类  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Heart</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>内部类的使用场景、作用</strong></p><ul><li><p>当一个事物的内部，还有一个部分需要一个完整的结构进行描述，而这个内部的完整的结构又只为外部事物提供服务，那么整个内部的完整结构可以选择使用内部类来设计。</p></li><li><p>内部类通常可以方便访问外部类的成员，包括私有的成员。</p></li><li><p>内部类提供了更好的封装性，内部类本身就可以用private protectecd等修饰，封装性可以做更多控制。</p></li></ul><h4 id="2-2内部类之一：静态内部类-了解"><a href="#2-2内部类之一：静态内部类-了解" class="headerlink" title="2.2内部类之一：静态内部类[了解]"></a>2.2内部类之一：静态内部类[了解]</h4><p><strong>什么是静态内部类？</strong></p><ul><li><p>有static修饰，属于外部类本身。</p></li><li><p>它的特点和使用与普通类是完全一样的，类有的成分它都有，只是位置在别人里面而已。</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line"><span class="comment">// 静态成员内部类      </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>静态内部类创建对象的格式：</strong>  </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//格式：外部类名.内部类名 对象名 = new 外部类名.内部类构造器;</span></span><br><span class="line"><span class="comment">//范例：Outer.Inner in =  new Outer.Inner();</span></span><br></pre></td></tr></table></figure><p><strong>静态内部类的访问拓展：</strong> </p><p>1、静态内部类中是否可以直接访问外部类的静态成员？ </p><ul><li><strong>可以，外部类的静态成员只有一份可以被共享访问。</strong></li></ul><p>2、静态内部类中是否可以直接访问外部类的实例成员？ </p><ul><li><strong>不可以的，外部类的实例成员必须用外部类对象访问。</strong></li></ul><h4 id="2-3内部类之二：成员内部类-了解"><a href="#2-3内部类之二：成员内部类-了解" class="headerlink" title="2.3内部类之二：成员内部类[了解]"></a>2.3内部类之二：成员内部类[了解]</h4><p><strong>什么是成员内部类？</strong></p><ul><li><p>无static修饰，属于外部类的对象。</p></li><li><p>JDK16之前，成员内部类中不能定义静态成员，JDK 16开始也可以定义静态成员了。</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line"><span class="comment">// 成员内部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>成员内部类创建对象的格式：</strong>  </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//格式:外部类名.内部类名 对象名 = new 外部类构造器.new 内部类构造器();</span></span><br><span class="line"><span class="comment">//范例:Outer.Inner in =  new Outer().new  Inner();</span></span><br></pre></td></tr></table></figure><p><strong>成员内部类-面试题</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">heartbeat</span> <span class="operator">=</span> <span class="number">150</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Heart</span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">heartbeat</span> <span class="operator">=</span> <span class="number">110</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">heartbeat</span> <span class="operator">=</span> <span class="number">78</span>;</span><br><span class="line">System.out.println(??); <span class="comment">// 78  </span></span><br><span class="line">System.out.println(??); <span class="comment">// 110 </span></span><br><span class="line">System.out.println(??); <span class="comment">// 150</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：在成员内部类中访问所在外部类对象 ，格式：外部类名.this。</strong></p><p><strong>成员内部类的访问拓展：</strong> </p><p>1、成员内部类中是否可以直接访问外部类的静态成员？ </p><ul><li><strong>可以，外部类的静态成员只有一份可以被共享访问。</strong></li></ul><p>2、成员内部类的实例方法中是否可以直接访问外部类的实例成员？ </p><ul><li><strong>可以的，因为必须先有外部类对象，才能有成员内部类对象，所以可以直接访问外部类对象的实例成员。</strong></li></ul><h4 id="2-4内部类之三：局部内部类-了解"><a href="#2-4内部类之三：局部内部类-了解" class="headerlink" title="2.4内部类之三：局部内部类[了解]"></a>2.4内部类之三：局部内部类[了解]</h4><p><strong>局部内部类 （鸡肋语法，了解即可）</strong></p><ul><li><p>局部内部类放在方法、代码块、构造器等执行体中。</p></li><li><p>局部内部类的类文件名为： 外部类$N内部类.class。</p></li></ul><h4 id="2-5内部类之四：匿名内部类概述-重点"><a href="#2-5内部类之四：匿名内部类概述-重点" class="headerlink" title="2.5内部类之四：匿名内部类概述[重点]"></a>2.5内部类之四：匿名内部类概述[重点]</h4><p><strong>匿名内部类：</strong></p><ul><li><p>本质上是一个没有名字的局部内部类，定义在方法中、代码块中、等。</p></li><li><p><strong>作用</strong>：方便创建子类对象，最终目的为了简化代码编写。</p></li></ul><p><strong>格式：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">new</span> 类|抽象类名|或者接口名() &#123;   </span><br><span class="line"> 重写方法;</span><br><span class="line"> &#125;;   <span class="comment">//分号</span></span><br><span class="line"></span><br><span class="line"><span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>() &#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">a. run();</span><br></pre></td></tr></table></figure><p><strong>特点总结：</strong></p><ul><li><p>匿名内部类是一个<strong>没有名字的内部类</strong>。</p></li><li><p>匿名内部类写出来就会<strong>产生一个匿名内部类的对象</strong>。</p></li><li><p>匿名内部类的对象类型相当于是当前<strong>new的那个的类型的子类类型</strong>。</p></li></ul><h4 id="2-6匿名内部类常见使用形式"><a href="#2-6匿名内部类常见使用形式" class="headerlink" title="2.6匿名内部类常见使用形式"></a>2.6匿名内部类常见使用形式</h4><p><strong>匿名内部类在开发中的使用形式了解</strong></p><ul><li>某个学校需要让老师，学生，运动员一起参加游泳比赛</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*游泳接口*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Swimming</span> &#123;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 测试类*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JumppingDemo</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//需求：goSwimming方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义一个方法让所有角色进来一起比赛</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">goSwimming</span><span class="params">(Swimming swimming)</span> &#123;        swimming.swim();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>匿名内部类可以作为方法的实际参数进行传输。</strong></p><h4 id="2-7匿名内部类真实使用场景演示"><a href="#2-7匿名内部类真实使用场景演示" class="headerlink" title="2.7匿名内部类真实使用场景演示"></a>2.7匿名内部类真实使用场景演示</h4><p><strong>匿名内部类在开发中的真实使用场景演示</strong></p><ul><li>给按钮绑定点击事件</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  为按钮绑定点击事件监听器。</span></span><br><span class="line">btn.addActionListener(<span class="keyword">new</span> <span class="title class_">ActionListener</span>() &#123;         `<span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent e)</span> &#123;               System.out.println(<span class="string">&quot;登录一下~~&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//btn.addActionListener(e -&gt; System.out.println(&quot;登录一下~~&quot;));</span></span><br></pre></td></tr></table></figure><p><strong>使用总结:</strong></p><p><strong>开发中不是我们主动去定义匿名内部类的，而是别人需要我们写或者我们可以写的时候才会使用。</strong></p><p><strong>匿名内部类的代码可以实现代码进一步的简化（回扣主题）</strong></p><h3 id="3-常用API"><a href="#3-常用API" class="headerlink" title="3.常用API"></a>3.常用API</h3><p><strong>什么是API?</strong></p><ul><li><p>API(Application Programming interface) 应用程序编程接口。</p></li><li><p><strong>简单来说：就是<em>Java</em>帮我们已经写好的一些方法，我们直接拿过来用就可以了。</strong></p></li></ul><p><strong>Object类的作用：</strong></p><ul><li><p>Object类的方法是一切子类对象都可以直接使用的，所以我们要学习Object类的方法。</p></li><li><p>一个类要么默认继承了Object类，要么间接继承了Object类，Object类是Java中的祖宗类。</p></li></ul><h4 id="3-1Object类的常用方法："><a href="#3-1Object类的常用方法：" class="headerlink" title="3.1Object类的常用方法："></a><strong>3.1Object类的常用方法：</strong></h4><table><thead><tr><th align="center">方法名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><strong>public String toString()</strong></td><td align="center"><strong>默认是返回当前对象在堆内存中的地址信息:类的全限名@内存地址</strong></td></tr><tr><td align="center"><strong>public boolean equals(Object o)</strong></td><td align="center"><strong>默认是比较当前对象与另一个对象的地址是否相同，相同返回true，不同返回false</strong></td></tr></tbody></table><h5 id="3-1-1Object的toString方法："><a href="#3-1-1Object的toString方法：" class="headerlink" title="3.1.1Object的toString方法："></a><strong>3.1.1Object的toString方法：</strong></h5><p><strong>问题引出</strong></p><ul><li><p>开发中直接输出对象，默认输出对象的地址其实是毫无意义的。</p></li><li><p>开发中输出对象变量，更多的时候是希望看到对象的内容数据而不是对象的地址信息。</p></li></ul><p><strong>toString存在的意义</strong></p><ul><li><strong>父类toString()方法存在的意义就是为了被子类重写，以便返回对象的内容信息，而不是地址信息！！</strong></li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//在子类中先进行方法重写,万能快捷键</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, sex=&quot;</span> + sex +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//主函数使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;   </span><br><span class="line">   </span><br><span class="line">   <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;周雄&quot;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="number">19</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// System.out.println(s.toString());//默认可以省略toString</span></span><br><span class="line"></span><br><span class="line">    System.out.println(s); <span class="comment">//按重写方法排版</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-2Object的equals方法："><a href="#3-2Object的equals方法：" class="headerlink" title="3.2Object的equals方法："></a><strong>3.2Object的equals方法：</strong></h5><p><strong>问题思考</strong></p><ul><li>直接比较两个对象的地址是否相同完全可以用“&#x3D;&#x3D;”替代equals。</li></ul><p><strong>equals存在的意义</strong></p><ul><li><strong>父类equals方法存在的意义就是为了被子类重写，以便子类自己来定制比较规则。</strong></li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;周雄&quot;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="number">19</span>);</span><br><span class="line"><span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;周雄&quot;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="number">19</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// equals默认是比较2个对象的地址是否相同。</span></span><br><span class="line">System.out.println(s1.equals(s2)); <span class="comment">//false</span></span><br><span class="line">System.out.println(s1 == s2);      <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//子类重写后会调用子类重写的来比较内容是否相同。</span></span><br><span class="line">System.out.println(s1.equals(s2)); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h4 id="3-2Objects概述"><a href="#3-2Objects概述" class="headerlink" title="3.2Objects概述"></a><strong>3.2Objects概述</strong></h4><ul><li>Objects是一个工具类，提供了一些方法去完成一些功能。</li></ul><p><strong>Objects的常见方法：</strong></p><table><thead><tr><th align="center">方法名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><strong>public  static boolean equals(Object a,  Object b)</strong></td><td align="center"><strong>比较两个对象的，底层会先进行非空判断，从而可以避免空指针异常。再进行equals比较</strong></td></tr><tr><td align="center"><strong>public  static boolean isNull(Object obj)</strong></td><td align="center"><strong>判断变量是否为null  ,为null返回true  ,反之</strong></td></tr></tbody></table><h5 id="3-2-1Objects的equals方法"><a href="#3-2-1Objects的equals方法" class="headerlink" title="3.2.1Objects的equals方法"></a><strong>3.2.1Objects的equals方法</strong></h5><p><strong>官方在进行字符串比较时，没有用字符串对象的的equals方法，而是选择了Objects的equals方法来比较。</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="comment">//官方方法重写</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line"><span class="comment">// 1、判断是否是同一个对象比较，如果是返回true。</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 2、如果o是null返回false  如果o不是学生类型返回false  ...Student !=  ..Pig</span></span><br><span class="line"><span class="keyword">if</span> (o == <span class="literal">null</span> || <span class="built_in">this</span>.getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 3、说明o一定是学生类型而且不为null</span></span><br><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) o;</span><br><span class="line"><span class="keyword">return</span> sex == student.sex &amp;&amp; age == student.age &amp;&amp; Objects.equals(name, student.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>源码分析</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object a, Object b)</span> &#123;    <span class="keyword">return</span> (a == b) || (a != <span class="literal">null</span> &amp;&amp; a.equals(b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用Objects的equals方法在进行对象的比较会更安全。(建议使用)</strong></p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//掌握objects类的常用方法:equals</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s12</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;itheima&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 留下了隐患，可能出现空指针异常。</span></span><br><span class="line"><span class="comment">// System.out.println(s1.equals(s2));   </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 更安全，结果也是对的！推荐使用！</span></span><br><span class="line"><span class="comment">//有对象时，推荐方法重写后使用</span></span><br><span class="line">System.out.println(Objects.equals(s1, s2)); </span><br></pre></td></tr></table></figure><h5 id="3-2-2Objects的isNull方法"><a href="#3-2-2Objects的isNull方法" class="headerlink" title="3.2.2Objects的isNull方法"></a><strong>3.2.2Objects的isNull方法</strong></h5><p><strong>判断是否为空，两种方法效果相同</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;itheima&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(Objects.isNull(s1)); <span class="comment">// true</span></span><br><span class="line">System.out.println(s1 == <span class="literal">null</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">System.out.println(Objects.isNull(s2)); <span class="comment">// false</span></span><br><span class="line">System.out.println(s2 == <span class="literal">null</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h4 id="3-3StringBuilder可变的字符串类概述"><a href="#3-3StringBuilder可变的字符串类概述" class="headerlink" title="3.3StringBuilder可变的字符串类概述"></a><strong>3.3StringBuilder可变的字符串类概述</strong></h4><p><strong>StringBuilder概述</strong></p><ul><li><p>StringBuilder是一个<strong>可变的字符串类</strong>，我们可以把它看成是<strong>一个对象容器</strong>。</p></li><li><p><strong>作用</strong>：<strong>提高字符串的操作效率</strong>，如拼接、修改等。</p></li></ul><p><strong>StringBuilder 构造器</strong></p><table><thead><tr><th align="center">名称</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><strong>public  StringBuilder()</strong></td><td align="center"><strong>创建一个空白的可变的字符串对象，不包含任何内容</strong></td></tr><tr><td align="center"><strong>public  StringBuilder(String str)</strong></td><td align="center"><strong>创建一个指定字符串内容的可变字符串对象</strong></td></tr></tbody></table><p><strong>StringBuilder常用方法</strong></p><table><thead><tr><th align="center">方法名称</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><strong>public StringBuilder append(任意类型)</strong></td><td align="center"><strong>添加数据并返回StringBuilder对象本身</strong></td></tr><tr><td align="center"><strong>public StringBuilder reverse()</strong></td><td align="center"><strong>将对象的内容反转</strong></td></tr><tr><td align="center"><strong>public int length()</strong></td><td align="center"><strong>返回对象内容长度</strong></td></tr><tr><td align="center"><strong>public String toString()</strong></td><td align="center"><strong>通过toString()就可以实现把StringBuilder转换为String</strong></td></tr></tbody></table><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：学会使用StringBuilder操作字符串,</span></span><br><span class="line"><span class="comment">    最终还需要知道它性能好的原因</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(); <span class="comment">// </span></span><br><span class="line">        sb.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">        sb.append(<span class="number">1</span>);</span><br><span class="line">        sb.append(<span class="literal">false</span>);</span><br><span class="line">        sb.append(<span class="number">3.3</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        System.out.println(sb);  <span class="comment">//abc1false3.3abc</span></span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="comment">// 支持链式编程</span></span><br><span class="line">        sb1.append(<span class="string">&quot;a&quot;</span>).append(<span class="string">&quot;b&quot;</span>).append(<span class="string">&quot;c&quot;</span>).append(<span class="string">&quot;我爱你中国&quot;</span>);</span><br><span class="line">        System.out.println(sb1); <span class="comment">//abc我爱你中国</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// reverse()反转</span></span><br><span class="line">        sb1.reverse().append(<span class="string">&quot;110&quot;</span>); </span><br><span class="line">        System.out.println(sb1);  <span class="comment">//abc我爱你中国--&gt;国中你爱我cba</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// length()长度</span></span><br><span class="line">        System.out.println(sb1.length());  <span class="comment">//连接后字符长度</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意：StringBuilder只是拼接字符串的手段：效率好。</span></span><br><span class="line">        <span class="comment">// 最终的目的还是要恢复成String类型，方便传参</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        sb2.append(<span class="string">&quot;123&quot;</span>).append(<span class="string">&quot;456&quot;</span>);  </span><br><span class="line">        <span class="comment">// 恢复成String类型</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> sb2.toString();</span><br><span class="line">        check(rs);</span><br></pre></td></tr></table></figure><p><strong>为什么拼接、反转字符串建议使用StringBuilder?</strong></p><ul><li><p><strong>String</strong> <strong>：内容是不可变的、拼接字符串性能差。</strong></p></li><li><p><strong>StringBuilder：内容是可变的、拼接字符串性能好、代码优雅。</strong></p></li><li><p><strong>定义字符串使用String</strong></p></li><li><p><strong>拼接、修改等操作字符串使用StringBuilder</strong></p></li></ul><p><em><strong>案例:</strong></em></p><p><em><strong>打印整型数组内容</strong></em></p><p><strong>需求：</strong></p><p>设计一个方法用于输出任意整型数组的内容，要求输出成如下格式：</p><p>   “该数组内容为：[11, 22, 33, 44, 55]”</p><p><strong>分析</strong>：</p><p>1、定义一个方法，要求该方法能够接收数组，并输出数组内容。 —&gt; 需要参数吗？需要返回值类型申明吗？</p><p>2、定义一个静态初始化的数组，调用该方法，并传入该数组。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//*需求：</span></span><br><span class="line">设计一个方法用于输出任意整型数组的内容，要求输出成如下格式：</span><br><span class="line">“该数组内容为：[<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>]”</span><br><span class="line"><span class="comment">//分析：</span></span><br><span class="line"><span class="number">1</span>、定义一个方法，要求该方法能够接收数组，并输出数组内容。</span><br><span class="line">    ---&gt; 需要参数吗？需要返回值类型申明吗？</span><br><span class="line"><span class="number">2</span>、定义一个静态初始化的数组，调用该方法，并传入该数组。</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr1 = <span class="literal">null</span>;  <span class="comment">//数组为空</span></span><br><span class="line">        System.out.println(show(arr1));</span><br><span class="line">        <span class="type">int</span>[] arr2 = &#123;<span class="number">10</span>, <span class="number">88</span>, <span class="number">66</span>&#125;; <span class="comment">//数组有值</span></span><br><span class="line">        System.out.println(show(arr2));</span><br><span class="line">        <span class="type">int</span>[] arr3 = &#123;&#125;;    <span class="comment">//数组无任何值</span></span><br><span class="line">        System.out.println(show(arr3));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">show</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr != <span class="literal">null</span>) &#123;   <span class="comment">//判断数组不为空</span></span><br><span class="line">            <span class="comment">//创建StringBuilder 构造器</span></span><br><span class="line">            <span class="type">StringBuffer</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(); </span><br><span class="line">            System.out.print(<span class="string">&quot;[&quot;</span>);</span><br><span class="line">            <span class="comment">//遍历数组中每一个元素</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">                s.append(arr[i]).append(i == arr.length - <span class="number">1</span> ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;,&quot;</span>);  <span class="comment">//判断元素是否为最后一个 </span></span><br><span class="line">            &#125;</span><br><span class="line">            s.append(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">st</span> <span class="operator">=</span> s.toString(); </span><br><span class="line">            <span class="comment">//以方法返回值类型String返回</span></span><br><span class="line">            <span class="keyword">return</span> st;</span><br><span class="line">        &#125; <span class="keyword">else</span>              <span class="comment">//判断数组为空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-4Math类"><a href="#3-4Math类" class="headerlink" title="3.4Math类"></a><strong>3.4Math类</strong></h4><ul><li><p>包含执行基本数字运算的方法，Math类没有提供公开的构造器。</p></li><li><p><strong>如何使用类中的成员呢？</strong>看类的成员是否都是静态的，如果是，通过类名就可以直接调用</p></li></ul><p><strong>Math 类的常用方法：</strong></p><table><thead><tr><th align="center"><strong>方法名</strong></th><th align="center"><strong>说明</strong></th></tr></thead><tbody><tr><td align="center"><strong>public static int abs(int a)</strong></td><td align="center"><strong>获取参数绝对值</strong></td></tr><tr><td align="center"><strong>public static double  ceil(double a)</strong></td><td align="center"><strong>向上取整</strong></td></tr><tr><td align="center"><strong>public static double  floor(double a)</strong></td><td align="center"><strong>向下取整</strong></td></tr><tr><td align="center"><strong>public static int round(float a)</strong></td><td align="center"><strong>四舍五入</strong></td></tr><tr><td align="center"><strong>public static int max(int  a,int b)</strong></td><td align="center"><strong>获取两个int值中的较大值</strong></td></tr><tr><td align="center"><strong>public static double pow(double  a,double b)</strong></td><td align="center"><strong>返回a的b次幂的值</strong></td></tr><tr><td align="center"><strong>public static double random()</strong></td><td align="center"><strong>返回值为double的随机值，范围[0.0,1.0)</strong></td></tr></tbody></table><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    目标：Math类的使用。</span></span><br><span class="line"><span class="comment">    Math用于做数学运算。</span></span><br><span class="line"><span class="comment">    Math类中的方法全部是静态方法，直接用类名调用即可。</span></span><br><span class="line"><span class="comment">    方法：</span></span><br><span class="line"><span class="comment">方法名                                      说明</span></span><br><span class="line"><span class="comment">public static int abs(int a)         获取参数a的绝对值：                                      </span></span><br><span class="line"><span class="comment">public static double ceil(double a)      向上取整       </span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">public static double floor(double a)     向下取整        </span></span><br><span class="line"><span class="comment">         </span></span><br><span class="line"><span class="comment">public static double pow(double a, double b)   获取a的b次幂</span></span><br><span class="line"><span class="comment">         </span></span><br><span class="line"><span class="comment">public static long round(double a)      四舍五入取整</span></span><br><span class="line"><span class="comment">   </span></span><br><span class="line"><span class="comment">小结：</span></span><br><span class="line"><span class="comment">    记住。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MathDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.取绝对值:返回正数</span></span><br><span class="line">        System.out.println(Math.abs(<span class="number">10</span>)); <span class="comment">// 10</span></span><br><span class="line">        System.out.println(Math.abs(-<span class="number">10.3</span>)); <span class="comment">// 10.3</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.向上取整: 5</span></span><br><span class="line">        System.out.println(Math.ceil(<span class="number">4.00000001</span>)); <span class="comment">// 5.0</span></span><br><span class="line">        System.out.println(Math.ceil(<span class="number">4.0</span>)); <span class="comment">// 4.0</span></span><br><span class="line">        <span class="comment">// 3.向下取整：4</span></span><br><span class="line">        System.out.println(Math.floor(<span class="number">4.99999999</span>)); <span class="comment">// 4.0</span></span><br><span class="line">        System.out.println(Math.floor(<span class="number">4.0</span>)); <span class="comment">// 4.0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.求指数次方</span></span><br><span class="line">        System.out.println(Math.pow(<span class="number">2</span> , <span class="number">3</span>)); <span class="comment">// 2^3 = 8.0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 5.四舍五入 10</span></span><br><span class="line">        System.out.println(Math.round(<span class="number">4.49999</span>)); <span class="comment">// 4</span></span><br><span class="line">        System.out.println(Math.round(<span class="number">4.500001</span>)); <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.随机数[0~1) （包前不包后）</span></span><br><span class="line">        System.out.println(Math.random());  <span class="comment">// 0.0 - 1.0 </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拓展： 3 - 9 之间的随机数  （0 - 6） + 3</span></span><br><span class="line">        <span class="comment">//  [0 - 6] + 3</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span>  (<span class="type">int</span>)(Math.random() * <span class="number">7</span>) + <span class="number">3</span>;</span><br><span class="line">        System.out.println(data);</span><br></pre></td></tr></table></figure><h4 id="3-5System-工具类概述"><a href="#3-5System-工具类概述" class="headerlink" title="3.5System 工具类概述"></a><strong>3.5System 工具类概述</strong></h4><ul><li>System也是一个工具类，代表了当前系统，提供了一些与系统相关的方法。</li></ul><p><strong>System 类的常用方法</strong></p><table><thead><tr><th align="center">方法名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><strong>public  static void exit(int status)</strong></td><td align="center"><strong>终止当前运行的 Java 虚拟机，非零表示异常终止</strong></td></tr><tr><td align="center"><strong>public  static long currentTimeMillis()</strong></td><td align="center"><strong>返回当前系统的时间毫秒值形式</strong></td></tr><tr><td align="center"><strong>public  static void arraycopy(数据源数组, 起始索引, 目的地数组, 起始索引, 拷贝个数)</strong></td><td align="center"><strong>数组拷贝</strong></td></tr></tbody></table><p><strong>时间毫秒值</strong></p><ul><li><p>计算机认为时间是有起点的，起始时间： 1970年1月1日 00:00:00</p></li><li><p>时间毫秒值：指的是从1970年1月1日   00:00:00走到此刻的总的毫秒数，应该是很大的。 1s &#x3D; 1000ms。</p></li><li><p><strong>原因：</strong></p><p>​    1969年8月，贝尔实验室的程序员肯汤普逊利用妻儿离开一个月的机会，开始着手创造一个全新的革命性的操作系统，他使用B编译语言在老旧的PDP-7机器上开发出了Unix的一个版本。</p><p>随后，汤普逊和同事丹尼斯里奇改进了B语言，开发出了C语言，重写了UNIX。</p><p> <strong>1970年1月1日 算C语言的生日</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">System.out.println(time);<span class="comment">//1575465416955</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;程序开始。。。&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// System.exit(0); // JVM终止！ 0是有程序员正常终止，非0位非正常终止</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;程序结束。。。。&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2、计算机认为时间有起源：返回1970-1-1 00：00：00 走到此刻的总的毫秒值：时间毫秒值。</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(time);  <span class="comment">//截至到目前时间毫秒</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 功能：进行时间的计算：性能分析</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis(); <span class="comment">//运行前时间</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;输出：&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();  <span class="comment">//运行结束时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">upTime</span> <span class="operator">=</span> (endTime - startTime)/<span class="number">1000.0</span>;  <span class="comment">//时间差</span></span><br><span class="line">        System.out.println(upTime+ <span class="string">&quot;s&quot;</span>); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、做数组拷贝（了解）</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         arraycopy(Object src,  int  srcPos,</span></span><br><span class="line"><span class="comment">         Object dest, int destPos,</span></span><br><span class="line"><span class="comment">         int length)</span></span><br><span class="line"><span class="comment">         参数一：被拷贝的数组</span></span><br><span class="line"><span class="comment">         参数二：从哪个索引位置开始拷贝</span></span><br><span class="line"><span class="comment">         参数三：复制的目标数组</span></span><br><span class="line"><span class="comment">         参数四：粘贴位置</span></span><br><span class="line"><span class="comment">         参数五：拷贝元素的个数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">int</span>[] arr1 = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>, <span class="number">70</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] arr2 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">6</span>]; <span class="comment">// [0, 0, 0, 0, 0, 0] ==&gt;  [0, 0, 40, 50, 60, 0]</span></span><br><span class="line">        System.arraycopy(arr1, <span class="number">3</span>, arr2, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr2));</span><br></pre></td></tr></table></figure><h4 id="3-6BigDecimal作用"><a href="#3-6BigDecimal作用" class="headerlink" title="3.6BigDecimal作用"></a>3.6<strong>BigDecimal作用</strong></h4><ul><li>用于解决浮点型运算精度失真的问题</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">// 浮点型运算的时候直接+  * / 可能会出现数据失真（精度问题）。  System.out.println(0.09 + 0.01);  //0.09999999999999</span></span><br><span class="line">System.out.println(<span class="number">1.0</span> - <span class="number">0.32</span>);   <span class="comment">//0.67999999999999</span></span><br><span class="line">System.out.println(<span class="number">1.015</span> * <span class="number">100</span>);  <span class="comment">//101.499999999999</span></span><br><span class="line">System.out.println(<span class="number">1.301</span> / <span class="number">100</span>);  <span class="comment">//0.01300999999999</span></span><br><span class="line">System.out.println(<span class="string">&quot;-------------------------&quot;</span>);</span><br><span class="line"><span class="type">double</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0.1</span> + <span class="number">0.2</span>;             <span class="comment">//0.30000000000004</span></span><br><span class="line">System.out.println(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用步骤</strong></p><ul><li><strong>创建对象BigDecimal封装浮点型数据（最好的方式是调用方法）</strong></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> BigDecimal <span class="title function_">valueOf</span><span class="params">(<span class="type">double</span> val)</span>:   </span><br><span class="line"><span class="comment">//包装浮点数成为BigDecimal对象。</span></span><br></pre></td></tr></table></figure><p><strong>BigDecima常用API</strong></p><table><thead><tr><th align="center"><strong>方法名</strong></th><th align="left"><strong>说明</strong></th></tr></thead><tbody><tr><td align="center"><strong>public BigDecimal add(BigDecimal b)</strong></td><td align="left"><strong>加法</strong></td></tr><tr><td align="center"><strong>public BigDecimal subtract(BigDecimal b)</strong></td><td align="left"><strong>减法</strong></td></tr><tr><td align="center"><strong>public BigDecimal multiply(BigDecimal b)</strong></td><td align="left"><strong>乘法</strong></td></tr><tr><td align="center"><strong>public BigDecimal divide(BigDecimal b)</strong></td><td align="left"><strong>除法</strong></td></tr><tr><td align="center"><strong>public BigDecimal divide (另一个BigDecimal对象，精确几位，舍入模式)</strong></td><td align="left"><strong>除法</strong></td></tr></tbody></table><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0.1</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0.2</span>;</span><br><span class="line"><span class="comment">// 包装浮点型数据成为大数据对象 BigDeciaml</span></span><br><span class="line">     <span class="type">BigDecimal</span> <span class="variable">a1</span> <span class="operator">=</span> BigDecimal.valueOf(a);</span><br><span class="line">     <span class="type">BigDecimal</span> <span class="variable">b1</span> <span class="operator">=</span> BigDecimal.valueOf(b);</span><br><span class="line">        </span><br><span class="line">     <span class="type">BigDecimal</span> <span class="variable">c1</span> <span class="operator">=</span> a1.add(b1);<span class="comment">//加</span></span><br><span class="line">   <span class="comment">//BigDecimal c1 = a1.subtract(b1);//减</span></span><br><span class="line">   <span class="comment">//BigDecimal c1 = a1.multiply(b1);//乘</span></span><br><span class="line">   <span class="comment">//BigDecimal c1 = a1.divide(b1);//除</span></span><br><span class="line">        </span><br><span class="line">    System.out.println(c1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目的：以double类型传出去</span></span><br><span class="line">   <span class="type">double</span> <span class="variable">rs</span> <span class="operator">=</span> c1.doubleValue(); <span class="comment">//转换位double类型</span></span><br><span class="line">   System.out.println(rs);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意事项：BigDecimal是一定要精度运算的</span></span><br><span class="line">   <span class="type">BigDecimal</span> <span class="variable">a11</span> <span class="operator">=</span> BigDecimal.valueOf(<span class="number">10.0</span>);</span><br><span class="line">   <span class="type">BigDecimal</span> <span class="variable">b11</span> <span class="operator">=</span> BigDecimal.valueOf(<span class="number">3.0</span>);</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">   参数一：除数 </span></span><br><span class="line"><span class="comment">   参数二：保留小数位数  </span></span><br><span class="line"><span class="comment">   参数三：舍入模式</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"> <span class="type">BigDecimal</span> <span class="variable">c11</span> <span class="operator">=</span> a11.divide(b11, <span class="number">2</span>, RoundingMode.HALF_UP); </span><br><span class="line"> System.out.println(c11);  <span class="comment">// 3.33</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> java,面向对象进阶,多态,内部类,常用API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>day11 - 包、权限修饰符、final、常量、枚举、抽象类、接口</title>
      <link href="/post/383d7cb7.html"/>
      <url>/post/383d7cb7.html</url>
      
        <content type="html"><![CDATA[<h2 id="day12-面向对象进阶"><a href="#day12-面向对象进阶" class="headerlink" title="day12.面向对象进阶"></a>day12.面向对象进阶</h2><hr><hr><h3 id="1-包"><a href="#1-包" class="headerlink" title="1.包"></a>1.包</h3><p><strong>什么是包？</strong></p><ul><li><p>包是用来分门别类的管理各种不同类的，类似于文件夹、建包利于程序的管理和维护。</p></li><li><p>建包的语法格式：package 公司域名倒写.技术名称。报名建议全部英文小写，且具备意义</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.javabean;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>建包语句必须在第一行，一般IDEA工具会帮助创建</li></ul><p><strong>导包</strong> </p><ul><li><p>相同包下的类可以直接访问，不同包下的类必须导包,才可以使用！导包格式：<strong>import</strong> <strong>包名.类名;</strong></p></li><li><p>假如一个类中需要用到不同类，而这个两个类的名称是一样的，那么默认只能导入一个类，另一个类要带包名访问。</p></li></ul><hr><hr><h3 id="2-权限修饰符"><a href="#2-权限修饰符" class="headerlink" title="2.权限修饰符"></a>2.权限修饰符</h3><p><strong>什么是权限修饰符？</strong></p><ul><li><p>权限修饰符：是用来控制一个成员能够被访问的范围的。</p></li><li><p>可以修饰成员变量，方法，构造器，内部类，不同权限修饰符修饰的成员能够被访问的范围将受到限制。</p></li></ul><p><strong>权限修饰符的分类和具体作用范围：</strong></p><ul><li><p>权限修饰符：有四种作用范围由小到大</p><p>（private -&gt; 缺省 -&gt; protected - &gt; public ）</p><table><thead><tr><th><strong>修饰符</strong></th><th align="center">同一 个类中</th><th align="center">同一个包中其他类</th><th align="center">不同包下的子类</th><th align="center">不同包下的无关类</th></tr></thead><tbody><tr><td>private</td><td align="center">√</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td>缺省</td><td align="center">√</td><td align="center">√</td><td align="center"></td><td align="center"></td></tr><tr><td>protected</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center"></td></tr><tr><td>public</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr></tbody></table></li></ul><p><strong>学完权限修饰符需要具备如下能力</strong></p><ul><li><p>能够识别别人定义的成员的访问权限。</p></li><li><p>自己定义成员（方法，成员变量，构造器等）一般满足如下要求：</p><ul><li>成员变量一般私有。</li><li>方法一般公开。</li><li>如果该成员只希望本类访问，使用private修饰。</li><li>如果该成员只希望本类，同一个包下的其他类和子类访问，使用protected修饰。</li></ul></li></ul><hr><hr><h3 id="3-final"><a href="#3-final" class="headerlink" title="3.final"></a>3.final</h3><hr><h4 id="3-1final的作用"><a href="#3-1final的作用" class="headerlink" title="3.1final的作用"></a>3.1final的作用</h4><ul><li><p>final 关键字是最终的意思，可以修饰（方法，变量，类）</p></li><li><p>修饰方法：表明该方法是最终方法，不能被重写。</p></li><li><p>修饰变量：表示该变量第一次赋值后，不能再次被赋值(有且仅能被赋值一次)。</p></li><li><p>修饰类：表明该类是最终类，不能被继承。</p></li></ul><hr><h4 id="3-2-final修饰变量的注意"><a href="#3-2-final修饰变量的注意" class="headerlink" title="3.2 final修饰变量的注意"></a>3.2 final修饰变量的注意</h4><ul><li><p>final修饰的变量是基本类型：那么变量存储的<strong>数据值</strong>不能发生改变。</p></li><li><p>final修饰的变量是引用类型：那么变量存储的<strong>地址值</strong>不能发生改变，但是地址指向的对象内容是可以发生变化的。</p></li></ul><hr><hr><h3 id="4-常量"><a href="#4-常量" class="headerlink" title="4.常量"></a>4.常量</h3><hr><h4 id="4-1常量概述和基本作用"><a href="#4-1常量概述和基本作用" class="headerlink" title="4.1常量概述和基本作用"></a>4.1常量概述和基本作用</h4><p><strong>常量</strong> </p><ul><li><p>常量是使用了public static final修饰的成员变量，必须有初始化值，而且执行的过程中其值不能被改变。</p></li><li><p>常量的作用和好处：可以用于做系统的配置信息，方便程序的维护，同时也能提高可读</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Constant</span> &#123;    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SCHOOL_NAME</span>  <span class="operator">=</span> “传智教育<span class="string">&quot;;   public static final String LOGIN_NAME  = “admin&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PASS_WORD</span>  <span class="operator">=</span> “<span class="number">123456</span><span class="string">&quot;;</span></span><br><span class="line"><span class="string">&#125; </span></span><br></pre></td></tr></table></figure><p><strong>建议：</strong>常量命名规范：英文单词全部大写，多个单词下划线连接起来。</p><p><strong>常量的执行原理</strong></p><ul><li><p>在编译阶段会进行“宏替换”，把使用常量的地方全部替换成真实的字面量。</p></li><li><p>这样做的好处是让使用常量的程序的执行性能与直接使用字面量是一样的。</p></li></ul><hr><h4 id="4-2常量做信息标志和分类"><a href="#4-2常量做信息标志和分类" class="headerlink" title="4.2常量做信息标志和分类"></a>4.2常量做信息标志和分类</h4><p><strong>案例说明：</strong></p><ul><li>现在开发的超级玛丽游戏需要接收用户输入的四个方向的信号（上下左右），以便控制玛丽移动的方向。</li></ul><p><strong>选择常量做信息标志和分类：</strong></p><ul><li>代码可读性好，实现了软编码形式。</li></ul><hr><hr><h3 id="5-枚举"><a href="#5-枚举" class="headerlink" title="5.枚举"></a>5.枚举</h3><hr><h4 id="5-1枚举的概述"><a href="#5-1枚举的概述" class="headerlink" title="5.1枚举的概述"></a>5.1枚举的概述</h4><p><strong>枚举的概述</strong></p><ul><li>枚举是Java中的一种特殊类型</li></ul><p><strong>枚举的作用：</strong></p><ul><li>是为了做信息的标志和信息的分类</li></ul><p><strong>定义枚举类的格式:</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 <span class="keyword">enum</span> 枚举名称&#123;</span><br><span class="line">            第一行都是罗列枚举类实例的名称。</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Season</span>&#123;    </span><br><span class="line">SPRING , SUMMER , AUTUMN , WINTER;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>枚举的特征：</strong></p><ul><li><p>枚举类都是继承了枚举类型：java.lang.Enum</p></li><li><p>枚举都是最终类，不可以被继承。</p></li><li><p>构造器都是私有的，枚举对外不能创建对象。</p></li><li><p>枚举类的第一行默认都是罗列枚举对象的名称的。</p></li><li><p>枚举类相当于是多例模式。</p></li></ul><hr><h4 id="5-2枚举的使用场景演示"><a href="#5-2枚举的使用场景演示" class="headerlink" title="5.2枚举的使用场景演示"></a>5.2枚举的使用场景演示</h4><p><strong>案例说明：</strong></p><ul><li>现在开发的超级玛丽游戏需要接收用户输入的四个方向的信号（上下左右），以便控制玛丽移动的方向。</li></ul><p><strong>选择常量做信息标志和分类：</strong></p><ul><li>虽然可以实现可读性，但是入参值不受约束，代码相对不够严谨。</li></ul><p><strong>枚举做信息标志和分类：</strong></p><ul><li>代码可读性好，入参约束严谨，代码优雅，是最好的信息分类技术！建议使用!</li></ul><hr><hr><h3 id="6-抽象类"><a href="#6-抽象类" class="headerlink" title="6.抽象类"></a>6.抽象类</h3><hr><h4 id="6-1抽象类概述"><a href="#6-1抽象类概述" class="headerlink" title="6.1抽象类概述"></a>6.1抽象类概述</h4><p><strong>抽象类</strong></p><ul><li>在Java中<strong>abstract</strong>是抽象的意思，如果一个类中的<strong>已知有某个方法</strong>，但是<strong>方法的具体实现不能确定</strong>，就可以申明成<strong>abstract</strong>修饰的抽象方法（不能写方法体了），这个类必须用abstract修饰，被称为抽象类。（只能修饰方法、类）</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 <span class="keyword">abstract</span> 返回值类型 方法名称(形参列表);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 <span class="keyword">abstract</span> class 类名&#123;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>抽象的使用总结与注意事项</strong></p><ul><li><p>抽象类可以理解成类的不完整设计图，是用来被子类继承的。</p></li><li><p>一个类如果<strong>继承了抽象类</strong>，那么这个类<strong>必须重写完抽象类的全部抽象方法</strong>，否则这个类也<strong>必须定义成抽象类</strong>。</p></li></ul><hr><h4 id="6-2抽象类的案例"><a href="#6-2抽象类的案例" class="headerlink" title="6.2抽象类的案例"></a>6.2抽象类的案例</h4><p><strong>系统需求</strong></p><ul><li><p>某加油站推出了2种支付卡，一种是预存10000的<strong>金卡</strong>，后续加油享受<strong>8折优惠</strong>，另一种是预存5000的<strong>银卡</strong> ,后续加油享受<strong>8.5折优惠</strong>。</p></li><li><p>请分别实现2种卡片进入收银系统后的逻辑，卡片需要包含主人<strong>名称，余额，支付功能。</strong></p></li></ul><p><strong>分析实现</strong></p><ul><li><p>创建一张卡片父类：定义属性包括主人名称、余额、支付功能（具体实现交给子类）</p></li><li><p>创建一张白金卡类：重写支付功能，按照原价的8折计算输出。</p></li><li><p>创建一张银卡类：重写支付功能，按照原价的8.5折计算输出。</p></li></ul><hr><h4 id="6-3抽象类的特征、注意事项"><a href="#6-3抽象类的特征、注意事项" class="headerlink" title="6.3抽象类的特征、注意事项"></a>6.3抽象类的特征、注意事项</h4><p><strong>特征和注意事项</strong></p><ul><li><p><strong>有得有失</strong>: 得到了抽象方法，失去了创建对象的能力。</p></li><li><p><strong>抽象类为什么不能创建对象？</strong></p></li><li><ul><li><p>类有的成员（成员变量、方法、构造器）抽象类都具备</p></li><li><p>抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类（只能修饰方法、类）</p></li><li><p>一个类继承了抽象类必须重写完抽象类的全部抽象方法，否则这个类也必须定义成抽象类。</p></li><li><p>不能用abstract修饰变量、代码块、构造器。</p></li></ul></li></ul><hr><h4 id="6-4abstract和final是什么关系？"><a href="#6-4abstract和final是什么关系？" class="headerlink" title="6.4abstract和final是什么关系？"></a>6.4abstract和final是什么关系？</h4><p><strong>互斥关系</strong></p><ul><li><p><strong>abstract</strong>定义的<strong>抽象类</strong>作为模板让<strong>子类继承</strong>，<strong>final</strong>定义的<strong>类不能被继承</strong>。</p></li><li><p><strong>抽象方法</strong>定义通用<strong>方法</strong>让<strong>子类重写</strong>，<strong>final</strong>定义的<strong>方法</strong>子类<strong>不能重写</strong>。</p></li></ul><hr><h4 id="6-4抽象类的应用知识：模板方法模式"><a href="#6-4抽象类的应用知识：模板方法模式" class="headerlink" title="6.4抽象类的应用知识：模板方法模式"></a>6.4抽象类的应用知识：模板方法模式</h4><p><strong>什么时候使用模板方法模式</strong></p><p><strong>使用场景说明</strong>：当系统中出现同一个功能多处在开发，而该功能中大部分代码是一样的，只有其中部分可能不同的时候。</p><p><strong>模板方法模式实现步骤</strong></p><ul><li><p>把功能定义成一个所谓的模板方法，放在抽象类中，模板方法中只定义通用且能确定的代码。</p></li><li><p>模板方法中不能决定的功能定义成抽象方法让具体子类去实现。</p></li></ul><p><strong>案例：银行利息结算系统</strong></p><p><strong>需求：</strong></p><ul><li><p>某软件公司要为某银行的业务支撑系统开发一个利息结算系统，账户有活期和定期账户两种，</p></li><li><p>活期是0.35%，定期是 1.75%，定期如果满10万额外给予3%的收益。</p></li><li><p>结算利息要先进行用户名、密码验证，验证失败直接提示，登录成功进行结算</p></li></ul><p><strong>分析：</strong></p><p>活期————登录验证</p><p>​                       计算利息…</p><p>定期————输出利息</p><p><strong>银行利息结算系统实现</strong></p><p><strong>需求：</strong></p><ul><li><p>活期是0.35%，定期是 1.75%，定期如果满10万额外给予3%的收益。</p></li><li><p>结算利息要先进行用户名、密码验证，验证失败直接提示，登录成功进行结算</p></li></ul><p><strong>分析：</strong></p><p>①：创建一个抽象的账户类Account作为父类模板，提供属性（卡号，余额）</p><p>②：在父类Account中提供一个模板方法实现登录验证，利息结算、利息输出。</p><p>③：具体的利息结算定义成抽象方法，交给子类实现。</p><p>④：定义活期账户类，让子类重写实现具体的结算方法</p><p>⑤：定义定期账户类，让子类重写实现具体的结算方法</p><p>⑥：创建账户对象，完成相关功能。</p><p><strong>模板方法我们是建议使用final修饰的，这样会更专业，那么为什么呢？</strong></p><p>答：模板方法是给子类直接使用的，不是让子类重写的，</p><p>一旦子类重写了模板方法就失效了。</p><hr><hr><h3 id="7-接口"><a href="#7-接口" class="headerlink" title="7.接口"></a>7.接口</h3><hr><h4 id="7-1接口概述、特点"><a href="#7-1接口概述、特点" class="headerlink" title="7.1接口概述、特点"></a>7.1接口概述、特点</h4><p><strong>接口的定义与特点</strong></p><p>接口的格式如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">接口用关键字interface来定义</span><br><span class="line"><span class="keyword">public</span> interface 接口名 &#123;</span><br><span class="line">       <span class="comment">// 常量</span></span><br><span class="line">       <span class="comment">// 抽象方法</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><ul><li><p>JDK8之前接口中只能是<strong>抽象方法</strong>和<strong>常量</strong>，没有其他成分了。</p></li><li><p><strong>接口不能实例化</strong>。</p></li><li><p>接口中的成员都是<strong>public修饰</strong>的，写不写都是，因为规范的目的是为了公开化。</p></li></ul><hr><h4 id="7-2接口的基本使用：被实现"><a href="#7-2接口的基本使用：被实现" class="headerlink" title="7.2接口的基本使用：被实现"></a>7.2接口的基本使用：被实现</h4><p><strong>接口的用法</strong>：</p><ul><li><p>接口是用来被类实现（<strong>implements</strong>）的，<strong>实现接口的类称为实现类</strong>。实现类可以理解成所谓的<strong>子类</strong>。(接口也具有继承关系)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 class 实现类 implements 接口<span class="number">1</span>, 接口<span class="number">2</span>, 接口<span class="number">3</span> , ... &#123;</span><br><span class="line">&#125;</span><br><span class="line">实现的关键字：implements</span><br></pre></td></tr></table></figure></li><li><p>从上面可以看出，接口可以被类单实现，也可以被类多实现。</p></li></ul><p><strong>接口实现的注意事项：</strong></p><ul><li><strong>一个类实现接口，必须重写完全部接口的全部抽象方法，否则这个类需要定义成抽象类。</strong></li></ul><hr><h4 id="7-3接口与接口的关系：多继承"><a href="#7-3接口与接口的关系：多继承" class="headerlink" title="7.3接口与接口的关系：多继承"></a>7.3接口与接口的关系：多继承</h4><p><strong>基本小结</strong></p><ul><li><p>类和类的关系：单继承。</p></li><li><p>类和接口的关系：多实现。</p></li><li><p>接口和接口的关系：多继承，一个接口可以同时继承多个接口。</p></li></ul><p><strong>接口多继承的作用</strong></p><ul><li>规范合并，整合多个接口为同一个接口，便于子类实现。</li></ul><hr><h4 id="7-4JDK8开始接口新增方法"><a href="#7-4JDK8开始接口新增方法" class="headerlink" title="7.4JDK8开始接口新增方法"></a>7.4JDK8开始接口新增方法</h4><p><strong>第一种：默认方法</strong>  (实例方法)</p><ul><li><p>类似之前写的普通实例方法：<strong>必须用default修饰</strong></p></li><li><p>默认会public修饰。需要用接口的实现类的对象来调用</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(默认<span class="keyword">public</span>) <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123; </span><br><span class="line">System.out.println(<span class="string">&quot;--开始跑--&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">等同于普通实例方法，但是在接口里面必须用<span class="keyword">default</span>修饰，风格~~</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123; </span><br><span class="line">System.out.println(<span class="string">&quot;--开始跑--&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第二种：静态方法</strong></p><ul><li>默认会public修饰，<strong>必须static修饰。</strong></li></ul><p><strong>注意：接静态方法必须用本身的接口名来调用</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(默认<span class="keyword">public</span>) <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">inAddr</span><span class="params">()</span>&#123;  </span><br><span class="line">System.out.println(<span class="string">&quot;我们都在黑马培训中心快乐的学习Java!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第三种：私有方法</strong></p><ul><li><p>就是私有的实例方法:，<strong>必须使用private修饰</strong>，从<strong>JDK 1.9才开始有的</strong>。</p></li><li><p>只能在<strong>本类中被其他的默认方法</strong>或者<strong>私有方法</strong>访问。</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(默认<span class="keyword">public</span>) <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">()</span>&#123;    </span><br><span class="line">System.out.println(<span class="string">&quot;--准备--&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="7-5使用接口的注意事项"><a href="#7-5使用接口的注意事项" class="headerlink" title="7.5使用接口的注意事项"></a>7.5使用接口的注意事项</h4><p><strong>接口的注意事项</strong></p><ol><li>接口不能创建对象</li><li>一个类实现多个接口，多个接口中有同样的静态方法不冲突。</li><li>一个类继承了父类，同时又实现了接口，父类中和接口中有同名方法，默认用父类的。</li><li>一个类实现了多个接口，多个接口中存在同名的默认方法，不冲突，这个类重写该方法即可。</li><li>一个接口继承多个接口，是没有问题的，如果多个接口中存在规范冲突则不能多继承。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> java,面向对象进阶,包,权限修饰符,final,常量,枚举,抽象类,接口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>day10 - static、继承、单例、代码块</title>
      <link href="/post/b149836c.html"/>
      <url>/post/b149836c.html</url>
      
        <content type="html"><![CDATA[<h3 id="day11-面向对象进阶"><a href="#day11-面向对象进阶" class="headerlink" title="day11.面向对象进阶"></a>day11.面向对象进阶</h3><h3 id="1-静态关键字：static"><a href="#1-静态关键字：static" class="headerlink" title="1.静态关键字：static"></a>1.静态关键字：static</h3><h4 id="1-1static的作用、修饰成员变量的用法"><a href="#1-1static的作用、修饰成员变量的用法" class="headerlink" title="1.1static的作用、修饰成员变量的用法"></a>1.1static的作用、修饰成员变量的用法</h4><p><strong>static关键字的作用</strong></p><ul><li><p>static是静态的意思，可以修饰成员变量和成员方法。</p></li><li><p>static修饰成员变量表示该成员变量只在内存中只存储一份，可以被共享访问、修改。</p></li></ul><p><strong>成员变量可以分为2类</strong></p><ul><li><p>静态成员变量（有static修饰，属于类，内存中加载一次）: 常表示如在线人数信息、等需要被共享的信息，可以被共享访问。</p></li><li><p>实例成员变量（无static修饰，存在于每个对象中）：常表示姓名name、年龄age、等属于每个对象的信息。</p></li></ul><h4 id="1-2static修饰成员变量的内存原理"><a href="#1-2static修饰成员变量的内存原理" class="headerlink" title="1.2static修饰成员变量的内存原理"></a>1.2static修饰成员变量的内存原理</h4><h4 id="1-3static修饰成员方法的基本用法"><a href="#1-3static修饰成员方法的基本用法" class="headerlink" title="1.3static修饰成员方法的基本用法"></a>1.3static修饰成员方法的基本用法</h4><p><strong>成员方法的分类：</strong></p><ul><li><p>静态成员方法（有static修饰，属于类），建议用类名访问，也可以用对象访问。</p><p><strong>类名.静态成员方法。</strong></p><p><strong>对象.静态成员方法。（不推荐）</strong></p></li><li><p>实例成员方法（无static修饰，属于对象），只能用对象触发访问。</p><p><strong>对象.实例成员方法。</strong></p></li></ul><p><strong>使用场景</strong></p><ul><li><p>表示对象自己的行为的，且方法中需要访问实例成员的，则该方法必须申明成实例方法。</p></li><li><p>如果该方法是以执行一个共用功能为目的，则可以申明成静态方法。</p></li></ul><p><strong>定义员工类的实例</strong></p><p>需求：请完成一个标准实体类的设计，并提供如下要求实现。</p><p>①：某公司的员工信息系统中，需要定义一个公司的员工类Employee，包含如下信息（name, age , 所在部门名称dept ） , 定义一个静态的成员变量company记录公司的名称。</p><p>②：需要在Employee类中定义一个方法showInfos()，用于输出当前员工对象的信息。如name, age ，dept 以及公司名称company的信息。</p><p>③：需要在Employee类中定义定义一个通用的静态方法compareByAge，用于传输两个员工对象的年龄进入，并返回比较较大的年龄，例如：2个人中的最大年龄是:45岁。</p><h4 id="1-4static修饰成员方法的内存原理"><a href="#1-4static修饰成员方法的内存原理" class="headerlink" title="1.4static修饰成员方法的内存原理"></a>1.4static修饰成员方法的内存原理</h4><h4 id="1-5static实际应用案例：设计工具类"><a href="#1-5static实际应用案例：设计工具类" class="headerlink" title="1.5static实际应用案例：设计工具类"></a>1.5static实际应用案例：设计工具类</h4><p><strong>工具类：</strong></p><ul><li>工具类中定义的都是一些静态方法，每个方法都是以完成一个共用的功能为目的。</li></ul><p><strong>现状问题分析：</strong></p><ul><li>如果登录和注册等多处地方都存在验证码逻辑，就会导致同一个功能多处开发，会出现代码重复度过高。</li></ul><p><strong>工具类的好处</strong></p><ul><li>一是调用方便，二是提高了代码复用（一次编写，处处可用）</li></ul><p><strong>为什么工具类中的方法不用实例方法做？</strong></p><ul><li>实例方法需要创建对象调用，此时用对象只是为了调用方法，这样只会浪费内存。</li></ul><p><strong>工具类的定义注意</strong></p><ul><li><p>建议将<strong>工具类的构造器进行私有，工具类无需创建对象</strong>。</p></li><li><p>里面都是静态方法，直接用类名访问即可。</p></li></ul><h4 id="1-6static的注意事项总结-面试热点"><a href="#1-6static的注意事项总结-面试热点" class="headerlink" title="1.6static的注意事项总结[面试热点]"></a>1.6static的注意事项总结[面试热点]</h4><p><strong>static访问注意实现：</strong></p><ul><li><p>静态方法只能访问静态的成员，不可以直接访问实例成员。</p></li><li><p>实例方法可以访问静态的成员，也可以访问实例成员。</p></li><li><p>静态方法中是不可以出现this关键字的。</p></li></ul><hr><hr><h3 id="2-static应用知识：代码块"><a href="#2-static应用知识：代码块" class="headerlink" title="2.static应用知识：代码块"></a>2.static应用知识：代码块</h3><h4 id="2-1代码块的分类、作用"><a href="#2-1代码块的分类、作用" class="headerlink" title="2.1代码块的分类、作用"></a>2.1代码块的分类、作用</h4><p><strong>代码块概述</strong></p><ul><li><p>代码块是类的5大成分之一（成员变量、构造器，方法，代码块，内部类），定义在类中方法外。</p></li><li><p>在Java类下，使用 { } 括起来的代码被称为代码块 。</p></li></ul><p><strong>代码块分为</strong></p><ul><li><p><strong>静态代码块</strong>:</p><ul><li><strong>格式</strong>：static{}</li><li><strong>特点</strong>：需要通过static关键字修饰，随着类的加载而加载，并且自动触发、只执行一次</li><li><strong>使用场景</strong>：在类加载的时候做一些静态数据初始化的操作，以便后续使用。</li></ul></li><li><p><strong>构造代码块</strong>（<strong>了解，用的少</strong>）：</p><ul><li><strong>格式</strong>：{}</li><li><strong>特点</strong>：每次创建对象，调用构造器执行时，都会执行该代码块中的代码，并且在构造器执行前执行</li><li><strong>使用场景</strong>：初始化实例资源。</li></ul></li></ul><h4 id="2-2静态代码块的应用案例"><a href="#2-2静态代码块的应用案例" class="headerlink" title="2.2静态代码块的应用案例"></a>2.2静态代码块的应用案例</h4><p><strong>斗地主游戏</strong></p><p><strong>需求：</strong><br> 在启动游戏房间的时候，应该提前准备好54张牌，后续才可以直接使用这些牌数据。</p><p><strong>分析：</strong></p><p>①该房间只需要一副牌。</p><p>②定义一个静态的ArrayList集合存储54张牌对象，静态的集合只会加载一份。</p><p>③在启动游戏房间前，应该将54张牌初始化好</p><p>④当系统启动的同时需要准备好54张牌数据，此时可以用静态代码块完成。</p><hr><hr><h3 id="3-static应用知识：单例"><a href="#3-static应用知识：单例" class="headerlink" title="3.static应用知识：单例"></a>3.static应用知识：单例</h3><h4 id="3-1设计模式、单例模式介绍、饿汉单例模式"><a href="#3-1设计模式、单例模式介绍、饿汉单例模式" class="headerlink" title="3.1设计模式、单例模式介绍、饿汉单例模式"></a>3.1设计模式、单例模式介绍、饿汉单例模式</h4><p><strong>什么是设计模式（Design pattern）</strong></p><ul><li><p>开发中经常遇到一些问题，一个问题通常有n种解法的，但其中肯定有一种解法是最优的，这个最优的解法被人总结出来了，称之为设计模式。</p></li><li><p>设计模式有20多种，对应20多种软件开发中会遇到的问题，学设计模式主要是学2点：</p><ul><li>第一：这种模式用来解决什么问题。</li><li>第二：遇到这种问题了，该模式是怎么写的，他是如何解决这个问题的。</li></ul></li></ul><p><strong>单例模式</strong></p><ul><li><p>可以保证系统中，应用该模式的这个类永远只有一个实例，即一个类永远只能创建一个对象。</p></li><li><p>例如任务管理器对象我们只需要一个就可以解决问题了，这样可以节省内存空间。</p></li></ul><p><strong>单例的实现方式很多</strong></p><ul><li><p>饿汉单例模式。</p></li><li><p>懒汉单例模式。</p></li><li><p>…</p></li></ul><p><strong>饿汉单例设计模式</strong></p><ul><li>在用类获取对象的时候，对象已经提前为你创建好了。</li></ul><p><strong>设计步骤：</strong></p><ul><li><p>定义一个类，把构造器私有。</p></li><li><p>定义一个静态变量存储一个对象。</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** a、定义一个单例类 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleInstance</span> &#123;    </span><br><span class="line"><span class="comment">/** c.定义一个静态变量存储一个对象即可 :属于类，与类一起加载一次 */</span>  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">SingleInstance</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleInstance</span> ();    </span><br><span class="line"></span><br><span class="line"><span class="comment">/** b.单例必须私有构造器*/</span>   </span><br><span class="line"><span class="keyword">private</span> <span class="title function_">SingleInstance</span> <span class="params">()</span>&#123;        </span><br><span class="line">System.out.println(<span class="string">&quot;创建了一个对象&quot;</span>);   </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2懒汉单例模式"><a href="#3-2懒汉单例模式" class="headerlink" title="3.2懒汉单例模式"></a>3.2懒汉单例模式</h4><p><strong>懒汉单例设计模式</strong></p><ul><li>在真正需要该对象的时候，才去创建一个对象(延迟加载对象)。</li></ul><p><strong>设计步骤：</strong></p><ul><li><p>定义一个类，把构造器私有。</p></li><li><p>定义一个静态变量存储一个对象。</p></li><li><p>提供一个返回单例对象的方法</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 定义一个单例类 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleInstance</span>&#123;</span><br><span class="line"><span class="comment">/** 定义一个静态变量存储一个对象即可 :属于类，与类一起加载一次 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> SingleInstance instance ; <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 单例必须私有构造器*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">SingleInstance</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 必须提供一个方法返回一个单例对象  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> SingleInstance <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> ...;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><hr><h3 id="4-面向对象三大特征之二：继承"><a href="#4-面向对象三大特征之二：继承" class="headerlink" title="4.面向对象三大特征之二：继承"></a>4.面向对象三大特征之二：继承</h3><h4 id="4-1继承概述、使用继承的好处"><a href="#4-1继承概述、使用继承的好处" class="headerlink" title="4.1继承概述、使用继承的好处"></a>4.1继承概述、使用继承的好处</h4><p><strong>什么是继承？</strong></p><ul><li>Java中提供一个关键字extends，用这个关键字，我们可以让一个类和另一个类建立起父子关系。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">People</span> &#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>Student称为子类（派生类），People称为父类(基类 或超类)。</li></ul><p><strong>使用继承的好处</strong></p><ul><li>当子类继承父类后，就可以直接使用父类公共的属性和方法了。因此，用好这个技术可以很好的我们提高代码的复用性</li></ul><p><strong>继承的格式</strong></p><ul><li><strong>子类 extends父类</strong></li></ul><p><strong>继承后子类的特点</strong></p><ul><li><p><strong>子类 继承父类，子类可以得到父类的属性和行为，子类可以使用。</strong></p></li><li><p><strong>Java中子类更强大</strong></p></li></ul><h4 id="4-2继承的设计规范、内存运行原理"><a href="#4-2继承的设计规范、内存运行原理" class="headerlink" title="4.2继承的设计规范、内存运行原理"></a>4.2继承的设计规范、内存运行原理</h4><p><strong>继承设计规范：</strong></p><ul><li>子类们相同特征（共性属性，共性方法）放在父类中定义</li><li>子类独有的的属性和行为应该定义在子类自己里面。</li></ul><p><strong>为什么？</strong> </p><ul><li>如果子类的独有属性、行为定义在父类中，会导致其它子类也会得到这些属性和行为，这不符合面向对象逻辑。</li></ul><h4 id="4-3继承的特点"><a href="#4-3继承的特点" class="headerlink" title="4.3继承的特点"></a>4.3继承的特点</h4><p><strong>继承的特点</strong></p><p>​①子类可以继承父类的属性和行为，但是子类不能继承父类的构造器。</p><p>​②Java是单继承模式：一个类只能继承一个直接父类。</p><p>​③Java不支持多继承、但是支持多层继承。</p><p>​④Java中所有的类都是Object类的子类。</p><p><strong>1、子类是否可以继承父类的构造器？</strong></p><ul><li>不可以的，子类有自己的构造器，父类构造器用于初始化父类对象。</li></ul><p><strong>2、子类是否可以继承父类的私有成员？</strong></p><ul><li>可以的，只是不能直接访问。</li></ul><p><strong>3、子类是否可以继承父类的静态成员？</strong></p><ul><li><p>有争议的知识点。</p></li><li><p>子类可以直接使用父类的静态成员（共享）</p></li><li><p>但个人认为：子类不能继承父类的静态成员。（共享并非继承）</p></li></ul><p><strong>注意：Java只支持单继承，不支持多继承。</strong></p><ul><li><strong>单继承：子类只能继承一个直接父类</strong></li><li><strong>不支持多继承：子类不能同时继承多个父类</strong></li></ul><p><strong>Java支持多层继承</strong></p><ul><li>子类 A 继承父类 B ，父类B 可以 继承父类 C</li></ul><p><strong>Object特点：</strong></p><ul><li>Java中所有类，要么直接继承了Object , 要么默认继承了Object , 要么间接继承了Object, Object是祖宗类。</li></ul><h4 id="4-4继承后：成员变量、成员方法的访问特点"><a href="#4-4继承后：成员变量、成员方法的访问特点" class="headerlink" title="4.4继承后：成员变量、成员方法的访问特点"></a>4.4继承后：成员变量、成员方法的访问特点</h4><p><strong>在子类方法中访问成员（成员变量、成员方法）满足：就近原则</strong></p><ul><li><p>先子类局部范围找</p></li><li><p>然后子类成员范围找</p></li><li><p>然后父类成员范围找，如果父类范围还没有找到则报错。</p></li></ul><p><strong>如果子父类中，出现了重名的成员，会优先使用子类的，此时如果一定要在子类中使用父类的怎么办？</strong></p><ul><li><p>可以通过super关键字，指定访问父类的成员。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">格式：<span class="built_in">super</span>.父类成员变量/父类成员方法</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-5继承后：方法重写"><a href="#4-5继承后：方法重写" class="headerlink" title="4.5继承后：方法重写"></a>4.5继承后：方法重写</h4><p><strong>什么是方法重写？</strong></p><ul><li>在继承体系中，子类出现了和父类中一模一样的方法声明，我们就称子类这个方法是重写的方法。</li></ul><p><strong>方法重写的应用场景</strong></p><ul><li><p>当子类需要父类的功能，但父类的该功能不完全满足自己的需求时。</p></li><li><p>子类可以重写父类中的方法。</p></li></ul><p><strong>案例演示：</strong></p><ul><li><p>旧手机的功能只能是基本的打电话，发信息</p></li><li><p>新手机的功能需要能够：基本的打电话下支持视频通话。基本的发信息下支持发送语音和图片。</p></li></ul><p><strong>@Override重写注解</strong></p><ul><li><p>@Override是放在重写后的方法上，作为重写是否正确的校验注解。</p></li><li><p>加上该注解后如果重写错误，编译阶段会出现错误提示。</p></li><li><p>建议重写方法都加@Override注解，代码安全，优雅！</p></li></ul><p><strong>方法重写注意事项和要求</strong></p><ul><li><p>重写方法的名称、形参列表必须与被重写方法的名称和参数列表一致。</p></li><li><p>私有方法不能被重写。</p></li><li><p>子类重写父类方法时，访问权限必须大于或者等于父类 </p><p>（暂时了解 ：缺省 &lt; protected &lt; public）</p></li><li><p>子类不能重写父类的静态方法，如果重写会报错的。</p></li></ul><h4 id="4-6继承后：子类构造器的特点"><a href="#4-6继承后：子类构造器的特点" class="headerlink" title="4.6继承后：子类构造器的特点"></a>4.6继承后：子类构造器的特点</h4><p><strong>子类继承父类后构造器的特点：</strong></p><ul><li>子类中所有的构造器默认都会先访问父类中无参的构造器，再执行自己。</li></ul><p><strong>为什么？</strong></p><ul><li><p>子类在初始化的时候，有可能会使用到父类中的数据，如果父类没有完成初始化，子类将无法使用父类的数据。</p></li><li><p>子类初始化之前，一定要调用父类构造器先完成父类数据空间的初始化。</p></li></ul><p><strong>怎么调用父类构造器的？</strong></p><ul><li>子类构造器的第一行语句默认都是：<strong>super()，不写也存在。</strong></li></ul><h4 id="4-7继承后：子类构造器访问父类有参构造器"><a href="#4-7继承后：子类构造器访问父类有参构造器" class="headerlink" title="4.7继承后：子类构造器访问父类有参构造器"></a>4.7继承后：子类构造器访问父类有参构造器</h4><p><strong>super调用父类有参数构造器的作用：</strong></p><ul><li>初始化继承自父类的数据。</li></ul><p><strong>如果父类中没有无参数构造器，只有有参构造器，会出现什么现象呢？</strong></p><ul><li>会报错。因为子类默认是调用父类无参构造器的。</li></ul><p><strong>如何解决？</strong></p><ul><li>子类构造器中可以通过书写 super(…)，手动调用父类的有参数构造器</li></ul><h4 id="4-8this、super使用总结"><a href="#4-8this、super使用总结" class="headerlink" title="4.8this、super使用总结"></a>4.8this、super使用总结</h4><p><strong>this和super详情</strong></p><ul><li><strong>this</strong>：代表本类对象的引用；<strong>super</strong>：代表父类存储空间的标识。</li></ul><table><thead><tr><th align="center">关键字</th><th align="center"><strong>访问成员变量</strong></th><th align="center"><strong>访问成员方法</strong></th><th align="center">访问构造方法</th></tr></thead><tbody><tr><td align="center"><strong>this</strong></td><td align="center">this.成员变量  访问本类成员变量</td><td align="center">this.成员方法(…)  访问本类成员方法</td><td align="center">this(…)  访问本类构器</td></tr><tr><td align="center"><strong>super</strong></td><td align="center">super.成员变量  访问父类成员变量</td><td align="center">super.成员方法(…)  访问父类成员方法</td><td align="center">super(…)  访问父类构造器</td></tr></tbody></table><p><strong>实际上，在以上的总结中，唯独只有this调用本类其他构造器我们是没有接触过的。</strong></p><p><strong>案例需求：</strong></p><ul><li><p>在学员信息登记系统中，后台创建对象封装数据的时候如果用户没有输入学校，则默认使用“黑马培训中心”。</p></li><li><p>如果用户输入了学校则使用用户输入的学校信息。</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;        </span><br><span class="line"><span class="keyword">private</span> String schoolName;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span>&#123;</span><br><span class="line">          <span class="built_in">this</span>(name , “黑马培训中心”);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name , String schoolName )</span>&#123;</span><br><span class="line">          <span class="built_in">this</span>.name = name;</span><br><span class="line">          <span class="built_in">this</span>.schoolName = schoolName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>this(…)和super(…)使用注意点：</strong></p><ul><li><p>子类通过 this (…）去调用本类的其他构造器，本类其他构造器会通过 super 去手动调用父类的构造器，最终还是会调用父类构造器的。</p></li><li><p>注意：this(…) super(…) 都只能放在构造器的第一行，所以二者不能共存在同一个构造器中。</p></li></ul><p>继承后的真实类型</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">instanceof</span></span><br><span class="line"></span><br><span class="line"> <span class="title function_">if</span> <span class="params">(u <span class="keyword">instanceof</span> Customer)</span>&#123;  <span class="comment">//u:父类对象  Customer：子类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> java,面向对象进阶,static，单例，代码块，继承 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>day09 - API</title>
      <link href="/post/bb5ff40.html"/>
      <url>/post/bb5ff40.html</url>
      
        <content type="html"><![CDATA[<h1 id="ATM系统功能实战"><a href="#ATM系统功能实战" class="headerlink" title="ATM系统功能实战"></a>ATM系统功能实战</h1><h2 id="系统准备、首页设计"><a href="#系统准备、首页设计" class="headerlink" title="系统准备、首页设计"></a>系统准备、首页设计</h2><p><strong>系统准备内容分析：</strong></p><p>①每个用户的账户信息都是一个对象，需要提供账户类。</p><p>②需要准备一个容器，用于存储系统全部账户对象信息。</p><p>③首页只需要包含：登录和注册2个功能。</p><p><strong>实现步骤：</strong></p><p>①定义账户类，用于后期创建账户对象封装用户的账户信息。</p><p>②账户类中的信息至少需要包含（卡号、姓名、密码、余额、取现额度）</p><p>③需要准备一个ArrayList的集合，用于存储系统用户的账户对象。</p><p>④定义一个系统启动类ATMSystem需要展示欢迎页包含2个功能：开户功能、登录账户。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String cardId;  <span class="comment">// 卡号</span></span><br><span class="line">    <span class="keyword">private</span> String userName;  <span class="comment">// 客户名称</span></span><br><span class="line">    <span class="keyword">private</span> String passWord;  <span class="comment">// 密码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> money;  <span class="comment">// 余额</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> quotaMoney;  <span class="comment">// 当次取现限额</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">(String cardId, String userName, String passWord, <span class="type">double</span> quotaMoney)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cardId = cardId;</span><br><span class="line">        <span class="built_in">this</span>.userName = userName;</span><br><span class="line">        <span class="built_in">this</span>.passWord = passWord;</span><br><span class="line">        <span class="built_in">this</span>.quotaMoney = quotaMoney;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCardId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cardId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCardId</span><span class="params">(String cardId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cardId = cardId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUserName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserName</span><span class="params">(String userName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPassWord</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> passWord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPassWord</span><span class="params">(String passWord)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.passWord = passWord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getMoney</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMoney</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getQuotaMoney</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> quotaMoney;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setQuotaMoney</span><span class="params">(<span class="type">double</span> quotaMoney)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.quotaMoney = quotaMoney;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ATMSystem</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、准备系统需要的容器对象，用于存储账户对象</span></span><br><span class="line">        ArrayList&lt;Account&gt; accounts = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、准备系统的首页：登录 开户</span></span><br><span class="line">        showMain(accounts);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showMain</span><span class="params">(ArrayList&lt;Account&gt; accounts)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=============欢迎进入首页=================&quot;</span>);</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请您输入您想做的操作：&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;1、登录&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;2、开户&quot;</span>);</span><br><span class="line">            System.out.print(<span class="string">&quot;您可以输入命令了：&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">command</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">            <span class="keyword">switch</span> (command) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    <span class="comment">// 登录</span></span><br><span class="line">                    login(accounts, sc);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    <span class="comment">// 开户</span></span><br><span class="line">                    register(accounts, sc);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;您当前输入的操作命令不被支持！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用户开户功能实现"><a href="#用户开户功能实现" class="headerlink" title="用户开户功能实现"></a>用户开户功能实现</h2><p>开户功能其实就是就是往系统的集合容器中存入一个新的账户对象的信息。</p><p><strong>开户功能实现步骤</strong></p><p>①定义方法完成开户：</p><p>②键盘录入姓名、密码、确认密码（需保证两次密码一致）</p><p>③生成账户卡号，卡号必须由系统自动生成8位数字（必须保证卡号的唯一）</p><p>④创建Account账户类对象用于封装账户信息（姓名、密码、卡号）</p><p>⑤把Account账户类对象存入到集合accounts中去。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户开户功能</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> accounts 账户的集合对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(ArrayList&lt;Account&gt; accounts, Scanner sc)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;===============用户开户功能==============&quot;</span>);</span><br><span class="line">    <span class="comment">// 2、键盘录入 姓名 密码 确认密码</span></span><br><span class="line">    System.out.println(<span class="string">&quot;请您输入开户名称：&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> sc.next();</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请您输入开户密码：&quot;</span>);</span><br><span class="line">        password = sc.next();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;请您输入确认密码：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">okPassword</span> <span class="operator">=</span> sc.next();</span><br><span class="line">        <span class="comment">// 判断两次输入的密码是否一致</span></span><br><span class="line">        <span class="keyword">if</span>(okPassword.equals(password))&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;两次密码必须一致~~~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;请您输入当次限额：&quot;</span>);</span><br><span class="line">    <span class="type">double</span> <span class="variable">quotaMoney</span> <span class="operator">=</span> sc.nextDouble();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、生成账户的卡号，卡号是8位，而且不能与其他账户卡号重复。</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">cardId</span> <span class="operator">=</span> createCardId(accounts);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4、创建一个账户对象封装账户的信息</span></span><br><span class="line">    <span class="comment">//   public Account(String cardId, String userName, String passWord, double money, double quotaMoney)</span></span><br><span class="line">    <span class="type">Account</span> <span class="variable">account</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span>(cardId, name, password,quotaMoney);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5、把账户对象添加到集合中去</span></span><br><span class="line">    accounts.add(account);</span><br><span class="line">    System.out.println(<span class="string">&quot;恭喜您，您开户成功，您的卡号是：&quot;</span> + account.getCardId() +<span class="string">&quot;。请您妥善保管&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">createCardId</span><span class="params">(ArrayList&lt;Account&gt; accounts)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 生成8位随机的数字代表卡号</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">cardId</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            cardId += r.nextInt(<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断卡号是否重复了</span></span><br><span class="line">        <span class="type">Account</span> <span class="variable">acc</span> <span class="operator">=</span> getAccountByCardId(cardId, accounts);</span><br><span class="line">        <span class="keyword">if</span>(acc == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 说明当前卡号没有重复</span></span><br><span class="line">            <span class="keyword">return</span> cardId;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Account <span class="title function_">getAccountByCardId</span><span class="params">(String cardId , ArrayList&lt;Account&gt; accounts)</span>&#123;</span><br><span class="line">    <span class="comment">// 根据卡号查询账户对象</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; accounts.size(); i++) &#123;</span><br><span class="line">        <span class="type">Account</span> <span class="variable">acc</span> <span class="operator">=</span> accounts.get(i);</span><br><span class="line">        <span class="keyword">if</span>(acc.getCardId().equals(cardId))&#123;</span><br><span class="line">            <span class="keyword">return</span> acc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 查无此账户，说明卡号没有重复了！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用户登录功能实现"><a href="#用户登录功能实现" class="headerlink" title="用户登录功能实现"></a>用户登录功能实现</h2><p><strong>分析</strong></p><p>①定义方法：</p><p>②让用户键盘录入卡号，根据卡号查询账户对象。</p><p>③如果没有找到了账户对象，说明卡号不存在，提示继续输入卡号。</p><p>④如果找到了账户对象，说明卡号存在，继续输入密码。</p><p>⑤如果密码不正确，提示继续输入密码</p><p>⑥如果密码正确，提示登陆成功！！</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 完成用户登录</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> accounts</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(ArrayList&lt;Account&gt; accounts, Scanner sc)</span> &#123;</span><br><span class="line">    <span class="comment">// 必须系统中存在账户才可以登录</span></span><br><span class="line">    <span class="keyword">if</span>(accounts.size() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 没有任何账户</span></span><br><span class="line">        System.out.println(<span class="string">&quot;当前系统中无任何账户，您需要先注册！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 直接结束方法的执行！</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、让用户键盘录入卡号，</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请您输入登录的卡号：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">cardId</span> <span class="operator">=</span> sc.next();</span><br><span class="line">        <span class="comment">// 根据卡号查询账户对象。</span></span><br><span class="line">        <span class="type">Account</span> <span class="variable">acc</span> <span class="operator">=</span> getAccountByCardId(cardId , accounts);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、判断账户对象是否存在，存在说明卡号没问题</span></span><br><span class="line">        <span class="keyword">if</span>(acc != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 4、让用户继续输入密码</span></span><br><span class="line">                System.out.println(<span class="string">&quot;请您输入登录的密码：&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> sc.next();</span><br><span class="line">                <span class="comment">// 5、判断密码是否正确</span></span><br><span class="line">                <span class="keyword">if</span>(acc.getPassWord().equals(password))&#123;</span><br><span class="line">                    <span class="comment">// 密码正确，登录成功</span></span><br><span class="line">                    <span class="comment">// 展示系统登录后的操作界面（下节课继续完成的功能！！）</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;恭喜您，&quot;</span> + acc.getUserName() +<span class="string">&quot;先生/女士成功进入系统，您的卡号是：&quot;</span> + acc.getCardId());</span><br><span class="line">                    <span class="comment">// 展示操作页面</span></span><br><span class="line">                    showUserCommand(sc, acc , accounts);</span><br><span class="line">                    <span class="keyword">return</span>; <span class="comment">// 继续结束登录方法</span></span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;您的密码有误，请确认！&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;对不起，不存在该卡号的账户！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用户操作页设计、查询账户、退出账户功能实现"><a href="#用户操作页设计、查询账户、退出账户功能实现" class="headerlink" title="用户操作页设计、查询账户、退出账户功能实现"></a>用户操作页设计、查询账户、退出账户功能实现</h2><p>①用户登录成功后，需要进入用户操作页，退出账户是需要回到首页的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showUserCommand</span><span class="params">(Scanner sc, Account acc , ArrayList&lt;Account&gt; accounts)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;==================用户操作界面===================&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;1、查询账户&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;2、存款&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;3、取款&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;4、转账&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;5、修改密码&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;6、退出&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;7、注销账户&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;请您输入操作命令：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">command</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="keyword">switch</span> (command) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    <span class="comment">// 查询账户</span></span><br><span class="line">                    showAccount(acc);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    <span class="comment">// 存款</span></span><br><span class="line">                    depositMoney(acc, sc);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                    <span class="comment">// 取款</span></span><br><span class="line">                    drawMoney(acc,sc);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                    <span class="comment">// 转账</span></span><br><span class="line">                    transferMoney(accounts, acc , sc);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                    <span class="comment">// 修改密码</span></span><br><span class="line">                    updatePassWord(acc,sc);</span><br><span class="line">                    <span class="keyword">return</span>; <span class="comment">// 结束当前操作的方法</span></span><br><span class="line">                <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                    <span class="comment">// 退出</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;欢迎下次光临！！&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span>; <span class="comment">// 结束当前操作的方法！</span></span><br><span class="line">                <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">                    <span class="comment">// 注销账户</span></span><br><span class="line">                    <span class="comment">// 从当前集合中抹掉当前账户对象即可</span></span><br><span class="line">                    accounts.remove(acc);</span><br><span class="line">                    System.out.println(<span class="string">&quot;销户成功了！！&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span>;<span class="comment">// 结束当前操作的方法！</span></span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;您的命令输入有误~~~&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>②查询就是直接展示当前登录成功的账户对象的信息。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showAccount</span><span class="params">(Account acc)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;==================当前账户详情===================&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;卡号：&quot;</span> + acc.getCardId());</span><br><span class="line">    System.out.println(<span class="string">&quot;姓名：&quot;</span> + acc.getUserName());</span><br><span class="line">    System.out.println(<span class="string">&quot;余额：&quot;</span> + acc.getMoney());</span><br><span class="line">    System.out.println(<span class="string">&quot;当次限额：&quot;</span> + acc.getQuotaMoney());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用户存款功能实现"><a href="#用户存款功能实现" class="headerlink" title="用户存款功能实现"></a>用户存款功能实现</h2><p>①存款就是拿到当前账户对象。</p><p>②然后让用户输入存款的金额。</p><p>③调用账户对象的setMoney方法将账户余额修改成存钱后的余额。</p><p>④存钱后需要查询一下账户信息，确认是否存钱成功了！</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   存钱的</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> acc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">depositMoney</span><span class="params">(Account acc, Scanner sc)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;==================存钱操作===================&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;请您输入存款的金额：&quot;</span>);</span><br><span class="line">    <span class="type">double</span> <span class="variable">money</span> <span class="operator">=</span> sc.nextDouble();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接把金额修改到账户对象的money属性中去</span></span><br><span class="line">    acc.setMoney(acc.getMoney() + money);</span><br><span class="line">    System.out.println(<span class="string">&quot;存款完成！！&quot;</span>);</span><br><span class="line">    showAccount(acc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用户取款功能实现"><a href="#用户取款功能实现" class="headerlink" title="用户取款功能实现"></a>用户取款功能实现</h2><p><strong>取款分析</strong></p><p>①取款需要先判断账户是否有钱。</p><p>②有钱则拿到自己账户对象。</p><p>③然后让用户输入取款金额</p><p>④判断取款金额是否超过了当次限额，以及余额是否足够</p><p>⑤满足要求则调用账户对象的setMoney方法完成金额的修改。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   取款</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> acc</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">drawMoney</span><span class="params">(Account acc, Scanner sc)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;==================取款操作===================&quot;</span>);</span><br><span class="line">    <span class="comment">// 1、判断它的账户是否足够100元</span></span><br><span class="line">    <span class="keyword">if</span>(acc.getMoney() &gt;= <span class="number">100</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请您输入取款的金额：&quot;</span>);</span><br><span class="line">            <span class="type">double</span> <span class="variable">money</span> <span class="operator">=</span> sc.nextDouble();</span><br><span class="line">            <span class="comment">// 2、判断这个金额有没有超过当次限额</span></span><br><span class="line">            <span class="keyword">if</span>(money &gt; acc.getQuotaMoney())&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;您当次取款金额超过每次限额，不要取那么多，每次最多可以取：&quot;</span> + acc.getQuotaMoney());</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 3、判断当前余额是否足够你取钱</span></span><br><span class="line">                <span class="keyword">if</span>(acc.getMoney() &gt;= money)&#123;</span><br><span class="line">                    <span class="comment">// 够钱，可以取钱了</span></span><br><span class="line">                    acc.setMoney(acc.getMoney() - money);</span><br><span class="line">                    System.out.println(<span class="string">&quot;恭喜您，取钱&quot;</span> + money + <span class="string">&quot;成功了！当前账户还剩余：&quot;</span> + acc.getMoney());</span><br><span class="line">                    <span class="keyword">return</span>;<span class="comment">// 取钱后干掉取钱方法</span></span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;余额不足啊！&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;您自己的金额没有超过100元，就别取了~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用户转账功能实现"><a href="#用户转账功能实现" class="headerlink" title="用户转账功能实现"></a>用户转账功能实现</h2><p><strong>分析</strong></p><p>①转账功能需要判断系统中是否有2个账户对象及以上。</p><p>②同时还要判断自己账户是否有钱。</p><p>③接下来需要输入对方卡号，判断对方账户是否存在。</p><p>④对方账户存在还需要认证对方户主的姓氏。</p><p>⑤满足要求则可以把自己账户对象的金额修改到对方账户对象中去。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  转账功能</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> accounts</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> acc</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">transferMoney</span><span class="params">(ArrayList&lt;Account&gt; accounts, Account acc, Scanner sc)</span> &#123;</span><br><span class="line">    <span class="comment">// 1、判断系统中是否有2个账户及以上</span></span><br><span class="line">    <span class="keyword">if</span>(accounts.size() &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;对不起，系统中无其他账户，您不可以转账！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、判断自己的账户对象中是否有钱</span></span><br><span class="line">    <span class="keyword">if</span>(acc.getMoney() == <span class="number">0</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;对不起，您自己都没钱，就别转了~~&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、开始转账逻辑</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请您输入对方账户的卡号：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">cardId</span> <span class="operator">=</span> sc.next();</span><br><span class="line">        <span class="type">Account</span> <span class="variable">account</span> <span class="operator">=</span> getAccountByCardId(cardId , accounts);</span><br><span class="line">        <span class="comment">// 判断这个账户对象是否存在，存在说明对方卡号输入正确</span></span><br><span class="line">        <span class="keyword">if</span>(account != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 判断这个账户对象是否是当前登录的账户自己</span></span><br><span class="line">            <span class="keyword">if</span>(account.getCardId().equals(acc.getCardId()))&#123;</span><br><span class="line">                <span class="comment">// 正在给自己转账</span></span><br><span class="line">                System.out.println(<span class="string">&quot;您不可以为自己转账！&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 确认对方的姓氏</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;*&quot;</span> + account.getUserName().substring(<span class="number">1</span>);</span><br><span class="line">                System.out.print(<span class="string">&quot;请您确认【&quot;</span> + name + <span class="string">&quot;】的姓氏：&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">preName</span> <span class="operator">=</span> sc.next(); <span class="comment">// 王</span></span><br><span class="line">                <span class="comment">// 判断        黑马关之琳</span></span><br><span class="line">                <span class="keyword">if</span>(account.getUserName().startsWith(preName))&#123;</span><br><span class="line">                    <span class="comment">// 真正开始转账了</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;请您输入转账的金额：&quot;</span>);</span><br><span class="line">                    <span class="type">double</span> <span class="variable">money</span> <span class="operator">=</span> sc.nextDouble();</span><br><span class="line">                    <span class="comment">// 判断这个金额是否超过了自己的余额</span></span><br><span class="line">                    <span class="keyword">if</span>(money &gt; acc.getMoney() )&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;对不起，您要转账的金额太多，您最多可以转账多少：&quot;</span> + acc.getMoney());</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 真的可以转了</span></span><br><span class="line">                        acc.setMoney(acc.getMoney() - money);</span><br><span class="line">                        account.setMoney(account.getMoney() + money);</span><br><span class="line">                        System.out.println(<span class="string">&quot;恭喜您，转账成功了，已经为&quot;</span> + account.getUserName() +<span class="string">&quot;转账多少：&quot;</span> + money);</span><br><span class="line">                        showAccount(acc);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;对不起，您认证的信息有误~~~&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;对不起，您输入的转账卡号有问题！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用户密码修改、销户功能实现"><a href="#用户密码修改、销户功能实现" class="headerlink" title="用户密码修改、销户功能实现"></a>用户密码修改、销户功能实现</h2><p><strong>分析</strong></p><p>①修改密码就是把当前对象的密码属性使用set方法进行更新。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">updatePassWord</span><span class="params">(Account acc, Scanner sc)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;===========修改密码=======================&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请您输入正确的密码：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">okPassWord</span> <span class="operator">=</span> sc.next();</span><br><span class="line">        <span class="comment">// 判断密码是否正确</span></span><br><span class="line">        <span class="keyword">if</span>(acc.getPassWord().equals(okPassWord))&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 可以输入新密码</span></span><br><span class="line">                System.out.println(<span class="string">&quot;请您输入新的密码：&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">newPassWord</span> <span class="operator">=</span> sc.next();</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;请您输入确认密码：&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">okNewPassWord</span> <span class="operator">=</span> sc.next();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(newPassWord.equals(okNewPassWord)) &#123;</span><br><span class="line">                    <span class="comment">// 修改账户对象的密码为新密码</span></span><br><span class="line">                    acc.setPassWord(newPassWord);</span><br><span class="line">                    <span class="keyword">return</span>; <span class="comment">// 直接结束掉！！</span></span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;您两次输入的密码不一致~~&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前输入的密码不正确~~~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>②销户是从集合对象中删除当前对象，并回到首页。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">    <span class="comment">// 注销账户</span></span><br><span class="line">    <span class="comment">// 从当前集合中抹掉当前账户对象即可</span></span><br><span class="line">    accounts.remove(acc);</span><br><span class="line">    System.out.println(<span class="string">&quot;销户成功了！！&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;<span class="comment">// 结束当前操作的方法！</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> java,基础语法,ATM系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>day08 - API</title>
      <link href="/post/eaac7003.html"/>
      <url>/post/eaac7003.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-API"><a href="#1-API" class="headerlink" title="1.API"></a>1.API</h2><h3 id="1-1API概述"><a href="#1-1API概述" class="headerlink" title="1.1API概述"></a>1.1API概述</h3><ul><li><p>什么是API</p><p>​API (Application Programming Interface) ：应用程序编程接口</p></li><li><p>java中的API</p><p>​指的就是 JDK 中提供的各种功能的 Java类，这些类将底层的实现封装了起来，我们不需要关心这些类是如何实现的，只需要学习这些类如何使用即可，我们可以通过帮助文档来学习这些API如何使用。</p></li></ul><h3 id="1-2如何使用API帮助文档"><a href="#1-2如何使用API帮助文档" class="headerlink" title="1.2如何使用API帮助文档"></a>1.2如何使用API帮助文档</h3><ul><li><p>打开帮助文档</p></li><li><p>找到索引选项卡中的输入框</p></li><li><p>在输入框中输入Random</p></li><li><p>看类在哪个包下</p></li><li><p>看类的描述</p></li><li><p>看构造方法</p></li><li><p>看成员方法</p></li></ul><h2 id="2-String类"><a href="#2-String类" class="headerlink" title="2.String类"></a>2.String类</h2><h3 id="2-1String类概述"><a href="#2-1String类概述" class="headerlink" title="2.1String类概述"></a>2.1String类概述</h3><p>​String 类代表字符串，Java 程序中的所有字符串文字（例如“abc”）都被实现为此类的实例。也就是说，Java 程序中所有的双引号字符串，都是 String 类的对象。String 类在 java.lang 包下，所以使用的时候不需要导包！</p><h3 id="2-2String类的特点"><a href="#2-2String类的特点" class="headerlink" title="2.2String类的特点"></a>2.2String类的特点</h3><ul><li>字符串不可变，它们的值在创建后不能被更改</li><li>虽然 String 的值是不可变的，但是它们可以被共享</li><li>字符串效果上相当于字符数组( char[] )，但是底层原理是字节数组( byte[] )</li></ul><h3 id="2-3String类的构造方法"><a href="#2-3String类的构造方法" class="headerlink" title="2.3String类的构造方法"></a>2.3String类的构造方法</h3><ul><li><p>常用的构造方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public   String()</td><td>创建一个空白字符串对象，不含有任何内容</td></tr><tr><td>public   String(char[] chs)</td><td>根据字符数组的内容，来创建字符串对象</td></tr><tr><td>public   String(byte[] bys)</td><td>根据字节数组的内容，来创建字符串对象</td></tr><tr><td>String s &#x3D;   “abc”;</td><td>直接赋值的方式创建字符串对象，内容就是abc</td></tr></tbody></table></li><li><p>示例代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//public String()：创建一个空白字符串对象，不含有任何内容</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;s1:&quot;</span> + s1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//public String(char[] chs)：根据字符数组的内容，来创建字符串对象</span></span><br><span class="line">        <span class="type">char</span>[] chs = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(chs);</span><br><span class="line">        System.out.println(<span class="string">&quot;s2:&quot;</span> + s2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//public String(byte[] bys)：根据字节数组的内容，来创建字符串对象</span></span><br><span class="line">        <span class="type">byte</span>[] bys = &#123;<span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>&#125;;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bys);</span><br><span class="line">        System.out.println(<span class="string">&quot;s3:&quot;</span> + s3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//String s = “abc”;直接赋值的方式创建字符串对象，内容就是abc</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;s4:&quot;</span> + s4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-4创建字符串对象两种方式的区别"><a href="#2-4创建字符串对象两种方式的区别" class="headerlink" title="2.4创建字符串对象两种方式的区别"></a>2.4创建字符串对象两种方式的区别</h3><ul><li><p>直接赋值方式创建</p><p>​以 “  ” 方式给出的字符串对象，在字符常量池中储存，而且形同内容指挥在其中储存一份</p></li><li><p>通过构造方法创建</p><p>​通过 new 创建的字符串对象，每 new 一次都会产生一个新对象，放在堆内存中，虽然内容相同，但是地址值不同</p></li></ul><p></p><h3 id="2-5字符串的比较"><a href="#2-5字符串的比较" class="headerlink" title="2.5字符串的比较"></a>2.5字符串的比较</h3><h4 id="2-5-1-号的作用"><a href="#2-5-1-号的作用" class="headerlink" title="2.5.1   &#x3D;&#x3D;号的作用"></a>2.5.1   &#x3D;&#x3D;号的作用</h4><ul><li>比较基本数据类型：比较的是具体的值</li><li>比较引用数据类型：比较的是对象地址值</li><li>所以  &#x3D;&#x3D;  不适合字符串的内容比较</li></ul><h4 id="2-5-2-equals方法的作用"><a href="#2-5-2-equals方法的作用" class="headerlink" title="2.5.2   equals方法的作用"></a>2.5.2   equals方法的作用</h4><ul><li><p>方法介绍   </p><p><strong>equals与equalsIgnoreCase的区别</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object anObject)</span></span><br><span class="line"><span class="comment">//比较两个字符串内容是否相同、区分大小写，多用于密码登录</span></span><br><span class="line"></span><br><span class="line">例：</span><br><span class="line">  <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;itheima&quot;</span>; <span class="comment">//创建正确用户名</span></span><br><span class="line">  <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;czbk&quot;</span>;    <span class="comment">//创建正确密码</span></span><br><span class="line"></span><br><span class="line">  <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">&quot;请输入密码：&quot;</span>);</span><br><span class="line">  <span class="type">String</span> <span class="variable">pwd</span> <span class="operator">=</span> sc.nextLine(); <span class="comment">//用户输入密码</span></span><br><span class="line">  System.out.println(<span class="string">&quot;请输入密码：&quot;</span>);</span><br><span class="line">  <span class="type">String</span> <span class="variable">pwd</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">   </span><br><span class="line">  <span class="keyword">if</span>(name.equals(username)&amp;&amp;pwd.equals(password)) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">     </span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equalsIgnoreCase</span><span class="params">(String anotherString)</span></span><br><span class="line">    <span class="comment">////比较两个字符串内容是否相同、不区分大小写，多用于验证码</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure></li><li><p>示例代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//构造方法的方式得到对象</span></span><br><span class="line">        <span class="type">char</span>[] chs = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(chs);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(chs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//直接赋值的方式得到对象</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//比较字符串对象地址是否相同</span></span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">        System.out.println(s1 == s3);</span><br><span class="line">        System.out.println(s3 == s4);</span><br><span class="line">        System.out.println(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//比较字符串内容是否相同</span></span><br><span class="line">        System.out.println(s1.equals(s2));</span><br><span class="line">        System.out.println(s1.equals(s3));</span><br><span class="line">        System.out.println(s3.equals(s4));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-6用户登录案例"><a href="#2-6用户登录案例" class="headerlink" title="2.6用户登录案例"></a>2.6用户登录案例</h3><h4 id="2-6-1案例需求"><a href="#2-6-1案例需求" class="headerlink" title="2.6.1案例需求"></a>2.6.1案例需求</h4><p>​已知用户名和密码，请用程序实现模拟用户登录。总共给三次机会，登录之后，给出相应的提示</p><h4 id="2-6-2代码实现"><a href="#2-6-2代码实现" class="headerlink" title="2.6.2代码实现"></a>2.6.2代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    思路：</span></span><br><span class="line"><span class="comment">        1:已知用户名和密码，定义两个字符串表示即可</span></span><br><span class="line"><span class="comment">        2:键盘录入要登录的用户名和密码，用 Scanner 实现</span></span><br><span class="line"><span class="comment">        3:拿键盘录入的用户名、密码和已知的用户名、密码进行比较，给出相应的提示。字符串的内容比较，用equals() 方法实现</span></span><br><span class="line"><span class="comment">        4:用循环实现多次机会，这里的次数明确，采用for循环实现，并在登录成功的时候，使用break结束循环</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTest01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//已知用户名和密码，定义两个字符串表示即可</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;itheima&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;czbk&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用循环实现多次机会，这里的次数明确，采用for循环实现，并在登录成功的时候，使用break结束循环</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//键盘录入要登录的用户名和密码，用 Scanner 实现</span></span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;请输入用户名：&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;请输入密码：&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">pwd</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//拿键盘录入的用户名、密码和已知的用户名、密码进行比较，给出相应的提示。字符串的内容比较，用equals() 方法实现</span></span><br><span class="line">            <span class="keyword">if</span>(name.equals(username)&amp;&amp;pwd.equals(password)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="number">2</span>-i == <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;你的账户被锁定，请与管理员联系&quot;</span>);</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//2,1,0</span></span><br><span class="line">                    <span class="comment">//i,0,1,2</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;登录失败，你还有&quot;</span> + (<span class="number">2</span> - i) + <span class="string">&quot;次机会&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-7遍历字符串案例"><a href="#2-7遍历字符串案例" class="headerlink" title="2.7遍历字符串案例"></a>2.7遍历字符串案例</h3><h4 id="2-7-1案例需求"><a href="#2-7-1案例需求" class="headerlink" title="2.7.1案例需求"></a>2.7.1案例需求</h4><p>​键盘录入一个字符串，使用程序实现在控制台遍历该字符串</p><h4 id="2-7-2代码实现"><a href="#2-7-2代码实现" class="headerlink" title="2.7.2代码实现"></a>2.7.2代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    思路：</span></span><br><span class="line"><span class="comment">        1:键盘录入一个字符串，用 Scanner 实现</span></span><br><span class="line"><span class="comment">        2:遍历字符串，首先要能够获取到字符串中的每一个字符</span></span><br><span class="line"><span class="comment">            public char charAt(int index)：返回指定索引处的char值，字符串的索引也是从0开始的</span></span><br><span class="line"><span class="comment">        3:遍历字符串，其次要能够获取到字符串的长度</span></span><br><span class="line"><span class="comment">            public int length()：返回此字符串的长度</span></span><br><span class="line"><span class="comment">            数组的长度：数组名.length</span></span><br><span class="line"><span class="comment">            字符串的长度：字符串对象.length()</span></span><br><span class="line"><span class="comment">        4:遍历字符串的通用格式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTest02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//键盘录入一个字符串，用 Scanner 实现</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入一个字符串：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;line.length(); i++) &#123;</span><br><span class="line">            System.out.println(line.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-8统计字符次数案例"><a href="#2-8统计字符次数案例" class="headerlink" title="2.8统计字符次数案例"></a>2.8统计字符次数案例</h3><h4 id="2-8-1案例需求"><a href="#2-8-1案例需求" class="headerlink" title="2.8.1案例需求"></a>2.8.1案例需求</h4><p>​键盘录入一个字符串，统计该字符串中大写字母字符，小写字母字符，数字字符出现的次数(不考虑其他字符)</p><h4 id="2-8-2代码实现"><a href="#2-8-2代码实现" class="headerlink" title="2.8.2代码实现"></a>2.8.2代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  思路：</span></span><br><span class="line"><span class="comment">        1:键盘录入一个字符串，用 Scanner 实现</span></span><br><span class="line"><span class="comment">        2:要统计三种类型的字符个数，需定义三个统计变量，初始值都为0</span></span><br><span class="line"><span class="comment">        3:遍历字符串，得到每一个字符</span></span><br><span class="line"><span class="comment">        4:判断该字符属于哪种类型，然后对应类型的统计变量+1</span></span><br><span class="line"><span class="comment">            假如ch是一个字符，我要判断它属于大写字母，小写字母，还是数字，直接判断该字符是否在对应的范围即可</span></span><br><span class="line"><span class="comment">            大写字母：ch&gt;=&#x27;A&#x27; &amp;&amp; ch&lt;=&#x27;Z&#x27;</span></span><br><span class="line"><span class="comment">            小写字母： ch&gt;=&#x27;a&#x27; &amp;&amp; ch&lt;=&#x27;z&#x27;</span></span><br><span class="line"><span class="comment">            数字： ch&gt;=&#x27;0&#x27; &amp;&amp; ch&lt;=&#x27;9&#x27;</span></span><br><span class="line"><span class="comment">        5:输出三种类型的字符个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTest03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//键盘录入一个字符串，用 Scanner 实现</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入一个字符串：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//要统计三种类型的字符个数，需定义三个统计变量，初始值都为0</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">bigCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">smallCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">numberCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历字符串，得到每一个字符</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;line.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> line.charAt(i);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断该字符属于哪种类型，然后对应类型的统计变量+1</span></span><br><span class="line">            <span class="keyword">if</span>(ch&gt;=<span class="string">&#x27;A&#x27;</span> &amp;&amp; ch&lt;=<span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">                bigCount++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ch&gt;=<span class="string">&#x27;a&#x27;</span> &amp;&amp; ch&lt;=<span class="string">&#x27;z&#x27;</span>) &#123;</span><br><span class="line">                smallCount++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                numberCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出三种类型的字符个数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;大写字母：&quot;</span> + bigCount + <span class="string">&quot;个&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;小写字母：&quot;</span> + smallCount + <span class="string">&quot;个&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;数字：&quot;</span> + numberCount + <span class="string">&quot;个&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-9字符串拼接案例"><a href="#2-9字符串拼接案例" class="headerlink" title="2.9字符串拼接案例"></a>2.9字符串拼接案例</h3><h4 id="2-9-1案例需求"><a href="#2-9-1案例需求" class="headerlink" title="2.9.1案例需求"></a>2.9.1案例需求</h4><p>​定义一个方法，把 int 数组中的数据按照指定的格式拼接成一个字符串返回，调用该方法，</p><p>​并在控制台输出结果。例如，数组为 int[] arr &#x3D; {1,2,3}; ，执行方法后的输出结果为：[1, 2, 3]</p><h4 id="2-9-2代码实现"><a href="#2-9-2代码实现" class="headerlink" title="2.9.2代码实现"></a>2.9.2代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    思路：</span></span><br><span class="line"><span class="comment">        1:定义一个 int 类型的数组，用静态初始化完成数组元素的初始化</span></span><br><span class="line"><span class="comment">        2:定义一个方法，用于把 int 数组中的数据按照指定格式拼接成一个字符串返回。</span></span><br><span class="line"><span class="comment">          返回值类型 String，参数列表 int[] arr</span></span><br><span class="line"><span class="comment">        3:在方法中遍历数组，按照要求进行拼接</span></span><br><span class="line"><span class="comment">        4:调用方法，用一个变量接收结果</span></span><br><span class="line"><span class="comment">        5:输出结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTest04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//定义一个 int 类型的数组，用静态初始化完成数组元素的初始化</span></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用方法，用一个变量接收结果</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> arrayToString(arr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;s:&quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个方法，用于把 int 数组中的数据按照指定格式拼接成一个字符串返回</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        两个明确：</span></span><br><span class="line"><span class="comment">            返回值类型：String</span></span><br><span class="line"><span class="comment">            参数：int[] arr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">arrayToString</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="comment">//在方法中遍历数组，按照要求进行拼接</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        s += <span class="string">&quot;[&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==arr.length-<span class="number">1</span>) &#123;</span><br><span class="line">                s += arr[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                s += arr[i];</span><br><span class="line">                s += <span class="string">&quot;, &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        s += <span class="string">&quot;]&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-10字符串反转案例"><a href="#2-10字符串反转案例" class="headerlink" title="2.10字符串反转案例"></a>2.10字符串反转案例</h3><h4 id="2-10-1案例需求"><a href="#2-10-1案例需求" class="headerlink" title="2.10.1案例需求"></a>2.10.1案例需求</h4><p>​定义一个方法，实现字符串反转。键盘录入一个字符串，调用该方法后，在控制台输出结果</p><p>​例如，键盘录入 abc，输出结果 cba</p><h4 id="2-10-2代码实现"><a href="#2-10-2代码实现" class="headerlink" title="2.10.2代码实现"></a>2.10.2代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    思路：</span></span><br><span class="line"><span class="comment">        1:键盘录入一个字符串，用 Scanner 实现</span></span><br><span class="line"><span class="comment">        2:定义一个方法，实现字符串反转。返回值类型 String，参数 String s</span></span><br><span class="line"><span class="comment">        3:在方法中把字符串倒着遍历，然后把每一个得到的字符拼接成一个字符串并返回</span></span><br><span class="line"><span class="comment">        4:调用方法，用一个变量接收结果</span></span><br><span class="line"><span class="comment">        5:输出结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTest05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//键盘录入一个字符串，用 Scanner 实现</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入一个字符串：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用方法，用一个变量接收结果</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> reverse(line);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;s:&quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个方法，实现字符串反转</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        两个明确：</span></span><br><span class="line"><span class="comment">            返回值类型：String</span></span><br><span class="line"><span class="comment">            参数：String s</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">reverse</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">//在方法中把字符串倒着遍历，然后把每一个得到的字符拼接成一个字符串并返回</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=s.length()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            ss += s.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ss;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-11帮助文档查看String常用方法"><a href="#2-11帮助文档查看String常用方法" class="headerlink" title="2.11帮助文档查看String常用方法"></a>2.11帮助文档查看String常用方法</h3><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public boolean   equals(Object anObject)</td><td>比较字符串的内容，严格区分大小写(用户名和密码)</td></tr><tr><td>public char charAt(int   index)</td><td>返回指定索引处的 char 值</td></tr><tr><td>public int   length()</td><td>返回此字符串的长度</td></tr><tr><td>startsWith</td><td>比较字符串首字符是否一致</td></tr></tbody></table><h2 id="3-ArrayList（集合）"><a href="#3-ArrayList（集合）" class="headerlink" title="3.ArrayList（集合）"></a>3.ArrayList（集合）</h2><h3 id="3-1ArrayList类概述"><a href="#3-1ArrayList类概述" class="headerlink" title="3.1ArrayList类概述"></a>3.1ArrayList类概述</h3><ul><li><p>什么是集合</p><p>​提供一种存储空间可变的存储模型，存储的数据容量可以发生改变</p></li><li><p>ArrayList集合的特点</p><p>​底层是数组实现的，长度可以变化</p></li><li><p>泛型的使用</p><p>​用于约束集合中存储元素的数据类型</p></li></ul><h3 id="3-2ArrayList类常用方法"><a href="#3-2ArrayList类常用方法" class="headerlink" title="3.2ArrayList类常用方法"></a>3.2ArrayList类常用方法</h3><h4 id="3-2-1构造方法"><a href="#3-2-1构造方法" class="headerlink" title="3.2.1构造方法"></a>3.2.1构造方法</h4><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public ArrayList()</td><td>创建一个空的集合对象</td></tr></tbody></table><h4 id="3-2-2成员方法"><a href="#3-2-2成员方法" class="headerlink" title="3.2.2成员方法"></a>3.2.2成员方法</h4><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public boolean   remove(Object o)</td><td>删除指定的元素，返回删除是否成功</td></tr><tr><td>public E   remove(int   index)</td><td>删除指定索引处的元素，返回被删除的元素</td></tr><tr><td>public E   set(int index,E   element)</td><td>修改指定索引处的元素，返回被修改的元素</td></tr><tr><td>public E   get(int   index)</td><td>返回指定索引处的元素</td></tr><tr><td>public int   size()</td><td>返回集合中的元素的个数</td></tr><tr><td>public boolean   add(E e)</td><td>将指定的元素追加到此集合的末尾</td></tr><tr><td>public void   add(int index,E   element)</td><td>在此集合中的指定位置插入指定的元素</td></tr></tbody></table><h4 id="3-2-3泛型概述"><a href="#3-2-3泛型概述" class="headerlink" title="3.2.3泛型概述"></a>3.2.3泛型概述</h4><ul><li><p>ArrayList&lt;引用数据类型&gt;： 其实就是一个泛型类，可以在编译阶段约束集合对象只能操作某种数据类型</p><p>举例：</p></li><li><p>ArrayList<String>:  此集合只能字符串类型的元素</p></li><li><p>ArrayList<Integer>:  此集合只能整形类型的元素</p></li></ul><p><strong>注意:集合中只能存储引用类型，不支持基本数据类型</strong></p><h4 id="3-2-4示例代码"><a href="#3-2-4示例代码" class="headerlink" title="3.2.4示例代码"></a>3.2.4示例代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayListDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建集合</span></span><br><span class="line">        ArrayList&lt;String&gt; array = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        array.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        array.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        array.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//public boolean remove(Object o)：删除指定的元素，返回删除是否成功</span></span><br><span class="line"><span class="comment">//        System.out.println(array.remove(&quot;world&quot;));</span></span><br><span class="line"><span class="comment">//        System.out.println(array.remove(&quot;javaee&quot;));</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//public E remove(int index)：删除指定索引处的元素，返回被删除的元素</span></span><br><span class="line"><span class="comment">//        System.out.println(array.remove(1));</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//IndexOutOfBoundsException</span></span><br><span class="line"><span class="comment">//        System.out.println(array.remove(3));</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//public E set(int index,E element)：修改指定索引处的元素，返回被修改的元素</span></span><br><span class="line"><span class="comment">//        System.out.println(array.set(1,&quot;javaee&quot;));</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//IndexOutOfBoundsException</span></span><br><span class="line"><span class="comment">//        System.out.println(array.set(3,&quot;javaee&quot;));</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//public E get(int index)：返回指定索引处的元素</span></span><br><span class="line"><span class="comment">//        System.out.println(array.get(0));</span></span><br><span class="line"><span class="comment">//        System.out.println(array.get(1));</span></span><br><span class="line"><span class="comment">//        System.out.println(array.get(2));</span></span><br><span class="line">        <span class="comment">//System.out.println(array.get(3)); //？？？？？？ 自己测试</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//public int size()：返回集合中的元素的个数</span></span><br><span class="line">        System.out.println(array.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出集合</span></span><br><span class="line">        System.out.println(<span class="string">&quot;array:&quot;</span> + array);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-3ArrayList存储字符串并遍历"><a href="#3-3ArrayList存储字符串并遍历" class="headerlink" title="3.3ArrayList存储字符串并遍历"></a>3.3ArrayList存储字符串并遍历</h3><h4 id="3-3-1案例需求"><a href="#3-3-1案例需求" class="headerlink" title="3.3.1案例需求"></a>3.3.1案例需求</h4><p>​创建一个存储字符串的集合，存储3个字符串元素，使用程序实现在控制台遍历该集合</p><h4 id="3-3-2代码实现"><a href="#3-3-2代码实现" class="headerlink" title="3.3.2代码实现"></a>3.3.2代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    思路：</span></span><br><span class="line"><span class="comment">   1:创建集合对象</span></span><br><span class="line"><span class="comment">   2:往集合中添加字符串对象</span></span><br><span class="line"><span class="comment">   3:遍历集合（遍历集合的通用格式）</span></span><br><span class="line"><span class="comment">     首先通过get(int index)方法获取到集合中的每一个元素</span></span><br><span class="line"><span class="comment">     其次通过size()方法要能够获取到集合的长度</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayListTest01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//创建集合对象</span></span><br><span class="line">        ArrayList&lt;String&gt; array =</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//往集合中添加字符串对象</span></span><br><span class="line">        array.add(<span class="string">&quot;刘正风&quot;</span>);</span><br><span class="line">        array.add(<span class="string">&quot;左冷禅&quot;</span>);</span><br><span class="line">        array.add(<span class="string">&quot;风清扬&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历集合的通用格式</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;array.size(); i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> array.get(i);</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4ArrayList存储学生对象并遍历"><a href="#3-4ArrayList存储学生对象并遍历" class="headerlink" title="3.4ArrayList存储学生对象并遍历"></a>3.4ArrayList存储学生对象并遍历</h3><h4 id="3-4-1案例需求"><a href="#3-4-1案例需求" class="headerlink" title="3.4.1案例需求"></a>3.4.1案例需求</h4><p>​创建一个存储学生对象的集合，存储3个学生对象，使用程序实现在控制台遍历该集合</p><h4 id="3-4-2代码实现"><a href="#3-4-2代码实现" class="headerlink" title="3.4.2代码实现"></a>3.4.2代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    思路：</span></span><br><span class="line"><span class="comment">        1:定义学生类</span></span><br><span class="line"><span class="comment">        2:创建集合对象</span></span><br><span class="line"><span class="comment">        3:创建学生对象</span></span><br><span class="line"><span class="comment">        4:添加学生对象到集合中</span></span><br><span class="line"><span class="comment">        5:遍历集合，采用通用遍历格式实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayListTest02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建集合对象</span></span><br><span class="line">        ArrayList&lt;Student&gt; array = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建学生对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;林青霞&quot;</span>, <span class="number">30</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;风清扬&quot;</span>, <span class="number">33</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张曼玉&quot;</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加学生对象到集合中</span></span><br><span class="line">        array.add(s1);</span><br><span class="line">        array.add(s2);</span><br><span class="line">        array.add(s3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历集合，采用通用遍历格式实现</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.size(); i++) &#123;</span><br><span class="line">            <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> array.get(i);</span><br><span class="line">            System.out.println(s.getName() + <span class="string">&quot;,&quot;</span> + s.getAge());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5ArrayList存储学生对象并遍历升级版"><a href="#3-5ArrayList存储学生对象并遍历升级版" class="headerlink" title="3.5ArrayList存储学生对象并遍历升级版"></a>3.5ArrayList存储学生对象并遍历升级版</h3><h4 id="3-5-1案例需求"><a href="#3-5-1案例需求" class="headerlink" title="3.5.1案例需求"></a>3.5.1案例需求</h4><p>​创建一个存储学生对象的集合，存储3个学生对象，使用程序实现在控制台遍历该集合</p><p>​        学生的姓名和年龄来自于键盘录入</p><h4 id="3-5-2代码实现"><a href="#3-5-2代码实现" class="headerlink" title="3.5.2代码实现"></a>3.5.2代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    思路：</span></span><br><span class="line"><span class="comment">        1:定义学生类，为了键盘录入数据方便，把学生类中的成员变量都定义为String类型</span></span><br><span class="line"><span class="comment">        2:创建集合对象</span></span><br><span class="line"><span class="comment">        3:键盘录入学生对象所需要的数据</span></span><br><span class="line"><span class="comment">        4:创建学生对象，把键盘录入的数据赋值给学生对象的成员变量</span></span><br><span class="line"><span class="comment">        5:往集合中添加学生对象</span></span><br><span class="line"><span class="comment">        6:遍历集合，采用通用遍历格式实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayListTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建集合对象</span></span><br><span class="line">        ArrayList&lt;Student&gt; array = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Student&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//为了提高代码的复用性，我们用方法来改进程序</span></span><br><span class="line">        addStudent(array);</span><br><span class="line">        addStudent(array);</span><br><span class="line">        addStudent(array);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历集合，采用通用遍历格式实现</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.size(); i++) &#123;</span><br><span class="line">            <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> array.get(i);</span><br><span class="line">            System.out.println(s.getName() + <span class="string">&quot;,&quot;</span> + s.getAge());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        两个明确：</span></span><br><span class="line"><span class="comment">            返回值类型：void</span></span><br><span class="line"><span class="comment">            参数：ArrayList&lt;Student&gt; array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addStudent</span><span class="params">(ArrayList&lt;Student&gt; array)</span> &#123;</span><br><span class="line">        <span class="comment">//键盘录入学生对象所需要的数据</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入学生姓名:&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入学生年龄:&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">age</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建学生对象，把键盘录入的数据赋值给学生对象的成员变量</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        s.setName(name);</span><br><span class="line">        s.setAge(age);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//往集合中添加学生对象</span></span><br><span class="line">        array.add(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> java,基础语法,API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>day07 - 面对对象</title>
      <link href="/post/ca2e86a8.html"/>
      <url>/post/ca2e86a8.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-类和对象"><a href="#1-类和对象" class="headerlink" title="1. 类和对象"></a>1. 类和对象</h2><h3 id="1-1-类和对象的理解"><a href="#1-1-类和对象的理解" class="headerlink" title="1.1 类和对象的理解"></a>1.1 类和对象的理解</h3><p>客观存在的事物皆为对象 ，所以我们也常常说万物皆对象。</p><ul><li>类<ul><li>类的理解<ul><li>类是对现实生活中一类具有共同属性和行为的事物的抽象</li><li>类是对象的数据类型，类是具有相同属性和行为的一组对象的集合</li><li>简单理解：类就是对现实事物的一种描述</li></ul></li><li>类的组成<ul><li>属性：指事物的特征，例如：手机事物（品牌，价格，尺寸）</li><li>行为：指事物能执行的操作，例如：手机事物（打电话，发短信）</li></ul></li></ul></li><li>类和对象的关系<ul><li>类：类是对现实生活中一类具有共同属性和行为的事物的抽象</li><li>对象：是能够看得到摸的着的真实存在的实体</li><li>简单理解：<strong>类是对事物的一种描述，对象则为具体存在的事物</strong></li></ul></li></ul><h3 id="1-2-类的定义"><a href="#1-2-类的定义" class="headerlink" title="1.2 类的定义"></a>1.2 类的定义</h3><p>类的组成是由属性和行为两部分组成</p><ul><li>属性：在类中通过成员变量来体现（类中方法外的变量）</li><li>行为：在类中通过成员方法来体现（和前面的方法相比去掉static关键字即可）</li></ul><p>类的定义步骤：</p><p>①定义类</p><p>②编写类的成员变量</p><p>③编写类的成员方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名 &#123;</span><br><span class="line"><span class="comment">// 成员变量</span></span><br><span class="line">变量<span class="number">1</span>的数据类型 变量<span class="number">1</span>；</span><br><span class="line">变量<span class="number">2</span>的数据类型 变量<span class="number">2</span>;</span><br><span class="line">…</span><br><span class="line"><span class="comment">// 成员方法</span></span><br><span class="line">方法<span class="number">1</span>;</span><br><span class="line">方法<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    手机类：</span></span><br><span class="line"><span class="comment">        类名：</span></span><br><span class="line"><span class="comment">        手机(Phone)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        成员变量：</span></span><br><span class="line"><span class="comment">        品牌(brand)</span></span><br><span class="line"><span class="comment">        价格(price)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        成员方法：</span></span><br><span class="line"><span class="comment">        打电话(call)</span></span><br><span class="line"><span class="comment">        发短信(sendMessage)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="comment">//成员变量</span></span><br><span class="line">    String brand;</span><br><span class="line">    <span class="type">int</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//成员方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打电话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发短信&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1-3-对象的使用"><a href="#1-3-对象的使用" class="headerlink" title="1.3 对象的使用"></a>1.3 对象的使用</h3><ul><li>创建对象的格式：<ul><li>类名 对象名 &#x3D; new 类名();</li></ul></li><li>调用成员的格式：<ul><li>对象名.成员变量</li><li>对象名.成员方法();</li></ul></li><li>示例代码</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    创建对象</span></span><br><span class="line"><span class="comment">        格式：类名 对象名 = new 类名();</span></span><br><span class="line"><span class="comment">        范例：Phone p = new Phone();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    使用对象</span></span><br><span class="line"><span class="comment">        1：使用成员变量</span></span><br><span class="line"><span class="comment">            格式：对象名.变量名</span></span><br><span class="line"><span class="comment">            范例：p.brand</span></span><br><span class="line"><span class="comment">        2：使用成员方法</span></span><br><span class="line"><span class="comment">            格式：对象名.方法名()</span></span><br><span class="line"><span class="comment">            范例：p.call()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhoneDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        <span class="type">Phone</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用成员变量</span></span><br><span class="line">        System.out.println(p.brand);</span><br><span class="line">        System.out.println(p.price);</span><br><span class="line"></span><br><span class="line">        p.brand = <span class="string">&quot;小米&quot;</span>;</span><br><span class="line">        p.price = <span class="number">2999</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(p.brand);</span><br><span class="line">        System.out.println(p.price);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用成员方法</span></span><br><span class="line">        p.call();</span><br><span class="line">        p.sendMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-学生对象-练习"><a href="#1-4-学生对象-练习" class="headerlink" title="1.4 学生对象-练习"></a>1.4 学生对象-练习</h3><ul><li>需求：首先定义一个学生类，然后定义一个学生测试类，在学生测试类中通过对象完成成员变量和成员方法的使用</li><li>分析：<ul><li>成员变量：姓名，年龄…</li><li>成员方法：学习，做作业…</li></ul></li><li>示例代码：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">![<span class="number">1</span>](C:\TeachRes\Java2019\JavaSe01\day07\<span class="number">4</span>-笔记\笔记图片资源包\<span class="number">1.</span>png)<span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="comment">//成员变量</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//成员方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;好好学习，天天向上&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doHomework</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;键盘敲烂，月薪过万&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    学生测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用对象</span></span><br><span class="line">        System.out.println(s.name + <span class="string">&quot;,&quot;</span> + s.age);</span><br><span class="line"></span><br><span class="line">        s.name = <span class="string">&quot;林青霞&quot;</span>;</span><br><span class="line">        s.age = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(s.name + <span class="string">&quot;,&quot;</span> + s.age);</span><br><span class="line"></span><br><span class="line">        s.study();</span><br><span class="line">        s.doHomework();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-对象内存图"><a href="#2-对象内存图" class="headerlink" title="2. 对象内存图"></a>2. 对象内存图</h2><h3 id="2-1-单个对象内存图"><a href="#2-1-单个对象内存图" class="headerlink" title="2.1 单个对象内存图"></a>2.1 单个对象内存图</h3><ul><li>成员变量使用过程</li></ul><p><img src="/images%5C1.png" alt="1"></p><ul><li>成员方法调用过程</li></ul><p><img src="/images%5C2.png" alt="2"></p><h3 id="2-2-多个对象内存图"><a href="#2-2-多个对象内存图" class="headerlink" title="2.2 多个对象内存图"></a>2.2 多个对象内存图</h3><ul><li>成员变量使用过程</li></ul><p><img src="/images%5C3.png" alt="3"></p><ul><li>成员方法调用过程</li></ul><p><img src="/images%5C4.png" alt="4"></p><ul><li><p>总结：</p><p>多个对象在堆内存中，都有不同的内存划分，成员变量存储在各自的内存区域中，成员方法多个对象共用的一份</p></li></ul><h3 id="2-3-多个对象指向相同内存图"><a href="#2-3-多个对象指向相同内存图" class="headerlink" title="2.3 多个对象指向相同内存图"></a>2.3 多个对象指向相同内存图</h3><p><img src="/images%5C4.bmp" alt="4"></p><ul><li><p>总结</p><p>当多个对象的引用指向同一个内存空间（变量所记录的地址值是一样的）</p><p>只要有任何一个对象修改了内存中的数据，随后，无论使用哪一个对象进行数据获取，都是修改后的数据。</p></li></ul><h2 id="3-成员变量和局部变量"><a href="#3-成员变量和局部变量" class="headerlink" title="3. 成员变量和局部变量"></a>3. 成员变量和局部变量</h2><h3 id="3-1-成员变量和局部变量的区别"><a href="#3-1-成员变量和局部变量的区别" class="headerlink" title="3.1 成员变量和局部变量的区别"></a>3.1 成员变量和局部变量的区别</h3><ul><li>类中位置不同：成员变量（类中方法外）局部变量（方法内部或方法声明上）</li><li>内存中位置不同：成员变量（堆内存）局部变量（栈内存）</li><li>生命周期不同：成员变量（随着对象的存在而存在，随着对象的消失而消失）局部变量（随着方法的调用而存在，醉着方法的调用完毕而消失）</li><li>初始化值不同：成员变量（有默认初始化值）局部变量（没有默认初始化值，必须先定义，赋值才能使用）</li></ul><h2 id="4-封装"><a href="#4-封装" class="headerlink" title="4. 封装"></a>4. 封装</h2><h3 id="4-1-private关键字"><a href="#4-1-private关键字" class="headerlink" title="4.1 private关键字"></a>4.1 private关键字</h3><p>private是一个修饰符，可以用来修饰成员（成员变量，成员方法）</p><ul><li><p>被private修饰的成员，只能在本类进行访问，针对private修饰的成员变量，如果需要被其他类使用，提供相应的操作</p><ul><li>提供“get变量名()”方法，用于获取成员变量的值，方法用public修饰</li><li>提供“set变量名(参数)”方法，用于设置成员变量的值，方法用public修饰</li></ul></li><li><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    学生类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="comment">//成员变量</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供get/set方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(a&lt;<span class="number">0</span> || a&gt;<span class="number">120</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;你给的年龄有误&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            age = a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//成员方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;,&quot;</span> + age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    学生测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        <span class="comment">//给成员变量赋值</span></span><br><span class="line">        s.name = <span class="string">&quot;林青霞&quot;</span>;</span><br><span class="line">        s.setAge(<span class="number">30</span>);</span><br><span class="line">        <span class="comment">//调用show方法</span></span><br><span class="line">        s.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-2-private的使用"><a href="#4-2-private的使用" class="headerlink" title="4.2 private的使用"></a>4.2 private的使用</h3><ul><li><p>需求：定义标准的学生类，要求name和age使用private修饰，并提供set和get方法以及便于显示数据的show方法，测试类中创建对象并使用，最终控制台输出  林青霞，30 </p></li><li><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    学生类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="comment">//成员变量</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get/set方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String n)</span> &#123;</span><br><span class="line">        name = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">        age = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;,&quot;</span> + age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    学生测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用set方法给成员变量赋值</span></span><br><span class="line">        s.setName(<span class="string">&quot;林青霞&quot;</span>);</span><br><span class="line">        s.setAge(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">        s.show();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用get方法获取成员变量的值</span></span><br><span class="line">        System.out.println(s.getName() + <span class="string">&quot;---&quot;</span> + s.getAge());</span><br><span class="line">        System.out.println(s.getName() + <span class="string">&quot;,&quot;</span> + s.getAge());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-3-this关键字"><a href="#4-3-this关键字" class="headerlink" title="4.3 this关键字"></a>4.3 this关键字</h3><ul><li>this修饰的变量用于指代成员变量，其主要作用是（区分局部变量和成员变量的重名问题）<ul><li>方法的形参如果与成员变量同名，不带this修饰的变量指的是形参，带this修饰的变量是成员变量</li><li>方法的形参没有与成员变量同名，不带this修饰的变量指的是成员变量</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;,&quot;</span> + age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-this内存原理"><a href="#4-4-this内存原理" class="headerlink" title="4.4 this内存原理"></a>4.4 this内存原理</h3><ul><li><p>this代表当前调用方法的引用，哪个对象（类）调用的方法，this就代表哪一个对象（类）</p></li><li><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        s1.setName(<span class="string">&quot;林青霞&quot;</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        s2.setName(<span class="string">&quot;张曼玉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>图解：</p><p><img src="/images%5C5.png" alt="5"></p><p><img src="/images%5C6.png" alt="6"></p></li></ul><h3 id="4-5-封装思想"><a href="#4-5-封装思想" class="headerlink" title="4.5 封装思想"></a>4.5 封装思想</h3><ol><li>封装概述<br> 是面向对象三大特征之一（封装，继承，多态）<br> 是面向对象编程语言对客观世界的模拟，客观世界里成员变量都是隐藏在对象内部的，外界是无法直接操作的</li><li>封装原则<br> 将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问<br> 成员变量private，提供对应的getXxx()&#x2F;setXxx()方法</li><li>封装好处<br> 通过方法来控制成员变量的操作，提高了代码的安全性<br> 把代码用方法进行封装，提高了代码的复用性</li></ol><h2 id="5-标准JavaBean"><a href="#5-标准JavaBean" class="headerlink" title="5.标准JavaBean"></a>5.标准JavaBean</h2><h3 id="5-1标准JavaBean概述"><a href="#5-1标准JavaBean概述" class="headerlink" title="5.1标准JavaBean概述"></a>5.1标准JavaBean概述</h3><p>​      可以理解为实体类，其对象可以用于在程序中封装数据（例如学生类，汽车类）</p><h3 id="5-2标准JavaBean风格"><a href="#5-2标准JavaBean风格" class="headerlink" title="5.2标准JavaBean风格"></a>5.2标准JavaBean风格</h3><p>  标准JavaBean须满足如下条件要求：</p><p>​<br>​      * 成员变量使用private修饰<br>​<br>​      * 提供每一个成员变量对应提供成套的setXxx()  getXxx()<br>​<br>​      * 必须提供一个无参构造器</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">创建过程</span><br><span class="line"><span class="keyword">package</span> javabean;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.成员变量私有</span></span><br><span class="line"> <span class="keyword">public</span> String  name;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//2.必须提供成套的getter和setter方法暴露成员变量的取值和赋值</span></span><br><span class="line"><span class="comment">//（快捷操作方法：右键 Generate,Gerrer and Setter,shift全选）</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.必须提供一个无参构造器（使用默认的）</span></span><br><span class="line">    <span class="comment">//或手写</span></span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建方法</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意：存在有参构造器时无参构造器消失，此时需要使用无参构造器时需要手动构造"><a href="#注意：存在有参构造器时无参构造器消失，此时需要使用无参构造器时需要手动构造" class="headerlink" title="注意：存在有参构造器时无参构造器消失，此时需要使用无参构造器时需要手动构造"></a><strong>注意：存在有参构造器时无参构造器消失，此时需要使用无参构造器时需要手动构造</strong></h4><h2 id="6-构造方法"><a href="#6-构造方法" class="headerlink" title="6. 构造方法"></a>6. 构造方法</h2><h3 id="6-1-构造方法概述"><a href="#6-1-构造方法概述" class="headerlink" title="6.1 构造方法概述"></a>6.1 构造方法概述</h3><p>构造方法是一种特殊的方法</p><ul><li><p>作用：创建对象   Student stu &#x3D; <strong>new Student();</strong></p></li><li><p>格式：</p><p>public class 类名{</p><p>​        修饰符 类名( 参数 ) {</p><p>​        }</p><p>}</p></li><li><p>功能：主要是完成对象数据的初始化</p></li><li><p>示例代码：</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;无参构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;,&quot;</span> + age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        s.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-构造方法的注意事项"><a href="#6-2-构造方法的注意事项" class="headerlink" title="6.2 构造方法的注意事项"></a>6.2 构造方法的注意事项</h3><ul><li>构造方法的创建</li></ul><p>如果没有定义构造方法，系统将给出一个默认的无参数构造方法<br>如果定义了构造方法，系统将不再提供默认的构造方法</p><ul><li>构造方法的重载</li></ul><p>如果自定义了带参构造方法，还要使用无参数构造方法，就必须再写一个无参数构造方法</p><ul><li>推荐的使用方式</li></ul><p>无论是否使用，都手工书写无参数构造方法</p><ul><li>重要功能！</li></ul><p>可以使用带参构造，为成员变量进行初始化</p><ul><li>示例代码</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    学生类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name,<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;,&quot;</span> + age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        s1.show();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//public Student(String name)</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;林青霞&quot;</span>);</span><br><span class="line">        s2.show();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//public Student(int age)</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">30</span>);</span><br><span class="line">        s3.show();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//public Student(String name,int age)</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;林青霞&quot;</span>,<span class="number">30</span>);</span><br><span class="line">        s4.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-3-标准类制作"><a href="#6-3-标准类制作" class="headerlink" title="6.3 标准类制作"></a>6.3 标准类制作</h3><ul><li>需求：定义标准学生类，要求分别使用空参和有参构造方法创建对象，空参创建的对象通过setXxx赋值，有参创建的对象直接赋值，并通过show方法展示数据。 </li><li>示例代码：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="comment">//成员变量</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//成员方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;,&quot;</span> + age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    创建对象并为其成员变量赋值的两种方式</span></span><br><span class="line"><span class="comment">        1:无参构造方法创建对象后使用setXxx()赋值</span></span><br><span class="line"><span class="comment">        2:使用带参构造方法直接创建带有属性值的对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//无参构造方法创建对象后使用setXxx()赋值</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        s1.setName(<span class="string">&quot;林青霞&quot;</span>);</span><br><span class="line">        s1.setAge(<span class="number">30</span>);</span><br><span class="line">        s1.show();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用带参构造方法直接创建带有属性值的对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;林青霞&quot;</span>,<span class="number">30</span>);</span><br><span class="line">        s2.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> java,基础语法,对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>day06 - Debug</title>
      <link href="/post/cad517f3.html"/>
      <url>/post/cad517f3.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-Debug模式"><a href="#1-Debug模式" class="headerlink" title="1.Debug模式"></a>1.Debug模式</h2><h3 id="1-1什么是Debug模式"><a href="#1-1什么是Debug模式" class="headerlink" title="1.1什么是Debug模式"></a>1.1什么是Debug模式</h3><p>是供程序员使用的程序调试工具，它可以用于查看程序的执行流程，也可以用于追踪程序执行过程来调试程序。</p><h2 id="2-基础练习（参考题目）"><a href="#2-基础练习（参考题目）" class="headerlink" title="2.基础练习（参考题目）"></a>2.基础练习（参考题目）</h2><h3 id="2-1减肥计划if版本"><a href="#2-1减肥计划if版本" class="headerlink" title="2.1减肥计划if版本"></a>2.1减肥计划if版本</h3><h4 id="2-1-1案例需求"><a href="#2-1-1案例需求" class="headerlink" title="2.1.1案例需求"></a>2.1.1案例需求</h4><p>​输入星期数，显示今天的减肥活动<br>​          周一：跑步<br>​          周二：游泳<br>​          周三：慢走<br>​          周四：动感单车<br>​          周五：拳击<br>​          周六：爬山<br>​          周日：好好吃一顿</p><h4 id="2-1-2代码实现"><a href="#2-1-2代码实现" class="headerlink" title="2.1.2代码实现"></a>2.1.2代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    思路：</span></span><br><span class="line"><span class="comment">        1:键盘录入一个星期数，用一个变量接收</span></span><br><span class="line"><span class="comment">        2:对星期数进行判断，这里用 if 语句实现</span></span><br><span class="line"><span class="comment">        3:在对应的语句控制中输出对应的减肥活动</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//键盘录入一个星期数，用一个变量接收</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入一个星期数：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">week</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对星期数进行判断，这里用 if 语句实现</span></span><br><span class="line">        <span class="keyword">if</span> (week &lt; <span class="number">1</span> || week &gt; <span class="number">7</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;你输入的星期数有误&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (week == <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;跑步&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (week == <span class="number">2</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;游泳&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (week == <span class="number">3</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;慢走&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (week == <span class="number">4</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;动感单车&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (week == <span class="number">5</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;拳击&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (week == <span class="number">6</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;爬山&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;好好吃一顿&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2减肥计划switch版本"><a href="#2-2减肥计划switch版本" class="headerlink" title="2.2减肥计划switch版本"></a>2.2减肥计划switch版本</h3><h4 id="2-2-1案例需求"><a href="#2-2-1案例需求" class="headerlink" title="2.2.1案例需求"></a>2.2.1案例需求</h4><p>​输入星期数，显示今天的减肥活动<br>​          周一：跑步<br>​          周二：游泳<br>​          周三：慢走<br>​          周四：动感单车<br>​          周五：拳击<br>​          周六：爬山<br>​          周日：好好吃一顿</p><h4 id="2-2-2代码实现"><a href="#2-2-2代码实现" class="headerlink" title="2.2.2代码实现"></a>2.2.2代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    思路：</span></span><br><span class="line"><span class="comment">        1:键盘录入一个星期数，用一个变量接收</span></span><br><span class="line"><span class="comment">        2:对星期数进行判断，这里用 switch 语句实现</span></span><br><span class="line"><span class="comment">        3:在对应的语句控制中输出对应的减肥活动</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    导包：</span></span><br><span class="line"><span class="comment">        1:手动导包  import java.util.Scanner;</span></span><br><span class="line"><span class="comment">        2:快捷键导包 Alt+Enter</span></span><br><span class="line"><span class="comment">        3:自动导包</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//键盘录入一个星期数，用一个变量接收</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入一个星期数：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">week</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对星期数进行判断，这里用 switch 语句实现</span></span><br><span class="line">        <span class="keyword">switch</span> (week) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;跑步&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;游泳&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;慢走&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;动感单车&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;拳击&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;爬山&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;好好吃一顿&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;你输入的星期数有误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3逢七跳过"><a href="#2-3逢七跳过" class="headerlink" title="2.3逢七跳过"></a>2.3逢七跳过</h3><h4 id="2-3-1案例需求"><a href="#2-3-1案例需求" class="headerlink" title="2.3.1案例需求"></a>2.3.1案例需求</h4><p>​朋友聚会的时候可能会玩一个游戏：逢七过。<br>​        规则是：从任意一个数字开始报数，当你要报的数字包含7或者是7的倍数时都要说：过。<br>​        为了帮助大家更好的玩这个游戏，这里我们直接在控制台打印出1-100之间的满足逢七必过规则的数据。<br>​        这样，大家将来在玩游戏的时候，就知道哪些数据要说：过。</p><h4 id="2-3-2代码实现"><a href="#2-3-2代码实现" class="headerlink" title="2.3.2代码实现"></a>2.3.2代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    思路：</span></span><br><span class="line"><span class="comment">        1:数据在1-100之间，用for循环实现数据的获取</span></span><br><span class="line"><span class="comment">        2:根据规则，用if语句实现数据的判断：要么个位是7，要么十位是7，要么能够被7整除</span></span><br><span class="line"><span class="comment">        3:在控制台输出满足规则的数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//数据在1-100之间，用for循环实现数据的获取</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">1</span>; x&lt;=<span class="number">100</span>; x++) &#123;</span><br><span class="line">            <span class="comment">//根据规则，用if语句实现数据的判断：要么个位是7，要么十位是7，要么能够被7整除</span></span><br><span class="line">            <span class="keyword">if</span>(x%<span class="number">10</span>==<span class="number">7</span> || x/<span class="number">10</span>%<span class="number">10</span>==<span class="number">7</span> || x%<span class="number">7</span>==<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//在控制台输出满足规则的数据</span></span><br><span class="line">                System.out.println(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4不死神兔"><a href="#2-4不死神兔" class="headerlink" title="2.4不死神兔"></a>2.4不死神兔</h3><h4 id="2-4-1案例需求"><a href="#2-4-1案例需求" class="headerlink" title="2.4.1案例需求"></a>2.4.1案例需求</h4><p>​有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第三个月后每个月又生一对兔子，<br>​        假如兔子都不死，问第二十个月的兔子对数为多少？</p><h4 id="2-4-2代码实现"><a href="#2-4-2代码实现" class="headerlink" title="2.4.2代码实现"></a>2.4.2代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   思路：</span></span><br><span class="line"><span class="comment">        1:为了存储多个月的兔子对数，定义一个数组，用动态初始化完成数组元素的初始化，长度为20</span></span><br><span class="line"><span class="comment">        2:因为第1个月，第2个月兔子的对数是已知的，都是1，所以数组的第1个元素，第2个元素值也都是1</span></span><br><span class="line"><span class="comment">        3:用循环实现计算每个月的兔子对数</span></span><br><span class="line"><span class="comment">        4:输出数组中最后一个元素的值，就是第20个月的兔子对数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//为了存储多个月的兔子对数，定义一个数组，用动态初始化完成数组元素的初始化，长度为20</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//因为第1个月，第2个月兔子的对数是已知的，都是1，所以数组的第1个元素，第2个元素值也都是1</span></span><br><span class="line">        arr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        arr[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用循环实现计算每个月的兔子对数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">2</span>; x&lt;arr.length; x++) &#123;</span><br><span class="line">            arr[x] = arr[x-<span class="number">2</span>] + arr[x-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出数组中最后一个元素的值，就是第20个月的兔子对数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;第二十个月兔子的对数是：&quot;</span> + arr[<span class="number">19</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5百钱白鸡"><a href="#2-5百钱白鸡" class="headerlink" title="2.5百钱白鸡"></a>2.5百钱白鸡</h3><h4 id="2-5-1案例需求"><a href="#2-5-1案例需求" class="headerlink" title="2.5.1案例需求"></a>2.5.1案例需求</h4><p>​我国古代数学家张丘建在《算经》一书中提出的数学问题：鸡翁一值钱五，鸡母一值钱三，鸡雏三值钱一。<br>​        百钱买百鸡，问鸡翁、鸡母、鸡雏各几何？</p><h4 id="2-5-2代码实现"><a href="#2-5-2代码实现" class="headerlink" title="2.5.2代码实现"></a>2.5.2代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    思路：</span></span><br><span class="line"><span class="comment">        1:第1层循环，用于表示鸡翁的范围，初始化表达式的变量定义为 x=0，判断条件是x&lt;=20</span></span><br><span class="line"><span class="comment">        2:第2层循环，用于表示鸡母的范围，初始化表达式的变量定义为 y=0，判断条件是y&lt;=33</span></span><br><span class="line"><span class="comment">        3:这个时候，用于表示鸡雏的变量 z = 100 – x – y</span></span><br><span class="line"><span class="comment">        4:判断表达式 z%3==0 和表达式 5*x + 3*y + z/3 = 100 是否同时成立，如果成立，输出对应的 x，y，z 的值，就是对应的鸡翁，鸡母，鸡雏的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//第1层循环，用于表示鸡翁的范围，初始化表达式的变量定义为 x=0，判断条件是x&lt;=20</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>; x&lt;=<span class="number">20</span>; x++) &#123;</span><br><span class="line">            <span class="comment">//第2层循环，用于表示鸡母的范围，初始化表达式的变量定义为 y=0，判断条件是y&lt;=33</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> y=<span class="number">0</span>; y&lt;=<span class="number">33</span>; y++) &#123;</span><br><span class="line">                <span class="comment">//这个时候，用于表示鸡雏的变量 z = 100 – x – y</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">z</span> <span class="operator">=</span> <span class="number">100</span> - x - y;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//判断表达式 z%3==0 和表达式 5*x + 3*y + z/3 = 100 是否同时成立</span></span><br><span class="line">                <span class="keyword">if</span>(z%<span class="number">3</span>==<span class="number">0</span> &amp;&amp; <span class="number">5</span>*x+<span class="number">3</span>*y+z/<span class="number">3</span>==<span class="number">100</span>) &#123;</span><br><span class="line">                    System.out.println(x+<span class="string">&quot;,&quot;</span>+y+<span class="string">&quot;,&quot;</span>+z);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6数组元素求和"><a href="#2-6数组元素求和" class="headerlink" title="2.6数组元素求和"></a>2.6数组元素求和</h3><h4 id="2-6-1案例需求"><a href="#2-6-1案例需求" class="headerlink" title="2.6.1案例需求"></a>2.6.1案例需求</h4><p>​有这样的一个数组，元素是{68,27,95,88,171,996,51,210}。求出该数组中满足要求的元素和，<br>​        要求是：求和的元素个位和十位都不能是7，并且只能是偶数</p><h4 id="2-6-2代码实现"><a href="#2-6-2代码实现" class="headerlink" title="2.6.2代码实现"></a>2.6.2代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   思路：</span></span><br><span class="line"><span class="comment">        1:定义一个数组，用静态初始化完成数组元素的初始化</span></span><br><span class="line"><span class="comment">        2:定义一个求和变量，初始值是0</span></span><br><span class="line"><span class="comment">        3:遍历数组，获取到数组中的每一个元素</span></span><br><span class="line"><span class="comment">        4:判断该元素是否满足条件，如果满足条件就累加</span></span><br><span class="line"><span class="comment">        5:输出求和变量的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test06</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//定义一个数组，用静态初始化完成数组元素的初始化</span></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">68</span>, <span class="number">27</span>, <span class="number">95</span>, <span class="number">88</span>, <span class="number">171</span>, <span class="number">996</span>, <span class="number">51</span>, <span class="number">210</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义一个求和变量，初始值是0</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历数组，获取到数组中的每一个元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>; x&lt;arr.length; x++) &#123;</span><br><span class="line">            <span class="comment">//判断该元素是否满足条件，如果满足条件就累加</span></span><br><span class="line">            <span class="keyword">if</span>(arr[x]%<span class="number">10</span>!=<span class="number">7</span> &amp;&amp; arr[x]/<span class="number">10</span>%<span class="number">10</span>!=<span class="number">7</span> &amp;&amp; arr[x]%<span class="number">2</span>==<span class="number">0</span>) &#123;</span><br><span class="line">                sum += arr[x];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出求和变量的值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;sum:&quot;</span> + sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-7判断两个数组是否相同"><a href="#2-7判断两个数组是否相同" class="headerlink" title="2.7判断两个数组是否相同"></a>2.7判断两个数组是否相同</h3><h4 id="2-7-1案例需求"><a href="#2-7-1案例需求" class="headerlink" title="2.7.1案例需求"></a>2.7.1案例需求</h4><p>​定义一个方法，用于比较两个数组的内容是否相同</p><h4 id="2-7-2代码实现"><a href="#2-7-2代码实现" class="headerlink" title="2.7.2代码实现"></a>2.7.2代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    思路：</span></span><br><span class="line"><span class="comment">        1:定义两个数组，分别使用静态初始化完成数组元素的初始化</span></span><br><span class="line"><span class="comment">        2:定义一个方法，用于比较两个数组的内容是否相同</span></span><br><span class="line"><span class="comment">        3:比较两个数组的内容是否相同，按照下面的步骤实现就可以了</span></span><br><span class="line"><span class="comment">            首先比较数组长度，如果长度不相同，数组内容肯定不相同，返回false</span></span><br><span class="line"><span class="comment">            其次遍历，比较两个数组中的每一个元素，只要有元素不相同，返回false</span></span><br><span class="line"><span class="comment">            最后循环遍历结束后，返回true</span></span><br><span class="line"><span class="comment">        4:调用方法，用变量接收</span></span><br><span class="line"><span class="comment">        5:输出结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test07</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//定义两个数组，分别使用静态初始化完成数组元素的初始化</span></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>&#125;;</span><br><span class="line">        <span class="comment">//int[] arr2 = &#123;11, 22, 33, 44, 55&#125;;</span></span><br><span class="line">        <span class="type">int</span>[] arr2 = &#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用方法，用变量接收</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> compare(arr,arr2);</span><br><span class="line">        <span class="comment">//输出结果</span></span><br><span class="line">        System.out.println(flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个方法，用于比较两个数组的内容是否相同</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        两个明确：</span></span><br><span class="line"><span class="comment">            返回值类型：boolean</span></span><br><span class="line"><span class="comment">            参数：int[] arr, int[] arr2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span>[] arr2)</span> &#123;</span><br><span class="line">        <span class="comment">//首先比较数组长度，如果长度不相同，数组内容肯定不相同，返回false</span></span><br><span class="line">        <span class="keyword">if</span>(arr.length != arr2.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//其次遍历，比较两个数组中的每一个元素，只要有元素不相同，返回false</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>; x&lt;arr.length; x++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[x] != arr2[x]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最后循环遍历结束后，返回true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-8查找元素在数组中出现的索引位置"><a href="#2-8查找元素在数组中出现的索引位置" class="headerlink" title="2.8查找元素在数组中出现的索引位置"></a>2.8查找元素在数组中出现的索引位置</h3><h4 id="2-8-1案例需求"><a href="#2-8-1案例需求" class="headerlink" title="2.8.1案例需求"></a>2.8.1案例需求</h4><p>​已知一个数组 arr &#x3D; {19, 28, 37, 46, 50}; 键盘录入一个数据，查找该数据在数组中的索引。</p><p>​并在控制台输出找到的索引值。如果没有查找到，则输出-1</p><h4 id="2-8-2代码实现"><a href="#2-8-2代码实现" class="headerlink" title="2.8.2代码实现"></a>2.8.2代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    思路：</span></span><br><span class="line"><span class="comment">        1:定义一个数组，用静态初始化完成数组元素的初始化</span></span><br><span class="line"><span class="comment">        2:键盘录入要查找的数据，用一个变量接收</span></span><br><span class="line"><span class="comment">        3:定义一个索引变量，初始值为-1</span></span><br><span class="line"><span class="comment">        4:遍历数组，获取到数组中的每一个元素</span></span><br><span class="line"><span class="comment">        5:拿键盘录入的数据和数组中的每一个元素进行比较，如果值相同，就把该值对应的索引赋值给索引变量,并结束循环</span></span><br><span class="line"><span class="comment">        6:输出索引变量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test08</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//定义一个数组，用静态初始化完成数组元素的初始化</span></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">19</span>, <span class="number">28</span>, <span class="number">37</span>, <span class="number">46</span>, <span class="number">50</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//键盘录入要查找的数据，用一个变量接收</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入要查找的数据：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用方法</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> getIndex(arr, number);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出索引变量</span></span><br><span class="line">        System.out.println(<span class="string">&quot;index: &quot;</span> + index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找指定的数据在数组中的索引</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        两个明确：</span></span><br><span class="line"><span class="comment">            返回值类型：int</span></span><br><span class="line"><span class="comment">            参数：int[] arr, int number</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getIndex</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> number)</span> &#123;</span><br><span class="line">        <span class="comment">//定义一个索引变量，初始值为-1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历数组，获取到数组中的每一个元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>; x&lt;arr.length; x++) &#123;</span><br><span class="line">            <span class="comment">//拿键盘录入的数据和数组中的每一个元素进行比较，如果值相同，就把该值对应的索引赋值给索引变量,并结束循环</span></span><br><span class="line">            <span class="keyword">if</span>(arr[x] == number) &#123;</span><br><span class="line">                index = x;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回索引</span></span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-9数组元素反转"><a href="#2-9数组元素反转" class="headerlink" title="2.9数组元素反转"></a>2.9数组元素反转</h3><h4 id="2-9-1案例需求"><a href="#2-9-1案例需求" class="headerlink" title="2.9.1案例需求"></a>2.9.1案例需求</h4><p>​已知一个数组 arr &#x3D; {19, 28, 37, 46, 50}; 用程序实现把数组中的元素值交换，<br>​        交换后的数组 arr &#x3D; {50, 46, 37, 28, 19}; 并在控制台输出交换后的数组元素。</p><h4 id="2-9-2代码实现"><a href="#2-9-2代码实现" class="headerlink" title="2.9.2代码实现"></a>2.9.2代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    思路：</span></span><br><span class="line"><span class="comment">        1:定义一个数组，用静态初始化完成数组元素的初始化</span></span><br><span class="line"><span class="comment">        2:循环遍历数组，这一次初始化语句定义两个索引变量，判断条件是开始索引小于等于结束索引</span></span><br><span class="line"><span class="comment">        3:变量交换</span></span><br><span class="line"><span class="comment">        4:遍历数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test09</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//定义一个数组，用静态初始化完成数组元素的初始化</span></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">19</span>, <span class="number">28</span>, <span class="number">37</span>, <span class="number">46</span>, <span class="number">50</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用反转的方法</span></span><br><span class="line">        reverse(arr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历数组</span></span><br><span class="line">        printArray(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        两个明确：</span></span><br><span class="line"><span class="comment">            返回值类型：void</span></span><br><span class="line"><span class="comment">            参数：int[] arr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="comment">//循环遍历数组，这一次初始化语句定义两个索引变量，判断条件是开始索引小于等于结束索引</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>, end = arr.length - <span class="number">1</span>; start &lt;= end; start++, end--) &#123;</span><br><span class="line">            <span class="comment">//变量交换</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[start];</span><br><span class="line">            arr[start] = arr[end];</span><br><span class="line">            arr[end] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        两个明确：</span></span><br><span class="line"><span class="comment">            返回值类型：void</span></span><br><span class="line"><span class="comment">            参数：int[] arr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;[&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>; x &lt; arr.length; x++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x == arr.length - <span class="number">1</span>) &#123;</span><br><span class="line">                System.out.print(arr[x]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.print(arr[x] + <span class="string">&quot;, &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-10评委打分"><a href="#2-10评委打分" class="headerlink" title="2.10评委打分"></a>2.10评委打分</h3><h4 id="2-10-1案例需求"><a href="#2-10-1案例需求" class="headerlink" title="2.10.1案例需求"></a>2.10.1案例需求</h4><p>​在编程竞赛中，有6个评委为参赛的选手打分，分数为0-100的整数分。<br>​        选手的最后得分为：去掉一个最高分和一个最低分后 的4个评委平均值 (不考虑小数部分)。</p><h4 id="2-10-2代码实现"><a href="#2-10-2代码实现" class="headerlink" title="2.10.2代码实现"></a>2.10.2代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    思路：</span></span><br><span class="line"><span class="comment">        1:定义一个数组，用动态初始化完成数组元素的初始化，长度为6</span></span><br><span class="line"><span class="comment">        2:键盘录入评委分数</span></span><br><span class="line"><span class="comment">        3:由于是6个评委打分，所以，接收评委分数的操作，用循环改进</span></span><br><span class="line"><span class="comment">        4:定义方法实现获取数组中的最高分(数组最大值)，调用方法</span></span><br><span class="line"><span class="comment">        5:定义方法实现获取数组中的最低分(数组最小值) ，调用方法</span></span><br><span class="line"><span class="comment">        6:定义方法实现获取数组中的所有元素的和(数组元素求和) ，调用方法</span></span><br><span class="line"><span class="comment">        7:按照计算规则进行计算得到平均分</span></span><br><span class="line"><span class="comment">        8:输出平均分</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test10</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//定义一个数组，用动态初始化完成数组元素的初始化，长度为6</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//键盘录入评委分数</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//由于是6个评委打分，所以，接收评委分数的操作，用循环改进</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>; x&lt;arr.length; x++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入第&quot;</span> + (x + <span class="number">1</span>) + <span class="string">&quot;个评委的打分：&quot;</span>);</span><br><span class="line">            arr[x] = sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//printArray(arr);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义方法实现获取数组中的最高分(数组最大值)，调用方法</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> getMax(arr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义方法实现获取数组中的最低分(数组最小值) ，调用方法</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> getMin(arr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义方法实现获取数组中的所有元素的和(数组元素求和) ，调用方法</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> getSum(arr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//按照计算规则进行计算得到平均分</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">avg</span> <span class="operator">=</span> (sum - max - min) / (arr.length - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出平均分</span></span><br><span class="line">        System.out.println(<span class="string">&quot;选手的最终得分是：&quot;</span> + avg);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        两个明确：</span></span><br><span class="line"><span class="comment">            返回值类型：int</span></span><br><span class="line"><span class="comment">            参数：int[] arr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>; x&lt;arr.length; x++) &#123;</span><br><span class="line">            sum += arr[x];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        两个明确：</span></span><br><span class="line"><span class="comment">            返回值类型：int</span></span><br><span class="line"><span class="comment">            参数：int[] arr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">1</span>; x&lt;arr.length; x++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[x] &lt; min) &#123;</span><br><span class="line">                min = arr[x];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        两个明确：</span></span><br><span class="line"><span class="comment">            返回值类型：int</span></span><br><span class="line"><span class="comment">            参数：int[] arr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getMax</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">1</span>; x&lt;arr.length; x++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[x] &gt; max) &#123;</span><br><span class="line">                max = arr[x];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;[&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>; x &lt; arr.length; x++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x == arr.length - <span class="number">1</span>) &#123;</span><br><span class="line">                System.out.print(arr[x]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.print(arr[x] + <span class="string">&quot;, &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> java,基础语法,Debug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>day05 - 方法</title>
      <link href="/post/bb00120e.html"/>
      <url>/post/bb00120e.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-方法概述"><a href="#1-方法概述" class="headerlink" title="1. 方法概述"></a>1. 方法概述</h2><h3 id="1-1-方法的概念（理解）"><a href="#1-1-方法的概念（理解）" class="headerlink" title="1.1 方法的概念（理解）"></a>1.1 方法的概念（理解）</h3><p>​方法（method）是将具有独立功能的代码块组织成为一个整体，使其具有特殊功能的代码集</p><ul><li>注意：<ul><li>方法必须先创建才可以使用，该过程成为方法定义</li><li>方法创建后并不是直接可以运行的，需要手动使用后，才执行，该过程成为方法调用</li></ul></li></ul><h2 id="2-方法的定义和调用"><a href="#2-方法的定义和调用" class="headerlink" title="2. 方法的定义和调用"></a>2. 方法的定义和调用</h2><h3 id="2-1-无参数方法定义和调用（掌握）"><a href="#2-1-无参数方法定义和调用（掌握）" class="headerlink" title="2.1 无参数方法定义和调用（掌握）"></a>2.1 无参数方法定义和调用（掌握）</h3><ul><li><p>定义格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> 方法名 (   ) &#123;</span><br><span class="line"><span class="comment">// 方法体;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>范例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span> <span class="params">(    )</span> &#123;</span><br><span class="line"><span class="comment">// 方法体;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>调用格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方法名();</span><br></pre></td></tr></table></figure></li><li><p>范例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">method();</span><br></pre></td></tr></table></figure></li><li><p>注意：</p><p>​方法必须先定义，后调用，否则程序将报错</p></li></ul><h3 id="2-2-方法调用过程图解（理解）"><a href="#2-2-方法调用过程图解（理解）" class="headerlink" title="2.2 方法调用过程图解（理解）"></a>2.2 方法调用过程图解（理解）</h3><ul><li>总结：每个方法在被调用执行的时候，都会进入栈内存，并且拥有自己独立的内存空间，方法内部代码调用完毕之后，会从栈内存中弹栈消失。</li></ul><h3 id="2-3-无参数方法的练习（应用）"><a href="#2-3-无参数方法的练习（应用）" class="headerlink" title="2.3 无参数方法的练习（应用）"></a>2.3 无参数方法的练习（应用）</h3><ul><li>需求：设计一个方法用于打印两个数中的较大数 </li><li>思路：<ul><li>①定义一个方法，用于打印两个数字中的较大数，例如getMax() </li><li>②方法中定义两个变量，用于保存两个数字 </li><li>③使用分支语句分两种情况对两个数字的大小关系进行处理 </li><li>④在main()方法中调用定义好的方法</li></ul></li><li>代码：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//在main()方法中调用定义好的方法</span></span><br><span class="line">        getMax();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个方法，用于打印两个数字中的较大数，例如getMax()</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getMax</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//方法中定义两个变量，用于保存两个数字</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用分支语句分两种情况对两个数字的大小关系进行处理</span></span><br><span class="line">        <span class="keyword">if</span>(a &gt; b) &#123;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-带参数方法定义和调用"><a href="#3-带参数方法定义和调用" class="headerlink" title="3. 带参数方法定义和调用"></a>3. 带参数方法定义和调用</h2><h3 id="3-1-带参数方法定义和调用（掌握）"><a href="#3-1-带参数方法定义和调用（掌握）" class="headerlink" title="3.1 带参数方法定义和调用（掌握）"></a>3.1 带参数方法定义和调用（掌握）</h3><ul><li><p>定义格式：</p><p>参数：由数据类型和变量名组成 -  数据类型 变量名</p><p>参数范例：int a</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> 方法名 (参数<span class="number">1</span>) &#123;</span><br><span class="line">方法体;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> 方法名 (参数<span class="number">1</span>, 参数<span class="number">2</span>, 参数<span class="number">3.</span>..) &#123;</span><br><span class="line">方法体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>范例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">isEvenNumber</span><span class="params">(<span class="type">int</span> number)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getMax</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>注意：</p><pre><code>  方法定义时，参数中的数据类型与变量名都不能缺少，缺少任意一个程序将报错      方法定义时，多个参数之间使用逗号( ，)分隔</code></pre></li></ul></li><li><p>调用格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方法名(参数)；</span><br><span class="line"></span><br><span class="line">方法名(参数<span class="number">1</span>,参数<span class="number">2</span>);</span><br></pre></td></tr></table></figure></li><li><p>范例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">isEvenNumber(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">getMax(<span class="number">10</span>,<span class="number">20</span>);</span><br></pre></td></tr></table></figure><ul><li>方法调用时，参数的数量与类型必须与方法定义中的设置相匹配，否则程序将报错</li></ul></li></ul><h3 id="3-2-形参和实参（理解）"><a href="#3-2-形参和实参（理解）" class="headerlink" title="3.2 形参和实参（理解）"></a>3.2 形参和实参（理解）</h3><ol><li>形参：方法定义中的参数</li></ol><p>​          等同于变量定义格式，例如：int number</p><ol start="2"><li>实参：方法调用中的参数</li></ol><p>​          等同于使用变量或常量，例如： 10  number</p><h3 id="3-3-带参数方法练习（应用）"><a href="#3-3-带参数方法练习（应用）" class="headerlink" title="3.3 带参数方法练习（应用）"></a>3.3 带参数方法练习（应用）</h3><ul><li>需求：设计一个方法用于打印两个数中的较大数，数据来自于方法参数 }</li><li>思路：<ul><li>①定义一个方法，用于打印两个数字中的较大数，例如getMax() </li><li>②为方法定义两个参数，用于接收两个数字 </li><li>③使用分支语句分两种情况对两个数字的大小关系进行处理 </li><li>④在main()方法中调用定义好的方法（使用常量）</li><li>⑤在main()方法中调用定义好的方法（使用变量）</li></ul></li><li>代码：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//在main()方法中调用定义好的方法（使用常量）</span></span><br><span class="line">        getMax(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">        <span class="comment">//调用方法的时候，人家要几个，你就给几个，人家要什么类型的，你就给什么类型的</span></span><br><span class="line">        <span class="comment">//getMax(30);</span></span><br><span class="line">        <span class="comment">//getMax(10.0,20.0);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//在main()方法中调用定义好的方法（使用变量）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">        getMax(a, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个方法，用于打印两个数字中的较大数，例如getMax()</span></span><br><span class="line">    <span class="comment">//为方法定义两个参数，用于接收两个数字</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getMax</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="comment">//使用分支语句分两种情况对两个数字的大小关系进行处理</span></span><br><span class="line">        <span class="keyword">if</span>(a &gt; b) &#123;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-带返回值方法的定义和调用"><a href="#4-带返回值方法的定义和调用" class="headerlink" title="4. 带返回值方法的定义和调用"></a>4. 带返回值方法的定义和调用</h2><h3 id="4-1-带返回值方法定义和调用（掌握）"><a href="#4-1-带返回值方法定义和调用（掌握）" class="headerlink" title="4.1 带返回值方法定义和调用（掌握）"></a>4.1 带返回值方法定义和调用（掌握）</h3><ul><li><p>定义格式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> 数据类型 方法名 ( 参数 ) &#123; </span><br><span class="line"><span class="keyword">return</span> 数据 ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>范例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isEvenNumber</span><span class="params">( <span class="type">int</span> number )</span> &#123;           </span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getMax</span><span class="params">( <span class="type">int</span> a, <span class="type">int</span> b )</span> &#123;</span><br><span class="line"><span class="keyword">return</span>  <span class="number">100</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意：<ul><li>方法定义时return后面的返回值与方法定义上的数据类型要匹配，否则程序将报错</li></ul></li></ul></li><li><p>调用格式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方法名 ( 参数 ) ;</span><br><span class="line">数据类型 变量名 = 方法名 ( 参数 ) ;</span><br></pre></td></tr></table></figure></li><li><p>范例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">isEvenNumber ( <span class="number">5</span> ) ;</span><br><span class="line"><span class="type">boolean</span>  <span class="variable">flag</span> <span class="operator">=</span>  isEvenNumber ( <span class="number">5</span> ); </span><br></pre></td></tr></table></figure><ul><li>注意：<ul><li>方法的返回值通常会使用变量接收，否则该返回值将无意义</li></ul></li></ul></li></ul><h3 id="4-2-带返回值方法练习（应用）"><a href="#4-2-带返回值方法练习（应用）" class="headerlink" title="4.2 带返回值方法练习（应用）"></a>4.2 带返回值方法练习（应用）</h3><ul><li><p>需求：设计一个方法可以获取两个数的较大值，数据来自于参数</p></li><li><p>思路：</p><ul><li>①定义一个方法，用于获取两个数字中的较大数 </li><li>②使用分支语句分两种情况对两个数字的大小关系进行处理 </li><li>③根据题设分别设置两种情况下对应的返回结果 </li><li>④在main()方法中调用定义好的方法并使用变量保存 </li><li>⑤在main()方法中调用定义好的方法并直接打印结果</li></ul></li><li><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//在main()方法中调用定义好的方法并使用变量保存</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> getMax(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在main()方法中调用定义好的方法并直接打印结果</span></span><br><span class="line">        System.out.println(getMax(<span class="number">10</span>,<span class="number">20</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个方法，用于获取两个数字中的较大数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getMax</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="comment">//使用分支语句分两种情况对两个数字的大小关系进行处理</span></span><br><span class="line">        <span class="comment">//根据题设分别设置两种情况下对应的返回结果</span></span><br><span class="line">        <span class="keyword">if</span>(a &gt; b) &#123;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="5-方法的注意事项"><a href="#5-方法的注意事项" class="headerlink" title="5. 方法的注意事项"></a>5. 方法的注意事项</h2><h3 id="5-1-方法的注意事项（掌握）"><a href="#5-1-方法的注意事项（掌握）" class="headerlink" title="5.1 方法的注意事项（掌握）"></a>5.1 方法的注意事项（掌握）</h3><ul><li><p>方法不能嵌套定义</p><ul><li><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">methodOne</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">methodTwo</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">// 这里会引发编译错误!!!</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>void表示无返回值，可以省略return，也可以单独的书写return，后面不加数据</p><ul><li><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">methodTwo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//return 100; 编译错误，因为没有具体返回值类型</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//System.out.println(100); return语句后面不能跟数据或代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="5-2-方法的通用格式（掌握）"><a href="#5-2-方法的通用格式（掌握）" class="headerlink" title="5.2 方法的通用格式（掌握）"></a>5.2 方法的通用格式（掌握）</h3><ul><li><p>格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> 返回值类型 方法名(参数) &#123;</span><br><span class="line">   方法体; </span><br><span class="line">   <span class="keyword">return</span> 数据 ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>解释：</p><ul><li><p>public static 修饰符，目前先记住这个格式</p><p>   返回值类型方法操作完毕之后返回的数据的数据类型</p><p>​如果方法操作完毕，没有数据返回，这里写void，而且方法体中一般不写return</p><p>   方法名调用方法时候使用的标识</p><p>   参数由数据类型和变量名组成，多个参数之间用逗号隔开</p><p>   方法体完成功能的代码块</p><p>   return如果方法操作完毕，有数据返回，用于把数据返回给调用者</p></li></ul></li><li><p>定义方法时，要做到两个明确</p><ul><li>明确返回值类型：主要是明确方法操作完毕之后是否有数据返回，如果没有，写void；如果有，写对应的数据类型</li><li>明确参数：主要是明确参数的类型和数量</li></ul></li><li><p>调用方法时的注意：</p><ul><li>void类型的方法，直接调用即可</li><li>非void类型的方法，推荐用变量接收调用</li></ul></li></ul><h2 id="6-方法重载"><a href="#6-方法重载" class="headerlink" title="6. 方法重载"></a>6. 方法重载</h2><h3 id="6-1-方法重载（理解）"><a href="#6-1-方法重载（理解）" class="headerlink" title="6.1 方法重载（理解）"></a>6.1 方法重载（理解）</h3><ul><li><p>方法重载概念</p><p>方法重载指同一个类中定义的多个方法之间的关系，满足下列条件的多个方法相互构成重载</p><ul><li>多个方法在同一个类中</li><li>多个方法具有相同的方法名</li><li>多个方法的参数不相同，类型不同或者数量不同</li></ul></li><li><p>注意：</p><ul><li>重载仅对应方法的定义，与方法的调用无关，调用方式参照标准格式</li><li>重载仅针对同一个类中方法的名称与参数进行识别，与返回值无关，换句话说不能通过返回值来判定两个方法是否相互构成重载</li></ul></li><li><p>正确范例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodDemo</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fn</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">    <span class="comment">//方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fn</span><span class="params">(<span class="type">double</span> a)</span> &#123;</span><br><span class="line">    <span class="comment">//方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodDemo</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">float</span> <span class="title function_">fn</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">    <span class="comment">//方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fn</span><span class="params">(<span class="type">int</span> a , <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="comment">//方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>错误范例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodDemo</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fn</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">    <span class="comment">//方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fn</span><span class="params">(<span class="type">int</span> a)</span> &#123; <span class="comment">/*错误原因：重载与返回值无关*/</span></span><br><span class="line">    <span class="comment">//方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fn</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">        <span class="comment">//方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fn</span><span class="params">(<span class="type">double</span> a)</span> &#123; <span class="comment">/*错误原因：这是两个类的两个fn方法*/</span></span><br><span class="line">        <span class="comment">//方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="6-2-方法重载练习（掌握）"><a href="#6-2-方法重载练习（掌握）" class="headerlink" title="6.2 方法重载练习（掌握）"></a>6.2 方法重载练习（掌握）</h3><ul><li><p>需求：使用方法重载的思想，设计比较两个整数是否相同的方法，兼容全整数类型（byte,short,int,long） </p></li><li><p>思路：</p><ul><li>①定义比较两个数字的是否相同的方法compare()方法，参数选择两个int型参数</li><li>②定义对应的重载方法，变更对应的参数类型，参数变更为两个long型参数</li><li>③定义所有的重载方法，两个byte类型与两个short类型参数 </li><li>④完成方法的调用，测试运行结果</li></ul></li><li><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//调用方法</span></span><br><span class="line">        System.out.println(compare(<span class="number">10</span>, <span class="number">20</span>));</span><br><span class="line">        System.out.println(compare((<span class="type">byte</span>) <span class="number">10</span>, (<span class="type">byte</span>) <span class="number">20</span>));</span><br><span class="line">        System.out.println(compare((<span class="type">short</span>) <span class="number">10</span>, (<span class="type">short</span>) <span class="number">20</span>));</span><br><span class="line">        System.out.println(compare(<span class="number">10L</span>, <span class="number">20L</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//int</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;int&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> a == b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//byte</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(<span class="type">byte</span> a, <span class="type">byte</span> b)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;byte&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> a == b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//short</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(<span class="type">short</span> a, <span class="type">short</span> b)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;short&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> a == b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//long</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(<span class="type">long</span> a, <span class="type">long</span> b)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;long&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> a == b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="7-方法的参数传递"><a href="#7-方法的参数传递" class="headerlink" title="7. 方法的参数传递"></a>7. 方法的参数传递</h2><h3 id="7-1-方法参数传递基本类型（理解）"><a href="#7-1-方法参数传递基本类型（理解）" class="headerlink" title="7.1 方法参数传递基本类型（理解）"></a>7.1 方法参数传递基本类型（理解）</h3><ul><li><p>测试代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArgsDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用change方法前：&quot;</span> + number);</span><br><span class="line">        change(number);</span><br><span class="line">        System.out.println(<span class="string">&quot;调用change方法后：&quot;</span> + number);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">        number = <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>结论：</p><ul><li>基本数据类型的参数，形式参数的改变，不影响实际参数</li></ul></li><li><p>结论依据：</p><ul><li>每个方法在栈内存中，都会有独立的栈空间，方法运行结束后就会弹栈消失</li></ul></li></ul><h3 id="7-2-方法参数传递引用类型（理解）"><a href="#7-2-方法参数传递引用类型（理解）" class="headerlink" title="7.2 方法参数传递引用类型（理解）"></a>7.2 方法参数传递引用类型（理解）</h3><ul><li><p>测试代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArgsDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用change方法前：&quot;</span> + arr[<span class="number">1</span>]);</span><br><span class="line">        change(arr);</span><br><span class="line">        System.out.println(<span class="string">&quot;调用change方法后：&quot;</span> + arr[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        arr[<span class="number">1</span>] = <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>结论：</p><ul><li>**对于引用类型的参数，形式参数的改变，影响实际参数的值 **</li></ul></li><li><p>结论依据：</p><ul><li>引用数据类型的传参，传入的是<strong>地址值</strong>，内存中会造成两个引用指向同一个内存的效果，所以即使方法弹栈，堆内存中的数据也已经是改变后的结果</li></ul></li></ul><h3 id="7-3-数组遍历（应用）"><a href="#7-3-数组遍历（应用）" class="headerlink" title="7.3 数组遍历（应用）"></a>7.3 数组遍历（应用）</h3><ul><li><p>需求：设计一个方法用于数组遍历，要求遍历的结果是在一行上的。例如：[11, 22, 33, 44, 55] </p></li><li><p>思路：</p><ul><li><p>①因为要求结果在一行上输出，所以这里需要在学习一个新的输出语句System.out.print(“内容”);</p><p>System.out.println(“内容”); 输出内容并换行</p><p>System.out.print(“内容”); 输出内容不换行</p><p>System.out.println(); 起到换行的作用</p></li><li><p>②定义一个数组，用静态初始化完成数组元素初始化</p></li><li><p>③定义一个方法，用数组遍历通用格式对数组进行遍历</p></li><li><p>④用新的输出语句修改遍历操作</p></li><li><p>⑤调用遍历方法</p></li></ul></li><li><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodTest01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//定义一个数组，用静态初始化完成数组元素初始化</span></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用方法</span></span><br><span class="line">        printArray(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个方法，用数组遍历通用格式对数组进行遍历</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        两个明确：</span></span><br><span class="line"><span class="comment">            返回值类型：void</span></span><br><span class="line"><span class="comment">            参数：int[] arr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;[&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>; x&lt;arr.length; x++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(x == arr.length-<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.print(arr[x]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.print(arr[x]+<span class="string">&quot;, &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="7-4-数组最大值（应用）"><a href="#7-4-数组最大值（应用）" class="headerlink" title="7.4 数组最大值（应用）"></a>7.4 数组最大值（应用）</h3><ul><li><p>需求：设计一个方法用于获取数组中元素的最大值 </p></li><li><p>思路：</p><ul><li>①定义一个数组，用静态初始化完成数组元素初始化</li><li>②定义一个方法，用来获取数组中的最大值，最值的认知和讲解我们在数组中已经讲解过了</li><li>③调用获取最大值方法，用变量接收返回结果</li><li>④把结果输出在控制台</li></ul></li><li><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodTest02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//定义一个数组，用静态初始化完成数组元素初始化</span></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">12</span>, <span class="number">45</span>, <span class="number">98</span>, <span class="number">73</span>, <span class="number">60</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用获取最大值方法，用变量接收返回结果</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> getMax(arr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把结果输出在控制台</span></span><br><span class="line">        System.out.println(<span class="string">&quot;number:&quot;</span> + number);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个方法，用来获取数组中的最大值</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        两个明确：</span></span><br><span class="line"><span class="comment">            返回值类型：int</span></span><br><span class="line"><span class="comment">            参数：int[] arr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getMax</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">1</span>; x&lt;arr.length; x++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[x] &gt; max) &#123;</span><br><span class="line">                max = arr[x];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> java,基础语法,方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>day04 - 数组</title>
      <link href="/post/305c640.html"/>
      <url>/post/305c640.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-数组"><a href="#1-数组" class="headerlink" title="1.数组"></a>1.数组</h2><h3 id="1-1什么是数组【理解】"><a href="#1-1什么是数组【理解】" class="headerlink" title="1.1什么是数组【理解】"></a>1.1什么是数组【理解】</h3><p>​数组就是存储数据长度固定的容器，存储多个数据的数据类型要一致。 </p><h3 id="1-2数组定义格式【记忆】"><a href="#1-2数组定义格式【记忆】" class="headerlink" title="1.2数组定义格式【记忆】"></a>1.2数组定义格式【记忆】</h3><h4 id="1-2-1第一种"><a href="#1-2-1第一种" class="headerlink" title="1.2.1第一种"></a>1.2.1第一种</h4><p>​数据类型[] 数组名</p><p>​示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr;        </span><br><span class="line"><span class="type">double</span>[] arr;      </span><br><span class="line"><span class="type">char</span>[] arr;</span><br></pre></td></tr></table></figure><h4 id="1-2-2第二种"><a href="#1-2-2第二种" class="headerlink" title="1.2.2第二种"></a>1.2.2第二种</h4><p>​数据类型 数组名[]</p><p>​示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[];</span><br><span class="line"><span class="type">double</span> arr[];</span><br><span class="line"><span class="type">char</span> arr[];</span><br></pre></td></tr></table></figure><h3 id="1-3数组动态初始化【应用】"><a href="#1-3数组动态初始化【应用】" class="headerlink" title="1.3数组动态初始化【应用】"></a>1.3数组动态初始化【应用】</h3><h4 id="1-3-1什么是动态初始化"><a href="#1-3-1什么是动态初始化" class="headerlink" title="1.3.1什么是动态初始化"></a>1.3.1什么是动态初始化</h4><p>​数组动态初始化就是只给定数组的长度，由系统给出默认初始化值。</p><h4 id="1-3-2动态初始化格式"><a href="#1-3-2动态初始化格式" class="headerlink" title="1.3.2动态初始化格式"></a>1.3.2动态初始化格式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数据类型[] 数组名 = <span class="keyword">new</span> 数据类型[数组长度];</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br></pre></td></tr></table></figure><h4 id="1-3-3动态初始化格式详解"><a href="#1-3-3动态初始化格式详解" class="headerlink" title="1.3.3动态初始化格式详解"></a>1.3.3动态初始化格式详解</h4><ul><li><p>等号左边：</p><ul><li><p>int:数组的数据类型</p></li><li><p>[]:代表这是一个数组</p></li><li><p>arr:代表数组的名称</p></li></ul></li><li><p>等号右边：</p></li><li><p>new:为数组开辟内存空间</p></li><li><p>int:数组的数据类型</p></li><li><p>[]:代表这是一个数组</p></li><li><p>5:代表数组的长度</p></li></ul><h3 id="1-4数组元素访问【应用】"><a href="#1-4数组元素访问【应用】" class="headerlink" title="1.4数组元素访问【应用】"></a>1.4数组元素访问【应用】</h3><h4 id="1-4-1什么是索引"><a href="#1-4-1什么是索引" class="headerlink" title="1.4.1什么是索引"></a>1.4.1什么是索引</h4><p>​每一个存储到数组的元素，都会自动的拥有一个编号，从0开始。</p><p>​这个自动编号称为数组索引(index)，可以通过数组的索引访问到数组中的元素。 </p><h4 id="1-4-2访问数组元素格式"><a href="#1-4-2访问数组元素格式" class="headerlink" title="1.4.2访问数组元素格式"></a>1.4.2访问数组元素格式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数组名[索引];</span><br></pre></td></tr></table></figure><h4 id="1-4-3示例代码"><a href="#1-4-3示例代码" class="headerlink" title="1.4.3示例代码"></a>1.4.3示例代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出数组名</span></span><br><span class="line">        System.out.println(arr); <span class="comment">//[I@880ec60</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出数组中的元素</span></span><br><span class="line">        System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">        System.out.println(arr[<span class="number">1</span>]);</span><br><span class="line">        System.out.println(arr[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5内存分配【理解】"><a href="#1-5内存分配【理解】" class="headerlink" title="1.5内存分配【理解】"></a>1.5内存分配【理解】</h3><h4 id="1-5-1内存概述"><a href="#1-5-1内存概述" class="headerlink" title="1.5.1内存概述"></a>1.5.1内存概述</h4><p>​内存是计算机中的重要原件，临时存储区域，作用是运行程序。</p><p>​我们编写的程序是存放在硬盘中的，在硬盘中的程序是不会运行的。</p><p>​必须放进内存中才能运行，运行完毕后会清空内存。 </p><p>​Java虚拟机要运行程序，必须要对内存进行空间的分配和管理。 </p><h4 id="1-5-2java中的内存分配"><a href="#1-5-2java中的内存分配" class="headerlink" title="1.5.2java中的内存分配"></a>1.5.2java中的内存分配</h4><ul><li>目前我们只需要记住两个内存，分别是：栈内存和堆内存</li></ul><table><thead><tr><th>区域名称</th><th>作用</th></tr></thead><tbody><tr><td>寄存器</td><td>给CPU使用，和我们开发无关。</td></tr><tr><td>本地方法栈</td><td>JVM在使用操作系统功能的时候使用，和我们开发无关。</td></tr><tr><td>方法区</td><td>存储可以运行的class文件。</td></tr><tr><td>堆内存</td><td>存储对象或者数组，new来创建的，都存储在堆内存。</td></tr><tr><td>方法栈</td><td>方法运行时使用的内存，比如main方法运行，进入方法栈中执行。</td></tr></tbody></table><h3 id="1-6单个数组的内存图【理解】"><a href="#1-6单个数组的内存图【理解】" class="headerlink" title="1.6单个数组的内存图【理解】"></a>1.6单个数组的内存图【理解】</h3><h3 id="1-7多个数组的内存图【理解】"><a href="#1-7多个数组的内存图【理解】" class="headerlink" title="1.7多个数组的内存图【理解】"></a>1.7多个数组的内存图【理解】</h3><h3 id="1-8多个数组指向相同内存图【理解】"><a href="#1-8多个数组指向相同内存图【理解】" class="headerlink" title="1.8多个数组指向相同内存图【理解】"></a>1.8多个数组指向相同内存图【理解】</h3><h3 id="1-9数组静态初始化【应用】"><a href="#1-9数组静态初始化【应用】" class="headerlink" title="1.9数组静态初始化【应用】"></a>1.9数组静态初始化【应用】</h3><h4 id="1-9-1什么是静态初始化"><a href="#1-9-1什么是静态初始化" class="headerlink" title="1.9.1什么是静态初始化"></a>1.9.1什么是静态初始化</h4><p>​在创建数组时，直接将元素确定</p><h4 id="1-9-2静态初始化格式"><a href="#1-9-2静态初始化格式" class="headerlink" title="1.9.2静态初始化格式"></a>1.9.2静态初始化格式</h4><ul><li><p>完整版格式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数据类型[] 数组名 = <span class="keyword">new</span> 数据类型[]&#123;元素<span class="number">1</span>,元素<span class="number">2</span>,...&#125;;</span><br></pre></td></tr></table></figure></li><li><p>简化版格式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数据类型[] 数组名 = &#123;元素<span class="number">1</span>,元素<span class="number">2</span>,...&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="1-9-3示例代码"><a href="#1-9-3示例代码" class="headerlink" title="1.9.3示例代码"></a>1.9.3示例代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//定义数组</span></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出数组名</span></span><br><span class="line">        System.out.println(arr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出数组中的元素</span></span><br><span class="line">        System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">        System.out.println(arr[<span class="number">1</span>]);</span><br><span class="line">        System.out.println(arr[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-10数组操作的两个常见小问题【应用】"><a href="#1-10数组操作的两个常见小问题【应用】" class="headerlink" title="1.10数组操作的两个常见小问题【应用】"></a>1.10数组操作的两个常见小问题【应用】</h3><h4 id="1-10-1索引越界异常"><a href="#1-10-1索引越界异常" class="headerlink" title="1.10.1索引越界异常"></a>1.10.1索引越界异常</h4><ul><li><p>出现原因</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">        System.out.println(arr[<span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组长度为3，索引范围是0~2，但是我们却访问了一个3的索引。</p><p>程序运行后，将会抛出ArrayIndexOutOfBoundsException 数组越界异常。在开发中，数组的越界异常是不能出现的，一旦出现了，就必须要修改我们编写的代码。 </p></li><li><p>解决方案</p><p>将错误的索引修改为正确的索引范围即可！</p></li></ul><h4 id="1-10-2空指针异常"><a href="#1-10-2空指针异常" class="headerlink" title="1.10.2空指针异常"></a>1.10.2空指针异常</h4><ul><li><p>出现原因</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把null赋值给数组</span></span><br><span class="line">        arr = <span class="literal">null</span>;</span><br><span class="line">        System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>arr &#x3D; null 这行代码，意味着变量arr将不会再保存数组的内存地址，也就不允许再操作数组了，因此运行的时候会抛出 NullPointerException 空指针异常。在开发中，数组的越界异常是不能出现的，一旦出现了，就必须要修改我们编写的代码。</p></li><li><p>解决方案</p><p>给数组一个真正的堆内存空间引用即可！</p></li></ul><h3 id="1-11数组遍历【应用】"><a href="#1-11数组遍历【应用】" class="headerlink" title="1.11数组遍历【应用】"></a>1.11数组遍历【应用】</h3><ul><li><p>数组遍历：就是将数组中的每个元素分别获取出来，就是遍历。遍历也是数组操作中的基石。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayTest01</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">System.out.println(arr[<span class="number">1</span>]);</span><br><span class="line">System.out.println(arr[<span class="number">2</span>]);</span><br><span class="line">System.out.println(arr[<span class="number">3</span>]);</span><br><span class="line">System.out.println(arr[<span class="number">4</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码是可以将数组中每个元素全部遍历出来，但是如果数组元素非常多，这种写法肯定不行，因此我们需要改造成循环的写法。数组的索引是 0 到 lenght-1 ，可以作为循环的条件出现。 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayTest01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//定义数组</span></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用通用的遍历格式</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>; x &lt; arr.length; x++) &#123;</span><br><span class="line">            System.out.println(arr[x]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-12数组最值【应用】"><a href="#1-12数组最值【应用】" class="headerlink" title="1.12数组最值【应用】"></a>1.12数组最值【应用】</h3><ul><li><p>最大值获取：从数组的所有元素中找出最大值。</p></li><li><p>实现思路：</p><ul><li>定义变量，保存数组0索引上的元素</li><li>遍历数组，获取出数组中的每个元素</li><li>将遍历到的元素和保存数组0索引上值的变量进行比较</li><li>如果数组元素的值大于了变量的值，变量记录住新的值</li><li>数组循环遍历结束，变量保存的就是数组中的最大值</li></ul></li><li><p>代码实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayTest02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//定义数组</span></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">12</span>, <span class="number">45</span>, <span class="number">98</span>, <span class="number">73</span>, <span class="number">60</span>&#125;;</span><br><span class="line">        <span class="comment">//定义一个变量，用于保存最大值</span></span><br><span class="line">        <span class="comment">//取数组中第一个数据作为变量的初始值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//与数组中剩余的数据逐个比对，每次比对将最大值保存到变量中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">1</span>; x&lt;arr.length; x++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[x] &gt; max) &#123;</span><br><span class="line">                max = arr[x];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//循环结束后打印变量的值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;max:&quot;</span> + max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> java,基础语法,数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>day03 - 循环</title>
      <link href="/post/979f52f0.html"/>
      <url>/post/979f52f0.html</url>
      
        <content type="html"><![CDATA[<h2 id="1、流程控制语句（应用）"><a href="#1、流程控制语句（应用）" class="headerlink" title="1、流程控制语句（应用）"></a>1、流程控制语句（应用）</h2><p>在一个程序执行的过程中，各条语句的执行顺序对程序的结果是有直接影响的。所以，我们必须清楚每条语句的执行流程。而且，很多时候要通过控制语句的执行顺序来实现我们想要的功能。</p><h3 id="1-1-流程控制语句分类"><a href="#1-1-流程控制语句分类" class="headerlink" title="1.1 流程控制语句分类"></a>1.1 流程控制语句分类</h3><p>​顺序结构</p><p>​分支结构(if, switch)</p><p>​循环结构(for, while, do…while)</p><h3 id="1-2-顺序结构"><a href="#1-2-顺序结构" class="headerlink" title="1.2 顺序结构"></a>1.2 顺序结构</h3><p>顺序结构是程序中最简单最基本的流程控制，没有特定的语法结构，按照代码的先后顺序，依次执行，程序中大多数的代码都是这样执行的。</p><h3 id="1-3-分支结构：if语句"><a href="#1-3-分支结构：if语句" class="headerlink" title="1.3 分支结构：if语句"></a>1.3 分支结构：if语句</h3><h4 id="if语句格式1"><a href="#if语句格式1" class="headerlink" title="if语句格式1"></a>if语句格式1</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line"><span class="keyword">if</span> (关系表达式) &#123;</span><br><span class="line">    语句体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行流程：</p><p>①首先计算关系表达式的值</p><p>②如果关系表达式的值为true就执行语句体</p><p>③如果关系表达式的值为false就不执行语句体</p><p>④继续执行后面的语句内容</p><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IfDemo</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;开始&quot;</span>);</span><br><span class="line"><span class="comment">//定义两个变量</span></span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="comment">//需求：判断a和b的值是否相等，如果相等，就在控制台输出：a等于b</span></span><br><span class="line"><span class="keyword">if</span>(a == b) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;a等于b&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//需求：判断a和c的值是否相等，如果相等，就在控制台输出：a等于c</span></span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span>(a == c) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;a等于c&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="if语句格式2"><a href="#if语句格式2" class="headerlink" title="if语句格式2"></a>if语句格式2</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line"><span class="keyword">if</span> (关系表达式) &#123;</span><br><span class="line">    语句体<span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    语句体<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行流程：</p><p>①首先计算关系表达式的值</p><p>②如果关系表达式的值为true就执行语句体1</p><p>③如果关系表达式的值为false就执行语句体2</p><p>④继续执行后面的语句内容</p><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IfDemo02</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;开始&quot;</span>);</span><br><span class="line"><span class="comment">//定义两个变量</span></span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">b = <span class="number">5</span>;</span><br><span class="line"><span class="comment">//需求：判断a是否大于b，如果是，在控制台输出：a的值大于b，否则，在控制台输出：a的值不大于b</span></span><br><span class="line"><span class="keyword">if</span>(a &gt; b) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;a的值大于b&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;a的值不大于b&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>if语句案例：奇偶数</p><p>需求：任意给出一个整数，请用程序实现判断该整数是奇数还是偶数，并在控制台输出该整数是奇数还是偶数。</p><p>分析：</p><p>​①为了体现任意给出一个整数，采用键盘录入一个数据</p><p>​②判断整数是偶数还是奇数要分两种情况进行判断，使用if..else结构</p><p>​③判断是否偶数需要使用取余运算符实现该功能 number % 2 &#x3D;&#x3D; 0</p><p>​④根据判定情况，在控制台输出对应的内容</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IfTest01</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//为了体现任意给出一个整数，采用键盘录入一个数据。(导包，创建对象，接收数据)</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">System.out.println(<span class="string">&quot;请输入一个整数：&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"><span class="comment">//判断整数是偶数还是奇数要分两种情况进行判断，使用if..else结构</span></span><br><span class="line"><span class="comment">//判断是否偶数需要使用取余运算符实现该功能 number % 2 == 0</span></span><br><span class="line"><span class="comment">//根据判定情况，在控制台输出对应的内容</span></span><br><span class="line"><span class="keyword">if</span>(number%<span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">System.out.println(number + <span class="string">&quot;是偶数&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(number + <span class="string">&quot;是奇数&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="if语句格式3"><a href="#if语句格式3" class="headerlink" title="if语句格式3"></a>if语句格式3</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line"><span class="keyword">if</span> (关系表达式<span class="number">1</span>) &#123;</span><br><span class="line">    语句体<span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (关系表达式<span class="number">2</span>) &#123;</span><br><span class="line">    语句体<span class="number">2</span>;</span><br><span class="line">&#125; </span><br><span class="line">…</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    语句体n+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行流程：</p><p>①首先计算关系表达式1的值</p><p>②如果值为true就执行语句体1；如果值为false就计算关系表达式2的值</p><p>③如果值为true就执行语句体2；如果值为false就计算关系表达式3的值</p><p>④…</p><p>⑤如果没有任何关系表达式为true，就执行语句体n+1。</p><p>示例：键盘录入一个星期数(1,2,…7)，输出对应的星期一，星期二，…星期日</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IfDemo03</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;开始&quot;</span>);</span><br><span class="line"><span class="comment">// 需求：键盘录入一个星期数(1,2,...7)，输出对应的星期一，星期二，...星期日</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">System.out.println(<span class="string">&quot;请输入一个星期数(1-7)：&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">week</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"><span class="keyword">if</span>(week == <span class="number">1</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;星期一&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(week == <span class="number">2</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;星期二&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(week == <span class="number">3</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;星期三&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(week == <span class="number">4</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;星期四&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(week == <span class="number">5</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;星期五&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(week == <span class="number">6</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;星期六&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;星期日&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>if语句格式3案例：</p><p>需求：小明快要期末考试了，小明爸爸对他说，会根据他不同的考试成绩，送他不同的礼物，假如你可以控制小明的得分，请用程序实现小明到底该获得什么样的礼物，并在控制台输出。</p><p>分析：</p><p>​①小明的考试成绩未知，可以使用键盘录入的方式获取值</p><p>​②由于奖励种类较多，属于多种判断，采用if…else…if格式实现</p><p>​③为每种判断设置对应的条件</p><p>​④为每种判断设置对应的奖励</p><h3 id="1-4-分支结构：switch语句"><a href="#1-4-分支结构：switch语句" class="headerlink" title="1.4 分支结构：switch语句"></a>1.4 分支结构：switch语句</h3><h5 id="switch语句结构（掌握）"><a href="#switch语句结构（掌握）" class="headerlink" title="switch语句结构（掌握）"></a>switch语句结构（掌握）</h5><ul><li><p>格式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (表达式) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">语句体<span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">语句体<span class="number">2</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">语句体n+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>执行流程：</p><ul><li>首先计算出表达式的值 </li><li>其次，和case依次比较，一旦有对应的值，就会执行相应的语句，在执行的过程中，遇到break就会结 束。 </li><li>最后，如果所有的case都和表达式的值不匹配，就会执行default语句体部分，然后程序结束掉。</li></ul></li></ul><h5 id="switch语句练习-春夏秋冬（应用）"><a href="#switch语句练习-春夏秋冬（应用）" class="headerlink" title="switch语句练习-春夏秋冬（应用）"></a>switch语句练习-春夏秋冬（应用）</h5><ul><li>需求：一年有12个月，分属于春夏秋冬4个季节，键盘录入一个月份，请用程序实现判断该月份属于哪个季节，并输出。 </li><li>运行结果：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">春：3、4、5</span><br><span class="line">夏：6、7、8</span><br><span class="line">秋：9、10、11</span><br><span class="line">冬：1、2、12</span><br></pre></td></tr></table></figure><ul><li>示例代码：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//键盘录入月份数据，使用变量接收</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入一个月份：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="comment">//case穿透</span></span><br><span class="line">        <span class="keyword">switch</span>(month) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;冬季&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;春季&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;夏季&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;秋季&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;你输入的月份有误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意：如果switch中得case，没有对应break的话，则会出现case穿透的现象。</li></ul><h3 id="1-5-循环结构：for循环"><a href="#1-5-循环结构：for循环" class="headerlink" title="1.5 循环结构：for循环"></a>1.5 循环结构：for循环</h3><h4 id="for循环结构（掌握）"><a href="#for循环结构（掌握）" class="headerlink" title="for循环结构（掌握）"></a>for循环结构（掌握）</h4><ul><li><p>循环：</p><p>循环语句可以在满足循环条件的情况下，反复执行某一段代码，这段被重复执行的代码被称为循环体语句，当反复 执行这个循环体时，需要在合适的时候把循环判断条件修改为false，从而结束循环，否则循环将一直执行下去，形 成死循环。 </p></li><li><p>for循环格式：</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (初始化语句;条件判断语句;条件控制语句) &#123;</span><br><span class="line">循环体语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>格式解释：</p><ul><li>初始化语句：  用于表示循环开启时的起始状态，简单说就是循环开始的时候什么样</li><li>条件判断语句：用于表示循环反复执行的条件，简单说就是判断循环是否能一直执行下去</li><li>循环体语句：  用于表示循环反复执行的内容，简单说就是循环反复执行的事情</li><li>条件控制语句：用于表示循环执行中每次变化的内容，简单说就是控制循环是否能执行下去</li></ul></li><li><p>执行流程：</p><p>①执行初始化语句</p><p>②执行条件判断语句，看其结果是true还是false</p><p>​             如果是false，循环结束</p><p>​             如果是true，继续执行</p><p>③执行循环体语句</p><p>④执行条件控制语句</p><p>⑤回到②继续</p></li></ul><h4 id="for循环练习-输出数据（应用）"><a href="#for循环练习-输出数据（应用）" class="headerlink" title="for循环练习-输出数据（应用）"></a>for循环练习-输出数据（应用）</h4><ul><li>需求：在控制台输出1-5和5-1的数据 </li><li>示例代码：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForTest01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//需求：输出数据1-5</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line"><span class="comment">//需求：输出数据5-1</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">5</span>; i&gt;=<span class="number">1</span>; i--) &#123;</span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="for循环练习-求和（应用）"><a href="#for循环练习-求和（应用）" class="headerlink" title="for循环练习-求和（应用）"></a>for循环练习-求和（应用）</h4><ul><li>需求：求1-5之间的数据和，并把求和结果在控制台输出  </li><li>示例代码：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForTest02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//求和的最终结果必须保存起来，需要定义一个变量，用于保存求和的结果，初始值为0</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//从1开始到5结束的数据，使用循环结构完成</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line"><span class="comment">//将反复进行的事情写入循环结构内部</span></span><br><span class="line">             <span class="comment">// 此处反复进行的事情是将数据 i 加到用于保存最终求和的变量 sum 中</span></span><br><span class="line">sum += i;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sum += i;sum = sum + i;</span></span><br><span class="line"><span class="comment">第一次：sum = sum + i = 0 + 1 = 1;</span></span><br><span class="line"><span class="comment">第二次：sum = sum + i = 1 + 2 = 3;</span></span><br><span class="line"><span class="comment">第三次：sum = sum + i = 3 + 3 = 6;</span></span><br><span class="line"><span class="comment">第四次：sum = sum + i = 6 + 4 = 10;</span></span><br><span class="line"><span class="comment">第五次：sum = sum + i = 10 + 5 = 15;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当循环执行完毕时，将最终数据打印出来</span></span><br><span class="line">System.out.println(<span class="string">&quot;1-5之间的数据和是：&quot;</span> + sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>本题要点：<ul><li>今后遇到的需求中，如果带有求和二字，请立即联想到求和变量</li><li>求和变量的定义位置，必须在循环外部，如果在循环内部则计算出的数据将是错误的</li></ul></li></ul><h4 id="for循环练习-求偶数和（应用）"><a href="#for循环练习-求偶数和（应用）" class="headerlink" title="for循环练习-求偶数和（应用）"></a>for循环练习-求偶数和（应用）</h4><ul><li>需求：求1-100之间的偶数和，并把求和结果在控制台输出 }</li><li>示例代码：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForTest03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//求和的最终结果必须保存起来，需要定义一个变量，用于保存求和的结果，初始值为0</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//对1-100的数据求和与1-5的数据求和几乎完全一样，仅仅是结束条件不同</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">100</span>; i++) &#123;</span><br><span class="line"><span class="comment">//对1-100的偶数求和，需要对求和操作添加限制条件，判断是否是偶数</span></span><br><span class="line"><span class="keyword">if</span>(i%<span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">sum += i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当循环执行完毕时，将最终数据打印出来</span></span><br><span class="line">System.out.println(<span class="string">&quot;1-100之间的偶数和是：&quot;</span> + sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="for循环练习-水仙花（应用）"><a href="#for循环练习-水仙花（应用）" class="headerlink" title="for循环练习-水仙花（应用）"></a>for循环练习-水仙花（应用）</h4><ul><li>需求：在控制台输出所有的“水仙花数” </li><li>解释：什么是水仙花数？<ul><li>水仙花数，指的是一个三位数，个位、十位、百位的数字立方和等于原数<ul><li>例如<code>153  3*3*3 + 5*5*5 + 1*1*1 = 153</code></li></ul></li></ul></li><li>思路：<ol><li>获取所有的三位数，准备进行筛选，最小的三位数为100，最大的三位数为999，使用for循环获取</li><li>获取每一个三位数的个位，十位，百位，做if语句判断是否是水仙花数</li></ol></li><li>示例代码</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForTest04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//输出所有的水仙花数必然要使用到循环，遍历所有的三位数，三位数从100开始，到999结束</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">100</span>; i&lt;<span class="number">1000</span>; i++) &#123;</span><br><span class="line"><span class="comment">//在计算之前获取三位数中每个位上的值</span></span><br><span class="line"><span class="type">int</span> <span class="variable">ge</span> <span class="operator">=</span> i%<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">shi</span> <span class="operator">=</span> i/<span class="number">10</span>%<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">bai</span> <span class="operator">=</span> i/<span class="number">10</span>/<span class="number">10</span>%<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判定条件是将三位数中的每个数值取出来，计算立方和后与原始数字比较是否相等</span></span><br><span class="line"><span class="keyword">if</span>(ge*ge*ge + shi*shi*shi + bai*bai*bai == i) &#123;</span><br><span class="line"><span class="comment">//输出满足条件的数字就是水仙花数</span></span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="for循环练习-统计水仙花数个数（应用）"><a href="#for循环练习-统计水仙花数个数（应用）" class="headerlink" title="for循环练习-统计水仙花数个数（应用）"></a>for循环练习-统计水仙花数个数（应用）</h4><ul><li>需求：统计“水仙花数”一共有多少个，并在控制台输出个数 </li><li>示例代码：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForTest05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//定义变量count，用于保存“水仙花数”的数量，初始值为0</span></span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//输出所有的水仙花数必然要使用到循环，遍历所有的三位数，三位数从100开始，到999结束</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">100</span>; i&lt;<span class="number">1000</span>; i++) &#123;</span><br><span class="line"><span class="comment">//在计算之前获取三位数中每个位上的值</span></span><br><span class="line"><span class="type">int</span> <span class="variable">ge</span> <span class="operator">=</span> i%<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">shi</span> <span class="operator">=</span> i/<span class="number">10</span>%<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">bai</span> <span class="operator">=</span> i/<span class="number">10</span>/<span class="number">10</span>%<span class="number">10</span>;</span><br><span class="line"><span class="comment">//在判定水仙花数的过程中，满足条件不再输出，更改为修改count的值，使count+1</span></span><br><span class="line"><span class="keyword">if</span>(ge*ge*ge + shi*shi*shi + bai*bai*bai == i) &#123;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印输出最终结果</span></span><br><span class="line">System.out.println(<span class="string">&quot;水仙花共有：&quot;</span> + count + <span class="string">&quot;个&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>本题要点：<ul><li>今后如果需求带有统计xxx，请先想到计数器变量</li><li>计数器变量定义的位置，必须在循环外部</li></ul></li></ul><h3 id="1-6-循环结构：-while循环"><a href="#1-6-循环结构：-while循环" class="headerlink" title="1.6 循环结构： while循环"></a>1.6 循环结构： while循环</h3><h4 id="while结构（掌握）"><a href="#while结构（掌握）" class="headerlink" title="while结构（掌握）"></a>while结构（掌握）</h4><ul><li><p>while循环完整格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">初始化语句;</span><br><span class="line"><span class="keyword">while</span> (条件判断语句) &#123;</span><br><span class="line">循环体语句;</span><br><span class="line">    条件控制语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>while循环执行流程：</p><p>①执行初始化语句</p><p>②执行条件判断语句，看其结果是true还是false</p><p>​             如果是false，循环结束</p><p>​             如果是true，继续执行</p><p>③执行循环体语句</p><p>④执行条件控制语句</p><p>⑤回到②继续</p></li><li><p>示例代码：</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WhileDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//需求：在控制台输出5次&quot;HelloWorld&quot;</span></span><br><span class="line"><span class="comment">//for循环实现</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;HelloWorld&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line"><span class="comment">//while循环实现</span></span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(j&lt;=<span class="number">5</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;HelloWorld&quot;</span>);</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="while循环练习-珠穆朗玛峰（应用）"><a href="#while循环练习-珠穆朗玛峰（应用）" class="headerlink" title="while循环练习-珠穆朗玛峰（应用）"></a>while循环练习-珠穆朗玛峰（应用）</h4><ul><li>需求：世界最高山峰是珠穆朗玛峰(8844.43米&#x3D;8844430毫米)，假如我有一张足够大的纸，它的厚度是0.1毫米。请问，我折叠多少次，可以折成珠穆朗玛峰的高度?</li><li>示例代码：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WhileTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//定义一个计数器，初始值为0</span></span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//定义纸张厚度</span></span><br><span class="line"><span class="type">double</span> <span class="variable">paper</span> <span class="operator">=</span> <span class="number">0.1</span>;</span><br><span class="line"><span class="comment">//定义珠穆朗玛峰的高度</span></span><br><span class="line"><span class="type">int</span> <span class="variable">zf</span> <span class="operator">=</span> <span class="number">8844430</span>;</span><br><span class="line"><span class="comment">//因为要反复折叠，所以要使用循环，但是不知道折叠多少次，这种情况下更适合使用while循环</span></span><br><span class="line"><span class="comment">//折叠的过程中当纸张厚度大于珠峰就停止了，因此继续执行的要求是纸张厚度小于珠峰高度</span></span><br><span class="line"><span class="keyword">while</span>(paper &lt;= zf) &#123;</span><br><span class="line"><span class="comment">//循环的执行过程中每次纸张折叠，纸张的厚度要加倍</span></span><br><span class="line">paper *= <span class="number">2</span>;</span><br><span class="line"><span class="comment">//在循环中执行累加，对应折叠了多少次</span></span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印计数器的值</span></span><br><span class="line">System.out.println(<span class="string">&quot;需要折叠：&quot;</span> + count + <span class="string">&quot;次&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-7-循环结构：do-while循环"><a href="#1-7-循环结构：do-while循环" class="headerlink" title="1.7 循环结构：do-while循环"></a>1.7 循环结构：do-while循环</h3><h4 id="do…while循环结构（掌握）"><a href="#do…while循环结构（掌握）" class="headerlink" title="do…while循环结构（掌握）"></a>do…while循环结构（掌握）</h4><ul><li><p>完整格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">初始化语句;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">循环体语句;</span><br><span class="line">条件控制语句;</span><br><span class="line">&#125;<span class="keyword">while</span>(条件判断语句);</span><br></pre></td></tr></table></figure></li><li><p>执行流程：</p><p>① 执行初始化语句</p><p>② 执行循环体语句</p><p>③ 执行条件控制语句</p><p>④ 执行条件判断语句，看其结果是true还是false</p><p>如果是false，循环结束</p><p>如果是true，继续执行</p><p>⑤ 回到②继续</p></li><li><p>示例代码：</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoWhileDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//需求：在控制台输出5次&quot;HelloWorld&quot;</span></span><br><span class="line"><span class="comment">//for循环实现</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;HelloWorld&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line"><span class="comment">//do...while循环实现</span></span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;HelloWorld&quot;</span>);</span><br><span class="line">j++;</span><br><span class="line">&#125;<span class="keyword">while</span>(j&lt;=<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-8-三种循环的区别（理解）"><a href="#1-8-三种循环的区别（理解）" class="headerlink" title="1.8 三种循环的区别（理解）"></a>1.8 三种循环的区别（理解）</h3><ul><li>三种循环的区别<ul><li>for循环和while循环先判断条件是否成立，然后决定是否执行循环体（先判断后执行）</li><li>do…while循环先执行一次循环体，然后判断条件是否成立，是否继续执行循环体（先执行后判断）</li></ul></li><li>for循环和while的区别<ul><li>条件控制语句所控制的自增变量，因为归属for循环的语法结构中，在for循环结束后，就不能再次被访问到了</li><li>条件控制语句所控制的自增变量，对于while循环来说不归属其语法结构中，在while循环结束后，该变量还可以继续使用</li></ul></li><li>死循环（无限循环）的三种格式<ol><li>for(;;){}</li><li>while(true){}</li><li>do {} while(true);</li></ol></li></ul><h3 id="1-9-跳转控制语句（掌握）"><a href="#1-9-跳转控制语句（掌握）" class="headerlink" title="1.9  跳转控制语句（掌握）"></a>1.9  跳转控制语句（掌握）</h3><ul><li>跳转控制语句（break）<ul><li>跳出循环，结束循环</li></ul></li><li>跳转控制语句（continue）<ul><li>跳过本次循环，继续下次循环</li></ul></li><li>注意： continue只能在循环中进行使用！</li></ul><h3 id="1-10-循环嵌套（理解）"><a href="#1-10-循环嵌套（理解）" class="headerlink" title="1.10 循环嵌套（理解）"></a>1.10 循环嵌套（理解）</h3><ul><li><p>循环嵌套概述：在循环中，继续定义循环</p></li><li><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="comment">//外循环控制小时的范围，内循环控制分钟的范围</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">hour</span> <span class="operator">=</span> <span class="number">0</span>; hour &lt; <span class="number">24</span>; hour++) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">minute</span> <span class="operator">=</span> <span class="number">0</span>; minute &lt; <span class="number">60</span>; minute++) &#123;</span><br><span class="line">               System.out.println(hour + <span class="string">&quot;时&quot;</span> + minute + <span class="string">&quot;分&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>理解：</p><ul><li>请反复理解这句话（整个内循环，就是外循环的一个循环体，内部循环体没有执行完毕，外循环是不会继续向下执行的）</li></ul></li><li><p>结论：</p><ul><li>外循环执行一次，内循环执行一圈</li></ul></li></ul><h3 id="1-11-Random"><a href="#1-11-Random" class="headerlink" title="1.11 Random"></a>1.11 Random</h3><h4 id="Random产生随机数（掌握）"><a href="#Random产生随机数（掌握）" class="headerlink" title="Random产生随机数（掌握）"></a>Random产生随机数（掌握）</h4><ul><li><p>概述：</p><ul><li>Random类似Scanner，也是Java提供好的API，内部提供了产生随机数的功能<ul><li>API后续课程详细讲解，现在可以简单理解为Java已经写好的代码</li></ul></li></ul></li><li><p>使用步骤：</p><ol><li><p>导入包</p><p>import java.util.Random;</p></li><li><p>创建对象</p><p>Random r &#x3D; new Random();</p></li><li><p>产生随机数</p><p>int num &#x3D; r.nextInt(10);</p><p>解释： 10代表的是一个范围，如果括号写10，产生的随机数就是0-9，括号写20，参数的随机数则是0-19</p></li></ol></li><li><p>示例代码：</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RandomDemo</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//创建对象</span></span><br><span class="line"><span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"><span class="comment">//用循环获取10个随机数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line"><span class="comment">//获取随机数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> r.nextInt(<span class="number">10</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;number:&quot;</span> + number);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//需求：获取一个1-100之间的随机数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> r.nextInt(<span class="number">100</span>) + <span class="number">1</span>;</span><br><span class="line">System.out.println(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Random练习-猜数字（应用）"><a href="#Random练习-猜数字（应用）" class="headerlink" title="Random练习-猜数字（应用）"></a>Random练习-猜数字（应用）</h4><ul><li><p>需求：</p><p>程序自动生成一个1-100之间的数字，使用程序实现猜出这个数字是多少？</p><p>当猜错的时候根据不同情况给出相应的提示</p><p>A. 如果猜的数字比真实数字大，提示你猜的数据大了</p><p>B. 如果猜的数字比真实数字小，提示你猜的数据小了</p><p>C. 如果猜的数字与真实数字相等，提示恭喜你猜中了</p></li><li><p>示例代码：</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RandomTest</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//要完成猜数字的游戏，首先需要有一个要猜的数字，使用随机数生成该数字，范围1到100</span></span><br><span class="line"><span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"><span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> r.nextInt(<span class="number">100</span>) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="comment">//使用程序实现猜数字，每次均要输入猜测的数字值，需要使用键盘录入实现</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;请输入你要猜的数字：&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">guessNumber</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"></span><br><span class="line"><span class="comment">//比较输入的数字和系统产生的数据，需要使用分支语句。</span></span><br><span class="line">             <span class="comment">//这里使用if..else..if..格式，根据不同情况进行猜测结果显示</span></span><br><span class="line"><span class="keyword">if</span>(guessNumber &gt; number) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;你猜的数字&quot;</span> + guessNumber + <span class="string">&quot;大了&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(guessNumber &lt; number) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;你猜的数字&quot;</span> + guessNumber + <span class="string">&quot;小了&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;恭喜你猜中了&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> java,基础语法,循环 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>day01 - Java基础概述</title>
      <link href="/post/aeb1c77.html"/>
      <url>/post/aeb1c77.html</url>
      
        <content type="html"><![CDATA[<h3 id="day01-Java基础概述"><a href="#day01-Java基础概述" class="headerlink" title="day01-Java基础概述"></a>day01-Java基础概述</h3><p>点击查看概述图：<a href="https://raw.githubusercontent.com/Liooser/Liooser.github.io/main/images/index/day01-Java%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0.png">day01-Java基础概述.png (2257×4669) (raw.githubusercontent.com)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> java,面向对象进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>day02 - Java基础语法</title>
      <link href="/post/87265b95.html"/>
      <url>/post/87265b95.html</url>
      
        <content type="html"><![CDATA[<h1 id="day02-Java基础语法"><a href="#day02-Java基础语法" class="headerlink" title="day02 - Java基础语法"></a>day02 - Java基础语法</h1><h2 id="类型转换问题"><a href="#类型转换问题" class="headerlink" title="类型转换问题"></a>类型转换问题</h2><h4 id="类型转换（理解）"><a href="#类型转换（理解）" class="headerlink" title="类型转换（理解）"></a>类型转换（理解）</h4><p>在Java中，会存在不同类型的数据需要一起参与运算，所以这些数据类型之间是需要相互转换的，分为两种情况：自动类型转换和强制类型转换。</p><h4 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h4><p><strong>类型范围小</strong>的变量，可以<strong>直接赋值</strong>给<strong>类型范围大</strong>的变量。</p><p>把一个表示数据范围小的数值或者变量赋值给另一个表示数据范围大的变量。这种转换方式是自动的，直接书写即可。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// 将int类型的10直接赋值给double类型</span></span><br><span class="line">System.out.println(num); <span class="comment">// 输出10.0</span></span><br><span class="line"></span><br><span class="line"><span class="type">byte</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">12</span> ;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a;</span><br><span class="line">System.out.println(b); <span class="comment">// 12</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="表达式的自动类型转换"><a href="#表达式的自动类型转换" class="headerlink" title="表达式的自动类型转换"></a><strong>表达式的自动类型转换</strong></h4><p>在表达式中，小范围类型的变量会自动转换成当前较大范围的类型再运算。</p><p><strong>注意事项：</strong></p><p><strong>表达式的最终结果类型由表达式中的最高类型决定</strong>。</p><p>在表达式中，byte、short、char 是直接转换成int类型参与运算的。 </p><h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><p>类型范围大的数据或者变量，不能直接<strong>赋值</strong>给<strong>类型范围小</strong>的变量，会报错，把一个表示数据范围大的数值或者变量赋值给另一个表示数据范围小的变量必须进行强制类型转换。</p><p>强制类型转换格式：目标数据类型 变量名 &#x3D; (目标数据类型)值或者变量;</p><p>​例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">5.5</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> (<span class="type">int</span>) num1; <span class="comment">// 将double类型的num1强制转换为int类型</span></span><br><span class="line">System.out.println(num2); <span class="comment">// 输出5（小数位直接舍弃）</span></span><br></pre></td></tr></table></figure><p>说明：</p><ol><li>char类型的数据转换为int类型是按照码表中对应的int值进行计算的。比如在ASCII码表中，’a’对应97。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">System.out.println(x); <span class="comment">// 将输出97</span></span><br></pre></td></tr></table></figure><ol start="2"><li>整数默认是int类型，byte、short和char类型数据参与运算均会自动转换为int类型。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">b3</span> <span class="operator">=</span> b1 + b2; </span><br><span class="line"><span class="comment">// 第三行代码会报错，b1和b2会自动转换为int类型，计算结果为int，int赋值给byte需要强制类型转换。</span></span><br><span class="line"><span class="comment">// 修改为:</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> b1 + b2;</span><br><span class="line"><span class="comment">// 或者：</span></span><br><span class="line"><span class="type">byte</span> <span class="variable">b3</span> <span class="operator">=</span> (<span class="type">byte</span>) (b1 + b2);</span><br></pre></td></tr></table></figure><ol><li>boolean类型不能与其他基本数据类型相互转换。</li></ol><h2 id="1-运算符"><a href="#1-运算符" class="headerlink" title="1. 运算符"></a>1. 运算符</h2><h3 id="1-1-算术运算符（理解）"><a href="#1-1-算术运算符（理解）" class="headerlink" title="1.1 算术运算符（理解）"></a>1.1 算术运算符（理解）</h3><h4 id="1-1-1-运算符和表达式"><a href="#1-1-1-运算符和表达式" class="headerlink" title="1.1.1 运算符和表达式"></a>1.1.1 运算符和表达式</h4><p>运算符：对常量或者变量进行操作的符号</p><p>表达式：用运算符把常量或者变量连接起来符合java语法的式子就可以称为表达式。</p><p>​                    不同运算符连接的表达式体现的是不同类型的表达式。</p><p>举例说明：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + b;</span><br></pre></td></tr></table></figure><p>  +：是运算符，并且是算术运算符。</p><p>  a + b：是表达式，由于+是算术运算符，所以这个表达式叫算术表达式。</p><h4 id="1-1-2-算术运算符"><a href="#1-1-2-算术运算符" class="headerlink" title="1.1.2 算术运算符"></a>1.1.2 算术运算符</h4><table><thead><tr><th>符号</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td>+</td><td>加</td><td>参看小学一年级</td></tr><tr><td>-</td><td>减</td><td>参看小学一年级</td></tr><tr><td>*</td><td>乘</td><td>参看小学二年级，与“×”相同</td></tr><tr><td>&#x2F;</td><td>除</td><td>参看小学二年级，与“÷”相同</td></tr><tr><td>%</td><td>取余</td><td>获取的是两个数据做除法的余数</td></tr></tbody></table><p>注意：</p><p>&#x2F;和%的区别：两个数据做除法，&#x2F;取结果的商，%取结果的余数。</p><p>整数操作只能得到整数，要想得到小数，必须有浮点数参与运算。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">System.out.println(a / b); <span class="comment">// 输出结果3</span></span><br><span class="line">System.out.println(a % b); <span class="comment">// 输出结果1</span></span><br></pre></td></tr></table></figure><h4 id="1-1-3-字符的“-”操作"><a href="#1-1-3-字符的“-”操作" class="headerlink" title="1.1.3 字符的“+”操作"></a>1.1.3 字符的“+”操作</h4><p>char类型参与算术运算，使用的是计算机底层对应的十进制数值。需要我们记住三个字符对应的数值：</p><p>‘a’  –  97a-z是连续的，所以’b’对应的数值是98，’c’是99，依次递加</p><p>‘A’  –  65A-Z是连续的，所以’B’对应的数值是66，’C’是67，依次递加</p><p>‘0’  –  480-9是连续的，所以’1’对应的数值是49，’2’是50，依次递加</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以通过使用字符与整数做算术运算，得出字符对应的数值是多少</span></span><br><span class="line"><span class="type">char</span> <span class="variable">ch1</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">System.out.println(ch1 + <span class="number">1</span>); <span class="comment">// 输出98，97 + 1 = 98</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> <span class="variable">ch2</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">System.out.println(ch2 + <span class="number">1</span>); <span class="comment">// 输出66，65 + 1 = 66</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> <span class="variable">ch3</span> <span class="operator">=</span> <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">System.out.println(ch3 + <span class="number">1</span>); <span class="comment">// 输出49，48 + 1 = 49</span></span><br></pre></td></tr></table></figure><p>算术表达式中包含不同的基本数据类型的值的时候，整个算术表达式的类型会自动进行提升。</p><p>提升规则：</p><p>byte类型，short类型和char类型将被提升到int类型，不管是否有其他类型参与运算。</p><p>整个表达式的类型自动提升到与表达式中最高等级的操作数相同的类型</p><p>​       等级顺序：byte,short,char –&gt; int –&gt; long –&gt; float –&gt; double</p><p>例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="comment">// byte b3 = b1 + b2; // 该行报错，因为byte类型参与算术运算会自动提示为int，int赋值给byte可能损失精度</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i3</span> <span class="operator">=</span> b1 + b2; <span class="comment">// 应该使用int接收</span></span><br><span class="line"><span class="type">byte</span> <span class="variable">b3</span> <span class="operator">=</span> (<span class="type">byte</span>) (b1 + b2); <span class="comment">// 或者将结果强制转换为byte类型</span></span><br><span class="line">-------------------------------</span><br><span class="line"><span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">20.0</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">num3</span> <span class="operator">=</span> num1 + num2; <span class="comment">// 使用double接收，因为num1会自动提升为double类型</span></span><br></pre></td></tr></table></figure><p>tips：正是由于上述原因，所以在程序开发中我们很少使用byte或者short类型定义整数。也很少会使用char类型定义字符，而使用字符串类型，更不会使用char类型做算术运算。</p><h4 id="1-1-4-字符串的“-”操作"><a href="#1-1-4-字符串的“-”操作" class="headerlink" title="1.1.4 字符串的“+”操作"></a>1.1.4 字符串的“+”操作</h4><p>当“+”操作中出现字符串时，这个”+”是字符串连接符，而不是算术运算。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;itheima&quot;</span>+ <span class="number">666</span>); <span class="comment">// 输出：itheima666</span></span><br></pre></td></tr></table></figure><p>在”+”操作中，如果出现了字符串，就是连接运算符，否则就是算术运算。当连续进行“+”操作时，从左到右逐个执行。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="number">1</span> + <span class="number">99</span> + <span class="string">&quot;年黑马&quot;</span>); <span class="comment">// 输出：199年黑马</span></span><br><span class="line">System.out.println(<span class="number">1</span> + <span class="number">2</span> + <span class="string">&quot;itheima&quot;</span> + <span class="number">3</span> + <span class="number">4</span>); <span class="comment">// 输出：3itheima34</span></span><br><span class="line"><span class="comment">// 可以使用小括号改变运算的优先级 </span></span><br><span class="line">System.out.println(<span class="number">1</span> + <span class="number">2</span> + <span class="string">&quot;itheima&quot;</span> + (<span class="number">3</span> + <span class="number">4</span>)); <span class="comment">// 输出：3itheima7</span></span><br></pre></td></tr></table></figure><h3 id="1-2-赋值运算符（应用）"><a href="#1-2-赋值运算符（应用）" class="headerlink" title="1.2 赋值运算符（应用）"></a>1.2 赋值运算符（应用）</h3><p>赋值运算符的作用是将一个表达式的值赋给左边，左边必须是可修改的，不能是常量。</p><table><thead><tr><th>符号</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td>&#x3D;</td><td>赋值</td><td>a&#x3D;10，将10赋值给变量a</td></tr><tr><td>+&#x3D;</td><td>加后赋值</td><td>a+&#x3D;b，将a+b的值给a</td></tr><tr><td>-&#x3D;</td><td>减后赋值</td><td>a-&#x3D;b，将a-b的值给a</td></tr><tr><td>*&#x3D;</td><td>乘后赋值</td><td>a*&#x3D;b，将a×b的值给a</td></tr><tr><td>&#x2F;&#x3D;</td><td>除后赋值</td><td>a&#x2F;&#x3D;b，将a÷b的商给a</td></tr><tr><td>%&#x3D;</td><td>取余后赋值</td><td>a%&#x3D;b，将a÷b的余数给a</td></tr></tbody></table><p>注意：</p><p>扩展的赋值运算符隐含了强制类型转换。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">short</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">s = s + <span class="number">10</span>; <span class="comment">// 此行代码报出，因为运算中s提升为int类型，运算结果int赋值给short可能损失精度</span></span><br><span class="line"></span><br><span class="line">s += <span class="number">10</span>; <span class="comment">// 此行代码没有问题，隐含了强制类型转换，相当于 s = (short) (s + 10);</span></span><br></pre></td></tr></table></figure><h3 id="1-3-自增自减运算符（理解）"><a href="#1-3-自增自减运算符（理解）" class="headerlink" title="1.3 自增自减运算符（理解）"></a>1.3 自增自减运算符（理解）</h3><table><thead><tr><th>符号</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td>++</td><td>自增</td><td>变量的值加1</td></tr><tr><td>–</td><td>自减</td><td>变量的值减1</td></tr></tbody></table><p>注意事项：</p><p>​++和– 既可以放在变量的后边，也可以放在变量的前边。</p><p>​单独使用的时候， ++和– 无论是放在变量的前边还是后边，结果是一样的。</p><p>​参与操作的时候，如果放在变量的后边，先拿变量参与操作，后拿变量做++或者–。</p><p>​参与操作的时候，如果放在变量的前边，先拿变量做++或者–，后拿变量参与操作。</p><p>​最常见的用法：单独使用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">i++; <span class="comment">// 单独使用</span></span><br><span class="line">System.out.println(<span class="string">&quot;i:&quot;</span> + i); <span class="comment">// i:11</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">++j; <span class="comment">// 单独使用</span></span><br><span class="line">System.out.println(<span class="string">&quot;j:&quot;</span> + j); <span class="comment">// j:11</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> x++; <span class="comment">// 赋值运算，++在后边，所以是使用x原来的值赋值给y，x本身自增1</span></span><br><span class="line">System.out.println(<span class="string">&quot;x:&quot;</span> + x + <span class="string">&quot;, y:&quot;</span> + y); <span class="comment">// x:11，y:10</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> ++m; <span class="comment">// 赋值运算，++在前边，所以是使用m自增后的值赋值给n，m本身自增1</span></span><br><span class="line">System.out.println(<span class="string">&quot;m:&quot;</span> + m + <span class="string">&quot;, m:&quot;</span> + m); <span class="comment">// m:11，m:11</span></span><br></pre></td></tr></table></figure><p>练习：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> x++ + x++ + x++;</span><br><span class="line">System.out.println(y); <span class="comment">// y的值是多少？</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">解析，三个表达式都是++在后，所以每次使用的都是自增前的值，但程序自左至右执行，所以第一次自增时，使用的是10进行计算，但第二次自增时，x的值已经自增到11了，所以第二次使用的是11，然后再次自增。。。</span></span><br><span class="line"><span class="comment">所以整个式子应该是：int y = 10 + 11 + 12;</span></span><br><span class="line"><span class="comment">输出结果为33。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">注意：通过此练习深刻理解自增和自减的规律，但实际开发中强烈建议不要写这样的代码！小心挨打！</span><br></pre></td></tr></table></figure><h3 id="1-4-关系运算符（应用）"><a href="#1-4-关系运算符（应用）" class="headerlink" title="1.4 关系运算符（应用）"></a>1.4 关系运算符（应用）</h3><p>关系运算符有6种关系，分别为小于、小于等于、大于、等于、大于等于、不等于。</p><table><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody><tr><td>&#x3D;&#x3D;</td><td>a&#x3D;&#x3D;b，判断a和b的值是否相等，成立为true，不成立为false</td></tr><tr><td>!&#x3D;</td><td>a!&#x3D;b，判断a和b的值是否不相等，成立为true，不成立为false</td></tr><tr><td>&gt;</td><td>a&gt;b，判断a是否大于b，成立为true，不成立为false</td></tr><tr><td>&gt;&#x3D;</td><td>a&gt;&#x3D;b，判断a是否大于等于b，成立为true，不成立为false</td></tr><tr><td>&lt;</td><td>a&lt;b，判断a是否小于b，成立为true，不成立为false</td></tr><tr><td>&lt;&#x3D;</td><td>a&lt;&#x3D;b，判断a是否小于等于b，成立为true，不成立为false</td></tr></tbody></table><p>注意事项：</p><p>​关系运算符的结果都是boolean类型，要么是true，要么是false。</p><p>​千万不要把“&#x3D;&#x3D;”误写成“&#x3D;”，”&#x3D;&#x3D;”是判断是否相等的关系，”&#x3D;”是赋值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">System.out.println(a == b); <span class="comment">// false</span></span><br><span class="line">System.out.println(a != b); <span class="comment">// true</span></span><br><span class="line">System.out.println(a &gt; b); <span class="comment">// false</span></span><br><span class="line">System.out.println(a &gt;= b); <span class="comment">// false</span></span><br><span class="line">System.out.println(a &lt; b); <span class="comment">// true</span></span><br><span class="line">System.out.println(a &lt;= b); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 关系运算的结果肯定是boolean类型，所以也可以将运算结果赋值给boolean类型的变量</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> a &gt; b;</span><br><span class="line">System.out.println(flag); <span class="comment">// 输出false</span></span><br></pre></td></tr></table></figure><h3 id="1-5-逻辑运算符（应用）"><a href="#1-5-逻辑运算符（应用）" class="headerlink" title="1.5 逻辑运算符（应用）"></a>1.5 逻辑运算符（应用）</h3><p>逻辑运算符把各个运算的关系表达式连接起来组成一个复杂的逻辑表达式，以判断程序中的表达式是否成立，判断的结果是 true 或 false。</p><table><thead><tr><th>符号</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td>&amp;</td><td>逻辑与</td><td>a&amp;b，a和b都是true，结果为true，否则为false</td></tr><tr><td>|</td><td>逻辑或</td><td>a|b，a和b都是false，结果为false，否则为true</td></tr><tr><td>^</td><td>逻辑异或</td><td>a^b，a和b结果不同为true，相同为false</td></tr><tr><td>!</td><td>逻辑非</td><td>!a，结果和a的结果正好相反</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义变量</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//&amp; “与”，并且的关系，只要表达式中有一个值为false，结果即为false</span></span><br><span class="line">System.out.println((i &gt; j) &amp; (i &gt; k)); <span class="comment">//false &amp; false,输出false</span></span><br><span class="line">System.out.println((i &lt; j) &amp; (i &gt; k)); <span class="comment">//true &amp; false,输出false</span></span><br><span class="line">System.out.println((i &gt; j) &amp; (i &lt; k)); <span class="comment">//false &amp; true,输出false</span></span><br><span class="line">System.out.println((i &lt; j) &amp; (i &lt; k)); <span class="comment">//true &amp; true,输出true</span></span><br><span class="line">System.out.println(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//| “或”，或者的关系，只要表达式中有一个值为true，结果即为true</span></span><br><span class="line">System.out.println((i &gt; j) | (i &gt; k)); <span class="comment">//false | false,输出false</span></span><br><span class="line">System.out.println((i &lt; j) | (i &gt; k)); <span class="comment">//true | false,输出true</span></span><br><span class="line">System.out.println((i &gt; j) | (i &lt; k)); <span class="comment">//false | true,输出true</span></span><br><span class="line">System.out.println((i &lt; j) | (i &lt; k)); <span class="comment">//true | true,输出true</span></span><br><span class="line">System.out.println(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//^ “异或”，相同为false，不同为true</span></span><br><span class="line">System.out.println((i &gt; j) ^ (i &gt; k)); <span class="comment">//false ^ false,输出false</span></span><br><span class="line">System.out.println((i &lt; j) ^ (i &gt; k)); <span class="comment">//true ^ false,输出true</span></span><br><span class="line">System.out.println((i &gt; j) ^ (i &lt; k)); <span class="comment">//false ^ true,输出true</span></span><br><span class="line">System.out.println((i &lt; j) ^ (i &lt; k)); <span class="comment">//true ^ true,输出false</span></span><br><span class="line">System.out.println(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//! “非”，取反</span></span><br><span class="line">System.out.println((i &gt; j)); <span class="comment">//false</span></span><br><span class="line">System.out.println(!(i &gt; j)); <span class="comment">//!false，,输出true</span></span><br></pre></td></tr></table></figure><h4 id="短路逻辑运算符"><a href="#短路逻辑运算符" class="headerlink" title="短路逻辑运算符"></a>短路逻辑运算符</h4><table><thead><tr><th>符号</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td>&amp;&amp;</td><td>短路与</td><td>作用和&amp;相同，但是有短路效果</td></tr><tr><td>||</td><td>短路或</td><td>作用和|相同，但是有短路效果</td></tr></tbody></table><p>在逻辑与运算中，只要有一个表达式的值为false，那么结果就可以判定为false了，没有必要将所有表达式的值都计算出来，短路与操作就有这样的效果，可以提高效率。同理在逻辑或运算中，一旦发现值为true，右边的表达式将不再参与运算。</p><ul><li><p>逻辑与&amp;，无论左边真假，右边都要执行。</p></li><li><p>短路与&amp;&amp;，如果左边为真，右边执行；如果左边为假，右边不执行。</p></li><li><p>逻辑或|，无论左边真假，右边都要执行。</p></li><li><p>短路或||，如果左边为假，右边执行；如果左边为真，右边不执行。</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">System.out.println((x++ &gt; <span class="number">4</span>) &amp; (y++ &gt; <span class="number">5</span>)); <span class="comment">// 两个表达都会运算</span></span><br><span class="line">System.out.println(x); <span class="comment">// 4</span></span><br><span class="line">System.out.println(y); <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">System.out.println((x++ &gt; <span class="number">4</span>) &amp;&amp; (y++ &gt; <span class="number">5</span>)); <span class="comment">// 左边已经可以确定结果为false，右边不参与运算</span></span><br><span class="line">System.out.println(x); <span class="comment">// 4</span></span><br><span class="line">System.out.println(y); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><h3 id="1-6-三元运算符（理解）"><a href="#1-6-三元运算符（理解）" class="headerlink" title="1.6 三元运算符（理解）"></a>1.6 三元运算符（理解）</h3><p>三元运算符语法格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">关系表达式 ? 表达式<span class="number">1</span> : 表达式<span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>解释：问号前面的位置是判断的条件，判断结果为boolean型，为true时调用表达式1，为false时调用表达式2。其逻辑为：如果条件表达式成立或者满足则执行表达式1，否则执行第二个。</p><p>举例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a &gt; b ? a : b; <span class="comment">// 判断 a&gt;b 是否为真，如果为真取a的值，如果为假，取b的值</span></span><br></pre></td></tr></table></figure><p>三元运算符案例：</p><p>1、需求：动物园里有两只老虎，已知两只老虎的体重分别为180kg、200kg，请用程序实现判断两只老虎的体重是否相同。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OperatorTest01</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//1：定义两个变量用于保存老虎的体重，单位为kg，这里仅仅体现数值即可。</span></span><br><span class="line"><span class="type">int</span> <span class="variable">weight1</span> <span class="operator">=</span> <span class="number">180</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">weight2</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line"><span class="comment">//2：用三元运算符实现老虎体重的判断，体重相同，返回true，否则，返回false。</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> weight1 == weight2 ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//3：输出结果</span></span><br><span class="line">System.out.println(<span class="string">&quot;b:&quot;</span> + b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、需求：一座寺庙里住着三个和尚，已知他们的身高分别为150cm、210cm、165cm，请用程序实现获取这三个和尚的最高身高。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OperatorTest02</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//1：定义三个变量用于保存和尚的身高，单位为cm，这里仅仅体现数值即可。</span></span><br><span class="line"><span class="type">int</span> <span class="variable">height1</span> <span class="operator">=</span> <span class="number">150</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">height2</span> <span class="operator">=</span> <span class="number">210</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">height3</span> <span class="operator">=</span> <span class="number">165</span>;</span><br><span class="line"><span class="comment">//2：用三元运算符获取前两个和尚的较高身高值，并用临时身高变量保存起来。</span></span><br><span class="line"><span class="type">int</span> <span class="variable">tempHeight</span> <span class="operator">=</span> height1 &gt; height2 ? height1 : height2;</span><br><span class="line"><span class="comment">//3：用三元运算符获取临时身高值和第三个和尚身高较高值，并用最大身高变量保存。</span></span><br><span class="line"><span class="type">int</span> <span class="variable">maxHeight</span> <span class="operator">=</span> tempHeight &gt; height3 ? tempHeight : height3;</span><br><span class="line"><span class="comment">//4：输出结果</span></span><br><span class="line">System.out.println(<span class="string">&quot;maxHeight:&quot;</span> + maxHeight);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-数据输入（应用）"><a href="#2-数据输入（应用）" class="headerlink" title="2. 数据输入（应用）"></a>2. 数据输入（应用）</h2><p>我们可以通过 Scanner 类来获取用户的输入。使用步骤如下：</p><p>1、导包。Scanner 类在java.util包下，所以需要将该类导入。导包的语句需要定义在类的上面。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner; </span><br></pre></td></tr></table></figure><p>2、创建Scanner对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);<span class="comment">// 创建Scanner对象，sc表示变量名，其他均不可变</span></span><br></pre></td></tr></table></figure><p>3、接收数据</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> sc.nextInt(); <span class="comment">// 表示将键盘录入的值作为int数返回。</span></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScannerDemo</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//创建对象</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="comment">//接收数据</span></span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"><span class="comment">//输出数据</span></span><br><span class="line">System.out.println(<span class="string">&quot;x:&quot;</span> + x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改写三个和尚案例，数据使用键盘录入。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScannerTest</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//身高未知，采用键盘录入实现。首先导包，然后创建对象。</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="comment">//键盘录入三个身高分别赋值给三个变量。</span></span><br><span class="line">System.out.println(<span class="string">&quot;请输入第一个和尚的身高：&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">height1</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">System.out.println(<span class="string">&quot;请输入第二个和尚的身高：&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">height2</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">System.out.println(<span class="string">&quot;请输入第三个和尚的身高：&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">height3</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"><span class="comment">//用三元运算符获取前两个和尚的较高身高值，并用临时身高变量保存起来。</span></span><br><span class="line"><span class="type">int</span> <span class="variable">tempHeight</span> <span class="operator">=</span> height1 &gt; height2 ? height1 : height2;</span><br><span class="line"><span class="comment">//用三元运算符获取临时身高值和第三个和尚身高较高值，并用最大身高变量保存。</span></span><br><span class="line"><span class="type">int</span> <span class="variable">maxHeight</span> <span class="operator">=</span> tempHeight &gt; height3 ? tempHeight : height3;</span><br><span class="line"><span class="comment">//输出结果。</span></span><br><span class="line">System.out.println(<span class="string">&quot;这三个和尚中身高最高的是：&quot;</span> + maxHeight +<span class="string">&quot;cm&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IfTest02</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//小明的考试成绩未知，可以使用键盘录入的方式获取值</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">System.out.println(<span class="string">&quot;请输入一个分数：&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"><span class="comment">//由于奖励种类较多，属于多种判断，采用if...else...if格式实现</span></span><br><span class="line"><span class="comment">//为每种判断设置对应的条件</span></span><br><span class="line"><span class="comment">//为每种判断设置对应的奖励</span></span><br><span class="line"><span class="comment">//数据测试：正确数据，边界数据，错误数据</span></span><br><span class="line"><span class="keyword">if</span>(score&gt;<span class="number">100</span> || score&lt;<span class="number">0</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;你输入的分数有误&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(score&gt;=<span class="number">95</span> &amp;&amp; score&lt;=<span class="number">100</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;山地自行车一辆&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(score&gt;=<span class="number">90</span> &amp;&amp; score&lt;=<span class="number">94</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;游乐场玩一次&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(score&gt;=<span class="number">80</span> &amp;&amp; score&lt;=<span class="number">89</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;变形金刚玩具一个&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;胖揍一顿&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> java,基础语法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title></title>
      <link href="/404/style.css"/>
      <url>/404/style.css</url>
      
        <content type="html"><![CDATA[.main{  margin-top: 15%;}.st0{fill:#fff}.st2{fill:#5d89af}.st3{fill:#709abf}.st4,.st6{  fill:#fff;  stroke:#b3dcdf;  stroke-miterlimit:10}.st6{  stroke:#5d89af;  stroke-width:2}.st7,.st8,.st9{  stroke:#709abf;  stroke-miterlimit:10}.st7{  stroke-width:5;  stroke-linecap:round;  fill:none}.st8,.st9{  fill:#fff}.st9{  fill:none}.st10{  }#cloud1{  animation: cloud003 15s linear infinite;}#cloud2{  animation: cloud002 25s linear infinite;}#cloud3{  animation: cloud003 20s linear infinite;}#cloud4{  animation: float 4s linear infinite;}#cloud5{  animation: float 8s linear infinite;}#cloud7{  animation: float 5s linear infinite;}#tracks{  animation: slide 650ms linear infinite;}#bumps{  animation: land 10000ms linear infinite;}@keyframes jig {    0% { transform: translateY(0px); }    50% { transform: translateY(1px); }    100% { transform: translateY(0px); }}#car-layers{  animation: jig 0.35s linear infinite;}@keyframes land {    from { transform: translateX(0); }    to { transform: translateX(1000px); }}@keyframes slide {    from { transform: translateX(0px); }    to { transform: translateX(100px); }}/* @keyframes cloudFloat {  0% { transform: translateX(0) translateY(3px); }  100% { transform: translateX(1000px) translateY(0); }} */@keyframes cloud001 {  0% { transform: translateX(-1000px) translateY(3px); }  100% { transform: translateX(1000px) translateY(0); }}@keyframes cloud002 {  0% { transform: translateX(-1000px) translateY(3px); }  100% { transform: translateX(1000px) translateY(0); }}@keyframes cloud003 {  0% { transform: translateX(-1000px) translateY(3px); }  100% { transform: translateX(1000px) translateY(0); }}@keyframes float {    0% { transform: translateY(0px) translateX(0); }    50% { transform: translateY(8px) translateX(5px); }    100% { transform: translateY(0px) translateX(0); }}#bracefront, #braceback{  animation: braces 1s linear infinite;}@keyframes braces {    0% { transform: translateX(-2px); }  25% { transform: translateX(3px); }    50% { transform: translateX(-2px); }    75% { transform: translateX(3px); }  100% { transform: translateX(-2px); }}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/404/index.html"/>
      <url>/404/index.html</url>
      
        <content type="html"><![CDATA[<!DOCTYPE html><html lang="en" ><head>  <meta charset="UTF-8"><title>该页面不存在-404.life</title><link rel="shortcut icon" href="favicon.ico">  <link rel="stylesheet" href="./style.css"></head><body><!-- partial:index.partial.html --><div class="main">  <div>    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1000 355">  <g id="ocean">    <path id="sky" class="st0" d="M0 0h1000v203.1H0z"/>    <linearGradient id="water_1_" gradientUnits="userSpaceOnUse" x1="500" y1="354" x2="500" y2="200.667">      <stop offset="0" stop-color="#fff"/>      <stop offset="1" stop-color="#b3dcdf"/>    </linearGradient>    <path id="water" fill="url(#water_1_)" d="M0 200.7h1000V354H0z"/>    <path id="land" class="st0" d="M0 273.4h1000V354H0z"/>    <g id="bumps">      <path class="st0" d="M0 275.2s83.8-28 180-28 197 28 197 28H0z"/>    <path class="st0" d="M377 275.2s54.7-28 117.5-28 128.6 28 128.6 28H377z"/>    <path class="st0" d="M623.2 275.2s83.7-28 179.9-28 196.9 28 196.9 28H623.2z"/>      <path class="st0" d="M-998 275.2s83.8-28 180-28 197 28 197 28h-377z"/>      <path class="st0" d="M-621 275.2s54.7-28 117.5-28 128.6 28 128.6 28H-621z"/>      <path class="st0" d="M-374.8 275.2s83.7-28 179.9-28S2 275.2 2 275.2h-376.8z"/>    </g>  </g>  <g id="tracks">    <path class="st2" d="M9.8 282.4h-3L0 307.6h3z"/>    <path class="st2" d="M19.8 282.4h-3L10 307.6h3z"/>    <path class="st2" d="M29.8 282.4h-3L20 307.6h3z"/>    <path class="st2" d="M39.8 282.4h-3L30 307.6h3z"/>    <path class="st2" d="M49.8 282.4h-3L40 307.6h3z"/>    <path class="st2" d="M59.8 282.4h-3L50 307.6h3z"/>    <path class="st2" d="M69.8 282.4h-3L60 307.6h3z"/>    <path class="st2" d="M79.8 282.4h-3L70 307.6h3z"/>    <path class="st2" d="M89.8 282.4h-3L80 307.6h3z"/>    <path class="st2" d="M99.8 282.4h-3L90 307.6h3z"/>    <path class="st2" d="M109.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M119.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M129.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M139.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M149.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M159.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M169.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M179.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M189.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M199.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M209.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M219.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M229.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M239.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M249.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M259.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M269.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M279.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M289.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M299.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M309.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M319.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M329.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M339.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M349.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M359.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M369.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M379.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M389.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M399.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M409.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M419.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M429.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M439.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M449.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M459.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M469.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M479.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M489.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M499.8 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M1000 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M990 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M980 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M970 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M960 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M950 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M940 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M930 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M920 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M910 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M900 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M890 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M880 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M870 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M860 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M850 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M840 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M830 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M820 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M810 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M800 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M790 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M780 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M770 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M760 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M750 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M740 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M730 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M720 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M710 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M700 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M690 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M680 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M670 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M660 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M650 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M640 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M630 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M620 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M610 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M600 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M590 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M580 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M570 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M560 282.4h-3l-6.8 25.2h3z"/>    <g>      <path class="st2" d="M-490.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-480.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-470.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-460.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-450.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-440.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-430.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-420.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-410.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-400.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-390.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-380.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-370.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-360.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-350.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-340.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-330.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-320.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-310.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-300.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-290.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-280.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-270.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-260.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-250.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-240.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-230.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-220.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-210.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-200.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-190.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-180.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-170.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-160.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-150.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-140.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-130.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-120.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-110.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-100.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-90.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-80.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-70.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-60.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-50.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-40.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-30.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-20.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-10.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M-.2 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M500 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M490 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M480 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M470 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M460 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M450 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M440 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M430 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M420 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M410 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M400 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M390 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M380 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M370 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M360 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M350 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M340 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M330 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M320 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M310 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M300 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M290 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M280 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M270 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M260 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M250 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M240 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M230 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M220 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M210 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M200 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M190 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M180 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M170 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M160 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M150 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M140 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M130 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M120 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M110 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M100 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M90 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M80 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M70 282.4h-3l-6.8 25.2h3z"/>      <path class="st2" d="M60 282.4h-3l-6.8 25.2h3z"/>    </g>    <path class="st2" d="M550 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M540 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M530 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M520 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M510 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M550 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M540 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M530 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M520 282.4h-3l-6.8 25.2h3z"/>    <path class="st2" d="M510 282.4h-3l-6.8 25.2h3z"/>    <path class="st3" d="M-499.5 300.2H1000v5.1H-499.5z"/>    <path class="st3" d="M-499.5 283.8H1000v2.8H-499.5z"/>  </g>  <g id="cloudsAll">    <path id="cloud1" class="st4" d="M19.5 69.7s-21.3.5-25-12.2c0 0-4.3-21.3 16-21.8 0 0-2.1-12.2 12.2-14.9 0 0 15-3.2 21.3 6.9 0 0 3.6-20.7 17.8-22.3 0 0 24-3 26.6 13.1 0 0 .1 9.5-2.8 13.5 0 0 9.5-15 26.5-4.8 0 0 12.1 7.9 7 20.2 0 0 16 4.8 10.1 18.1 0 0-10.2 8.5-17.1-1.1 0 0-5.5 16-32.5 16 0 0-19.1 2.1-27-13.3 0 0 .5 10.1-13.3 10.6-.1 0-20.3 3.2-19.8-8z"/>    <path id="cloud3" class="st4" d="M836 132s-18.3 2.1-22.2-4.9c0 0-4.9-11.8 12.5-13.8 0 0-2.5-6.8 9.7-9.6 0 0 12.7-3.1 18.7 2.1 0 0 2-12.2 14-14.3 0 0 16.6-3.3 23.7 2.1 0 0 4.8 3.9 2.4 6.5 0 0 3.1-4.8 18.4-.4 0 0 10.9 3.5 7.2 11 0 0 13.8-1.5 9.7 9.5 0 0-4.1 10.8-15.5 4.8 0 0-3.1 5.6-26.4 7.9 0 0-16.3 2.8-24-5.3 0 0 1 5.7-10.8 7.2-.1.1-17.2 3.6-17.4-2.8z"/>    <path id="cloud2" class="st4" d="M19.3 159.5s-15.9.6-18.8-5.1c0 0-3.4-9.5 11.7-10.1 0 0-1.7-5.5 9-6.9 0 0 11.2-1.7 16 2.8 0 0 2.5-9.4 13.1-10.3 0 0 17.9-1.8 20 5.4 0 0 .2 4.3-2 6.1 0 0 6.9-6.9 19.8-2.6 0 0 9.1 3.4 5.5 9 0 0 6.5 0 4.5 6.7 0 0-2.6 5.6-9.6 1 0 0-4 7.3-24.2 7.7 0 0-14.2 1.3-20.4-5.5 0 0 .5 4.5-9.8 5 0 .1-15 1.8-14.8-3.2z"/>    <path id="cloud4" class="st4" d="M370.3 109.5s15.9.6 18.8-5.1c0 0 3.4-9.5-11.7-10.1 0 0 1.7-5.5-9-6.9 0 0-11.2-1.7-16 2.8 0 0-2.5-9.4-13.1-10.3 0 0-17.9-1.8-20 5.4 0 0-.2 4.3 2 6.1 0 0-6.9-6.9-19.8-2.6 0 0-9.1 3.4-5.5 9 0 0-12 1.9-7.7 8 0 0 7.5 4 12.8-.2 0 0 4 7.3 24.2 7.7 0 0 14.2 1.3 20.4-5.5 0 0-.5 4.5 9.8 5 0 0 15.1 1.7 14.8-3.3z"/>    <path id="cloud5" class="st4" d="M511.7 12.4s-21.3-.3-25 7c0 0-4.3 12.2 16 12.5 0 0-2.1 7 12.2 8.6 0 0 15 1.8 21.3-4 0 0 3.6 11.9 17.8 12.8 0 0 19.5 1.6 27-4.4 0 0 5-4.4 2.1-6.7 0 0 4.1 4.4 21.2-1.5 0 0 12.1-4.6 7-11.6 0 0 16-2.8 10.1-10.4 0 0-10.2-4.9-17.1.6 0 0-5.5-9.2-32.5-9.2 0 0-19.1-1.2-27 7.6 0 0 .5-5.8-13.3-6.1-.1.2-20.3-1.6-19.8 4.8z"/>  </g>  <g id="train">    <path fill="#b3dcdf" d="M344.5 248.5h507.2v37.8H344.5z"/>    <g id="wheels">      <circle class="st6" cx="384.1" cy="285.6" r="15.1"/>      <path class="st2" d="M384.1 295.7c-5.6 0-10.1-4.5-10.1-10.1s4.5-10.1 10.1-10.1 10.1 4.5 10.1 10.1c0 5.5-4.6 10.1-10.1 10.1z"/>      <circle class="st6" cx="416.1" cy="285.6" r="15.1"/>      <path class="st2" d="M416.1 295.7c-5.6 0-10.1-4.5-10.1-10.1s4.5-10.1 10.1-10.1 10.1 4.5 10.1 10.1c0 5.5-4.6 10.1-10.1 10.1z"/>      <circle class="st6" cx="469.1" cy="285.6" r="15.1"/>      <path class="st2" d="M469.1 295.7c-5.6 0-10.1-4.5-10.1-10.1s4.5-10.1 10.1-10.1 10.1 4.5 10.1 10.1c0 5.5-4.6 10.1-10.1 10.1z"/>      <circle class="st6" cx="734.1" cy="285.6" r="15.1"/>      <path class="st2" d="M734.1 295.7c-5.6 0-10.1-4.5-10.1-10.1s4.5-10.1 10.1-10.1 10.1 4.5 10.1 10.1c0 5.5-4.6 10.1-10.1 10.1z"/>      <circle class="st6" cx="766.1" cy="285.6" r="15.1"/>      <path class="st2" d="M766.1 295.7c-5.6 0-10.1-4.5-10.1-10.1s4.5-10.1 10.1-10.1 10.1 4.5 10.1 10.1c0 5.5-4.6 10.1-10.1 10.1z"/>      <circle class="st6" cx="821.1" cy="285.6" r="15.1"/>      <path class="st2" d="M821.1 295.7c-5.6 0-10.1-4.5-10.1-10.1s4.5-10.1 10.1-10.1 10.1 4.5 10.1 10.1c0 5.5-4.6 10.1-10.1 10.1z"/>    </g>    <path id="bracefront" class="st7" d="M383.2 285.6h88.1"/>    <path id="braceback" class="st7" d="M733.2 285.6h88.1"/>    <g id="car-layers">      <path id="car" class="st8" d="M321.8 300.7v-32.4s1.2.7-1.5-2.4v-29.1s3.1-11.6 10.7-21.1c0 0 7.6-12 15.5-17.5h1.3s10.2-4.9 30.9-28h.6s-.9-1.4 0-2.7c0 0 10.1-10.5 21-12.3 0 0 9.4-1.8 20.2-1.8h47.7V151H492v-1.1h10.1v1.1h19v2.2s8.2.9 19.2-4.2c0 0 1.4-1.1 28.8-1.1h291.5v6.8h7.5v2.2s12.2-.6 12.2 9.8V177l-10-.1v57.9s14.9-.5 14.9 10.2c0 0 1 9-14.9 8.9v3.8H719.5s-2.4.1-4.3 3l-15 29s-2.9 5.1-10.8 5.1H504.3s-2.9.1-6.1-5l-13.1-25s-4.5-7.1-11.8-7.1H369v2.4s-3.2 1.3-7.1 8.7L351.4 289s-2.9 6.3-6.9 6.4h-17.8l-4.9 5.3z"/>      <path id="streamline-outine" class="st8" d="M320.3 236.6s1.4-6.8 4.4-11.3c0 0 .1-2.3 23.2-6.3l78-16.6s103.3-21.1 134.9-26.1c0 0 93.3-16 120.5-17.9 0 0 57.6-4.3 100-4.1h88.9v63.4s-10.3 5.4-17.1 5.3c0 0-305.6 4.9-366.3 8.1 0 0-100.3 4.8-119.1 6.8 0-.1-46.6 1.2-47.4-1.3z"/>      <g id="window-grate">        <path class="st9" d="M739.5 182.6H854"/>        <path class="st9" d="M739.5 177.6H854"/>        <path class="st9" d="M739.5 172.6H854"/>        <path class="st9" d="M739.5 167.6H854"/>        <path class="st9" d="M739.5 161.4H854v26.1H739.5z"/>      </g>      <path class="st9" d="M320.3 257.8h549.9"/>      <g id="Text">        <text transform="translate(377.037 230.025)" class="st8 st10" font-size="21">          404        </text>        <text transform="translate(659.5 213.994)" class="st8 st10" font-size="24.025">        Page not found.        </text>      </g>      <g id="ladders">        <g id="ladder-f">          <path id="front-ladder" class="st8" d="M433.8 258.4h17.8v34.8h-17.8z"/>          <path id="fb-rung" class="st9" d="M433.8 281.1h17.7"/>          <path id="ft-rung" class="st9" d="M433.8 268.6h17.7"/>        </g>        <g id="ladder-b">          <path id="ladder-back" class="st8" d="M851.8 257.8h17.8v34.8h-17.8z"/>          <path id="bt-rung" class="st9" d="M851.8 268.6h17.7"/>          <path id="bb-rung" class="st9" d="M851.8 281.1h17.7"/>        </g>      </g>      <path id="window-front" class="st8" d="M350.5 196.4s-.4 3.9 15.2 4.3l32.3-30.3s-18.2 1.1-19-.8l-28.5 26.8z"/>    </g>  </g></svg>  </div></div><!-- partial -->  </body></html>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>友链</title>
      <link href="/butterfly/index.html"/>
      <url>/butterfly/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>butterfly</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>留言板</title>
      <link href="/messageboard/index.html"/>
      <url>/messageboard/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>myself</title>
      <link href="/myself/index.html"/>
      <url>/myself/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>日志</title>
      <link href="/timeline/index.html"/>
      <url>/timeline/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
